"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _syntax = _interopRequireDefault(require("./syntax"));

var _lexicon = require("./lexicon");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function tag(tagname) {
  return function fn(content, attr) {
    if (typeof content === "object") {
      // Curry
      return function (str) {
        return fn(str, content);
      };
    }

    if (typeof attr !== "object") {
      return "<".concat(tagname, ">").concat(content, "</").concat(tagname, ">");
    } else {
      var attrstr = Object.keys(attr).map(function (key) {
        return "".concat(key, "=\"").concat(attr[key], "\"");
      }).join(" ");
      return "<".concat(tagname, " ").concat(attrstr, ">").concat(content, "</").concat(tagname, ">");
    }
  };
}

var mi = tag("mi"),
    mn = tag("mn"),
    mo = tag("mo"),
    mfrac = tag("mfrac"),
    msup = tag("msup"),
    msub = tag("msub"),
    msubsup = tag("msubsup"),
    munder = tag("munder"),
    mover = tag("mover"),
    munderover = tag("munderover"),
    menclose = tag("menclose"),
    mrow = tag("mrow"),
    msqrt = tag("msqrt"),
    mroot = tag("mroot"),
    mfenced = tag("mfenced"),
    mtable = tag("mtable"),
    mtr = tag("mtr"),
    mtd = tag("mtd");

function parser(options) {
  var decimalMarkRE = options.decimalMark === "." ? "\\." : options.decimalMark,
      numberRegexp = new RegExp("^".concat(_lexicon.numbers.digitRange, "+(").concat(decimalMarkRE).concat(_lexicon.numbers.digitRange, "+)?")),
      colsplit = splitby(options.colSep),
      rowsplit = splitby(options.rowSep),
      newlinesplit = splitby("\n");

  function splitby(sep) {
    return function (str) {
      var split = [],
          inners = 0,
          index = 0;

      for (var i = 0; i < str.length; i += 1) {
        var rest = str.slice(i),
            char = str[i];

        if (rest.startsWith(sep) && !str.slice(0, i).match(/\\(\\{2})*$/)) {
          if (inners === 0) {
            split.push(str.slice(index, i));
            index = i + sep.length;
          }
        } else if (char.match(_lexicon.groupings.open.regexp)) {
          inners += 1;
        } else if (char.match(_lexicon.groupings.close.regexp)) {
          inners -= 1;
        }
      }

      split.push(str.slice(index));
      return split;
    };
  }

  var parse = function parse(ascii, mathml, space, grouped) {
    if (!ascii) {
      return mathml;
    }

    if (ascii.match(/^\s/)) {
      // Dont include the space it if there is a binary infix becoming
      // a prefix
      if (ascii.match(/^\s+(\/[^\/]|^[^\^]|_[^_|])/)) {
        return parse(ascii.trim(), mathml, true);
      } // Count the number of leading spaces


      var spaces = ascii.match(/^ +/),
          spacecount = spaces ? spaces[0].length : 0;

      if (spacecount > 1) {
        // spacewidth is a linear function of spacecount
        var spaceel = "<mspace width=\"".concat(spacecount - 1, "ex\" />");
        return parse(ascii.trim(), mathml + spaceel, true);
      }

      return parse(ascii.trim(), mathml, true);
    }

    var _parseone = parseone(ascii, grouped),
        _parseone2 = _slicedToArray(_parseone, 2),
        el = _parseone2[0],
        rest = _parseone2[1]; // ## Binary infixes ##
    // ### Fraction ###


    if ((rest && rest.trimLeft().startsWith("/") || rest.trimLeft().startsWith("./")) && !rest.trimLeft().match(/^\.?\/\//)) {
      var _splitNextFraction = splitNextFraction(el, rest);

      var _splitNextFraction2 = _slicedToArray(_splitNextFraction, 2);

      el = _splitNextFraction2[0];
      rest = _splitNextFraction2[1];
    }

    return parse(rest, mathml + el, false);
  };

  function parsegroup(ascii) {
    // Takes one asciiMath string and returns mathml in one group
    if (ascii.trim().length === 0) {
      return "";
    }

    var mathml = parse(ascii, "", false, true);
    return mathml === getlastel(mathml) ? mathml : mrow(mathml);
  }

  function parseone(ascii, grouped, lastel) {
    /**
     Return a split of the first element parsed to MathML and the rest
     of the string unparsed.
     */
    // TODO: split this up into smaller more readable code
    if (!ascii) {
      return ["", ""];
    }

    var el, rest;
    var head = ascii[0],
        tail = ascii.slice(1),
        nextsymbol = head + (tail.match(/^[A-Za-z]+/) || "");

    if (ascii.startsWith("sqrt")) {
      // ## Roots ##
      var split = parseone(ascii.slice(4).trim(), grouped);
      el = msqrt(split[0] ? removeSurroundingBrackets(split[0]) : mrow(""));
      rest = split[1];
    } else if (ascii.startsWith("root")) {
      var one = parseone(ascii.slice(4).trimLeft(), grouped),
          index = one[0] ? removeSurroundingBrackets(one[0]) : mrow(""),
          two = parseone(one[1].trimLeft(), grouped),
          base = two[0] ? removeSurroundingBrackets(two[0]) : mrow("");
      el = mroot(base + index);
      rest = two[1];
    } else if (head === "\\" && ascii.length > 1) {
      // ## Forced opperator ##
      if (ascii[1].match(/[(\[]/)) {
        var stop = findmatching(tail);
        el = mo(ascii.slice(2, stop));
        rest = ascii.slice(stop + 1);
      } else {
        el = mo(ascii[1]);
        rest = ascii.slice(2);
      }
    } else if (_lexicon.accents.contains(nextsymbol)) {
      // ## Accents ##
      var accent = _lexicon.accents.get(nextsymbol),
          next = ascii.slice(nextsymbol.length).trimLeft(),
          ijmatch = next.match(/^\s*\(?([ij])\)?/),
          _split = parseone(next);

      switch (accent.type) {
        // ## Accents on top ##
        case "over":
          if (ijmatch) {
            // use non-dotted i and j glyphs as to not clutter
            el = mover(mi(ijmatch[1] === "i" ? "ı" : "ȷ") + mo(accent.accent, {
              accent: true
            }));
            rest = next.slice(ijmatch[0].length);
          } else {
            el = mover(removeSurroundingBrackets(_split[0]) + mo(accent.accent, {
              accent: true
            }));
            rest = _split[1];
          }

          break;
        // ## Accents below ##

        case "under":
          el = munder(removeSurroundingBrackets(_split[0]) + mo(accent.accent));
          rest = _split[1];
          break;
        // ## Enclosings

        case "enclose":
          el = menclose(removeSurroundingBrackets(_split[0]), accent.attrs);
          rest = _split[1];
          break;

        default:
          throw new Error("Invalid config for accent " + nextsymbol);
      }
    } else if (_syntax.default.isfontCommand(ascii)) {
      // ## Font Commands ##
      var _split2 = _syntax.default.splitfont(ascii);

      el = tag(_split2.tagname)(_split2.text, _split2.font && {
        mathvariant: _split2.font
      });
      rest = _split2.rest;
    } else if (_lexicon.groupings.complex.contains(nextsymbol)) {
      // ## Complex groupings ##
      var grouping = _lexicon.groupings.complex.get(nextsymbol),
          _next = ascii.slice(nextsymbol.length).trimLeft(),
          _split3 = parseone(_next);

      el = mfenced(removeSurroundingBrackets(_split3[0]), grouping);
      rest = _split3[1];
    } else if (_syntax.default.isgroupStart(ascii) || _syntax.default.isvertGroupStart(ascii)) {
      // ## Groupings ##
      var _ref = _syntax.default.isgroupStart(ascii) ? _syntax.default.splitNextGroup(ascii) : _syntax.default.splitNextVert(ascii),
          _ref2 = _slicedToArray(_ref, 5),
          open = _ref2[1],
          group = _ref2[2],
          close = _ref2[3],
          after = _ref2[4];

      rest = _lexicon.groupings.open.get(after);

      var rows = function () {
        var lines = newlinesplit(group);
        return lines.length > 1 ? lines : rowsplit(group);
      }();

      if (_syntax.default.ismatrixInterior(group.trim(), options.colSep, options.rowSep)) {
        // ### Matrix ##
        if (group.trim().endsWith(options.colSep)) {
          // trailing row break
          group = group.trimRight().slice(0, -1);
        }

        var cases = open === "{" && close === "",
            table = parsetable(group, cases && {
          columnalign: "center left"
        });
        el = mfenced(table, {
          open: open,
          close: close
        });
      } else if (rows.length > 1) {
        // ### Column vector ###
        if (rows.length === 2 && open === "(" && close === ")") {
          // #### Binomial Coefficient ####
          // Experimenting with the binomial coefficient
          // Perhaps I'll remove this later
          var binom = mfrac(rows.map(parsegroup).join(""), {
            linethickness: 0
          });
          el = mfenced(binom, {
            open: open,
            close: close
          });
        } else {
          // #### Single column vector ####
          var vector = rows.map(colsplit);

          if (last(vector).length === 1 && last(vector)[0].match(/^\s*$/)) {
            // A trailing rowbreak
            vector = vector.slice(0, -1);
          }

          var matrix = vector.map(function (row) {
            return mtr(row.map(compose(mtd, parsegroup)).join(""));
          }).join("");
          el = mfenced(mtable(matrix), {
            open: open,
            close: close
          });
        }
      } else {
        // ### A fenced group ###
        var cols = colsplit(group),
            els = cols.map(parsegroup).join(""),
            attrs = {
          open: open,
          close: close
        };

        if (options.colSep !== ",") {
          attrs.separators = options.colSep;
        }

        el = mfenced(els, attrs);
      }
    } else if (!grouped && _syntax.default.isgroupable(ascii, options)) {
      // ## Whitespace ##
      // treat whitespace separated subexpressions as a group
      var _split4 = splitNextWhitespace(ascii);

      el = parsegroup(_split4[0]);
      rest = _split4[1];
    } else if (_lexicon.numbers.isdigit(head)) {
      // ## Number ##
      var number = ascii.match(numberRegexp)[0];
      el = mn(number);
      rest = tail.slice(number.length - 1);
    } else if (ascii.match(/^#`[^`]+`/)) {
      // ## Forced number ##
      var _number = ascii.match(/^#`([^`]+)`/)[1];
      el = mn(_number);
      rest = ascii.slice(_number.length + 3);
    } else if (ascii.match(new RegExp("^" + _lexicon.operators.regexp.source)) && !_lexicon.identifiers.contains(nextsymbol)) {
      // ## Operators ##
      var _syntax$splitNextOper = _syntax.default.splitNextOperator(ascii),
          _syntax$splitNextOper2 = _slicedToArray(_syntax$splitNextOper, 2),
          op = _syntax$splitNextOper2[0],
          _next2 = _syntax$splitNextOper2[1],
          derivative = ascii.startsWith("'"),
          prefix = contains(["∂", "∇"], op),
          stretchy = contains(["|"], op),
          mid = ascii.startsWith("| "),
          attr = {};

      if (derivative) {
        attr.lspace = 0;
        attr.rspace = 0;
      }

      if (prefix) {
        attr.rspace = 0;
      }

      if (stretchy) {
        attr.stretchy = true;
      }

      if (mid) {
        attr.lspace = "veryverythickmathspace";
        attr.rspace = "veryverythickmathspace";
      }

      el = mo(op, !isempty(attr) && attr);
      rest = _next2;
    } else if (_lexicon.identifiers.contains(nextsymbol)) {
      // Perhaps a special identifier character
      var ident = _lexicon.identifiers[nextsymbol]; // Uppercase greeks are roman font variant

      var uppercase = ident.match(/[\u0391-\u03A9\u2100-\u214F\u2200-\u22FF]/);
      el = uppercase ? mi(ident, {
        mathvariant: "normal"
      }) : mi(ident);
      rest = tail.slice(nextsymbol.length - 1);
    } else if (head === "O" && tail[0] === "/") {
      // The special case of the empty set. I suppose there is no
      // dividing by the latin capital letter O
      el = mi(_lexicon.identifiers["O/"], {
        mathvariant: "normal"
      });
      rest = tail.slice(1);
    } else {
      el = mi(head);
      rest = tail;
    }

    if (rest && rest.trimLeft().match(/\.?[\^_]/)) {
      if ((lastel ? !lastel.match(/m(sup|over)/) : true) && rest.trim().startsWith("_") && (rest.trim().length <= 1 || !rest.trim()[1].match(/[|_]/))) {
        // ### Subscript ###
        var _splitNextSubscript = splitNextSubscript(el, rest);

        var _splitNextSubscript2 = _slicedToArray(_splitNextSubscript, 2);

        el = _splitNextSubscript2[0];
        rest = _splitNextSubscript2[1];
      } else if (lastel !== "mover" && rest.trim().startsWith("._") && (rest.trim().length <= 2 || !rest.trim()[2].match(/[|_]/))) {
        // ### Underscript ###
        var _splitNextUnderscript = splitNextUnderscript(el, rest);

        var _splitNextUnderscript2 = _slicedToArray(_splitNextUnderscript, 2);

        el = _splitNextUnderscript2[0];
        rest = _splitNextUnderscript2[1];
      } else if ((lastel ? !lastel.match(/m(sub|under)/) : true) && rest.trim().startsWith("^") && (rest.trim().length <= 1 || rest.trim()[1] !== "^")) {
        // ### Superscript ###
        var _splitNextSuperscript = splitNextSuperscript(el, rest);

        var _splitNextSuperscript2 = _slicedToArray(_splitNextSuperscript, 2);

        el = _splitNextSuperscript2[0];
        rest = _splitNextSuperscript2[1];
      } else if (lastel !== "munder" && rest.trim().startsWith(".^") && (rest.trim().length <= 2 || rest.trim()[2] !== "^")) {
        // ### Overscript ###
        var _splitNextOverscript = splitNextOverscript(el, rest);

        var _splitNextOverscript2 = _slicedToArray(_splitNextOverscript, 2);

        el = _splitNextOverscript2[0];
        rest = _splitNextOverscript2[1];
      }
    }

    return [el, rest];
  }

  function splitNextSubscript(el, rest) {
    var next = parseone(rest.trim().slice(1).trim(), true, "msub"),
        sub = next[0] ? removeSurroundingBrackets(next[0]) : mrow("");
    var ml,
        ascii = next[1]; // ### Supersubscript ###

    if (ascii && ascii.trim().startsWith("^") && (ascii.trim().length <= 1 || !ascii.trim()[1] !== "^")) {
      var next2 = parseone(ascii.trim().slice(1).trim(), true),
          sup = next2[0] ? removeSurroundingBrackets(next2[0]) : mrow(""),
          tagfun = _syntax.default.shouldGoUnder(el) ? munderover : msubsup;
      ml = tagfun(el + sub + sup);
      ascii = next2[1];
    } else {
      var _tagfun = _syntax.default.shouldGoUnder(el) ? munder : msub;

      ml = _tagfun(el + sub);
    }

    return [ml, ascii];
  }

  function splitNextSuperscript(el, rest) {
    var next = parseone(rest.trim().slice(1).trim(), true, "msup"),
        sup = next[0] ? removeSurroundingBrackets(next[0]) : mrow("");
    var ml,
        ascii = next[1]; // ### Super- subscript ###

    if (ascii.trim().startsWith("_") && (ascii.trim().length <= 1 || !ascii.trim()[1].match(/[|_]/))) {
      var next2 = parseone(ascii.trim().slice(1).trim(), true),
          sub = next2[0] ? removeSurroundingBrackets(next2[0]) : mrow(""),
          tagfun = _syntax.default.shouldGoUnder(el) ? munderover : msubsup;
      ml = tagfun(el + sub + sup);
      ascii = next2[1];
    } else {
      var _tagfun2 = _syntax.default.shouldGoUnder(el) ? mover : msup;

      ml = _tagfun2(el + sup);
    }

    return [ml, ascii];
  }

  function splitNextUnderscript(el, rest) {
    var next = parseone(rest.trim().slice(2).trim(), true, "munder"),
        under = next[0] ? removeSurroundingBrackets(next[0]) : mrow("");
    var ml,
        ascii = next[1]; // ### Under- overscript ###

    var overmatch = ascii.match(/^(\.?\^)[^\^]/);

    if (overmatch) {
      var next2 = parseone(ascii.trim().slice(overmatch[1].length).trim(), true),
          over = next2[0] ? removeSurroundingBrackets(next2[0]) : mrow("");
      ml = munderover(el + under + over);
      ascii = next2[1];
    } else {
      ml = munder(el + under);
    }

    return [ml, ascii];
  }

  function splitNextOverscript(el, rest) {
    var next = parseone(rest.trim().slice(2).trim(), true, "mover"),
        over = next[0] ? removeSurroundingBrackets(next[0]) : mrow("");
    var ml,
        ascii = next[1]; // ### Under- overscript ###

    var undermatch = ascii.match(/^(\.?_)[^_|]/);

    if (undermatch) {
      var next2 = parseone(ascii.trim().slice(undermatch[1].length).trim(), true),
          under = next2[0] ? removeSurroundingBrackets(next2[0]) : mrow("");
      ml = munderover(el + under + over);
      ascii = next2[1];
    } else {
      ml = mover(el + over);
    }

    return [ml, ascii];
  }

  function splitNextFraction(el, rest) {
    var bevelled = rest.trim().startsWith("./"),
        rem = rest.trim().slice(bevelled ? 2 : 1);
    var next, ml, ascii;

    if (rem.startsWith(" ")) {
      var split = rem.trim().split(" ");
      next = parsegroup(split[0]);
      ascii = rem.trimLeft().slice(split[0].length + 1);
    } else {
      var _parseone3 = parseone(rem);

      var _parseone4 = _slicedToArray(_parseone3, 2);

      next = _parseone4[0];
      ascii = _parseone4[1];
    }

    next = next || mrow("");
    ml = mfrac(removeSurroundingBrackets(el) + removeSurroundingBrackets(next), bevelled && {
      bevelled: true
    });

    if (ascii && ascii.trim().startsWith("/") || ascii.trim().startsWith("./")) {
      return splitNextFraction(ml, ascii);
    }

    return [ml, ascii];
  }

  function splitNextWhitespace(str) {
    var re = new RegExp("(\\s|".concat(options.colSep, "|").concat(options.rowSep, "|$)"));
    var match = str.match(re),
        head = str.slice(0, match.index),
        sep = match[0],
        tail = str.slice(match.index + 1);
    var next = head,
        rest = sep + tail;

    if (!_syntax.default.isgroupStart(tail.trim()) && _syntax.default.endsInFunc(head)) {
      var newsplit = splitNextWhitespace(tail);
      next += sep + newsplit[0];
      rest = newsplit[1];
    } else if (head.match(/root$/)) {
      var split1 = splitNextWhitespace(tail),
          split2 = splitNextWhitespace(split1[1].trimLeft());
      next += sep + split1[0] + " " + split2[0];
      rest = sep + split2[1];
    }

    return [next, rest];
  }

  function parsetable(matrix, attrs) {
    var rows = function () {
      var lines = colsplit(matrix);
      return lines.length > 1 ? lines : newlinesplit(matrix);
    }().map(function (el) {
      return el.trim().slice(1, -1);
    });

    return mtable(rows.map(parserow).join(""), attrs);
  }

  function parserow(row, acc) {
    acc = typeof acc === "string" ? acc : "";

    if (!row || row.length === 0) {
      return mtr(acc);
    }

    var _parsecell = parsecell(row.trim(), ""),
        _parsecell2 = _slicedToArray(_parsecell, 2),
        mathml = _parsecell2[0],
        rest = _parsecell2[1];

    return parserow(rest.trim(), acc + mathml);
  }

  function parsecell(cell, acc) {
    if (!cell || cell.length === 0) {
      return [mtd(acc), ""];
    }

    if (cell[0] === options.colSep) {
      return [mtd(acc), cell.slice(1).trim()];
    }

    var _parseone5 = parseone(cell),
        _parseone6 = _slicedToArray(_parseone5, 2),
        mathml = _parseone6[0],
        rest = _parseone6[1];

    return parsecell(rest.trim(), acc + mathml);
  }

  return parse;
}

function splitlast(mathml) {
  /**
   Return a pair of all but last eliment and the last eliment
   */
  var lastel = getlastel(mathml),
      prewels = mathml.slice(0, mathml.lastIndexOf(lastel));
  return [prewels, lastel];
}

function removeSurroundingBrackets(mathml) {
  var inside = mathml.replace(/^<mfenced[^>]*>/, "").replace(/<\/mfenced>$/, "");

  if (splitlast(inside)[1] === inside) {
    return inside;
  } else {
    return mrow(inside);
  }
}

function getlastel(xmlstr) {
  // This breaks the linearity of the implimentation
  // optimation possible, perhaps an XML parser
  var tagmatch = xmlstr.match(/<\/(m[a-z]+)>$/);

  if (!tagmatch) {
    var spacematch = xmlstr.match(/<mspace\s*([a-z]+="[a-z]")*\s*\?>/);

    if (spacematch) {
      var _i2 = spacematch.match[0].length;
      return xmlstr.slice(_i2);
    } else {
      return "";
    }
  }

  var tagname = tagmatch[1];
  var i = xmlstr.length - (tagname.length + 3),
      inners = 0;

  for (i; i >= 0; i -= 1) {
    if (xmlstr.slice(i).startsWith("<".concat(tagname))) {
      if (inners === 0) {
        break;
      }

      inners -= 1;
    }

    if (xmlstr.slice(i - 2).startsWith("</".concat(tagname))) {
      inners += 1;
    }
  }

  return xmlstr.slice(i);
}

function findmatching(str) {
  var open = str[0],
      close = open === "(" ? ")" : open === "[" ? "]" : str[0];
  var inners = 0,
      index = 0;

  for (var i = 0; i < str.length; i += 1) {
    var char = str[i];
    index += 1;

    if (char === close) {
      inners -= 1;

      if (inners === 0) {
        break;
      }
    } else if (char === open) {
      inners += 1;
    }
  }

  return index;
}

function isempty(obj) {
  return Object.keys(obj).length === 0;
}

function contains(arr, el) {
  return arr.indexOf(el) >= 0;
}

function last(arr) {
  return arr.slice(-1)[0];
}

function compose(f, g) {
  return function (x) {
    return f(g(x));
  };
}

parser.getlastel = getlastel;
var _default = parser;
exports.default = _default;
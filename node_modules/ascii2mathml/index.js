"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ascii2mathml = ascii2mathml;
exports.default = void 0;

var _parser = _interopRequireDefault(require("./lib/parser"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ascii2mathml(asciimath, options) {
  // Curry
  if (typeof asciimath === "object") {
    return function (str, options2) {
      var opts = Object.assign({}, asciimath, options2);
      return ascii2mathml(str, opts);
    };
  }

  options = typeof options === "object" ? options : {};
  options.annotate = options.annotate || false;
  options.bare = options.bare || false;
  options.display = options.display || "inline";
  options.standalone = options.standalone || false;
  options.dir = options.dir || "ltr";
  options.decimalMark = options.decimalMark || ".";
  options.colSep = options.colSep || ",";
  options.rowSep = options.rowSep || ";";

  if (options.decimalMark === "," && options.colSep === ",") {
    options.colSep = ";";
  }

  if (options.colSep === ";" && options.rowSep === ";") {
    options.rowSep = ";;";
  }

  if (options.bare) {
    if (options.standalone) {
      throw new Error("Can't output a valid HTML without a root <math> element");
    }

    if (options.display && options.display.toLowerCase() !== "inline") {
      throw new Error("Can't display block without root element.");
    }

    if (options.dir && options.dir.toLowerCase() !== "ltr") {
      throw new Error("Can't have right-to-left direction without root element.");
    }
  }

  var parse = (0, _parser.default)(options);
  var out;
  var math = options.bare ? function (expr) {
    return expr;
  } : function (expr) {
    return "<math".concat(options.display !== "inline" ? " display=\"".concat(options.display, "\"") : "").concat(options.dir !== "ltr" ? " dir=\"".concat(options.dir, "\"") : "", ">").concat(expr, "</math>");
  };

  if (options.annotate) {
    // Make sure the all presentational part is the first element
    var parsed = parse(asciimath.trim(), ""),
        mathml = parsed === _parser.default.getlastel(parsed) ? parsed : "<mrow>".concat(parsed, "</mrow>");
    out = math("<semantics>" + mathml + '<annotation encoding="application/AsciiMath">' + asciimath + "</annotation>" + "</semantics>");
  } else {
    out = math(parse(asciimath.trim(), ""));
  }

  if (options.standalone) {
    out = "<!DOCTYPE html><html><head><title>" + asciimath + "</title></head>" + "<body>" + out + "</body></html>";
  }

  return out;
}

var _default = ascii2mathml;
exports.default = _default;


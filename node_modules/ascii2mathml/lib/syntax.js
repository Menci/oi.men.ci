"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lexicon = require("./lexicon");

function splitNextOperator(str) {
  var re = new RegExp("^" + _lexicon.operators.regexp.source),
      match = re.exec(str),
      op = match[0];
  return [_lexicon.operators.get(op), str.slice(op.length)];
}

function isgroupStart(str) {
  var re = new RegExp("^" + _lexicon.groupings.open.regexp.source);
  return str.match(re);
}

function isgroupable(str, options) {
  var re = new RegExp("^[0-9A-Za-z+\\-!]{2,}(\\s|".concat(options.colSep, "|").concat(options.rowSep, ")"));
  return str.match(re);
}

function ismatrixInterior(str, colSep, rowSep) {
  if (!isgroupStart(str)) {
    return false;
  }

  var rest = splitNextGroup(str)[4];

  if (!(rest.trim().startsWith(colSep) || rest.match(/^\s*\n/) && isgroupStart(rest.trim()))) {
    return false;
  } // Make sure we are building the matrix with parenthesis, as opposed
  // to rowSeps.


  while (rest && rest.trim()) {
    rest = (splitNextGroup(rest) || [])[4];

    if (rest && (rest.startsWith(rowSep) || rest.match(/^\s*\n/))) {
      // `rowSep` delimited matrices are handled elsewhere.
      return false;
    }
  }

  return true;
}

var funcEndingRe = new RegExp("(" + _lexicon.identifiers.funs.concat(Object.keys(_lexicon.accents)).concat(["sqrt"]).sort(function (a, b) {
  return a.length - b.length;
}).join("|") + ")$");

function endsInFunc(str) {
  return str.match(funcEndingRe);
}

function splitNextGroup(str) {
  /** Split the string into `[before, open, group, close, after]` */
  var openRE = new RegExp("^" + _lexicon.groupings.open.regexp.source),
      closeRE = new RegExp("^" + _lexicon.groupings.close.regexp.source);
  var start,
      stop,
      open,
      close,
      inners = 0,
      i = 0;

  while (i < str.length) {
    var rest = str.slice(i),
        openMatch = rest.match(openRE),
        closeMatch = rest.match(closeRE);

    if (openMatch) {
      if (typeof start !== "number") {
        start = i;
        open = openMatch[0];
      }

      inners += 1;
      i += openMatch[0].length;
    } else if (closeMatch) {
      inners -= 1;

      if (inners === 0) {
        close = closeMatch[0];
        stop = i + (close.length - 1);
        break;
      }

      i += closeMatch[0].length;
    } else {
      i += 1;
    }
  }

  if (!open) {
    return null;
  }

  return [start === 0 ? "" : str.slice(0, start), _lexicon.groupings.open.get(open), str.slice(start + open.length, close ? stop - (close.length - 1) : str.length), close ? _lexicon.groupings.close.get(close) : "", stop ? str.slice(stop + 1) : ""];
}

function isvertGroupStart(str) {
  if (!str.startsWith("|")) {
    return false;
  }

  var split = splitNextVert(str);
  return split && split[0] === "";
}

function splitNextVert(str) {
  function retval(start, stop, double) {
    return [start === 0 ? "" : str.slice(0, start), double ? "‖" : "|", str.slice(start + (double ? 2 : 1), stop), double ? "‖" : "|", str.slice(stop + (double ? 2 : 1))];
  }

  var start = str.indexOf("|"),
      stop = start + 1,
      rest = str.slice(start + 1),
      double = rest.startsWith("|"),
      re = double ? /\|\|/ : /\|/;

  if (double) {
    rest = rest.slice(1);
    stop += 1;
  }

  if (rest.indexOf("|") === -1) {
    return null;
  }

  if (rest.match(/^\.?[_\^]/)) {
    return null;
  }

  while (rest.length > 0) {
    var split = splitNextGroup(rest),
        head = split ? split[0] : rest,
        tail = split ? split[4] : "",
        match = re.exec(head);

    if (match) {
      return retval(start, stop + match.index, double);
    }

    stop += split.slice(0, -1).map(dot("length")).reduce(plus); // adjust for slim brackets

    if (split[1] === "") {
      stop += 2;
    } else if (split[1] === "〈") {
      stop += 1;
    }

    if (split[3] === "") {
      stop += 2;
    } else if (split[3] === "〉") {
      stop += 1;
    }

    rest = tail;
  }

  return null;
}

function dot(attr) {
  return function (obj) {
    return obj[attr];
  };
}

function plus(a, b) {
  return a + b;
} // Fonts
// =====


function isforcedEl(reEnd) {
  var re = new RegExp("^(" + _lexicon.fonts.regexp.source + " ?)?" + reEnd);
  return function (str) {
    return re.exec(str);
  };
}

var isforcedIdentifier = isforcedEl("(`)\\w+`");
var isforcedText = isforcedEl('(")');

function isfontCommand(str) {
  return isforcedIdentifier(str) || isforcedText(str);
}

function splitfont(ascii) {
  var typematch = isforcedIdentifier(ascii) || isforcedText(ascii),
      font = typematch && typematch[2],
      type = typematch && typematch[3],
      tagname = type === '"' ? "mtext" : type === "`" ? "mi" : "";
  var start = ascii.indexOf(type),
      stop = start + 1 + ascii.slice(start + 1).indexOf(type),
      fontvariant = start > 0 ? _lexicon.fonts.get(font) : "";
  return {
    tagname: tagname,
    text: ascii.slice(start + 1, stop),
    font: fontvariant,
    rest: ascii.slice(stop + 1)
  };
}

var underEls = ["<mi>lim</mi>", "<mo>∑</mo>", "<mo>∏</mo>"];

function shouldGoUnder(el) {
  return underEls.indexOf(el) >= 0;
}

var syntax = {
  endsInFunc: endsInFunc,
  isgroupStart: isgroupStart,
  isgroupable: isgroupable,
  isvertGroupStart: isvertGroupStart,
  splitNextGroup: splitNextGroup,
  splitNextVert: splitNextVert,
  splitNextOperator: splitNextOperator,
  ismatrixInterior: ismatrixInterior,
  isfontCommand: isfontCommand,
  splitfont: splitfont,
  shouldGoUnder: shouldGoUnder
};
var _default = syntax;
exports.default = _default;
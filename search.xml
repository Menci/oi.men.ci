<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[博客恢复维护~]]></title>
    <url>%2Fback%2F</url>
    <content type="text"><![CDATA[两年前改 Hexo 改的跑不起来了，于是之后再也没有更新过这个博客。 最近迁移数据的时候突然想起这个事，于是拿出来调了一下。现在 Hexo 修好了，也兼容了新版的 Node.js，可以继续更新了。同时也把整个博客项目整理开源了，在 https://github.com/Menci/oi.men.ci。欢迎大家查阅源代码，以及帮忙修复博客内容错误。 由于我已经离开算法竞赛比较久了，所以这个博客大概不会再有内容上的更新了，只会有错误修正。将来可能会给技术和生活相关的内容开个新的博客，敬请期待~]]></content>
  </entry>
  <entry>
    <title><![CDATA[Goodbye, 2018]]></title>
    <url>%2Fgoodbye-2018%2F</url>
    <content type="text"><![CDATA[.post .post-content .aplayer { margin-top: 20px; } var ap = new APlayer({ element: document.getElementById('aplayer'), narrow: false, autoplay: false, preload: 'metadata', showlrc: 3, mutex: true, theme: '#615754', music: { title: '風の唄', author: '京都幻想剧团 + 凋叶棕', url: 'https://cdn.menci.xyz/menci-oi-blog/music/fzg/fzg.ogg', pic: 'https://cdn.menci.xyz/menci-oi-blog/music/fzg/fzg.jpg', lrc: 'https://cdn.menci.xyz/menci-oi-blog/music/fzg/fzg.lrc' } }); 不知从何时开始，对元旦这种重要节日的概念，开始变得越来越浅 —— 从童年时的日思夜想，到如今，已经不再有什么期待，而只是当做一个平常的周末了。除了多放一天假之外，也便没有多么特殊了。但这总归是一年的结束，新一年的开始，这一年的回忆，大多数都在前半年高三的生活中，那时候便想，自己的故事一定要写给大家看，而现在看来，那些回忆也不过只有寥寥数言，但终究还是要在淡忘之前将他们记录下来，作为人生的一个阶段留下的记号罢。于是，便有了这些文字。 冬令营上的感动 年初的那段日子，昼思夜想的，便是冬令营上想带给全国 OIer 的《退役的你》了。演出的那天，没有机会去现场，便只能在视频直播里，去看着他们收到这一惊喜。那几个月，躺在床上的时候，去思考每一句歌词，坐在电脑旁的时候，去把每一个点点滴滴的素材，拼成这样一个完整的视频。那些看似平凡的画面，听起来朗朗上口的歌词，想必是每一个热爱着这一切的 OIer 心头最大的执念了吧。这也许只是那些 OI 题材的填词里最普通的一首，甚至看起来有些仓促，但这成功地感动了我自己，和那些和我自己一样的退役 OIer。 照亮阴影的阳光 高三这一年的主旋律，也许就是无边的阴影吧。永远做不完的题，永远考不到的目标 …… 身累心更累。看着黑板旁的数字一点点在减少 —— 从两百盼到零，从一月盼到六月，从周一盼到周五，从晨读盼到晚自习 …… 每一天都在孤独中度过 —— 那个时候总在想，如果身边能有哪个朋友能和我说话该多好呀，而再怎么想，都只能让自己更加感到孤独吧。每一次看到同学们一起在走廊里有说有笑地走着，心里都不是滋味。晚上望着教学楼外天空的那种感觉，大概已经淡忘了吧。感到自己努力学习不见成效的时候，看到未来的路变得模糊的时候，才是最失落的时候吧 …… 可就在这些阴暗的日子里，也会有一些期待、一些温暖的呢 …… 每个疲惫的夜晚，看到她的一句晚安总会感觉轻松许多，不管遇到多么难过的事，看到她的消息，总能变得开心起来。每次感到太累想要松懈的时候，想到有那个人在未来等着我，便又有了坚持下去的理由，有了继续努力的动力。 又是一年省选季 又到了四月份。 又到了省选的季节。 看到他们一个个有梦想的 OIer 走上考场的时候，便想到了从前的自己 —— 自从 NOI2017 结束的那一天开始，梦想实现了，梦想也结束了。不管怎么说，那种单纯为了自己喜欢的东西而去努力，不为了任何功利的努力，再也不会有了吧。九省联考的 Day1 结束，看到大家都在担心自己的命运，而有人已经放弃了希望，Day2 结束时，尘埃落定，又是几家欢喜几家愁 …… 竞赛就是这样，任何一次失误都可能成为永远的遗憾，在一层一层的选拔面前，我们每个人，都是命运下的蝼蚁。 看着这场游戏的参与者一年年的更替，从两年前懵懂无知时在空间看到的那句「进队了，谢谢大家」，到现在就连回忆都开始离自己越来越远 …… 留在昨日的，是大半的青春呐 …… 黎明之前的黑暗 五月份，班里终日沉浸在紧张的气氛中，大家都在为高考做着最后的准备。每一次的模拟成绩，都在分数线之上，尽管最低的时候只超过了几分，但总归还是没有低过。就算如此，仍在害怕自己高考会失利。喜欢的人也在忙于学习，没有时间陪我。想让高考来得快一些 —— 这样便不用再过这种日子了；又想让高考来得慢一些 —— 这样就有更多的时间来巩固，让自己更有把握。每天都这样纠结着，不知道该怎么做，偶然一次实验题得了满分，便能高兴一天，而第二天又错了好多选择题，便又在害怕自己考不上。 那一个月的事情，大概已经忘记了吧 —— 谁会总想去记得不好的回忆呢？每天晚上仍然想着自己喜欢的人，似乎又想前一年的某一段时间那样，被感情上的事困扰着。但终究只剩下最后一个月了，就这样迎来了高考。 六月是你的高考 高考的第一天，从学校赶到考场的路上，心里便有些紧张。第一场的语文，不知道为什么，之前从来没有把答题纸写得这么满过。写到作文的时候，时间看起来还很充裕，但写到一半的时候，便发现写得有些慢了，最后仍然是草草地结束了作文。下午的数学出乎了我的意料 —— 模拟考试几乎不会错的题型，有两道大题没做出来，回到家里便心态崩溃，不知道自己晚上是怎么度过的。第二天的理综则中规中矩，但看了答案之后还是感觉选择题没底，计算题也没有记得答案是否正确。 以至于，高考结束后的一段时间，我和家长也都在担心，会不会考不到分数线。公布成绩的那天，我甚是紧张，便躺在床上装作睡觉。客厅里父母在紧张着看着电视刷新成绩查询页面，看到我的成绩时，我听到门外传来惊喜的叫声，便松了一口气。母亲走进我的卧室，抱起我说儿子真厉害的时候，我想，这一切，终于结束了。 看到超过分数线 50 分的成绩，模拟考试中从来没有达到过的成绩，突然感到，这一年的所有付出的努力，所有承受的孤独，都不重要了 —— 不是说它们没有意义，而是说，得到了结果之后，我发现，这些经历也不过如此，既不需要去歌颂，也不需要去回忆。在未来，无论是这五百多分的成绩，还是两百多天的努力，都将和不到两年的 OI 回忆一起，成为永远的历史，成为最亲切的怀念。 大学生活的开始 九月份来到人大的时候，对大学的生活满怀期待 —— 然而刚开始便承受了一次打击 —— 大学宿舍不如高中宿舍好。但之后便习惯了，毕竟这里离校门、食堂和教学楼都很近。和同学们相处的还算融洽，课程也蛮是喜欢。 这边的食堂很好吃，点外卖也很方便，吃饭自然不成问题。因为有高中住宿舍的经历，所以住宿也不成问题。唯一算得上问题的，可能就是学习成绩了 —— 期中的成绩并不理想，而下半个学期也感觉自己没有太大的提升。一边是在提高对自己学习上的要求，另一边也接受了自己不如别人的事实。 新生研讨课上讲道，大学最重要的是找到你自己，找到自己最喜欢做什么。我深知自己在他们中不算优秀的人，在未来，也许我不会有非常长远的目标，但做对这个世界有用的事，做自己喜欢的事，这两个目标总是没错的吧。 The End 正如第一段中所说，一年来的回忆写出来，也不过寥寥数言。从前的每天都觉得自己的故事一定能感动别人，而写出来才发现，只有自己懂得自己的经历。那些快乐或者痛苦的记忆，转眼间，便成为了我们口中的故事，再一转眼间，我们便忘了故事是如何发生的。时间就是这样匆匆而去，我们在为未来奔波的旅途中，又能留下多少回忆呢？]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「2018 南京网络预赛」Sum - 线性筛]]></title>
    <url>%2Fjsk-30999%2F</url>
    <content type="text"><![CDATA[定义 为满足以下条件的有序二元组 的方案数（即 与 被认为是不同的方案）： ； 和 均为无平方因子数（即其因子中没有除 以外的完全平方数）。 求 ，。 链接 计蒜客 30999 题解 显然， 是积性函数，考虑线性筛。 当 为素数时，，即 与 ； 当 的最小质因子为 ，且 时，； 当 的最小质因子为 ，且 时： 如果 ，那么 中 的指数至少为 ，即无论如何划分 ，两个数中一定有一个数中 的指数为 ，即不存在合法的划分方案。 否则， 中 的指数至少为 ，把这两个 分别分给 中的 和 ，剩余的 就是一个子问题了，即 。 代码 #include &lt;cstdio&gt; // #include &lt;vector&gt; const int MAXN = 2e7; bool isNotPrime[MAXN + 1]; int primes[MAXN + 1], primeCnt; int f[MAXN + 1]; inline void sieve() { f[1] = 1; for (int i = 2; i &lt;= MAXN; i++) { if (!isNotPrime[i]) { primes[++primeCnt] = i; f[i] = 2; } for (int j = 1; j &lt;= primeCnt &amp;&amp; (long long)i * primes[j] &lt;= MAXN; j++) { isNotPrime[i * primes[j]] = true; if (i % primes[j] == 0) { f[i * primes[j]] = (i / primes[j] % primes[j] == 0) ? 0 : f[i] / 2; break; } else { f[i * primes[j]] = f[i] * 2; } } } } inline bool isSquareFree(int x) { for (int i = 2; i * i &lt;= x; i++) { if (x % i == 0) { x /= i; if (x % i == 0) return false; } } return true; } int main() { sieve(); static int s[MAXN + 1]; for (int i = 1; i &lt;= MAXN; i++) s[i] = s[i - 1] + f[i]; int T; scanf("%d", &amp;T); while (T--) { int n; scanf("%d", &amp;n); printf("%d\n", s[n]); } // // int cnt = 0; // std::vector&lt;int&gt; v; // for (int i = 1; i &lt;= 10000; i++) { // if (isSquareFree(i)) v.push_back(i); // // if (i % int(1e6) == 0) printf("%d: %d\n", i, cnt); // } // // printf("%d\n", cnt); // static int g[10000]; // for (int i = 0; i &lt; (int)v.size(); i++) { // for (int j = 0; j &lt; (int)v.size(); j++) { // int x = v[i] * v[j]; // if (x &lt; 10000) g[x]++; // } // } // for (int i = 1; i &lt; 10000; i++) { // if (f[i] != g[i]) printf("f[%d] = %d, g[%d] = %d\n", i, f[i], i, g[i]); // } // int s = 0; // for (int i = 1; i &lt; 100; i++) printf("%d, ", s += f[i]); // puts(""); }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2010」超级钢琴 - 可持久化线段树 + 堆]]></title>
    <url>%2Fnoi2010-piano%2F</url>
    <content type="text"><![CDATA[给一个长度为 的序列 ，定义一个区间 的价值为这个区间中数的总和。求区间长度在 之间的所有区间中，价值最大 的个区间的价值总和。 链接 BZOJ 2006 Luogu 2048 题解 预处理整个序列的前缀和 ，将区间 的总和转化为 。 建立 棵可持久化线段树，初始时每棵线段树的维护值均为 数组。 首先求出以每个位置为左端点的价值最大的区间（通过线段树查询与前缀和转化得到），将它们加入到堆中。每次从堆中取出最大的区间价值，假设它为 ，那么在第 棵线段树中将 处的值置为 （以确保这个区间不会被再次使用），并重新求出以 为左端点的的价值最大的区间，加入到堆中。以上过程重复 次即可得到答案。 时空复杂度均为 。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 500000; const int MAXN_LOG = 19; // Math.log2(500000) = 18.931568569324174 struct Value { int pos; long long val; Value() {} Value(int pos, long long val) : pos(pos), val(val) {} bool operator&lt;(const Value &amp;other) const { return val &lt; other.val; } }; extern struct SegT *curr; struct SegT { SegT *lc, *rc; int l, r; Value val; SegT() {} SegT(int l, int r, SegT *lc, SegT *rc, const Value &amp;val) : l(l), r(r), lc(lc), rc(rc), val(val) {} SegT(int l, int r, SegT *lc, SegT *rc) : l(l), r(r), lc(lc), rc(rc), val(std::max(lc-&gt;val, rc-&gt;val)) {} SegT *update(int pos, long long newVal) { if (pos &lt; l || pos &gt; r) return this; else if (l == r) return new (curr++) SegT(l, r, NULL, NULL, Value(pos, newVal)); else return new (curr++) SegT(l, r, lc-&gt;update(pos, newVal), rc-&gt;update(pos, newVal)); } Value query(int l, int r) { if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return val; else { int mid = this-&gt;l + (this-&gt;r - this-&gt;l) / 2; Value res(-1, LLONG_MIN); if (l &lt;= mid) res = std::max(res, lc-&gt;query(l, r)); if (r &gt; mid) res = std::max(res, rc-&gt;query(l, r)); return res; } } static SegT *build(int l, int r, long long *a) { if (l == r) return new (curr++) SegT(l, r, NULL, NULL, Value(l, a[l])); else { int mid = l + (r - l) / 2; return new (curr++) SegT(l, r, build(l, mid, a), build(mid + 1, r, a)); } } } *segt[MAXN + 1], _pool[MAXN * MAXN_LOG * 2], *curr = _pool; long long sum[MAXN + 1]; int min, max; struct Interval { int l, r, maxPos; long long val; Interval() {} Interval(int l, int r) : l(l), r(r) { int ql = l + min - 1, qr = std::min(l + max - 1, r); if (ql &gt; r) val = LLONG_MIN, maxPos = -1; else { Value x = segt[l]-&gt;query(ql, qr); val = x.val - sum[l - 1]; maxPos = x.pos; } // printf("Interval(%d, %d): ql = %d, qr = %d, maxPos = %d, val = %lld\n", l, r, ql, qr, maxPos, val); } bool operator&lt;(const Interval &amp;other) const { return val &lt; other.val; } }; struct Heap { Interval a[MAXN + 1]; int n; void push(const Interval &amp;x) { int i = ++n; a[i] = x; while (i &gt; 1 &amp;&amp; a[i / 2] &lt; a[i]) { std::swap(a[i], a[i / 2]); i /= 2; } } const Interval &amp;top() { return a[1]; } int size() { return n; } void pop() { a[1] = a[n--]; int i = 1; while (i * 2 &lt;= n) { int l = i * 2, r = i * 2 + 1; int next = r &lt;= n &amp;&amp; a[l] &lt; a[r] ? r : l; if (a[i] &lt; a[next]) { std::swap(a[next], a[i]); i = next; } else break; } } } heap; int main() { int n, k; scanf("%d %d %d %d", &amp;n, &amp;k, &amp;min, &amp;max); static int a[MAXN + 1]; for (int i = 1; i &lt;= n; i++) { scanf("%d", &amp;a[i]); sum[i] = sum[i - 1] + a[i]; } SegT *init = SegT::build(1, n, sum); for (int i = 1; i &lt;= n; i++) segt[i] = init; for (int i = 1; i &lt;= n; i++) heap.push(Interval(i, n)); long long ans = 0; while (k--) { Interval v = heap.top(); heap.pop(); ans += v.val; // printf("ans += %lld\n", v.val); segt[v.l] = segt[v.l]-&gt;update(v.maxPos, LLONG_MIN); v = Interval(v.l, v.r); if (v.val != LLONG_MAX) heap.push(v); } printf("%lld\n", ans); }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>可持久化线段树</tag>
        <tag>NOI</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP 模拟赛」Azuki loves chess - 数论]]></title>
    <url>%2Fazuki-loves-chess%2F</url>
    <content type="text"><![CDATA[在一个无穷大的中国象棋棋盘上，马每次可以在一个方向上移动一个单位，在另一个方向上移动两个单位。现将规则改为，马每次可以在一个方向上移动 个单位，在另一个方向上移动 个单位。问放置在 的马能否移动到 。 链接 LYOI #406 题解 题意可转化为，判断以下关于 的方程是否存在整数解： 将两维分开考虑，即 两式相加得 整理这三个式子得到 结论：这三个二元一次不定方程同时有解，是本题答案为 Yes 的充要条件，即： 必要性显然，下证充分性。 如果前两个方程有解，那么，通过它们的解构造出一组原方程一组可行解的方法是： 所以，原题有解，等价于前两个方程有解，且对应位置的未知数值的奇偶性相同。即，对于以下两个方程，存在一组整数解，使得 与 奇偶性相同， 与 奇偶性相同。 我们可以将上式都除去 ，即 上述方程化为 下面证明，在第三个方程有解的前提条件下，从前两个方程的任意一组解，都可得到一组满足条件（对应未知数的值奇偶性相同）的解。 由于 互质，所以它们不可能都是偶数。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 650D」Zip-line - 树状数组 + LIS]]></title>
    <url>%2Fcf-650d%2F</url>
    <content type="text"><![CDATA[给一个序列，每次求原序列的第 个数修改为 时的最长严格上升子序列长度。 链接 Codeforces 650D 题解 首先，预处理整个序列的 LIS 长度和以第 个数结尾的 LIS 长度 、以第 个数开头的 LIS 长度 。 查询时，考虑求包含被修改的数的 LIS 长度。假设被修改的是第 个数，那么找到其左边比新值 小的数对应的 的最大值，加上其右边比新值 大的数对应的 的最大值，再加上 （即把三段拼起来）。如果求得的数比原 LIS 长度更大，则即为答案，否则考虑被修改的数是否一定在 LIS 中。 若被修改的数可以不在 LIS 中，则答案一定不会比原 LIS 长度更小。 若被修改的数一定在 LIS 中，则答案最多减小 （从原 LIS 中去掉这个数）。 现在的问题是，如何求出哪些数一定在 LIS 中。 首先，用类似上文中的方法分别求出包含原序列中第 个数的 LIS 长度，如果该长度等于原序列的 LIS 长度，则第 个数可以在 LIS 中； 对于一个可以在 LIS 中的数 ，如果 左边有比 更大的数可以在 LIS 中，则它可以不在 LIS 中； 对于一个可以在 LIS 中的数 ，如果 右边有比 更小的数可以在 LIS 中，则它可以不在 LIS 中； 「对于 且 的 ，求 的最值」可在离散化后用离线加树状数组解决。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 400000; const int MAXL = MAXN + MAXN; struct Question { int pos, newVal, *ans; bool operator&lt;(const Question &amp;other) const { return pos &lt; other.pos; } } q[MAXN + 1]; int n, m, a[MAXN + 1], lisLeft[MAXN + 1], lisRight[MAXN + 1], required[MAXN + 1], initAns, cnt; inline int processLis(int *a, int *lis) { static int tmp[MAXN + 1]; int max = 0; for (int i = 1; i &lt;= n; i++) { int x = std::lower_bound(tmp + 1, tmp + max + 1, a[i]) - tmp; if (x == max + 1) tmp[++max] = a[i]; else tmp[x] = std::min(tmp[x], a[i]); lis[i] = x; } return max; } inline void discrete() { static int tmp[MAXL + 1]; for (int i = 1; i &lt;= n; i++) tmp[++cnt] = a[i]; for (int i = 1; i &lt;= m; i++) tmp[++cnt] = q[i].newVal; std::sort(tmp + 1, tmp + cnt + 1); int *end = std::unique(tmp + 1, tmp + cnt + 1); for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(tmp + 1, end, a[i]) - tmp; for (int i = 1; i &lt;= m; i++) q[i].newVal = std::lower_bound(tmp + 1, end, q[i].newVal) - tmp; } struct BinaryIndexedTree { int a[MAXL + 1], n; static int lowbit(int x) { return x &amp; -x; } void init(int n) { this-&gt;n = n; std::fill(a + 1, a + n + 1, 0); } int query(int pos) { int res = 0; for (int i = pos; i &gt; 0; i -= lowbit(i)) res = std::max(res, a[i]); return res; } void update(int pos, int x) { for (int i = pos; i &lt;= MAXL; i += lowbit(i)) a[i] = std::max(a[i], x); } } bit; inline void determineRequire() { static int len[MAXN + 1]; bit.init(cnt); for (int i = 1; i &lt;= n; i++) { len[i] += bit.query(a[i] - 1); bit.update(a[i], lisLeft[i]); } bit.init(cnt); for (int i = n; i &gt;= 1; i--) { len[i] += bit.query(cnt - a[i] + 1 - 1); bit.update(cnt - a[i] + 1, lisRight[i]); } // for (int i = 1; i &lt;= n; i++) printf("%d%c", len[i], " \n"[i == n]); static bool usable[MAXN + 1]; for (int i = 1; i &lt;= n; i++) if (len[i] + 1 == initAns) usable[i] = required[i] = true; int max = 0; for (int i = 1; i &lt;= n; i++) { if (max &gt;= a[i]) required[i] = false; if (usable[i]) max = std::max(max, a[i]); } int min = cnt + 1; for (int i = n; i &gt;= 1; i--) { if (min &lt;= a[i]) required[i] = false; if (usable[i]) min = std::min(min, a[i]); } } inline void solve() { std::sort(q + 1, q + m + 1); bit.init(cnt); for (int i = 1, j = 1; i &lt;= n &amp;&amp; j &lt;= m; i++) { for (; j &lt;= m &amp;&amp; q[j].pos == i; j++) *q[j].ans += bit.query(q[j].newVal - 1); bit.update(a[i], lisLeft[i]); } bit.init(cnt); for (int i = n, j = m; i &gt;= 1 &amp;&amp; j &gt;= 1; i--) { for (; j &gt;= 1 &amp;&amp; q[j].pos == i; j--) *q[j].ans += bit.query(cnt - q[j].newVal + 1 - 1); bit.update(cnt - a[i] + 1, lisRight[i]); } for (int i = 1; i &lt;= m; i++) { (*q[i].ans)++; if (!required[q[i].pos]) *q[i].ans = std::max(*q[i].ans, initAns); else *q[i].ans = std::max(*q[i].ans, initAns - 1); } } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); static int ans[MAXN + 1]; for (int i = 1; i &lt;= m; i++) { scanf("%d %d", &amp;q[i].pos, &amp;q[i].newVal); q[i].ans = &amp;ans[i]; } discrete(); initAns = processLis(a, lisLeft); static int revA[MAXN + 1]; for (int i = 1; i &lt;= n; i++) revA[i] = -a[n - i + 1]; processLis(revA, lisRight); std::reverse(lisRight + 1, lisRight + n + 1); determineRequire(); // for (int i = 1; i &lt;= n; i++) printf("%d%c", lisLeft[i], " \n"[i == n]); // for (int i = 1; i &lt;= n; i++) printf("%d%c", lisRight[i], " \n"[i == n]); // for (int i = 1; i &lt;= n; i++) printf("%d%c", required[i], " \n"[i == n]); solve(); for (int i = 1; i &lt;= m; i++) printf("%d\n", ans[i]); }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>Codeforces</tag>
        <tag>LIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦结束的地方]]></title>
    <url>%2Fwhere-the-dream-ends%2F</url>
    <content type="text"><![CDATA[new APlayer({ element: document.getElementById('aplayer1'), narrow: false, autoplay: false, showlrc: 3, preload: 'metadata', mutex: true, theme: '#615754', music: { title: 'Artificial Emotions', author: '心华', url: 'https://cdn.menci.xyz/menci-oi-blog/music/ae/ae.ogg', pic: 'https://cdn.menci.xyz/menci-oi-blog/music/ae/ae.jpg', lrc: 'https://cdn.menci.xyz/menci-oi-blog/music/ae/ae.lrc' } }); “终于 …… 要离开了吗 ……” 徘徊在绍兴一中的校园里，不舍地望着这里的一切，仿佛这曾是我所拥有的全部。 这里，是梦成真的地方； 也是，梦结束的地方 …… 一 我叫 Menci，是个准高中生。 OI 的学习是那年暑假开始的，八月初，第一次走进小机房的时候，我从没想过这会改变我整个高中的命运。 从那时起，ljz 学长便成了我很好的朋友。学长的教导总是有用的，无论在学习或是其它的方面。 那时候看着 Vijos 首页上写的「北京第八十中学」，好奇着「北京到底有多少中学？」从来不敢想自己有一天也能认识这个学校的人，更不敢想这个学校的人会看到我的 OJ。看着 Luogu 的花哨的 UI，也不敢想自己有一天能认识这个网站的主人。 开学后不就便是联赛，至今记得赛场上想出一道题时的兴奋，和调过大样例后长舒的一口气 —— 那是我第一次拿到一等奖。小机房的生活不久便结束了，学长们退役了，LYOI 便只剩下我一个人，和与我一级的新生。 二 我叫 Menci，是个无名蒟蒻。 第一次进入 OI「圈子」，便是那个在贴吧上看到的群吧。很难想象，正是一个在我今天看来再普通不过的群，正式开始了我的 OI 生涯。 不久后便认识了一些同在山东的 OIer，他们大多是高二。从那时起，我便了解到，从 NOIP 到省选再到 NOI，是多么远的路。 第一次「面基」，就是在 WC2016 了吧。也便是那时候见的 fqk、yzy 和 sxb；印象最深的是「yts 大爷」当时做的题，我至今还不会；偶然的机会认识了 Sengxian，后来成了很好的朋友 …… 那次 WC 让我知道了这个圈子是有多么的大，我想，总有一天，我也要成为这个圈子里不平凡的一员。 回到学校之后的事情，没有什么可讲的了。整个下学期都在停课，三月份，我去了安师大附中集训，相比于集训，更重要的是认识了来自河南的可爱的学姐 Fancy，对我 OI 生涯影响最大的人之一。 那之后又去了省常中集训，很多事已经不怎么记的住了，而印象最深的就是那个时候认识了~小学弟~ Leaves 吧。 三 我叫 Menci，是个 NOI 选手。 五月份的 CTSC / APIO 像是去北京旅游了一趟，印象最深的就是第一次住那么高档的酒店，还有久闻大名的「北京第八十中学」。成绩当然也没有想象中那么好。 六月份的 PKUSC 我没有参加，刚好是那几天，认识了新高一的小学妹 lyx。后来，她便是我在下一届中最看中的人，也是我非常重要的朋友。我一直在努力的去做一个「善良的学长」，但终究还是受限于能力 …… 省选的失利并不是一件多么严重的事，毕竟这才是高一，抱着试试看的心态申请了 D 类，结果竟然过了。我便成为了临沂一中的第一个 NOI 选手，虽然只拿了铜牌，但在当时看来已经是值得骄傲的成绩了吧。NOI 的最后两天晚上，和 zyz 去操场上聊了好久，关于过往，关于 OI，关于未来。也便是那时候，zyz 成了我最好的朋友。 八月份回到学校便开始给同一级的同学出题，说是出题，不过是一些把现有的 idea「转化」为成题罢了。同时也搭建了自己的 OJ，那便是后来的 ly.men.ci。 四 我叫 Menci，是个碌碌无为的人。 高二上学期一直是半停课状态，NOIP 之后还在担心成绩，但也还是没有想象中那么差的。没有进全省前十名是个遗憾，没上 500 分也是的。 那段时间被感情所折磨的恐惧，可不是每个人都能感受得到吧。那让我真正的感觉到自己是多么的有软弱与无能。好在，那样的事，终究不会有第二次了吧。 浪费掉的时间，也不会再有了。 五 我叫 Menci，是个有名蒟蒻。 冬令营上的《膜你抄》很成功，很多人都是从那时起认识 Menci 的。梦寐以求的在全国 OIer 面前表演节目，那便是我最快乐的时刻了吧。 三月份的雅礼集训，终于见识到了那些强校选手的整体实力，我思考着，强校到底是好是坏呢，如果我生在强校，但水平没有那么高，我还会有这么多机会吗 …… 终于，我站在了一个被羡慕的位置上。 可是，我真的值得羡慕吗 …… 省选失利，PKUSC 协议对 D 类无效，我想，只有名气没有实力，也是一种悲哀吧 …… 六 我叫 Menci，是个 OIer。 三次省队集训，学到了很多东西，当然也都是过着集体生活的快乐的时光。终于，倒计时开始了，作为一个 OIer 的时间，已经「过一天少一天」的在流逝了。 五月，六月，七月，好像昨天还是省选后的哭泣，明天就要去 NOI 了。 坐在去绍兴的火车上，想着，这是最后一站了吧。 不久前不还在说「高一不要有压力，还有一次机会」吗？ 这一年一点都不漫长，像是很充实，又像是在虚度。 晚上和他们一起，最后一次练习那些模板。 睡觉的时候，心情仍是如此的平静。 Day1 结束了，社会活动日，所有人都在愉快地玩耍。 终于，在 Day2 考场上，最后一分钟，保存了程序，在闪烁的命令行下打出「AFO」。 签约，最终选择了人大，满意的结果。 回到宿舍，看着来时的行李，不敢相信这就是我的最后一程。 我想让自己醒来，就像之前那样，可惜，这就是现实了。 终于，我用两年的青春，换来了一块银牌，和一纸协议。 我成功了。 七 我叫 Menci，是个退役的 OIer。 最初的时候，我们都在想，要取得什么样的成绩。殊不知，中间的经历，才是最珍贵的。 总有人说，看戏人终成戏中人。 实际上，戏中人，也终成看戏人。 下一个赛季依然是那么华丽 —— 只是，那都不属于我了。 “终于 …… 要离开了吗 ……” 徘徊在绍兴一中的校园里，不舍地望着这里的一切，仿佛这曾是我所拥有的全部。 这里，是梦成真的地方； 也是，梦结束的地方 ……]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 808G」Anthem of Berland - KMP + DP]]></title>
    <url>%2Fcf-808g%2F</url>
    <content type="text"><![CDATA[给一个含有字母以及 ? 的 串和一个含有字母的 串，其中 ? 可以匹配任何字符，求 串最多匹配 串多少次。 链接 Codeforces 808G 题解 对 进行 KMP，用类似 AC 自动机的方法预处理出 串的前 个字符加上字符 后，其后缀最多能匹配 串多长的前缀。 设 表示 串的前 个字符，其后缀最长匹配到 串的前缀长度为 ， 串的最多匹配次数，刷表转移。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; const int MAXN = 1e5; int main() { static char s[MAXN + 2], t[MAXN + 2]; scanf("%s %s", s + 1, t + 1); int n = strlen(s + 1), m = strlen(t + 1); static int ch[MAXN + 1][26], fail[MAXN + 1]; for (int i = 1; i &lt;= m; i++) ch[i - 1][t[i] - 'a'] = i; for (int i = 1, k = 0; i &lt;= m; i++) { if (i &gt; 1) { while (k &amp;&amp; t[k + 1] != t[i]) k = fail[k]; if (t[k + 1] == t[i]) fail[i] = ++k; else fail[i] = 0; // printf("fail[%d] = %d\n", i, fail[i]); } for (int j = 0; j &lt; 26; j++) { if (!ch[i][j]) { ch[i][j] = ch[fail[i]][j]; } } } std::vector&lt; std::vector&lt;int&gt; &gt; f(n + 1, std::vector&lt;int&gt;(m + 1, -1)); f[0][0] = 0; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt;= m; j++) { if (f[i][j] == -1) continue; // printf("f(%d, %d) = %d\n", i, j, f[i][j]); for (int c = s[i + 1] == '?' ? 0 : (s[i + 1] - 'a'); c &lt; (s[i + 1] == '?' ? 26 : (s[i + 1] - 'a' + 1)); c++) { f[i + 1][ch[j][c]] = std::max(f[i + 1][ch[j][c]], f[i][j] + (ch[j][c] == m)); } } } int ans = 0; for (int i = 0; i &lt;= m; i++) ans = std::max(ans, f[n][i]); printf("%d\n", ans); }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>字符串</tag>
        <tag>Codeforces</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「APIO2013」TOLL - 搜索 + 最小生成树]]></title>
    <url>%2Fapio2013-toll%2F</url>
    <content type="text"><![CDATA[幸福国度可以用 个城镇（用 到 编号）构成的集合来描述，这些城镇最开始由 条双向道路（用 到 编号）连接。城镇 是中央城镇。保证一个人从城镇 出发，经过这些道路，可以到达其他的任何一个城市。这些道路都是收费道路，道路 的使用者必须向道路的主人支付 分钱的费用。已知所有的这些 是互不相等的。最近有 条新道路建成，这些道路都属于亿万富豪 Mr. Greedy。 Mr. Greedy 可以决定每条新道路的费用（费用可以相同），并且他必须在明天宣布这些费用。 两周以后，幸福国度将举办一个盛况空前的嘉年华！大量的参与者将沿着这些道路游行并前往中央城镇。共计 个参与者将从城镇 出发前往中央城镇。这些人只会沿着一个选出的道路集合前行，并且这些选出的道路将在这件事的前一天公布。根据一个古老的习俗，这些道路将由幸福国度中最有钱的人选出，也就是 Mr. Greedy。同样根据这个习俗，Mr. Greedy 选出的这个道路集合必须使所有选出道路的费用之和最小，并且仍要保证任何人可以从城镇 前往城镇 （因此，这些选出的道路来自将费用作为相应边边权的“最小生成树”）。如果有多个这样的道路集合，Mr. Greedy 可以选其中的任何一个，只要满足费用和是最小的。 Mr. Greedy 很明确地知道，他从 条新道路中获得的收入不只是与费用有关。一条道路的收入等于所有经过这条路的人的花费之和。更准确地讲，如果 个人经过道路 ，道路 产生的收入为乘积 。注意 Mr. Greedy 只能从新道路收取费用，因为原来的道路都不属于他。 Mr. Greedy 有一个阴谋。他计划通过操纵费用和道路的选择来最大化他的收入。他希望指定每条新道路的费用（将在明天公布），并且选择嘉年华用的道路（将在嘉年华的前一天公布），使得他在 条新道路的收入最大。注意 Mr. Greedy 仍然需要遵循选出花费之和最小的道路集合的习俗。 你是一个记者，你想揭露他的计划。为了做成这件事，你必须先写一个程序来确定 Mr. Greedy 可以通过他的阴谋获取多少收入。 链接 BZOJ 3206 UOJ #108 题解 问题的本质是，用 条边中的一些边去替换最小生成树中的边，使得最小生成树大小不变，并使得每条新边的经过次数乘上边权的总和最大。 如果我们将所有 条新边都加入到最小生成树中，然后从小到大加入原有的边。考虑这些仍然被加入到最小生成树中的旧边，这些边是无论如何都要被加入的 —— 所以可以缩点，缩点后只会剩下 个点，剩下的旧边只会有 条。搜索 条边要选哪些，将其加入后从小到大加入旧边，之后每一条边 都会使 到 路径上的所有新边的权值对其权值取 。 并查集维护这个取 的过程即可。 代码 #include &lt;cstdio&gt; #include &lt;cctype&gt; #include &lt;cassert&gt; #include &lt;climits&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; const int __buffsize = 500000; char __buff[__buffsize]; char *__buffs, *__buffe; #define getchar() (__buffs == __buffe ? fread(__buff, 1, __buffsize, stdin), __buffe = __buff + __buffsize, *((__buffs = __buff)++) : *(__buffs++)) inline int read() { static int n, ch; n = 0, ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) n = n * 10 + ch - '0', ch = getchar(); return n; } const int MAXN = 100000; const int MAXK = 20; const int MAXM = 300000 + MAXK; struct Node { std::vector&lt;struct Edge&gt; e; Node *fa; int w, dep; long long s, initS; bool modifiable; } N[MAXK + 1 + 1]; struct Edge { Node *s, *t; int w; Edge(Node *s, Node *t, int w) : s(s), t(t), w(w) {} }; inline void addEdge(int s, int t, int w) { #ifdef DBG printf("addEdge(%d, %d, %d)\n", s, t, w); #endif N[s].e.push_back(Edge(&amp;N[s], &amp;N[t], w)); N[t].e.push_back(Edge(&amp;N[t], &amp;N[s], w)); } struct PlainEdge { int u, v, w; bool selected; bool operator&lt;(const PlainEdge &amp;other) const { return w &lt; other.w; } } E[MAXM + 1], newE[MAXM + 1]; int n, m, k, p[MAXN + 1], cnt, belong[MAXN + 1], edgeCnt; struct UnionFindSet { int fa[MAXN + 1]; void init(int n) { for (int i = 1; i &lt;= n; i++) fa[i] = i; } void merge(int x, int y) { fa[find(x)] = find(y); } int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); } } ufs; inline void prepare() { // Kruskal ufs.init(n); for (int i = m + 1; i &lt;= m + k; i++) { ufs.merge(E[i].u, E[i].v); } std::sort(E + 1, E + m + 1); for (int i = 1; i &lt;= m; i++) { if (ufs.find(E[i].u) != ufs.find(E[i].v)) { E[i].selected = true; ufs.merge(E[i].u, E[i].v); #ifdef DBG printf("Must Select Edge: (%d, %d, %d)\n", E[i].u, E[i].v, E[i].w); #endif } } // Discrete ufs.init(n); for (int i = 1; i &lt;= m; i++) if (E[i].selected) ufs.merge(E[i].u, E[i].v); static int a[MAXN + 1]; for (int i = 1; i &lt;= n; i++) a[i] = ufs.find(i); static int set[MAXN + 1]; std::copy(a + 1, a + n + 1, set + 1); std::sort(set + 1, set + n + 1); int *end = std::unique(set + 1, set + n + 1); for (int i = 1; i &lt;= n; i++) { belong[i] = std::lower_bound(set + 1, end, a[i]) - set; #ifdef DBG printf("%d belongs to block %d\n", i, belong[i]); #endif N[belong[i]].initS += p[i]; } cnt = end - (set + 1); static int w[MAXK + 2][MAXK + 2]; for (int i = 1; i &lt;= cnt; i++) for (int j = 1; j &lt;= cnt; j++) w[i][j] = INT_MAX; for (int i = 1; i &lt;= m; i++) { if (E[i].selected) continue; int u = belong[E[i].u], v = belong[E[i].v]; w[u][v] = w[v][u] = std::min(w[v][u], E[i].w); } for (int i = 1; i &lt;= cnt; i++) { for (int j = i + 1; j &lt;= cnt; j++) { if (w[i][j] != INT_MAX) { edgeCnt++; newE[edgeCnt].u = i; newE[edgeCnt].v = j; newE[edgeCnt].w = w[i][j]; // addEdge(i, j, w[i][j]); } } } std::sort(newE + 1, newE + edgeCnt + 1); // assert(belong[1] == 1); } inline void dfs(Node *v, Node *fa = NULL) { v-&gt;s = v-&gt;initS; for (Edge *e = &amp;v-&gt;e.front(); e &amp;&amp; e &lt;= &amp;v-&gt;e.back(); e++) { if (e-&gt;t == fa) continue; e-&gt;t-&gt;modifiable = e-&gt;w == INT_MAX; e-&gt;t-&gt;w = e-&gt;w; e-&gt;t-&gt;fa = v; e-&gt;t-&gt;dep = v-&gt;dep + 1; dfs(e-&gt;t, v); v-&gt;s += e-&gt;t-&gt;s; } } inline void clear() { for (int i = 1; i &lt;= edgeCnt; i++) newE[i].selected = false; for (int i = 1; i &lt;= cnt; i++) { N[i].modifiable = false; N[i].w = N[i].dep = N[i].s = 0; N[i].fa = NULL; N[i].e.clear(); } #ifdef DBG puts("[Cleared]"); #endif } /* inline Node *lca(Node *u, Node *v) { for (; u != v; u = u-&gt;fa) if (u-&gt;dep &lt; v-&gt;dep) std::swap(u, v); return u; } */ inline void applyMin(int u, int v, int w) { /* Node *p = lca(&amp;N[u], &amp;N[v]); for (Node *a = &amp;N[u]; a != p; a = a-&gt;fa) if (a-&gt;modifiable) a-&gt;w = std::min(a-&gt;w, w); for (Node *a = &amp;N[v]; a != p; a = a-&gt;fa) if (a-&gt;modifiable) a-&gt;w = std::min(a-&gt;w, w); */ // printf("apply min (%d, %d, %d)\n", v, u, w); u = ufs.find(u); v = ufs.find(v); while (u != v) { if (N[u].dep &lt; N[v].dep) std::swap(u, v); if (N[u].modifiable) N[u].w = w; ufs.merge(u, N[u].fa - N); u = ufs.find(u); } } inline long long solve() { long long ans = 0; for (int s = 0; s &lt; (1 &lt;&lt; k); s++) { clear(); ufs.init(cnt); // k new edges bool circle = false; for (int i = 0; i &lt; k; i++) { if (s &amp; (1 &lt;&lt; i)) { int u = belong[E[m + 1 + i].u], v = belong[E[m + 1 + i].v]; if (ufs.find(u) != ufs.find(v)) { ufs.merge(u, v); addEdge(u, v, INT_MAX); } else { circle = true; break; } } } if (circle) continue; // Old edges for (int i = 1; i &lt;= edgeCnt; i++) { if (ufs.find(newE[i].u) != ufs.find(newE[i].v)) { ufs.merge(newE[i].u, newE[i].v); newE[i].selected = true; addEdge(newE[i].u, newE[i].v, newE[i].w); } } /* for (int i = 1; i &lt;= cnt; i++) { for (int j = i + 1; j &lt;= cnt; j++) { if (w[i][j] != INT_MAX) { if (ufs.find(i) != ufs.find(j)) { ufs.merge(i, j); selected[i][j] = true; addEdge(i, j, w[i][j]); } } } } */ dfs(&amp;N[belong[1]]); ufs.init(cnt); for (int i = 1; i &lt;= edgeCnt; i++) { if (!newE[i].selected) { applyMin(newE[i].u, newE[i].v, newE[i].w); } } long long sum = 0; for (int i = 1; i &lt;= cnt; i++) { if (N[i].modifiable) sum += N[i].s * N[i].w; } ans = std::max(ans, sum); } return ans; } int main() { n = read(), m = read(), k = read(); for (int i = 1; i &lt;= m; i++) { E[i].u = read(); E[i].v = read(); E[i].w = read(); // scanf("%d %d %d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].w); } for (int i = m + 1; i &lt;= m + k; i++) { E[i].u = read(); E[i].v = read(); // scanf("%d %d", &amp;E[i].u, &amp;E[i].v); E[i].w = -1; } for (int i = 1; i &lt;= n; i++) p[i] = read(); // scanf("%d", &amp;p[i]); prepare(); printf("%lld\n", solve()); }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>APIO</tag>
        <tag>UOJ</tag>
        <tag>搜索</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「APIO2014」Split the sequence - 斜率优化 DP]]></title>
    <url>%2Fapio2014-sequence%2F</url>
    <content type="text"><![CDATA[你正在玩一个关于长度为 的非负整数序列的游戏。这个游戏中你需要把序列分成 个非空的块。为了得到 块，你需要重复下面的操作 次： 选择一个有超过一个元素的块（初始时你只有一块，即整个序列） 选择两个相邻元素把这个块从中间分开，得到两个非空的块。 每次操作后你将获得那两个新产生的块的元素和的乘积的分数。你想要最大化最后的总得分。 链接 BZOJ 3675 UOJ #104 题解 首先，可以发现分割顺序对答案不影响，所以可以 DP，设 表示前 个数分成 段的答案，设 为前缀和，则 时间复杂度为 ，考虑优化 设 ，上式化为 设 考虑两个决策 和 ， 比 优当且仅当 斜率优化。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cfloat&gt; #include &lt;algorithm&gt; const int MAXN = 100000; const int MAXK = 200; long long f[MAXK + 1][MAXN], *f0; int n, t, g[MAXK + 1][MAXN]; long long s[MAXN + 1]; inline long long F(int i) { return f0[i] - s[i] * s[n]; } inline double slope(int k1, int k2) { return s[k2] == s[k1] ? -DBL_MAX : (double)(F(k1) - F(k2)) / (s[k2] - s[k1]); } inline long long solve() { long long ans = 0; for (int j = 1; j &lt;= t; j++) { f0 = f[j - 1]; static int q[MAXN + 1]; int *l = q, *r = q - 1; *++r = j - 1; for (int i = j; i &lt; n; i++) { while (r - l &gt;= 1 &amp;&amp; slope(*l, *(l + 1)) &lt;= s[i]) l++; f[j][i] = F(*l) + s[i] * (s[n] - s[i] + s[*l]); g[j][i] = *l; // printf("f(%d, %d) = %lld (%d)\n", i, j, f[j][i], *l); ans = std::max(ans, f[j][i]); while (r - l &gt;= 1 &amp;&amp; slope(*r, i) &lt; slope(*(r - 1), *r)) r--; *++r = i; // *++r = f0[i] - s[i] * s[n]; } } return ans; } int main() { scanf("%d %d", &amp;n, &amp;t); static int a[MAXN + 1]; for (int i = 1; i &lt;= n; i++) { scanf("%d", &amp;a[i]); s[i] = s[i - 1] + a[i]; } /* static long long f[MAXN + 1][MAXK + 1]; static int g[MAXN + 1][MAXK + 1]; // long long ans = 0; for (int j = 1; j &lt;= t; j++) { for (int i = j; i &lt;= n; i++) { for (int k = j - 1; k &lt;= i - 1; k++) { if (f[i][j] &lt; f[k][j - 1] + (s[i] - s[k]) * (s[n] - s[i])) { f[i][j] = f[k][j - 1] + (s[i] - s[k]) * (s[n] - s[i]); // ans = std::max(ans, f[i][j]); g[i][j] = k; } } printf("f(%d, %d) = %lld (%d)\n", i, j, f[i][j], g[i][j]); } } */ long long ans = solve(); printf("%lld\n", ans); for (int i = n - 1; i &gt;= 0; i--) { if (f[t][i] == ans) { printf("%d", i); for (int k = t, p = g[t][i], cnt = 1; cnt &lt; t; p = g[--k][p], cnt++) printf(" %d", p); puts(""); goto end; } } end:; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>APIO</tag>
        <tag>UOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CTSC2012」Cheat - SAM + 二分 + 单调队列 DP]]></title>
    <url>%2Fctsc2012-cheat%2F</url>
    <content type="text"><![CDATA[给出 个串组成的「标准作文库」。对于任意一个串，如果它的长度不少于 且在标准作文库中出现过，则它是「熟悉」的。对于任意一个串，如果能将它划分为若干个串，使「熟悉」的串的长度超过总长度的 ，则称这个串是「熟悉的文章」，定义 为使这个串成为「熟悉的文章」的最大的 。给出若干个串，求每个串的 值。 链接 BZOJ 2806 题解 对标准做文库中的串建立 SAM，将每个串在 SAM 上运行，求出以每个字符结尾的最长匹配长度 。二分一个 ，设 表示前 个字符划分为若干个串，「熟悉」的串的长度和的最大值，则有 化为这种形式 单调队列优化即可。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 1100000; const int CHARSET_SIZE = 3; const double EPS = 1e-6; struct SuffixAutomaton { struct Node { Node *ch[CHARSET_SIZE], *next; int max; Node(int max = 0) : ch(), next(NULL), max(max) {} } *start, *last; void init() { start = last = new Node; } Node *extend(int c) { Node *u = new Node(last-&gt;max + 1), *v = last; do { v-&gt;ch[c] = u; v = v-&gt;next; } while (v &amp;&amp; !v-&gt;ch[c]); if (!v) { u-&gt;next = start; } else if (v-&gt;ch[c]-&gt;max == v-&gt;max + 1) { u-&gt;next = v-&gt;ch[c]; } else { Node *n = new Node(v-&gt;max + 1), *o = v-&gt;ch[c]; std::copy(o-&gt;ch, o-&gt;ch + CHARSET_SIZE, n-&gt;ch); n-&gt;next = o-&gt;next; o-&gt;next = u-&gt;next = n; for (; v &amp;&amp; v-&gt;ch[c] == o; v = v-&gt;next) v-&gt;ch[c] = n; } last = u; return u; } } sam; char s[MAXN + 2]; int len, matchLen[MAXN + 1]; inline void match() { SuffixAutomaton::Node *v = sam.start; int matched = 0; for (int i = 1; i &lt;= len; i++) { int c = s[i] - '0'; while (v != sam.start &amp;&amp; !v-&gt;ch[c]) { v = v-&gt;next; matched = v-&gt;max; } if (v-&gt;ch[c]) { v = v-&gt;ch[c]; matched++; } matchLen[i] = matched; // printf("%d, matched = %d\n", c, matched); } } /* inline bool check(int l) { // printf("l = %d\n", l); static int f[MAXN + 1]; std::fill(f + 1, f + len + 1, 0); for (int i = 1; i &lt;= len; i++) { f[i] = f[i - 1]; for (int j = i - matchLen[i]; j &lt;= i - l; j++) { // f[i] = std::max(f[i], f[j] + (i - j)); f[i] = std::max(f[i], f[j] - j + i); } // printf("f[%d] = %d\n", i, f[i]); } return f[len] + EPS &gt;= len * 0.9; } */ inline bool check(int l) { static int q[MAXN + 1], f[MAXN + 1]; int *ql = q, *qr = q - 1; std::fill(f + 1, f + len + 1, 0); for (int i = 1; i &lt;= len; i++) { f[i] = f[i - 1]; // Insert curr pos int curr = i - l; if (curr &gt;= 0) { while (ql &lt;= qr &amp;&amp; f[curr] - curr &gt; f[*qr] - *qr) qr--; *++qr = curr; } // Remove invalid pos while (ql &lt;= qr &amp;&amp; *ql &lt; i - matchLen[i]) ql++; // Get best pos if (ql &lt;= qr) f[i] = std::max(f[i], f[*ql] - *ql + i); } return f[len] + EPS &gt;= len * 0.9; } int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); sam.init(); while (m--) { scanf("%s", s + 1); int len = strlen(s + 1); for (int i = 1; i &lt;= len; i++) sam.extend(s[i] - '0'); if (m) sam.extend(2); } while (n--) { scanf("%s", s + 1); len = strlen(s + 1); match(); /* check(4); break; */ int l = 0, r = len; while (l &lt; r) { int mid = l + (r - l) / 2 + 1; if (check(mid)) l = mid; else r = mid - 1; } printf("%d\n", l); } }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>单调队列</tag>
        <tag>SAM</tag>
        <tag>CTSC</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2555」SubString - SAM + LCT]]></title>
    <url>%2Fbzoj-2555%2F</url>
    <content type="text"><![CDATA[在当前字符串的后面插入一个字符串； 询问字符串 在当前字符串中出现了几次？（作为连续子串） 链接 BZOJ 2555 题解 在线查询字符串的出现次数，需要在线维护 集合的大小。使用 Link-Cut Tree 维护有根树的子树和。每次 Link 两个节点后，重新将根节点置为有根树的根，然后将子节点的权值加到父节点到根的一条链上；反之，Cut 后要将其减去。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 600000; const int MAXL = 3000000; const int MAXM = 10000; const int CHARSET_SIZE = 26; struct LinkCutTree { struct Node { Node *ch[2], *fa, *pathFa; int val, tag; bool rev; int relation() { return this == fa-&gt;ch[1]; } void pushDown() { if (rev) { rev ^= 1; std::swap(ch[0], ch[1]); if (ch[0]) ch[0]-&gt;rev ^= 1; if (ch[1]) ch[1]-&gt;rev ^= 1; } if (tag) { if (ch[0]) ch[0]-&gt;add(tag); if (ch[1]) ch[1]-&gt;add(tag); tag = 0; } } void rotate() { pushDown(); int r = relation(); Node *o = fa; std::swap(pathFa, o-&gt;pathFa); fa = o-&gt;fa; if (o-&gt;fa) o-&gt;fa-&gt;ch[o-&gt;relation()] = this; o-&gt;ch[r] = ch[r ^ 1]; if (ch[r ^ 1]) ch[r ^ 1]-&gt;fa = o; ch[r ^ 1] = o; o-&gt;fa = this; } void splay() { while (fa) { if (fa-&gt;fa) fa-&gt;fa-&gt;pushDown(); fa-&gt;pushDown(); if (!fa-&gt;fa) rotate(); else if (fa-&gt;relation() == relation()) fa-&gt;rotate(), rotate(); else rotate(), rotate(); } } void expose() { splay(); pushDown(); if (ch[1]) { std::swap(ch[1]-&gt;fa, ch[1]-&gt;pathFa); ch[1] = NULL; } } bool splice() { splay(); if (!pathFa) return false; pathFa-&gt;expose(); pathFa-&gt;ch[1] = this; std::swap(pathFa, fa); return true; } void access() { expose(); while (splice()); } void evert() { access(); splay(); rev ^= 1; } void add(int delta) { val += delta; tag += delta; } } N[MAXN * 2 + 1]; void link(int fa, int ch) { Node *f = &amp;N[fa], *c = &amp;N[ch]; f-&gt;evert(); c-&gt;splay(); c-&gt;pathFa = f; N[0].evert(); f-&gt;access(); f-&gt;splay(); f-&gt;val += c-&gt;val; if (f-&gt;ch[0]) f-&gt;ch[0]-&gt;add(c-&gt;val); } void cut(int fa, int ch) { Node *f = &amp;N[fa], *c = &amp;N[ch]; f-&gt;evert(); c-&gt;access(); f-&gt;splay(); f-&gt;pushDown(); f-&gt;ch[1] = NULL; c-&gt;fa = NULL; N[0].evert(); f-&gt;access(); f-&gt;splay(); f-&gt;val -= c-&gt;val; if (f-&gt;ch[0]) f-&gt;ch[0]-&gt;add(-c-&gt;val); } void update(int u, int val) { N[u].val = val; } int query(int u) { Node *a = &amp;N[u]; a-&gt;splay(); return a-&gt;val; } } lct; struct SuffixAutomaton { struct Node { Node *ch[CHARSET_SIZE], *next; int max; Node(int max = 0) : ch(), next(NULL), max(max) {} } *start, *last, _pool[MAXN * 2 + 1], *_curr; void init() { _curr = _pool; start = last = new (_curr++) Node; } int id(Node *v) { return v - _pool; } Node *extend(int c) { Node *u = new (_curr++) Node(last-&gt;max + 1), *v = last; lct.update(id(u), 1); do { v-&gt;ch[c] = u; v = v-&gt;next; } while (v &amp;&amp; !v-&gt;ch[c]); if (!v) { u-&gt;next = start; lct.link(id(start), id(u)); } else if (v-&gt;ch[c]-&gt;max == v-&gt;max + 1) { u-&gt;next = v-&gt;ch[c]; lct.link(id(v-&gt;ch[c]), id(u)); } else { Node *n = new (_curr++) Node(v-&gt;max + 1), *o = v-&gt;ch[c]; std::copy(o-&gt;ch, o-&gt;ch + CHARSET_SIZE, n-&gt;ch); lct.cut(id(o-&gt;next), id(o)); lct.link(id(o-&gt;next), id(n)); lct.link(id(n), id(o)); lct.link(id(n), id(u)); n-&gt;next = o-&gt;next; o-&gt;next = u-&gt;next = n; for (; v &amp;&amp; v-&gt;ch[c] == o; v = v-&gt;next) v-&gt;ch[c] = n; } last = u; return u; } } sam; char s[MAXL + 2]; int len; inline void decode(int mask) { for (int i = 0; i &lt; len; i++) { mask = (mask * 131 + i) % len; std::swap(s[i + 1], s[mask + 1]); } } inline void extend() { for (int i = 1; i &lt;= len; i++) sam.extend(s[i] - 'A'); } inline int solve() { SuffixAutomaton::Node *v = sam.start; for (int i = 1; i &lt;= len; i++) { int c = s[i] - 'A'; if (!v-&gt;ch[c]) return 0; v = v-&gt;ch[c]; } return lct.query(sam.id(v)); } int main() { int q; scanf("%d", &amp;q); sam.init(); scanf("%s", s + 1); len = strlen(s + 1); extend(); int mask = 0; while (q--) { char type[sizeof("QUERY")]; scanf("%s %s", type, s + 1); len = strlen(s + 1); decode(mask); // puts(s + 1); if (type[0] == 'Q') { int ans = solve(); printf("%d\n", ans); mask ^= ans; } else { extend(); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>SAM</tag>
        <tag>Link-Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TJOI2015」弦论 - SAM]]></title>
    <url>%2Ftjoi2015-string%2F</url>
    <content type="text"><![CDATA[对于一个给定长度为 的字符串，求它的字典序第 小的子串。 链接 BZOJ 3998 题解 对串建立 SAM，预处理出每个节点沿着转移边向下走能走到的节点数量和节点的 大小之和，然后用类似权值线段树的方式查找第 小。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; const int MAXN = 5e5; const int CHARSET_SIZE = 26; struct SuffixAutomaton { struct Node { Node *ch[CHARSET_SIZE], *next; int max, posCnt, size, sizeAll; Node(int max = 0, bool newSuffix = false) : ch(), next(NULL), max(max), posCnt(newSuffix) {} int getMin() { return next-&gt;max + 1; } } *start, *last, _pool[MAXN * 2 + 1], *_curr; std::vector&lt;Node *&gt; topo; void init() { _curr = _pool; start = last = new (_curr++) Node; } Node *extend(int c) { Node *u = new (_curr++) Node(last-&gt;max + 1, true), *v = last; do { v-&gt;ch[c] = u; v = v-&gt;next; } while (v &amp;&amp; !v-&gt;ch[c]); if (!v) { u-&gt;next = start; } else if (v-&gt;ch[c]-&gt;max == v-&gt;max + 1) { u-&gt;next = v-&gt;ch[c]; } else { Node *n = new (_curr++) Node(v-&gt;max + 1, false), *o = v-&gt;ch[c]; std::copy(o-&gt;ch, o-&gt;ch + CHARSET_SIZE, n-&gt;ch); n-&gt;next = o-&gt;next; o-&gt;next = u-&gt;next = n; for (; v &amp;&amp; v-&gt;ch[c] == o; v = v-&gt;next) v-&gt;ch[c] = n; } last = u; return u; } std::vector&lt;Node *&gt; &amp;toposort() { static int buc[MAXN * 2 + 1]; int max = 0; for (Node *p = _pool; p != _curr; p++) { max = std::max(max, p-&gt;max); buc[p-&gt;max]++; } for (int i = 1; i &lt;= max; i++) buc[i] += buc[i - 1]; topo.resize(_curr - _pool); for (Node *p = _pool; p != _curr; p++) { topo[--buc[p-&gt;max]] = p; } return topo; } void calc() { toposort(); for (int i = topo.size() - 1; i &gt; 0; i--) { Node *v = topo[i]; v-&gt;next-&gt;posCnt += v-&gt;posCnt; } for (int i = topo.size() - 1; i &gt; 0; i--) { Node *v = topo[i]; v-&gt;size = 1; v-&gt;sizeAll = v-&gt;posCnt; for (int j = 0; j &lt; CHARSET_SIZE; j++) { if (v-&gt;ch[j]) { v-&gt;size += v-&gt;ch[j]-&gt;size; v-&gt;sizeAll += v-&gt;ch[j]-&gt;sizeAll; } } // printf("topo[%d]: (max = %d, min = %d, wordCnt = %d / %d, posCnt = %d, size = %d, sizeAll = %d)\n", i, v-&gt;max, v-&gt;getMin(), v-&gt;getWordCnt(true), v-&gt;getWordCnt(false), v-&gt;posCnt, v-&gt;size, v-&gt;sizeAll); } } } sam; inline void solveNoDup(int k) { SuffixAutomaton::Node *v = sam.start; while (k) { bool flag = false; for (int i = 0; i &lt; CHARSET_SIZE; i++) { if (v-&gt;ch[i]) { if (k - v-&gt;ch[i]-&gt;size &lt;= 0) { v = v-&gt;ch[i]; k--; putchar('a' + i); flag = true; break; } else k -= v-&gt;ch[i]-&gt;size; } } if (!flag) { puts("-1"); return; } } putchar('\n'); } inline void solveDup(int k) { SuffixAutomaton::Node *v = sam.start; while (k) { bool flag = false; for (int i = 0; i &lt; CHARSET_SIZE; i++) { if (v-&gt;ch[i]) { if (k - v-&gt;ch[i]-&gt;sizeAll &lt;= 0) { v = v-&gt;ch[i]; k -= v-&gt;posCnt; putchar('a' + i); flag = true; break; } else k -= v-&gt;ch[i]-&gt;sizeAll; } } if (!flag) { puts("-1"); return; } } putchar('\n'); } int main() { static char s[MAXN + 1]; scanf("%s", s); int n = strlen(s); sam.init(); for (int i = 0; i &lt; n; i++) sam.extend(s[i] - 'a'); sam.calc(); int t, k; scanf("%d %d", &amp;t, &amp;k); if (t == 0) solveNoDup(k); else solveDup(k); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>SAM</tag>
        <tag>TJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1396」识别子串 - SAM + 线段树]]></title>
    <url>%2Fbzoj-1396%2F</url>
    <content type="text"><![CDATA[对于一个字符串 ，和 中的第 个字符 ，定义子串 为一个关于 的识别子串，当且仅当： ； 在 中只出现一次。 求 关于每一位字符的最短识别子串长度。 链接 BZOJ 1396 题解 对 建立 SAM，找出其中所有 集合大小为 的，这些节点所表示的字符串只出现过一次。 用线段树维护每个位置的最短识别子串长度。对于一个符合条件的节点 ，它表示的所有子串的结束位置是固定的，设这个位置为 ，设最短的子串的起始位置为 ，则对于 范围内的每个位置 ， 都是它的识别子串，用 去更新它们的答案。起始位置在 左侧的那些子串（起始位置在 之间），以每个起始位置 开始的子串长度为 ，是一个关于 的一次函数，可以用线段树（李超树）维护。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; const int MAXN = 1e5; const int CHARSET_SIZE = 26; struct SuffixAutomaton { struct Node { Node *ch[CHARSET_SIZE], *next; int max, posCnt, pos; Node(int max = 0, bool newSuffix = false) : ch(), next(NULL), max(max), posCnt(newSuffix), pos(-1) {} int getMin() { return next-&gt;max + 1; } } *start, *last, _pool[MAXN * 2 + 1], *_curr; std::vector&lt;Node *&gt; topo; void init() { _curr = _pool; start = last = new (_curr++) Node; } Node *extend(int c) { Node *u = new (_curr++) Node(last-&gt;max + 1, true), *v = last; do { v-&gt;ch[c] = u; v = v-&gt;next; } while (v &amp;&amp; !v-&gt;ch[c]); if (!v) { u-&gt;next = start; } else if (v-&gt;ch[c]-&gt;max == v-&gt;max + 1) { u-&gt;next = v-&gt;ch[c]; } else { Node *n = new (_curr++) Node(v-&gt;max + 1, false), *o = v-&gt;ch[c]; std::copy(o-&gt;ch, o-&gt;ch + CHARSET_SIZE, n-&gt;ch); n-&gt;next = o-&gt;next; o-&gt;next = u-&gt;next = n; for (; v &amp;&amp; v-&gt;ch[c] == o; v = v-&gt;next) v-&gt;ch[c] = n; } last = u; return u; } std::vector&lt;Node *&gt; &amp;toposort() { static int buc[MAXN * 2 + 1]; int max = 0; for (Node *p = _pool; p != _curr; p++) { max = std::max(max, p-&gt;max); buc[p-&gt;max]++; } for (int i = 1; i &lt;= max; i++) buc[i] += buc[i - 1]; topo.resize(_curr - _pool); for (Node *p = _pool; p != _curr; p++) { topo[--buc[p-&gt;max]] = p; } for (int i = 0; i &lt;= max; i++) buc[i] = 0; return topo; } void calc() { toposort(); for (int i = topo.size() - 1; i &gt; 0; i--) { Node *v = topo[i]; v-&gt;next-&gt;posCnt += v-&gt;posCnt; } } } sam; struct LinearFunction { int k, b; LinearFunction(int x) : k(0), b(x) {} LinearFunction(int k, int b) : k(k), b(b) {} int operator()(int x) { return k * x + b; } }; struct SegT { int l, r, mid; SegT *lc, *rc; LinearFunction f; SegT(int l, int r, SegT *lc, SegT *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), f(INT_MAX) {} int query(int pos) { if (l == r) return f(pos); else return std::min(f(pos), (pos &gt; mid ? rc : lc)-&gt;query(pos)); } void cover(LinearFunction f) { if (f(mid) &lt; this-&gt;f(mid)) std::swap(f, this-&gt;f); if (f(l) &lt; this-&gt;f(l)) lc-&gt;cover(f); if (f(r) &lt; this-&gt;f(r)) rc-&gt;cover(f); } void update(int ql, int qr, const LinearFunction &amp;f) { if (ql &gt; r || qr &lt; l) return; else if (ql &lt;= l &amp;&amp; qr &gt;= r) cover(f); else lc-&gt;update(ql, qr, f), rc-&gt;update(ql, qr, f);; } static SegT *build(int l, int r) { if (l == r) return new SegT(l, r, NULL, NULL); else { int mid = l + (r - l) / 2; return new SegT(l, r, build(l, mid), build(mid + 1, r)); } } }; int main() { static char s[MAXN + 1]; scanf("%s", s); int n = strlen(s); sam.init(); for (int i = 0; i &lt; n; i++) { SuffixAutomaton::Node *v = sam.extend(s[i] - 'a'); v-&gt;pos = i; } sam.calc(); /* static int ans[MAXN + 1]; for (int i = 0; i &lt; n; i++) ans[i] = INT_MAX; */ SegT *seg = SegT::build(0, n - 1); for (int i = sam.topo.size() - 1; i &gt; 0; i--) { SuffixAutomaton::Node *v = sam.topo[i]; if (v-&gt;posCnt == 1 &amp;&amp; v-&gt;pos != -1) { // printf("pos = %d, [%d, %d]\n", v-&gt;pos, v-&gt;getMin(), v-&gt;max); int min = v-&gt;getMin(), max = v-&gt;max, right = v-&gt;pos; // [right - min + 1, right] &lt;-- min seg-&gt;update(right - min + 1, right, LinearFunction(min)); int l = right - max + 1, r = right - min + 1; // f(x) = -(x - l) + max // = -x + (l + max) // seg-&gt;update(l, r, LinearFunction(-1, l + max)); seg-&gt;update(l, r, LinearFunction(-1, right + 1)); /* for (int j = v-&gt;getMin(); j &lt;= v-&gt;max; j++) { for (int k = v-&gt;pos - j + 1; k &lt;= v-&gt;pos; k++) { putchar(s[k]); ans[k] = std::min(ans[k], j); } puts(""); } */ } } for (int i = 0; i &lt; n; i++) printf("%d\n", seg-&gt;query(i)); }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>BZOJ</tag>
        <tag>SAM</tag>
        <tag>李超树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2010」古代猪文 - 费马小定理 + Lucas + CRT]]></title>
    <url>%2Fsdoi2010-ancient%2F</url>
    <content type="text"><![CDATA[远古时期猪王国有 个文字，现有的文字数量为远古时期的 （ 是 的一个正约数），剩余的 个文字有很多种情况，假设有 种情况，则研究这些文字的代价为 ，求这个代价对 取模后的结果。 链接 BZOJ 1951 题解 列出式子，答案为 模数 是指数，根据费马小定理，指数可以化为 枚举 ，转化为快速求组合数。对模数 分解质因数的结果为 ，分别预处理在模这几个数意义下的阶乘及阶乘逆元，用 Lucas 定理计算出在模每个数意义下的组合数，并用 CRT 合并。 最后使用快速幂计算即可。 代码 #include &lt;cstdio&gt; const long long MOD = 999911659; const long long MOD_FACTORS[] = { 2, 3, 4679, 35617 }; // Factors of 999911659 - 1 const int MAXN = 35617; long long n; long long fac[4][MAXN + 1], facInv[4][MAXN + 1]; inline void exgcd(long long a, long long b, long long &amp;g, long long &amp;x, long long &amp;y) { if (!b) g = a, x = 1, y = 0; else exgcd(b, a % b, g, y, x), y -= x * (a / b); } inline long long inv(long long a, long long p) { long long g, res, tmp; exgcd(a, p, g, res, tmp); return (res % p + p) % p; } inline void prepare() { for (int i = 0; i &lt; 4; i++) { int p = MOD_FACTORS[i]; fac[i][0] = facInv[i][0] = 1; for (int j = 1; j &lt;= MAXN; j++) { fac[i][j] = fac[i][j - 1] * j % p; facInv[i][j] = inv(fac[i][j], p); } } } inline long long C(int n, int k, int i) { if (!k) return 1; if (n &lt; k) return 0; int p = MOD_FACTORS[i]; // printf("C(%d, %d) %% %d = %lld\n", n, k, p, fac[i][n] * facInv[i][k] % p * facInv[i][n - k] % p); return fac[i][n] * facInv[i][k] % p * facInv[i][n - k] % p; } // mod MOD_FACTORS[i] inline long long lucas(long long n, long long k, int i) { if (!k) return 1; int p = MOD_FACTORS[i]; return C(n % p, k % p, i) * lucas(n / p, k / p, i) % p; } inline void crtMerge(long long a1, long long p1, long long a2, long long p2, long long &amp;na, long long &amp;np) { // x = a1 (mod p1) // x = a2 (mod p2) // // =&gt; x = a1 + p1 * t1 // x = a2 + p2 * t2 // // =&gt; a1 + p1 * t1 = a2 + p2 * t2 // a1 - a2 = p2 * t2 - p1 * t1 // // =&gt; g = gcd(p1, p2) = p2 * d2 - p1 * d1 // t2 = d2 * ((a1 - a2) / g) // t1 = d1 * ((a1 - a2) / g) long long g, d1, d2; exgcd(p2, -p1, g, d2, d1); long long t2 = d2 * ((a1 - a2) / g); np = p1 / g * p2; if (np &lt; 0) np = -np; na = ((a2 + p2 * t2) % np + np) % np; // printf("crtMerge((%lld, %lld), (%lld, %lld)) = (%lld, %lld)\n", a1, p1, a2, p2, na, np); } inline long long crt(const long long a[], const long long p[], int n) { long long a0 = a[0], p0 = p[0]; for (int i = 1; i &lt; n; i++) { long long na, np; crtMerge(a0, p0, a[i], p[i], na, np); a0 = na; p0 = np; } return a0; } inline long long addFactor(long long d) { long long a[4]; for (int i = 0; i &lt; 4; i++) { a[i] = lucas(n, n / d, i); // printf("C(%lld, %lld) = %lld\n", n, n / d, a[i]); } long long res = crt(a, MOD_FACTORS, 4); // printf("addFactor(%lld) = %lld\n", d, res); return res; } inline long long pow(long long a, long long n, long long p) { long long res = 1; for (; n; n &gt;&gt;= 1, a = a * a % p) if (n &amp; 1) res = res * a % p; return res; } int main() { prepare(); long long g; scanf("%lld %lld", &amp;n, &amp;g); if (g == MOD) { puts("0"); } else { long long sum = 0; for (int d = 1; (long long)d * d &lt;= n; d++) { if (n % d == 0) { sum += addFactor(d); if (d != n / d) sum += addFactor(n / d); sum %= (MOD - 1); } } long long ans = pow(g, sum, MOD); printf("%lld\n", ans); } }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>Lucas 定理</tag>
        <tag>SDOI</tag>
        <tag>CRT</tag>
        <tag>费马小定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2013」随机数生成器 - 数学 + BSGS]]></title>
    <url>%2Fsdoi2013-random%2F</url>
    <content type="text"><![CDATA[给定 、、、，现有一数列 求最小的 满足 。 链接 BZOJ 3122 题解 令 ，得 当 时 否则，设 令 代入得 未知量只有左边 的指数，使用 BSGS 求出即可。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;map&gt; inline void exgcd(long long a, long long b, long long &amp;g, long long &amp;x, long long &amp;y) { if (!b) g = a, x = 1, y = 0; else exgcd(b, a % b, g, y, x), y -= x * (a / b); } inline long long inv(long long x, long long p) { long long g, res, tmp; exgcd(x, p, g, res, tmp); return (res % p + p) % p; } inline long long bsgs(long long a, long long b, long long p) { a %= p; b %= p; /* long long tmp = 1; for (int i = 1; i &lt;= p; i++) { if (tmp == b) return i - 1; tmp = tmp * a % p; } return -1; */ std::map&lt;long long, long long&gt; map; long long m = ceil(sqrt(p)), t = 1; for (int i = 0; i &lt; m; i++) { if (!map.count(t)) map[t] = i; t = t * a % p; } long long k = inv(t, p), w = b; for (int i = 0; i &lt; m; i++) { if (map.count(w)) return i * m + map[w]; w = w * k % p; } return -1; } inline long long solve(long long p, long long a, long long b, long long x1, long long t) { if (t == x1) return 1; else if (a == 0) return b == t ? 2 : -1; else if (a == 1) { if (!b) return -1; return ((((t - x1) % p + p) % p) * inv(b, p) % p) + 1; } else { long long q = inv(1 - a + p, p); long long d = (((t - b * q) % p + p) % p) * inv(((x1 - b * q) % p + p) % p, p); long long ans = bsgs(a, d, p); if (ans == -1) return -1; else return ans + 1; } } inline long long force(int p, int a, int b, int x1, int t) { if (a == 1) { if (!b) return -1; return ((((t - x1) % p + p) % p) * inv(b, p) % p) + 1; } /* int x = x1; for (int i = 1; i &lt;= p; i++) { // printf("a[%d] = %d\n", i, x); if (x == t) return i; x = (a * x + b) % p; } return -1; */ long long q = inv(1 - a + p, p), ai = 1; /* for (int i = 1; i &lt;= p; i++) { long long x = (ai * (((x1 - b * q) % p + p) % p) + b * q % p) % p; // printf("a[%d] = %lld\n", i, x); if (x == t) return i; ai = (ai * a) % p; } return -1; */ long long tmp = (((t - b * q) % p + p) % p) * inv(((x1 - b * q) % p + p) % p, p) % p; for (int i = 1; i &lt;= p; i++) { if (ai == tmp) return i; ai = (ai * a) % p; } return -1; } int main() { int T; scanf("%d", &amp;T); while (T--) { int p, a, b, x1, t; scanf("%d %d %d %d %d", &amp;p, &amp;a, &amp;b, &amp;x1, &amp;t); printf("%lld\n", solve(p, a, b, x1, t)); } }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>数论</tag>
        <tag>BSGS</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2008」Sandy 的卡片 - 差分 + SAM]]></title>
    <url>%2Fsdoi2008-card%2F</url>
    <content type="text"><![CDATA[相同的定义为：两个子串长度相同且一个串的全部元素加上一个数就会变成另一个串。给 个串，求它们相同的子串最大长度。 链接 BZOJ 4698 题解 将每个串差分（转化 ），转化为求最长公共子串，然后将结果 即为答案。 对第一个串建立 SAM，对 SAM 的每个节点维护当前匹配长度。对于每个串，将其放在 SAM 上运行，在每个节点处走到这个节点时这个串的最长匹配后缀长度。然后用每个点的当前匹配长度去更新其后缀链接指向节点的当前匹配长度（ 能匹配这么长，则 也能匹配这么长）。每个串的匹配长度取最小值，即为最长的公共「这个节点上字符串」长度。对每个节点的这个值去最大，即为答案。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;map&gt; const int MAXN = 1000; const int MAXL = 1000; struct SuffixAutomaton { struct Node { std::map&lt;int, Node *&gt; ch; Node *next; int max, currMatch, minMatch; Node(int max = 0) : next(NULL), max(max), currMatch(0), minMatch(max) {} } *start, *last, _pool[MAXL * 2 + 1], *_curr; std::vector&lt;Node *&gt; topo; void init() { _curr = _pool; start = last = new (_curr++) Node; } Node *extend(int c) { Node *u = new (_curr++) Node(last-&gt;max + 1), *v = last; for (; v &amp;&amp; !v-&gt;ch[c]; v = v-&gt;next) v-&gt;ch[c] = u; if (!v) { u-&gt;next = start; } else if (v-&gt;ch[c]-&gt;max == v-&gt;max + 1) { u-&gt;next = v-&gt;ch[c]; } else { Node *o = v-&gt;ch[c], *n = new (_curr++) Node(v-&gt;max + 1); n-&gt;ch = o-&gt;ch; n-&gt;next = o-&gt;next; u-&gt;next = o-&gt;next = n; for (; v &amp;&amp; v-&gt;ch[c] == o; v = v-&gt;next) v-&gt;ch[c] = n; } last = u; return u; } std::vector&lt;Node *&gt; toposort() { static int buc[MAXL * 2 + 1]; int max = 0; for (Node *p = _pool; p != _curr; p++) { buc[p-&gt;max]++; max = std::max(max, p-&gt;max); } for (int i = 1; i &lt;= max; i++) buc[i] += buc[i - 1]; topo.resize(_curr - _pool); for (Node *p = _pool; p != _curr; p++) topo[--buc[p-&gt;max]] = p; std::fill(buc, buc + max + 1, 0); return topo; } } sam; inline int lcs(std::vector&lt;int&gt; a[], int n) { sam.init(); for (int i = 1; i &lt;= int(a[1].size()); i++) { sam.extend(a[1][i]); } int ans = a[1].size() - 1; std::vector&lt;SuffixAutomaton::Node *&gt; topo = sam.toposort(); for (int i = 2; i &lt;= n; i++) { SuffixAutomaton::Node *v = sam.start; int l = 0; for (int j = 1; j &lt;= int(a[i].size()); j++) { int c = a[i][j]; while (v != sam.start &amp;&amp; !v-&gt;ch.count(c)) { v = v-&gt;next; l = v-&gt;max; } if (v-&gt;ch.count(c)) { v = v-&gt;ch[c]; l++; } v-&gt;currMatch = std::max(v-&gt;currMatch, l); } int tmp = 0; for (int i = topo.size() - 1; i &gt; 0; i--) { SuffixAutomaton::Node *v = topo[i]; v-&gt;next-&gt;currMatch = std::max(v-&gt;next-&gt;currMatch, v-&gt;currMatch); v-&gt;minMatch = std::min(v-&gt;minMatch, v-&gt;currMatch); v-&gt;currMatch = 0; tmp = std::max(tmp, v-&gt;minMatch); } ans = std::min(ans, tmp); } return ans; } int main() { int n; scanf("%d", &amp;n); static std::vector&lt;int&gt; a[MAXN + 1]; int maxAns = INT_MAX; for (int i = 1; i &lt;= n; i++) { int m; scanf("%d", &amp;m); maxAns = std::min(maxAns, m); a[i].resize(m + 1); for (int j = 1; j &lt;= m; j++) { scanf("%d", &amp;a[i][j]); } for (int j = m; j &gt; 1; j--) a[i][j] -= a[i][j - 1]; } printf("%d\n", std::min(lcs(a, n) + 1, maxAns)); }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>SAM</tag>
        <tag>差分</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3809」Gty 的二逼妹子序列 - 莫队 + 分块]]></title>
    <url>%2Fbzoj-3809%2F</url>
    <content type="text"><![CDATA[给一个序列，每次求 之间权值在 之间的不同的数的数量。 链接 BZOJ 3809 题解 莫队，用一个数据结构维护前缀和，维护当前区间每个数的出现次数，某个数第一次出现时在数据结构中加上这个数，最后一次删除时在数据结构中将其删除，每次转移到目标区间后在数据结构中查询两个前缀和作差。 这个数据结构可以用分块维护，分别维护每个位置的值和每个块的值，修改时分别在目标位置和所在块的值上加上增量，复杂度 ，查询时将整块的和整块外的值分别加入，复杂度 。因为只需要进行 次查询，所以这部分的时间复杂度为 ，并且转移时的复杂度相对与树状数组等结构少一个 。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; const int MAXN = 100000; const int MAXN_SQRT = 317 + 10; // Math.sqrt(100000) = 316.22776601683796 const int MAXM = 1000000; int n, blockSize, m, a[MAXN + 1], cnt[MAXN + 1]; struct Query { int l, r, a, b, *ans; bool operator&lt;(const Query &amp;other) const { if (l / blockSize == other.l / blockSize) return (l / blockSize % 2 == 1) ? (r &lt; other.r) : (r &gt; other.r); else return l / blockSize &lt; other.l / blockSize; } } Q[MAXM + 1]; struct Blocklize { int blockSize, blockCnt, valBlock[MAXN_SQRT + 1], val[MAXN + 1]; void init(int n) { blockSize = ceil(sqrt(n)); blockCnt = n / blockSize + (n % blockSize != 0); } int whichBlock(int x) { return (x - 1) / blockSize + 1; } int getBlockL(int bid) { return (bid - 1) * blockSize + 1; } int query(int pos) { int bid = whichBlock(pos), ans = 0; for (int i = 1; i &lt; bid; i++) ans += valBlock[i]; for (int i = getBlockL(bid); i &lt;= pos; i++) ans += val[i]; return ans; } void update(int pos, int delta) { int bid = whichBlock(pos); valBlock[bid] += delta; val[pos] += delta; } } ds; // data structure inline void extend(int pos, int d) { int x = a[pos]; if (d == 1) { if (++cnt[x] == 1) ds.update(x, d); } else { if (--cnt[x] == 0) ds.update(x, d); } } inline int query(int a, int b) { return ds.query(b) - ds.query(a - 1); } inline void mo() { int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) { Query &amp;q = Q[i]; while (r &lt; q.r) extend(++r, 1); while (r &gt; q.r) extend(r--, -1); while (l &gt; q.l) extend(--l, 1); while (l &lt; q.l) extend(l++, -1); *q.ans = query(q.a, q.b); } } int main() { scanf("%d %d", &amp;n, &amp;m); blockSize = ceil(sqrt(n)); ds.init(n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); static int ans[MAXM + 1]; for (int i = 1; i &lt;= m; i++) { scanf("%d %d %d %d", &amp;Q[i].l, &amp;Q[i].r, &amp;Q[i].a, &amp;Q[i].b); Q[i].ans = &amp;ans[i]; } std::sort(Q + 1, Q + m + 1); mo(); for (int i = 1; i &lt;= m; i++) printf("%d\n", ans[i]); }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>BZOJ</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2012」玄武密码 - SAM]]></title>
    <url>%2Fjsoi2012-symbol%2F</url>
    <content type="text"><![CDATA[给一个字符串 ，给一些字符串 ，求每个 的最长的在 中出现过的前缀的长度。 链接 BZOJ 4327 题解 对 建立 SAM，将每个 放在 SAM 上运行即可。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 1e7; const int CHARSET_SIZE = 4; struct SuffixAutomaton { struct Node { Node *ch[CHARSET_SIZE], *next; int max; Node(int max = 0) : ch(), next(NULL), max(max) {} } *start, *last; void init() { start = last = new Node; } Node *extend(int c) { Node *u = new Node(last-&gt;max + 1), *v = last; for (; v &amp;&amp; !v-&gt;ch[c]; v = v-&gt;next) v-&gt;ch[c] = u; if (!v) { u-&gt;next = start; } else if (v-&gt;ch[c]-&gt;max == v-&gt;max + 1) { u-&gt;next = v-&gt;ch[c]; } else { Node *n = new Node(v-&gt;max + 1), *o = v-&gt;ch[c]; std::copy(o-&gt;ch, o-&gt;ch + CHARSET_SIZE, n-&gt;ch); n-&gt;next = o-&gt;next; u-&gt;next = o-&gt;next = n; for (; v &amp;&amp; v-&gt;ch[c] == o; v = v-&gt;next) v-&gt;ch[c] = n; } last = u; return u; } } sam; inline int convert(char ch) { switch (ch) { case 'N': return 0; case 'S': return 1; case 'W': return 2; case 'E': return 3; default: return -1; } } inline int solve(char *s) { int len = strlen(s); SuffixAutomaton::Node *v = sam.start; for (int i = 0; i &lt; len; i++) { int c = convert(s[i]); if (v-&gt;ch[c]) v = v-&gt;ch[c]; else return i; // The i-th char is not matched } return len; } int main() { int n, m; static char s[MAXN + 1]; scanf("%d %d\n%s", &amp;n, &amp;m, s); sam.init(); for (int i = 0; i &lt; n; i++) { sam.extend(convert(s[i])); } while (m--) { static char s[MAXN + 1]; scanf("%s", s); printf("%d\n", solve(s)); } }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>SAM</tag>
        <tag>JSOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3569」DZY Loves Chinese II - 随机化 + 线性基]]></title>
    <url>%2Fbzoj-3569%2F</url>
    <content type="text"><![CDATA[给一个无向连通图，每次指定其中的 条边，求如果将这些边删除，剩余的图是否仍然连通。 链接 BZOJ 3569 题解 任选一个点开始 DFS，可以得到图的一棵生成树。我们称一条非树边 覆盖了树边 ，当且仅当 与 在树上的路径中包含 和 。 如果删除若干条边，使得原图不再连通，那么一定是删除了一条树边和所有覆盖了这条树边的非树边。我们给每条非树边赋一个随机权值，将每条树边的权值赋为所有覆盖它的非树边的权值的异或和 —— 如果删除的边的边权中，存在一个子集的异或和为零，则一定是选择了一条树边和所有覆盖它的非树边。使用线性基判断即可。 为每条树边赋权值的方式是，为每个点维护一个权值，对于每条非树边 ，将 和 的权值异或上这条边的权值，DFS 过程中将每个点的权值异或上所有子节点的权值（使异或上的权值从下向上传递，在 处被消去）， 到 的每个点的点权都被异或上了这条边的边权，将每条树边的边权赋为其靠近根的端点的点权即可。 代码 #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; const int MAXN = 100000; const int MAXM = 500000; const int MAXL = 40; // for LinearBasis struct Node { std::vector&lt;struct Edge&gt; e; bool vis; unsigned long long xorSum; } N[MAXN + 1]; struct Edge { Node *s, *t; int id; Edge(Node *s, Node *t, int id) : s(s), t(t), id(id) {} }; long long w[MAXM + 1]; inline void addEdge(int s, int t, int id) { N[s].e.push_back(Edge(&amp;N[s], &amp;N[t], id)); N[t].e.push_back(Edge(&amp;N[t], &amp;N[s], id)); } inline unsigned long long rand64() { return ((((unsigned long long)rand()) &lt;&lt; 32) | ((unsigned long long)rand())) &amp; ((1llu &lt;&lt; 40) - 1); } inline void dfs1(Node *v, Node *fa) { v-&gt;vis = true; for (Edge *e = &amp;v-&gt;e.front(); e &amp;&amp; e &lt;= &amp;v-&gt;e.back(); e++) { if (e-&gt;t != fa) { if (!e-&gt;t-&gt;vis) { dfs1(e-&gt;t, v); } else if (!w[e-&gt;id]) { unsigned long long r = rand64(); w[e-&gt;id] = r; v-&gt;xorSum ^= r; e-&gt;t-&gt;xorSum ^= r; } } } } inline void dfs2(Node *v, Node *fa) { v-&gt;vis = true; for (Edge *e = &amp;v-&gt;e.front(); e &amp;&amp; e &lt;= &amp;v-&gt;e.back(); e++) { if (e-&gt;t != fa) { if (!e-&gt;t-&gt;vis) { dfs2(e-&gt;t, v); w[e-&gt;id] = e-&gt;t-&gt;xorSum; v-&gt;xorSum ^= e-&gt;t-&gt;xorSum; } } } } struct LinearBasis { std::vector&lt;unsigned long long&gt; v; void build(unsigned long long *x, int n) { std::vector&lt;unsigned long long&gt; a(MAXL + 1); for (int i = 0; i &lt; n; i++) { unsigned long long t = x[i]; for (int j = MAXL; j &gt;= 0; j--) { if (!(t &amp; (1ull &lt;&lt; j))) continue; if (a[j]) t ^= a[j]; else { for (int k = 0; k &lt; j; k++) if (t &amp; (1ull &lt;&lt; k)) t ^= a[k]; for (int k = j + 1; k &lt;= MAXL; k++) if (a[k] &amp; (1ull &lt;&lt; j)) a[k] ^= t; a[j] = t; break; } } } v.clear(); for (int i = 0; i &lt;= MAXL; i++) if (a[i]) v.push_back(a[i]); } } lb; inline bool solve(int *a, int k) { // for (int i = 0; i &lt; k; i++) printf("%d%c", a[i], " \n"[i == k - 1]); // for (int i = 0; i &lt; k; i++) printf("%llu%c", w[a[i]], " \n"[i == k - 1]); #ifdef FORCE for (int s = 1; s &lt; (1 &lt;&lt; k); s++) { unsigned long long sum = 0; for (int i = 0; i &lt; k; i++) if (s &amp; (1 &lt;&lt; i)) sum ^= w[a[i]]; if (!sum) return false; } return true; #else unsigned long long tmp[k]; for (int i = 0; i &lt; k; i++) tmp[i] = w[a[i]]; lb.build(tmp, k); // printf("%lu &lt;-&gt; %d\n", lb.v.size(), k); return (int)lb.v.size() == k; #endif } int main() { srand(20000528); int n, m; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v); addEdge(u, v, i); } dfs1(&amp;N[1], NULL); for (int i = 1; i &lt;= n; i++) N[i].vis = false; dfs2(&amp;N[1], NULL); // for (int i = 1; i &lt;= m; i++) printf("w[%d] = %llu\n", i, w[i]); int q; scanf("%d", &amp;q); int ansSum = 0; while (q--) { int k; scanf("%d", &amp;k); int a[k]; for (int i = 0; i &lt; k; i++) { scanf("%d", &amp;a[i]); a[i] ^= ansSum; } bool ans = solve(a, k); ansSum += ans; puts(ans ? "Connected" : "Disconnected"); } }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>线性基</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1677」求和 - DP]]></title>
    <url>%2Fbzoj-1677%2F</url>
    <content type="text"><![CDATA[给出一个 ，使用一些 的若干次幂的数相加来求之。问有多少种方法。 链接 BZOJ 1677 题解 背包问题，以 作为物品，求出装满背包的方案数即为答案。 时间复杂度 ，空间 ，需要滚动数组。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 1e6; const int MAXN_LOG = 20; // Math.log2(1e6) = 19.931568569324174 const int MOD = 1e9; int main() { int n; scanf("%d", &amp;n); /* // 注释里都是泪啊 qnqqqqqqqqq static int f[MAXN + 1][MAXN_LOG + 1]; for (int i = 0; i &lt;= MAXN_LOG; i++) f[0][i] = 1; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt;= MAXN_LOG; j++) { if (j != 0) f[i][j] = f[i][j - 1]; if (i &gt;= (1 &lt;&lt; j)) (f[i][j] += f[i - (1 &lt;&lt; j)][j]) %= MOD; // / * for (int k = 0; k &lt;= j &amp;&amp; (1 &lt;&lt; k) &lt;= i; k++) { // printf(" f(%d, %d) &lt;-- f(%d, %d)\n", i, j, i - (1 &lt;&lt; k), k); (f[i][j] += f[i - (1 &lt;&lt; k)][k]) %= MOD; } // printf("f(%d, %d) = %d\n", i, j, f[i][j]); // * / } } */ static int f[MAXN + 1]; f[0] = 1; for (int i = 0; (1 &lt;&lt; i) &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (j - (1 &lt;&lt; i) &gt;= 0) (f[j] += f[j - (1 &lt;&lt; i)]) %= MOD; } } printf("%d\n", f[n]); }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>背包 DP</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2010」部落划分 - Kruskal]]></title>
    <url>%2Fjsoi2010-group%2F</url>
    <content type="text"><![CDATA[在二维平面上给若干个点，将这些点划分为若干个区域，定义两个区域的距离为这两个区域之间最近点对的距离。求将这些点划分为 个区域，使得最近的两个区域的距离最大值。 链接 BZOJ 1821 题解 要使得区域间的距离更远，就要使得区域内的点距离尽量近 —— 每次找距离最近的两个区域合并可以得到一组最优解。在每两个点之间连边，用 Kruskal 做一遍最小生成树，求出连接两个连通块的最短的边即为答案。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; const int MAXN = 1000; const int MAXM = MAXN * (MAXN - 1); struct Edge { int u, v; double w; Edge() {} Edge(int u, int v, double w) : u(u), v(v), w(w) {} bool operator&lt;(const Edge &amp;other) const { return w &lt; other.w; } } E[MAXM + 1]; struct UnionFindSet { int f[MAXN + 1]; void init(int n) { for (int i = 1; i &lt;= n; i++) f[i] = i; } int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); } void merge(int x, int y) { f[find(x)] = find(y); } } ufs; int n, m, k; inline double solve() { std::sort(E + 1, E + m + 1); ufs.init(n); int cnt = n; for (int i = 1; i &lt;= m; i++) { Edge &amp;e = E[i]; if (ufs.find(e.u) == ufs.find(e.v)) continue; if (cnt == k) return E[i].w; ufs.merge(e.u, e.v); cnt--; } return -1; } struct Point { int x, y; Point() {} Point(int x, int y) : x(x), y(y) {} } a[MAXN + 1]; inline double sqr(int x) { return x * x; } inline double dist(Point a, Point b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y)); } int main() { scanf("%d %d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) { scanf("%d %d", &amp;a[i].x, &amp;a[i].y); } for (int i = 1; i &lt;= n; i++) { for (int j = i + 1; j &lt;= n; j++) { E[++m] = Edge(i, j, dist(a[i], a[j])); } } printf("%.2lf\n", solve()); }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>最小生成树</tag>
        <tag>JSOI</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3744」Gty 的妹子序列 - 分块 + 树状数组]]></title>
    <url>%2Fbzoj-3744%2F</url>
    <content type="text"><![CDATA[给一个序列，每次询问 的逆序对数，强制在线。 链接 BZOJ 3744 题解 分块，建立 个树状数组，第 个维护从第一块到第 块内的数，每个树状数组 中维护每个数的出现次数，便于统计 块之前大于或小于 的数的数量。 预处理 块之间的答案或暴力计算答案时，维护一个树状数组，每加入一个数时更新树状数组。 询问跨过多个块时，假设跨过了（完整的） 块，我们要将不在块内的部分加入到块内，具体可以加入到 块的树状数组中，最后再撤销。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;cassert&gt; #include &lt;algorithm&gt; const int MAXN = 50000; const int MAXN_SQRT = 223 + 1; // Math.sqrt(50000) = 223.60679774997897 /* extern struct SegT *null; struct SegT { SegT *lc, *rc; int cnt; SegT() : lc(this), rc(this), cnt(0) {} SegT(SegT *lc, SegT *rc) : lc(lc), rc(rc), cnt(lc-&gt;cnt + rc-&gt;cnt) {} SegT(int cnt) : lc(null), rc(null), cnt(cnt) {} SegT *update(int l, int r, int pos, int delta) { if (l == r) return new SegT(cnt + delta); else { int mid = l + (r - l) / 2; if (pos &gt; mid) return new SegT(lc, rc-&gt;update(mid + 1, r, pos, delta)); else return new SegT(lc-&gt;update(l, mid, pos, delta), rc); } } int queryPrefix(int l, int r, int pos) { if (l == r) return cnt; else { int mid = l + (r - l) / 2; if (pos &gt; mid) return lc-&gt;cnt + rc-&gt;queryPrefix(mid + 1, r, pos); else return lc-&gt;queryPrefix(l, mid, pos); } } } *rt[MAXN + 1], *null = new SegT; */ int n, blockSize, blockCnt, a[MAXN + 1]; long long blockAns[MAXN_SQRT + 1][MAXN_SQRT + 1]; inline void discrete() { static int set[MAXN + 1]; std::copy(a + 1, a + n + 1, set + 1); std::sort(set + 1, set + n + 1); int *end = std::unique(set + 1, set + n + 1); for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(set + 1, end, a[i]) - set; } inline int blockID(int pos) { return (pos - 1) / blockSize + 1; } inline void getBlock(int bid, int &amp;l, int &amp;r) { l = (bid - 1) * blockSize + 1; r = std::min(n, l + blockSize - 1); } inline int getBlockL(int bid) { return (bid - 1) * blockSize + 1; } inline int getBlockR(int bid) { return std::min(n, getBlockL(bid) + blockSize - 1); } /* inline void validateBlocks() { for (int i = 1; i &lt;= blockCnt; i++) { int l, r; getBlock(i, l, r); printf("block[%d] = [%d, %d]\n", i, l, r); for (int j = l; j &lt;= r; j++) { assert(blockID(j) == i); } } } */ /* inline void buildSegT() { rt[0] = null; for (int i = 1; i &lt;= n; i++) { rt[i] = rt[i - 1]-&gt;update(1, n, a[i], 1); } } inline int queryLessThan(int l, int r, int x) { if (l &gt; r) return 0; return rt[r]-&gt;queryPrefix(1, n, x - 1) - rt[l - 1]-&gt;queryPrefix(1, n, x - 1); } inline int queryGreaterThan(int l, int r, int x) { if (l &gt; r) return 0; return (r - l + 1) - queryLessThan(l, r, x + 1); } */ struct BinaryIndexedTree { int a[MAXN + 1]; static int lowbit(int x) { return x &amp; -x; } void update(int pos, int delta) { for (int i = pos; i &lt;= n; i += lowbit(i)) a[i] += delta; // a[pos] += delta; } int query(int pos) { int res = 0; for (int i = pos; i &gt; 0; i -= lowbit(i)) res += a[i]; // for (int i = pos; i &gt; 0; i--) res += a[i]; return res; } int query(int l, int r) { if (l &gt; r) return 0; // printf("%d\n", query(r) - query(l - 1)); return query(r) - query(l - 1); } void clear() { for (int i = 1; i &lt;= n; i++) a[i] = 0; } } bits[MAXN_SQRT + 1], bit; inline void buildBIT() { for (int i = 1; i &lt;= blockCnt; i++) { bits[i] = bits[i - 1]; int l, r; getBlock(i, l, r); for (int j = l; j &lt;= r; j++) bits[i].update(a[j], 1); } } inline void prepare() { discrete(); buildBIT(); // buildSegT(); for (int i = 1; i &lt;= blockCnt; i++) { int l0 = getBlockL(i); bit.clear(); for (int j = i; j &lt;= blockCnt; j++) { blockAns[i][j] = blockAns[i][j - 1]; int l, r; getBlock(j, l, r); for (int k = l; k &lt;= r; k++) { // blockAns[i][j] += queryGreaterThan(l0, k - 1, a[k]); blockAns[i][j] += bit.query(a[k] + 1, n); // assert(bit.query(a[k] + 1, n) == queryGreaterThan(l0, k - 1, a[k])); bit.update(a[k], 1); } } } } inline long long force(int l, int r) { long long ans = 0; bit.clear(); for (int i = l; i &lt;= r; i++) { ans += bit.query(a[i] + 1, n); bit.update(a[i], 1); // ans += queryGreaterThan(l, i - 1, a[i]); } return ans; } inline long long query(int l, int r) { int lb = blockID(l), rb = blockID(r); if (rb - lb &lt;= 1) return force(l, r); long long ans = blockAns[lb + 1][rb - 1]; int lbr = getBlockR(lb), rbl = getBlockL(rb); for (int i = lbr; i &gt;= l; i--) { bits[rb - 1].update(a[i], 1); ans += bits[rb - 1].query(1, a[i] - 1) - bits[lb].query(1, a[i] - 1); // ans += queryLessThan(i + 1, rbl - 1, a[i]); } for (int i = rbl; i &lt;= r; i++) { bits[rb - 1].update(a[i], 1); ans += bits[rb - 1].query(a[i] + 1, n) - bits[lb].query(a[i] + 1, n); // ans += queryGreaterThan(l, i - 1, a[i]); } for (int i = rbl; i &lt;= r; i++) bits[rb - 1].update(a[i], -1); for (int i = lbr; i &gt;= l; i--) bits[rb - 1].update(a[i], -1); return ans; } int main() { scanf("%d", &amp;n); blockSize = ceil(sqrt(n)); blockCnt = n / blockSize + (n % blockSize != 0); // validateBlocks(); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); prepare(); int m; scanf("%d", &amp;m); int lastAns = 0; while (m--) { int l, r; scanf("%d %d", &amp;l, &amp;r); l ^= lastAns, r ^= lastAns; printf("%d\n", lastAns = query(l, r)); } }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>分块</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2016」背单词 - Trie + 贪心]]></title>
    <url>%2Fscoi2016-word%2F</url>
    <content type="text"><![CDATA[总共有 个单词，对于一个序号为 的单词（序号 都已经被填入）： 如果存在一个单词是它的后缀，并且当前没有被填入表内，代价为 颗泡椒才能学会； 当它的所有后缀都被填入表内的情况下，如果在 的位置上的单词都不是它的后缀，那么代价为 ； 当它的所有后缀都被填入表内的情况下，如果 的位置上存在是它后缀的单词，所有是它后缀的单词中，序号最大为 ，那么代价为 。 链接 BZOJ 4567 题解 第一种情况一定不会存在 —— 因为这种情况完全可以避免，而且在避免这种情况的情况下，最大代价不会超过 。 现在相当于，题目多了一个限制条件，每个字符串的后缀必须先被填入。我们把每个字符串反转，转化为每个字符串的前缀必须先被填入。 问题在于，填完一个字符串后，以它为前缀的字符串们被填入的顺序如何确定 —— 我们建立一棵 Trie 树，DFS 求出每个点 向上最近的单词点 ，注意这里的 不一定是 的子节点， 可以通过添加一个或多个字符来得到 。 将每个 与 建立父子节点关系，在新的树上 DFS，优先走子树大小（子树上的单词数量）较小的节点，记录每个节点的 DFS 序即为填写顺序。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; const int MAXN = 100000; const int MAXL = 510000; const int CHARSET_SIZE = 26; struct Node { Node *ch[CHARSET_SIZE]; std::vector&lt;Node *&gt; chWord; int size, wordID; bool isWord; Node() : ch(), size(0), isWord(false) {} } _pool[MAXL + 1], *_curr = _pool, *rt = new (_curr++) Node; inline void insert(char *begin, char *end) { Node *v = rt; for (char *p = begin; p != end; p++) { v-&gt;size++; if (!v-&gt;ch[*p]) { v-&gt;ch[*p] = new (_curr++) Node; } v = v-&gt;ch[*p]; } v-&gt;size++; v-&gt;isWord = true; } long long ans; inline bool compare(Node *a, Node *b) { int x = a ? a-&gt;size : 0; int y = b ? b-&gt;size : 0; return x &lt; y; } inline void dfs(Node *v, Node *lastPrefix) { if (v-&gt;isWord) { lastPrefix-&gt;chWord.push_back(v); } for (int i = 0; i &lt; CHARSET_SIZE; i++) { if (v-&gt;ch[i]) { dfs(v-&gt;ch[i], v-&gt;isWord ? v : lastPrefix); } } } inline void dfs2(Node *v, int dfnFa) { static int ts = 0; int dfn = ts++; // root's dfn is 0 ans += dfn - dfnFa; std::sort(v-&gt;chWord.begin(), v-&gt;chWord.end(), compare); for (size_t i = 0; i &lt; v-&gt;chWord.size(); i++) { dfs2(v-&gt;chWord[i], dfn); } } int main() { int n; scanf("%d", &amp;n); while (n--) { static char s[MAXL + 1]; scanf("%s", s); int len = strlen(s); for (int i = 0; i &lt; len; i++) s[i] -= 'a'; std::reverse(s, s + len); // puts(s); insert(s, s + len); } dfs(rt, rt); dfs2(rt, 0); printf("%lld\n", ans); }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>贪心</tag>
        <tag>Trie</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀自动机学习笔记]]></title>
    <url>%2Fsuffix-automaton-notes%2F</url>
    <content type="text"><![CDATA[后缀自动机是一种有限状态自动机，它可以（且仅可以）接受一个字符串的所有后缀。 定义 后缀自动机（suffix automaton，以下简称 SAM）的结构包含两部分，有向无环单词图（directed acyclic word graph，以下简称 DAWG）和前缀树（prefix tree）。SAM 中的每个节点都同时存在于这两个结构中。 我们对一个字符串 构造其 SAM，称 是该 SAM 的母串；下文中提到的「子串」、「前缀」与「后缀」，如非特殊说明，均指母串的「子串」、「前缀」与「后缀」。 记 为字符串 的长度。 DAWG 顾名思义，DAWG 是一个 DAG（有向无环图）。 DAWG 中，除起始节点外，每个节点表示一个或多个子串。 节点之间通过转移边相连，每条转移边上有一个字符。 从起始节点沿着转移边走，每条路径都对应着一个子串，即将走过的边上的字符首尾相连得到的子串（显然多条路径会到达同一个节点上）。 我们称在 SAM 上运行一个字符串 ，即为从 DAWG 的起始节点开始，第 次沿着字符 的转移边走，走完 次；如果 是母串的一个后缀，则称到达的节点为可接受的节点。 节点 每个节点所表示的所有字符串，一定是（母串的）某个前缀的若干个长度只相差 的后缀。 例：母串为 ，它的一个前缀为 ，某个节点 所表示的子串可能为 、 和 。 定义节点 中长度最小和最大的子串分别为 和 。 例：母串为 ，它的一个前缀为 ，假设存在某个节点 所表示的子串为 、 和 ，那么 ，。 定义节点 中长度最大的子串在母串中所有出现的结束位置的集合为 。 例：母串为 ，它的一个前缀为 ，假设存在某个节点 所表示的子串为 、 和 ，其中最长的为 ，它在母串中出现过两次，结束位置分别为 和 ，所以 。 性质：任意两个节点的 集合不同。 证明：如果两个节点的 集合相同，则说明这两个节点的出边是等价的（因为它们加上每个字符后得到的那些子串，其结束位置也是分别相同的），可以合并这两个节点。 只有从「表示整个母串的节点」到根的一条路径上的节点的 集合包含母串的末尾，所以只有这些节点是接受节点；并且从起始节点沿着转移边走到这些节点的路径上，将所有转移边上的字符首尾相连，得到的一定是一个后缀（即使它可能在母串的其它位置也出现过多次）。 转移边 到 有一条字符为 的转移边，表示 所表示的所有子串加上一个字符后，得到的子串，都可以由 表示。但不一定 所表示的所有字串都是由 的转移而来。 后缀链接与前缀树 定义 的后缀链接指向 ，当且仅当 且 中的子串均为 子串的后缀，记为 。 例：母串为 ，它的一个前缀为 ，假设存在某个节点 所表示的子串为 、 和 ；另一个节点 所表示的子串为 和 ，则 。 任意节点沿着后缀链接走，最终都会走到 DAWG 的起始节点。以后缀链接为边，所有的节点组成了一棵树，即前缀树。DAWG 的起始节点即为前缀树的根。 性质：前缀树中，子节点的 集合一定是其父节点的真子集，即 。 证明：因为 一定是 的后缀，所以 出现的位置， 一定也出现了，所以 。 如果 ，那么 和 应该被合并为一个点，所以 。 显然，一个节点的 集合包含其所有子节点 集合的并，如果这个节点表示了母串的一个前缀，则加上这个前缀的位置。 构造 在字符集为常数的情况下，SAM 的构造算法时空复杂度均为 ，稍后将证明这一结论。 SAM 的构造是一个增量算法，假设我们已有字符串 的 SAM，只需要考虑如何对其修改得到串 （ 为一个字符）的 SAM 即可。这里将用一个例子来说明这个过程，注意下图中的 和 、 和 、 和 这三组节点在实际情况下均可能是零个或多个节点，为了方便这里画出两个。 设之前表示整个串的节点为 ，从 到起始节点 的路径为 （）。则一定存在一个 ，使得 没有字符 的出转移边，如（黑色边为后缀链接，灰色边为字符 的转移边）： 例子中 表示的字符串一定是 所表示字符串的后缀，所以如果 中的字符串添加一个字符后得到的字符串存在于原母串中，则 中的字符串添加一个字符后得到的字符串一定也存在于原母串中。而 中的字符串都是 在前面添加若干个字符得到的，所以 中的子串添加一个字符后得到的字符串可能会不存在于母串中，图中我们假设 是第一个满足「添加一个字符后得到的字符串不存在于母串中」的节点。 现在加入了新的字符 ，所以 添加了字符 后得到的字符串出现了，而且它们是新母串的后缀。我们设这些新的字符串被新节点 所表示，显然 。 注意到，新加入的字符 导致新出现了 （新母串长度）个后缀，这些后缀都需要新的节点来表示。首先，节点 表示了 及更长的后缀，而更短的后缀已经可以由 及其后缀链接的路径上的节点来表示。所以，DAWG 的性质已经被满足。接下来考虑前缀树。 首先，如果不存在这样的 ，满足 有字符 的出边，则需要将 的后缀链接连向起始节点 ，因为新出现的 个后缀都需要节点 来表示，即 ，而为了满足前缀树是一棵树，需要将 的父节点置为树根。 如果 ，即， 中最长的字符串为 中最长的字符串加上字符 后得到的。因为 ，，，所以 ，所以 的后缀链接连向 。 如果 ，此时一定有 ，因为字符串 一定存在于 中，并且存在另一个异于 的节点 ，满足 且 有连向 的转移边。 此时我们不能将 的后缀链接连向 ，因为 中的字符串不全是 的后缀。举个例子， 中有子串 ， 中有子串 ， 中有子串 ， 中有子串 ， 中有子串 和 ，因为 不是 的后缀，所以 的后缀链接不能连向 。 我们需要将 拆成两个点，一个点 表示长度小于等于 的子串（例子中的 ），另一个点 表示长度更大的子串（例子中的 ）。 原有的 中，仅有长度小于等于 的子串是 与 中的字符串加上一个字符转移而来的，所以 与 的字符 的转移边应该连向 ，而其它子串均为其它节点转移而来的，所以其它节点的转移边应该连向 ，并且 应为原有的 ，并且 ，然后新节点 的后缀链接 。 注意到，在构造的过程中，每个子串都有对应的节点来表示，并且每个节点的 集合不会相同（根据对前缀树结构的改变，容易证明这一结论），所以构造算法是正确的。 实现 实现中要注意的是，节点只需要记录 ，而不需要记录 ，因为 。在将 拆成两个点时，因为要将「其它的点」连向 点，所以直接将原来的 点作为 点，修改其 属性，并新建一个 点，将需要连向 点的连过去即可 —— new 和 old 正是此处命名 与 的用意。 const int CHARSET_SIZE = 26; // 字符集大小为常数 struct SuffixAutomaton { struct Node { // ch 表示转移边，next 表示后缀链接 Node *ch[CHARSET_SIZE], *next; int max; Node(int max = 0) : ch(), next(NULL), max(max) {} // v-&gt;min = v-&gt;next-&gt;max + 1 int getMin() { return next-&gt;max + 1; } } *start, *last; // start 为起始节点，last 为表示整个母串的节点 // 注意先调用初始化 void init() { start = last = new Node; } // 加入一个新的字符，将 SAM 扩展 Node *extend(int c) { // 节点 u 表示新的整个母串 Node *u = new Node(last-&gt;max + 1), *v = last; // 将 last 的后缀链接路径上没有字符 c 出边的 v 全部连向 u // 注意判断 v 跳到 NULL 上 for (; v &amp;&amp; !v-&gt;ch[c]; v = v-&gt;next) v-&gt;ch[c] = u; // 如果 v 跳到了 NULL，则需要让 v 的后缀链接指向起始节点（也就是前缀树的根） if (!v) { u-&gt;next = start; } else if (v-&gt;ch[c]-&gt;max == v-&gt;max + 1) { // 直接将 u 的后缀链接连向 v 经过 c 的边转移后的点 u-&gt;next = v-&gt;ch[c]; } else { // 拆点，n 为新节点，o 为旧节点 Node *n = new Node(v-&gt;max + 1), *o = v-&gt;ch[c]; // 复制原有节点的出边到新节点 n 的出边 std::copy(o-&gt;ch, o-&gt;ch + CHARSET_SIZE, n-&gt;ch); // 新节点 n 的后缀链接指向原有节点的后缀链接目标 n-&gt;next = o-&gt;next; // 旧节点和新节点 u 的后缀链接指向新节点 n o-&gt;next = u-&gt;next = n; // 将路径上原有转移边指向 o 的节点改为指向 n for (; v &amp;&amp; v-&gt;ch[c] == o; v = v-&gt;next) v-&gt;ch[c] = n; } last = u; // 更新「表示整个母串的节点」 return u; } }; 复杂度证明 接下来我们证明这个算法的时空复杂度，它可以达到线性的空间复杂度，并在字符集为常数的情况下，达到线性的时间复杂度。 空间复杂度 整个结构包含两部分 —— DAWG 和前缀树，我们需要分别证明节点数和 DAWG 的边数是线性的，并且与字符集无关。 首先，每次加入节点时，最多新建两个节点，所以显然节点数的上界是 ，这一部分的复杂度得证。 对于 DAWG 的转移边，我们可以再将其分为两部分 —— 我们以起始节点为根，对 DAWG 建立一棵生成树，树边的数量一定是线性的，接下来只需要考虑非树边的数量。 我们定义集合 表示所有非树边，集合 表示串的所有后缀。如果我们能找到一个映射 ，使得对于任意的 ，若 ，一定有 （即 为单射），即可证明 。 对于两个节点 ，显然只可能存在一条非树边 或 ，假设存在 ，那么我们找到下面三段字符串： 从生成树的根沿着树边走到 ，将经过的所有转移边上的字符按顺序首尾相接（因为是沿着树边，所以这个串是唯一的）； 这条转移边上的字符； 从 开始，沿着字符字典序最小的转移边（可以是树边或非树边）走，直到走到一个可接受的节点 ，将经过的所有转移边上的字符按顺序首尾相接。 设这三段拼接得到得到的字符串为 ，因为这三段都是唯一的，所以 是唯一的，记 ；又因为整条路径是从起始节点走到一个可接受的节点，所以 一定是母串的一个后缀，并且，这条非树边 是运行字符串 时经过的第一条非树边。 每条非树边 都能对应到一个 ； 每个被对应到的 都能对应到唯一一个 。 所以，如果有两条边 和 满足 ，则一定有 —— 所以非树边的数量一定小于等于后缀的数量，即线性。 综上所述，SAM 中的节点数及其 DAWG 上的转移边数均为线性，即 SAM 的空间复杂度为线性，且与字符集大小无关。 时间复杂度 代码中时间复杂度并不显然的地方有以下两处： Node *u = new Node(last-&gt;max + 1), *v = last; // 将 last 的后缀链接路径上没有字符 c 出边的 v 全部连向 u for (; v &amp;&amp; !v-&gt;ch[c]; v = v-&gt;next) v-&gt;ch[c] = u; 如果 last 等于 start，则 last-&gt;next 为空，此时显然只会经过常数时间；否则，我们关注 last-&gt;next-&gt;max 这个量的变化： 循环一定会执行第一次（v 一定会被赋值为 last-&gt;next），也就是说，循环终止时 v-&gt;max 最大为 last-&gt;next-&gt;max，并且，v-&gt;max 经过常数时间即可从更大的值变为 last-&gt;next-&gt;max； 之后循环每进行一次，都会使 v-&gt;max 至少减少 1（因为 v-&gt;next-&gt;max 一定小于 v-&gt;max）； 循环结束后，u-&gt;next 被赋值为一个 max 为 v-&gt;max + 1 的节点，而 last 被赋值为 u，也就是说，last-&gt;next-&gt;max 的值变为 v-&gt;max + 1。 除每次调用 extend 的第一次循环外，每次循环 v-&gt;max 至少减少 ，而循环结束后，在下一次调用 extend 的第一次循环后（不计接下来将要分析的另一个 for 语句，这之间经历了常数时间），v-&gt;max 增加了 —— 所以 次调用 extend 后，这条 for 语句的总时间复杂度为 。 下面的另一个 for： // 将路径上原有转移边指向 o 的节点改为指向 n for (; v &amp;&amp; v-&gt;ch[c] == o; v = v-&gt;next) v-&gt;ch[c] = n; 我们考虑 o-&gt;max 的变化。首先，考虑下图中的这种情况，前三个 v 每个所转移到的节点都不同，这样 o-&gt;max 最多比 v3-&gt;max 多 ，而其它的情况，如果每个 v 转移到了多个节点，则转移到 o 的节点会离 v3 更远，其 max 会更小，即 o-&gt;max 会更小。注意，这里没有要求进入了新建节点 n 的分支，也就是说，即使没有新建节点 n，这一段也是成立的。 即，每一次 extend 调用后，o-&gt;max 最多会增加 ，这种情况下循环只进行第一次。 这条循环语句必第执行一次，之后每执行一次，都会使一个像 v2 这样的节点引出一条连向 n 的转移边，而每多进行一次循环，转移边连向 o 的节点就会少一个，每一次减少的节点都是给 o 贡献了最大的 max 的节点，所以每次 o-&gt;max 都会至少减小 —— 所以 次调用 extend 后，这条 for 语句的总时间复杂度也为 。 另外，和字符集相关的语句只有复制出边的这一行： // 复制原有节点的出边到新节点 n 的出边 std::copy(o-&gt;ch, o-&gt;ch + CHARSET_SIZE, n-&gt;ch); 显然，在字符集大小为常数的情况下，这条语句耗费常数时间。 综上所述，在字符集大小为常数的情况下，该构造算法的总时间复杂度为线性。 大字符集的处理 在字符集较大（如，在 C++ 的 int 范围内）的情况下，我们无法使用一个数组来保存所有字符的出边。比较简便的解决方法是使用 STL 容器 map —— 建立一个从字符到目标节点的映射。 显然，这样做，构造的时间复杂度不会超过 （ 为字符串长度， 为字符集大小），而空间复杂度不会改变。 struct SuffixAutomaton { struct Node { std::map&lt;int, Node *&gt; ch; // 用 std::map 保存转移边 Node *next; int max; Node(int max = 0) : next(NULL), max(max) {} } *start, *last; void init() { start = last = new Node; } Node *extend(int c) { Node *u = new Node(last-&gt;max + 1), *v = last; for (; v &amp;&amp; !v-&gt;ch[c]; v = v-&gt;next) v-&gt;ch[c] = u; if (!v) { u-&gt;next = start; } else if (v-&gt;ch[c]-&gt;max == v-&gt;max + 1) { u-&gt;next = v-&gt;ch[c]; } else { Node *o = v-&gt;ch[c], *n = new Node(v-&gt;max + 1); n-&gt;ch = o-&gt;ch; // 复制出边 n-&gt;next = o-&gt;next; o-&gt;next = u-&gt;next = n; for (; v &amp;&amp; v-&gt;ch[c] == o; v = v-&gt;next) v-&gt;ch[c] = n; } last = u; return u; } } sam; 拓扑序 SAM 中的 DAWG 满足一个性质，如果有一条转移边 ，则一定有 。类似的，如果 ，也有 。所以，按照每个节点记录的 max 长度排序，可以同时得到 DAWG 和前缀树的拓扑序。 使用计数排序可以做到线性的时空复杂度。 结束位置集合 我们可以在构造完 SAM 后，求出其拓扑序，然后递推求出每个节点的 集合的大小（一般只需要求出其大小，如果需要确切求出集合的元素，需要使用可持久化数据结构维护）。 struct SuffixAutomaton { struct Node { Node *ch[CHARSET_SIZE], *next; int max, posCnt; // posCnt 表示其 end-pos 集合的大小 // 对于一个新的节点，如果它表示了一个新的后缀，则它的 end-pos 集合中多一个位置 // 否则它的 end-pos 集合仅仅是前缀树上所有子节点的 end-pos 集合的并 Node(int max = 0, bool newSuffix = false) : ch(), next(NULL), max(max), posCnt(newSuffix) {} } *start, *last, _pool[MAXN * 2 + 1], *_curr; // 为了方便枚举所有节点，我们将节点放在内存池中，_curr 指向当前最后一个节点之后 std::vector&lt;Node *&gt; topo; // 存储拓扑序（按照 max 从小到大排序） void init() { _curr = _pool; start = last = new (_curr++) Node; } Node *extend(int c) { // 节点 u 表示了一个新的后缀 Node *u = new (_curr++) Node(last-&gt;max + 1, true), *v = last; for (; v &amp;&amp; !v-&gt;ch[c]; v = v-&gt;next) v-&gt;ch[c] = u; if (!v) { u-&gt;next = start; } else if (v-&gt;ch[c]-&gt;max == v-&gt;max + 1) { u-&gt;next = v-&gt;ch[c]; } else { // 节点 n 并没有表示一个新的后缀，所以它对 pos-end 集合的大小没有贡献 Node *n = new (_curr++) Node(v-&gt;max + 1, false), *o = v-&gt;ch[c]; std::copy(o-&gt;ch, o-&gt;ch + CHARSET_SIZE, n-&gt;ch); n-&gt;next = o-&gt;next; o-&gt;next = u-&gt;next = n; for (; v &amp;&amp; v-&gt;ch[c] == o; v = v-&gt;next) v-&gt;ch[c] = n; } last = u; return u; } // 拓扑排序 std::vector&lt;Node *&gt; &amp;toposort() { static int buc[MAXN * 2 + 1]; int max = 0; // 记录最大值，方便清空 buc 数组 // 普通的计数排序 for (Node *p = _pool; p != _curr; p++) { max = std::max(max, p-&gt;max); buc[p-&gt;max]++; } for (int i = 1; i &lt;= max; i++) buc[i] += buc[i - 1]; topo.resize(_curr - _pool); for (Node *p = _pool; p != _curr; p++) { topo[--buc[p-&gt;max]] = p; } // 清空 buc 数组以便下一次使用 std::fill(buc, buc + max + 1, 0); return topo; } void calc() { toposort(); // 按照拓扑序，从子节点向父节点递推 for (int i = topo.size() - 1; i &gt; 0; i--) // i &gt; 0 { Node *v = topo[i]; v-&gt;next-&gt;posCnt += v-&gt;posCnt; } } } sam; 如果需要动态维护 ，则需要一种数据结构，支持在有根树上加入一条边、删除一条边、求子树和 —— 将子树和转化为链加、单点查询即可用 Link-Cut Tree 维护。 应用 求本质不同的子串数量 每个节点 表示的子串长度在 范围内，所以对 求和即可。这个过程可以在线维护。 sam.init(); int ans = 0; for (int i = 1; i &lt;= n; i++) { char ch = s[i] - 'a'; SuffixAutomaton::Node *v = sam.extend(ch); ans += v-&gt;max - v-&gt;min + 1; } 求字符串的最小表示 设 为一字符串，（）表示将 的前 位剪切并拼接在 的最后得到的字符串，所有 中字典序最小的一个，称为 的最小表示。 求一个字符串 的最小表示，先对 建立 SAM，并从起始节点开始，每次找存在的字符最小的出边向后走，并记录这个字符，走 步后，记录下的字符首位连成的字符串即为 的最小表示。 因为所有的 都是 的子串，并且 SAM 上从起始节点开始沿着转移边走的每一条路径都对应着 的一个子串，所以这个算法是正确的。 求两个字符串的最长公共子串 对一个字符串建立 SAM，记录一个当前匹配的长度 ，和当前节点 ，枚举另一个字符串的每个字符 ： 如果 有字符 的转移边出边，则使 加一，并使 转移到出边指向的节点上； 如果 没有字符 的转移边出边，则使 转移到 ，并且使 等于 ，因为 中的字符串加入字符 后在母串中都不存在了，所以要舍弃一些前缀，而转移到 可以使舍弃的前缀最少，留下的串长度最长，而留下的已匹配的串的长度为 ，这时候继续检查节点 有没有字符 的转移边出边，直到有或者 转移到起始节点。 参考资料 Suffix Automaton Tutorial，Hunt Zhan WC2012 后缀自动机课件，陈立杰 2015 年信息学奥林匹克中国国家队论文集 - 后缀自动机及其应用，张天扬 震惊！SAM复杂度竟如此显然！，张晴川 A short guide to suffix automata，quasisphere]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2014」LIS - 最小割 + 网络流退流]]></title>
    <url>%2Fsdoi2014-lis%2F</url>
    <content type="text"><![CDATA[给定序列 ，序列中的每一项 有删除代价 和附加属性 。请删除若干项，使得 的最长上升子序列长度减少至少 ，且付出的代价之和最小，并输出方案。 如果有多种方案，请输出将删去项的附加属性排序 之后，字典序最小的一种。 链接 BZOJ 3632 题解 首先，第一问，求最小的删除代价使得 LIS 长度减少。 为序列中的每一项建立两个点 与 ，连边 ； 动态规划求出 表示以 结尾的 LIS 长度，设 如果能从 转移到 ，则连边 ； 对于每个 的 ，连边 ； 对于每个 的 ，连边 。 求出 到 的最小割，即为最小删除代价和 —— 因为这样所有的从 到 的路径都不连通的，即所有的原最长的上升序列都被断开了。 第二问，要求求一组方案使得 字典序最小 —— 我们检查按照 从小到大的顺序检查每一条 的边，如果它满流，并且从 无法到达 ，则表明 可以成为一条割边（但它不一定实际存在于当前残量网络的最小割集中）。我们将 记录到方案中，并且，为了使这条边实际成为割边，我们将这条边删除（将其本身和其反向边的容量置空），然后消除它对残量网络的影响 —— 从 到 进行一次最大流，从 到 进行一次最大流，这样使经过这条边的所有流量回到了源点，而这条边则相当于是一条割边。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 700; struct Node { std::vector&lt;struct Edge&gt; e; struct Edge *c; int l; } N[MAXN * 2 + 2]; struct Edge { Node *s, *t; int f, c, r; Edge(Node *s, Node *t, int c, int r) : s(s), t(t), f(0), c(c), r(r) {} }; inline int addEdge(int s, int t, int c) { // printf("%2d -&gt; %2d = %d\n", s, t, c); N[s].e.push_back(Edge(&amp;N[s], &amp;N[t], c, N[t].e.size())); N[t].e.push_back(Edge(&amp;N[t], &amp;N[s], 0, N[s].e.size() - 1)); return N[s].e.size() - 1; } struct Dinic { bool level(Node *s, Node *t, int n) { for (int i = 0; i &lt; n; i++) { N[i].c = &amp;N[i].e.front(); N[i].l = 0; } std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = &amp;v-&gt;e.front(); e &lt;= &amp;v-&gt;e.back(); e++) { if (e-&gt;f &lt; e-&gt;c &amp;&amp; !e-&gt;t-&gt;l) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } } return false; } int find(Node *s, Node *t, int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e &lt;= &amp;s-&gt;e.back(); e++) { if (e-&gt;f &lt; e-&gt;c &amp;&amp; e-&gt;t-&gt;l == s-&gt;l + 1) { int f = find(e-&gt;t, t, std::min(limit, e-&gt;c - e-&gt;f)); if (f) { e-&gt;f += f; e-&gt;t-&gt;e[e-&gt;r].f -= f; return f; } } } return 0; } int operator()(int s, int t, int n) { int res = 0; while (level(&amp;N[s], &amp;N[t], n)) { int f; while ((f = find(&amp;N[s], &amp;N[t])) &gt; 0) res += f; } return res; } } dinic; int main() { int T; scanf("%d", &amp;T); while (T--) { int n; scanf("%d", &amp;n); static int a[MAXN + 1], b[MAXN + 1], c[MAXN + 1]; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;b[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); // DP static int f[MAXN + 1]; int maxLen = 0; for (int i = 1; i &lt;= n; i++) { f[i] = 0; for (int j = 0; j &lt; i; j++) { if (a[j] &lt; a[i]) { f[i] = std::max(f[i], f[j] + 1); maxLen = std::max(maxLen, f[i]); } } } // Build Graph int s = 0, t = n * 2 + 1; static int edge[MAXN + 1]; for (int i = 1; i &lt;= n; i++) { edge[i] = addEdge(i, i + n, b[i]); if (f[i] == 1) addEdge(s, i, INT_MAX); if (f[i] == maxLen) addEdge(i + n, t, INT_MAX); for (int j = 1; j &lt; i; j++) { if (a[j] &lt; a[i] &amp;&amp; f[j] == f[i] - 1) { addEdge(j + n, i, INT_MAX); } } } int ans = dinic(s, t, n * 2 + 2); // Sort by C[i] static std::pair&lt;int, int&gt; p[MAXN + 1]; for (int i = 1; i &lt;= n; i++) p[i] = std::make_pair(c[i], i); std::sort(p + 1, p + n + 1); // Calc the plan std::vector&lt;int&gt; plan; for (int j = 1; j &lt;= n; j++) { int i = p[j].second; Edge &amp;e = N[i].e[edge[i]]; int u = e.s - N, v = e.t - N; if (e.f == e.c &amp;&amp; !dinic.level(e.s, e.t, n * 2 + 2)) { e.f = e.c = e.t-&gt;e[e.r].f = e.t-&gt;e[e.r].c = 0; dinic(u, s, n * 2 + 2); dinic(t, v, n * 2 + 2); plan.push_back(i); } } printf("%d %d\n", ans, int(plan.size())); std::sort(plan.begin(), plan.end()); for (size_t i = 0; i &lt; plan.size(); i++) printf("%d%c", plan[i], " \n"[i == plan.size() - 1]); // Clear up for (int i = 0; i &lt; n * 2 + 2; i++) N[i].e.clear(); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>最小割</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4499」线性函数 - 线段树]]></title>
    <url>%2Fbzoj-4499%2F</url>
    <content type="text"><![CDATA[小 C 最近在学习线性函数，线性函数可以表示为 。现在小 C 面前有 个线性函数 ，他对这 个线性函数执行 次操作，每次可以： M i K B 代表把第 个线性函数改为 ； Q l r x 返回 。 链接 BZOJ 4499 题解 两个线性函数 和 可以合并为 。 用线段树维护整个序列即可。 代码 #include &lt;cstdio&gt; const int MAXN = 200000; const long long MOD = 1e9 + 7; struct LinearFunction { long long k, b; LinearFunction() {} LinearFunction(long long k, long long b) : k(k), b(b) {} static LinearFunction merge(const LinearFunction &amp;l, const LinearFunction &amp;r) { return LinearFunction(l.k * r.k % MOD, (r.k * l.b % MOD + r.b) % MOD); } long long operator()(long long x) { return (k * x % MOD + b) % MOD; } }; struct SegT { int l, r, mid; SegT *lc, *rc; LinearFunction f; SegT(int l, int r, SegT *lc, SegT *rc, const LinearFunction &amp;f) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), f(f) {} SegT(int l, int r, SegT *lc, SegT *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), f(LinearFunction::merge(lc-&gt;f, rc-&gt;f)) {} void update(int pos, const LinearFunction &amp;f) { if (l == r) this-&gt;f = f; else (pos &lt;= mid ? lc : rc)-&gt;update(pos, f), this-&gt;f = LinearFunction::merge(lc-&gt;f, rc-&gt;f); } LinearFunction query(int l, int r) { if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return f; else if (r &lt;= mid) return lc-&gt;query(l, r); else if (l &gt; mid) return rc-&gt;query(l, r); else return LinearFunction::merge(lc-&gt;query(l, r), rc-&gt;query(l, r)); } static SegT *build(int l, int r, LinearFunction *a) { if (l == r) return new SegT(l, r, NULL, NULL, a[l]); else { int mid = l + (r - l) / 2; return new SegT(l, r, build(l, mid, a), build(mid + 1, r, a)); } } } *seg; int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); static LinearFunction a[MAXN + 1]; for (int i = 1; i &lt;= n; i++) scanf("%lld %lld", &amp;a[i].k, &amp;a[i].b); seg = SegT::build(1, n, a); while (m--) { char s[2]; scanf("%s", s); if (s[0] == 'M') { int i; LinearFunction f; scanf("%d %lld %lld", &amp;i, &amp;f.k, &amp;f.b); seg-&gt;update(i, f); } else { int l, r; long long x; scanf("%d %d %lld", &amp;l, &amp;r, &amp;x); LinearFunction f = seg-&gt;query(l, r); printf("%lld\n", f(x)); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2005」狡猾的商人 - 差分约束]]></title>
    <url>%2Fhnoi2005-trader%2F</url>
    <content type="text"><![CDATA[刁姹接到一个任务，为税务部门调查一位商人的账本，看看账本是不是伪造的。账本上记录了 个月以来的收入情况，其中第 个月的收入额为 。当 大于 时表示这个月盈利 元，当 小于 时表示这个月亏损 元。所谓一段时间内的总收入，就是这段时间内每个月的收入额的总和。刁姹的任务是秘密进行的，为了调查商人的账本，她只好跑到商人那里打工。她趁商人不在时去偷看账本，可是她无法将账本偷出来，每次偷看账本时她都只能看某段时间内账本上记录的收入情况，并且她只能记住这段时间内的总收入。现在，刁姹总共偷看了 次账本，当然也就记住了 段时间内的总收入，你的任务是根据记住的这些信息来判断账本是不是假的。 链接 BZOJ 1202 题解 设 的前缀和为 ，对于一个条件 ，将其转化为 ，转化为差分约束问题。 进而，对于每个条件，在图中添加一条 到 权值为 边和一条 到 权值为 的边。DFS 判断差分约束是否有解即可。 从每个未访问过的点出发，设它的值为 ，DFS 过程中找到树边则更新邻接点的值，找到返祖边则检验是否有矛盾，不会出现横叉边。 代码 #include &lt;cstdio&gt; #include &lt;vector&gt; const int MAXN = 100; struct Node { std::vector&lt;struct Edge&gt; e; int d; bool vis; } N[MAXN + 1]; struct Edge { Node *s, *t; int w; Edge(Node *s, Node *t, int w) : s(s), t(t), w(w) {} }; inline void addEdge(int s, int t, int w) { N[s].e.push_back(Edge(&amp;N[s], &amp;N[t], w)); N[t].e.push_back(Edge(&amp;N[t], &amp;N[s], -w)); } inline bool dfs(Node *v) { for (Edge *e = &amp;v-&gt;e.front(); e &amp;&amp; e &lt;= &amp;v-&gt;e.back(); e++) { if (!e-&gt;t-&gt;vis) { e-&gt;t-&gt;vis = true; e-&gt;t-&gt;d = v-&gt;d + e-&gt;w; if (!dfs(e-&gt;t)) return false; } else if (e-&gt;t-&gt;d != v-&gt;d + e-&gt;w) return false; } return true; } int main() { int T; scanf("%d", &amp;T); while (T--) { int n, m; scanf("%d %d", &amp;n, &amp;m); while (m--) { int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); addEdge(u - 1, v, w); } bool ans = true; for (int i = 0; i &lt;= n; i++) { if (!N[i].vis) { N[i].vis = true; if (!dfs(&amp;N[i])) { ans = false; break; } } } puts(ans ? "true" : "false"); for (int i = 0; i &lt;= n; i++) { N[i].e.clear(); N[i].d = 0; N[i].vis = false; } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>HNOI</tag>
        <tag>图论</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2004」高精度开根 - 高精度 + 二分]]></title>
    <url>%2Fhnoi2004-calc%2F</url>
    <content type="text"><![CDATA[给 和一个高精度数 ，求 。 链接 BZOJ 1213 题解 首先，从 开始每次扩大一倍，确定答案的范围。 然后二分答案检验即可。 高精度用 Python 比较方便。 代码 m = input() n = input() l = 0 r = 1 while r ** m &lt; n: r *= 2 while l &lt; r: # print "l = %d, r = %d" % (l, r) mid = (l + r) // 2 + 1 x = mid ** m if x &lt;= n: l = mid else: r = mid - 1 print l]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>高精度</tag>
        <tag>HNOI</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2588」Count on a tree - 主席树]]></title>
    <url>%2Fbzoj-2588%2F</url>
    <content type="text"><![CDATA[给定一棵 个节点的树，每个点有一个权值，对于 个询问 ，你需要回答 和 这两个节点间第 小的点权。 链接 BZOJ 2588 题解 对树上从根向下的路径做主席树前缀和，需要倍增求 LCA。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;queue&gt; const int MAXN = 100000; const int MAXN_LOG = 17; struct SegT *null; struct SegT { SegT *lc, *rc; int cnt; SegT(SegT *lc, SegT *rc) : lc(lc), rc(rc), cnt(lc-&gt;cnt + rc-&gt;cnt) {} SegT(SegT *lc, SegT *rc, int cnt) : lc(lc), rc(rc), cnt(cnt) {} SegT *insert(int l, int r, int x) { if (l == r) return new SegT(null, null, cnt + 1); else { int mid = l + (r - l) / 2; if (x &lt;= mid) return new SegT(lc-&gt;insert(l, mid, x), rc); else return new SegT(lc, rc-&gt;insert(mid + 1, r, x)); } } }; struct Node { std::vector&lt;Node *&gt; adj; Node *fa; int dep, w; bool vis; SegT *seg; } N[MAXN + 1]; inline void addEdge(int u, int v) { N[u].adj.push_back(&amp;N[v]); N[v].adj.push_back(&amp;N[u]); } inline void init() { null = new SegT(NULL, NULL, 0); null-&gt;lc = null-&gt;rc = null; } int n, f[MAXN + 1][MAXN_LOG + 1], logn; inline void build() { N[0].vis = true; N[0].seg = null; std::queue&lt;Node *&gt; q; q.push(&amp;N[1]); N[1].vis = true; N[1].dep = 1; N[1].fa = &amp;N[0]; while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;seg = v-&gt;fa-&gt;seg-&gt;insert(0, INT_MAX, v-&gt;w); for (Node **p = &amp;v-&gt;adj.front(), *u = *p; p &lt;= &amp;v-&gt;adj.back(); u = *++p) { if (!u-&gt;vis) { u-&gt;vis = true; u-&gt;dep = v-&gt;dep + 1; u-&gt;fa = v; q.push(u); } } } while ((1 &lt;&lt; (logn + 1)) &lt;= n) logn++; f[1][0] = 1; for (int i = 2; i &lt;= n; i++) f[i][0] = N[i].fa - N; for (int j = 1; j &lt;= logn; j++) { for (int i = 1; i &lt;= n; i++) { f[i][j] = f[f[i][j - 1]][j - 1]; } } } inline int lca(int u, int v) { if (N[u].dep &lt; N[v].dep) std::swap(u, v); if (N[u].dep &gt; N[v].dep) { for (int i = logn; i &gt;= 0; i--) { if (N[f[u][i]].dep &gt;= N[v].dep) u = f[u][i]; } } if (u != v) { for (int i = logn; i &gt;= 0; i--) { if (f[u][i] != f[v][i]) { u = f[u][i]; v = f[v][i]; } } return f[u][0]; } return u; } inline int query(int u, int v, int k) { int p = lca(u, v); SegT *su = N[u].seg, *sv = N[v].seg, *sp = N[p].seg, *sf = N[p].fa-&gt;seg; int l = 0, r = INT_MAX; while (l &lt; r) { int mid = l + (r - l) / 2; int s = su-&gt;lc-&gt;cnt + sv-&gt;lc-&gt;cnt - sp-&gt;lc-&gt;cnt - sf-&gt;lc-&gt;cnt; if (k &gt; s) { k -= s; l = mid + 1; su = su-&gt;rc; sv = sv-&gt;rc; sp = sp-&gt;rc; sf = sf-&gt;rc; } else { r = mid; su = su-&gt;lc; sv = sv-&gt;lc; sp = sp-&gt;lc; sf = sf-&gt;lc; } } return l; } int main() { int m; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;N[i].w); for (int i = 1; i &lt;= n - 1; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v); addEdge(u, v); } init(); build(); int lastAns = 0; while (m--) { int u, v, k; scanf("%d %d %d", &amp;u, &amp;v, &amp;k); u ^= lastAns; printf(m ? "%d\n" : "%d", lastAns = query(u, v, k)); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>BZOJ</tag>
        <tag>最近公共祖先</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2016」幸运数字 - 线性基 + 树链剖分 / 倍增]]></title>
    <url>%2Fscoi2016-lucky%2F</url>
    <content type="text"><![CDATA[A 国共有 座城市，这些城市由 条道路相连，使得任意两座城市可以互达，且路径唯一。每座城市都有一个幸运数字，以纪念碑的形式矗立在这座城市的正中心，作为城市的象征。一些旅行者希望游览 A 国。旅行者计划乘飞机降落在 号城市，沿着 号城市到 号城市之间那条唯一的路径游览，最终从 城市起飞离开 A 国。 在经过每一座城市时，游览者就会有机会与这座城市的幸运数字拍照，从而将这份幸运保存到自己身上。然而，幸运是不能简单叠加的，这一点游览者也十分清楚。他们迷信着幸运数字是以异或的方式保留在自己身上的。例如，游览者拍了 张照片，幸运值分别是 、、，那么最终保留在自己身上的幸运值就是 （）。 有些聪明的游览者发现，只要选择性地进行拍照，便能获得更大的幸运值。例如在上述三个幸运值中，只选择 和 ，可以保留的幸运值为 。现在，一些游览者找到了聪明的你，希望你帮他们计算出在他们的行程安排中可以保留的最大幸运值是多少。 链接 BZOJ 4568 题解 树链剖分或倍增维护链上的线性基，查询时合并线性基即可。 复杂度 或 。 代码 #include &lt;cstdio&gt; #include &lt;ctime&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;stack&gt; const int MAXN = 20000; const int MAXN_LOG = 14; const int MAXL = 60; struct Node { std::vector&lt;Node *&gt; adj; Node *fa, *ch, *top; bool vis; int dep, size, dfn; long long w; } N[MAXN + 1]; inline void addEdge(int u, int v) { N[u].adj.push_back(&amp;N[v]); N[v].adj.push_back(&amp;N[u]); } struct LinearBasis { // std::vector&lt;long long&gt; v; long long a[MAXL + 1]; LinearBasis() { std::fill(a, a + MAXL + 1, 0); } LinearBasis(long long *x, int n) { build(x, n); } void insert(long long t) { for (int j = MAXL; j &gt;= 0; j--) { if (!t) return; if (!(t &amp; (1ll &lt;&lt; j))) continue; if (a[j]) t ^= a[j]; else { for (int k = 0; k &lt; j; k++) if (t &amp; (1ll &lt;&lt; k)) t ^= a[k]; for (int k = j + 1; k &lt;= MAXL; k++) if (a[k] &amp; (1ll &lt;&lt; j)) a[k] ^= t; a[j] = t; break; } } } void build(long long *x, int n) { std::fill(a, a + MAXL + 1, 0); for (int i = 1; i &lt;= n; i++) { insert(x[i]); } } long long queryMax() { long long res = 0; for (int i = 0; i &lt;= MAXL; i++) res ^= a[i]; return res; } void mergeFrom(const LinearBasis &amp;other) { for (int i = 0; i &lt;= MAXL; i++) insert(other.a[i]); } static LinearBasis merge(const LinearBasis &amp;a, const LinearBasis &amp;b) { LinearBasis res = a; for (int i = 0; i &lt;= MAXL; i++) res.insert(b.a[i]); return res; } }; struct SegT { int l, r, mid; SegT *lc, *rc; LinearBasis lb; SegT(int l, int r, SegT *lc, SegT *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), lb(LinearBasis::merge(lc-&gt;lb, rc-&gt;lb)) {} SegT(int l, int r, SegT *lc, SegT *rc, long long x) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), lb(&amp;x - 1, 1) {} LinearBasis query(int l, int r) { if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return lb; else if (r &lt;= mid) return lc-&gt;query(l, r); else if (l &gt; mid) return rc-&gt;query(l, r); else return LinearBasis::merge(lc-&gt;query(l, r), rc-&gt;query(l, r)); } static SegT *build(int l, int r, long long *a) { if (l == r) return new SegT(l, r, NULL, NULL, a[l]); else { int mid = l + (r - l) / 2; return new SegT(l, r, build(l, mid, a), build(mid + 1, r, a)); } } } *seg; int n, root; inline void split() { std::stack&lt;Node *&gt; s; s.push(&amp;N[root]); N[root].dep = 1; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;vis) { v-&gt;vis = true; for (Node **p = &amp;v-&gt;adj.front(), *u = v-&gt;adj.front(); p &lt;= &amp;v-&gt;adj.back(); u = *++p) { if (!u-&gt;dep) { u-&gt;fa = v; u-&gt;dep = v-&gt;dep + 1; s.push(u); } } } else { v-&gt;size = 1; for (Node **p = &amp;v-&gt;adj.front(), *u = v-&gt;adj.front(); p &lt;= &amp;v-&gt;adj.back(); u = *++p) { v-&gt;size += u-&gt;size; if (!v-&gt;ch || v-&gt;ch-&gt;size &lt; u-&gt;size) v-&gt;ch = u; } s.pop(); } } for (int i = 1; i &lt;= n; i++) N[i].vis = false; int ts = 0; static Node *seq[MAXN + 1]; s.push(&amp;N[root]); while (!s.empty()) { Node *v = s.top(); if (!v-&gt;vis) { v-&gt;vis = true; v-&gt;top = (!v-&gt;fa || v != v-&gt;fa-&gt;ch) ? v : v-&gt;fa-&gt;top; seq[v-&gt;dfn = ++ts] = v; for (Node **p = &amp;v-&gt;adj.front(), *u = v-&gt;adj.front(); p &lt;= &amp;v-&gt;adj.back(); u = *++p) { if (u != v-&gt;fa &amp;&amp; u != v-&gt;ch) { s.push(u); } } if (v-&gt;ch) s.push(v-&gt;ch); } else { s.pop(); } } static long long x[MAXN + 1]; for (int i = 1; i &lt;= n; i++) x[i] = seq[i]-&gt;w; seg = SegT::build(1, n, x); } inline long long query(int u, int v) { Node *a = &amp;N[u], *b = &amp;N[v]; LinearBasis lb; while (a-&gt;top != b-&gt;top) { if (a-&gt;top-&gt;dep &lt; b-&gt;top-&gt;dep) std::swap(a, b); lb.mergeFrom(seg-&gt;query(a-&gt;top-&gt;dfn, a-&gt;dfn)); a = a-&gt;top-&gt;fa; } if (a-&gt;dep &gt; b-&gt;dep) std::swap(a, b); lb.mergeFrom(seg-&gt;query(a-&gt;dfn, b-&gt;dfn)); return lb.queryMax(); } /* int f[MAXN + 1][MAXN_LOG + 1], logn; LinearBasis g[MAXN + 1][MAXN_LOG + 1]; inline void prepare() { std::queue&lt;Node *&gt; q; q.push(&amp;N[root]); N[root].dep = 1; f[root][0] = root; g[root][0] = LinearBasis(&amp;N[root].w - 1, 1); while (!q.empty()) { Node *v = q.front(); q.pop(); for (Node **p = &amp;v-&gt;adj.front(), *u = v-&gt;adj.front(); p &lt;= &amp;v-&gt;adj.back(); u = *++p) { if (!u-&gt;dep) { u-&gt;dep = v-&gt;dep + 1; f[u - N][0] = v - N; long long a[2]; a[0] = u-&gt;w, a[1] = v-&gt;w; g[u - N][0] = LinearBasis(a - 1, 2); q.push(u); } } } while ((1 &lt;&lt; (logn + 1)) &lt;= n) logn++; for (int j = 1; j &lt;= logn; j++) { for (int i = 1; i &lt;= n; i++) { f[i][j] = f[f[i][j - 1]][j - 1]; g[i][j] = LinearBasis::merge(g[i][j - 1], g[f[i][j - 1]][j - 1]); } } } inline long long query(int u, int v) { if (N[u].dep &lt; N[v].dep) std::swap(u, v); LinearBasis lb; if (N[u].dep &gt; N[v].dep) { for (int i = logn; i &gt;= 0; i--) { if (N[f[u][i]].dep &gt;= N[v].dep) { lb.mergeFrom(g[u][i]); u = f[u][i]; } } } if (u != v) { for (int i = logn; i &gt;= 0; i--) { if (f[u][i] != f[v][i]) { lb.mergeFrom(g[u][i]); lb.mergeFrom(g[v][i]); u = f[u][i]; v = f[v][i]; } } lb.mergeFrom(g[u][0]); lb.mergeFrom(g[v][0]); u = f[u][0]; v = f[v][0]; } lb.insert(N[u].w); return lb.queryMax(); } */ int main() { int q; scanf("%d %d", &amp;n, &amp;q); // srand((n * q) ^ 20000528); // root = rand() % n + 1; root = 1; for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;N[i].w); for (int i = 1; i &lt;= n - 1; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v); addEdge(u, v); } // for (int i = 1; i &lt;= n; i++) std::random_shuffle(N[i].adj.begin(), N[i].adj.end()); split(); // prepare(); while (q--) { int u, v; scanf("%d %d", &amp;u, &amp;v); printf("%lld\n", query(u, v)); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>最近公共祖先</tag>
        <tag>线性基</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2844」albus 就是要第一个出场 - 线性基]]></title>
    <url>%2Fbzoj-2844%2F</url>
    <content type="text"><![CDATA[给定 个数 ，以及一个数 。将 的所有子集（可以为空）的异或值从小到大排序得到序列 ，请问 在 中第一次出现的下标是多少？保证 在 中出现。 链接 BZOJ 2844 题解 首先，求出这 个数的线性基。 考虑线性基所控制的某个二进制位，如果这一位为 ，那么线性基中控制这一位的元素一定被选择，这样可以求出 在去重后的 中第一次出现的下标是多少。 之后，计算每个重复的数字出现了多少次。设 中不在线性基中的数的集合为 （），考虑它的一个子集 （可以为空）， 的异或和一定可以唯一表示为 中若干个数的异或和，将它们都异或起来，我们可以的到 ，这样，我们就得到了 种方案得到 ，所以，对于每一个 ，它的出现次数至少为 。 接着证明它的上界，假设在 中任意选，最终都可以凑出这个数，而选择 中的数的方案一定是唯一的，即上界也为 。 代码 #include &lt;cstdio&gt; #include &lt;vector&gt; const int MAXN = 100000; const int MAXL = 30; const int MOD = 10086; struct LinearBasis { std::vector&lt;int&gt; bit; void build(int *x, int n) { std::vector&lt;int&gt; a(MAXL + 1); for (int i = 1; i &lt;= n; i++) { int t = x[i]; for (int j = MAXL; j &gt;= 0; j--) { if (!(t &amp; (1 &lt;&lt; j))) continue; if (a[j]) t ^= a[j]; else { for (int k = 0; k &lt; j; k++) if (t &amp; (1 &lt;&lt; k)) t ^= a[k]; for (int k = j + 1; k &lt;= MAXL; k++) if (a[k] &amp; (1 &lt;&lt; j)) a[k] ^= t; a[j] = t; break; } } } bit.clear(); for (int i = 0; i &lt;= MAXL; i++) if (a[i]) bit.push_back(i); } int size() { return bit.size(); } int rank(int x) { int res = 0; for (int i = 0; i &lt; (int)bit.size(); i++) if (x &amp; (1 &lt;&lt; bit[i])) res |= (1 &lt;&lt; i); // printf("rank = %d\n", res); return res; } } lb; inline int pow(int x, int n) { int res = 1; for (; n; n &gt;&gt;= 1, (x *= x) %= MOD) if (n &amp; 1) (res *= x) %= MOD; return res; } int main() { int n; scanf("%d", &amp;n); static int a[MAXN + 1]; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); lb.build(a, n); int x; scanf("%d", &amp;x); // printf("size = %d\n", lb.size()); int k = lb.rank(x); int ans = (k % MOD * pow(2, n - lb.size()) % MOD + 1) % MOD; printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
        <tag>BZOJ</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「WC2011」Xor - 线性基]]></title>
    <url>%2Fwc2011-xor%2F</url>
    <content type="text"><![CDATA[给一个无向连通图，求一条从 到 的路径（可以不是简单路径），使经过的边权的异或和最大。 链接 BZOJ 2115 题解 首先，一个显然的结论是，图中所有简单环的异或和，都是可以直接获得的 —— 因为我们可以从起点走到一个环，由 进入这个环，走一圈回到 然后原路返回起点，这样起点和 之间的边都经过了两次，相当于没有经过这些边，而环上的边权被留在了答案中。 我们可以 BFS 求出所有简单环的边权异或和，并求出它们的线性基。任意找一条从 到 的路径，然后从大到小考虑线性基中的每个元素加入到答案中会不会使答案更大即可。 **证明：**设当前答案为 ，考虑到的线性基中的当前元素为 ， 控制着线性基中的第 位，那么分为三种情况： 中第 位为 ， 中第 位为 ，此时不选 ； 中第 位为 ， 中第 位为 ，此时选 ； 中第 位为 ，此时一定有 ，不会影响。 根据归纳法，最终答案是正确的。 代码 #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;queue&gt; const int MAXN = 50000; const int MAXL = 60; struct Node { std::vector&lt;struct Edge&gt; e; Node *fa; long long dist; int dep; } N[MAXN + 1]; struct Edge { Node *s, *t; long long w; Edge(Node *s, Node *t, long long w) : s(s), t(t), w(w) {} }; inline void addEdge(int s, int t, long long w) { N[s].e.push_back(Edge(&amp;N[s], &amp;N[t], w)); N[t].e.push_back(Edge(&amp;N[t], &amp;N[s], w)); } inline std::vector&lt;long long&gt; bfs() { std::queue&lt;Node *&gt; q; q.push(&amp;N[1]); N[1].dep = 1; std::vector&lt;long long&gt; circles; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = &amp;v-&gt;e.front(); e &lt;= &amp;v-&gt;e.back(); e++) { if (!e-&gt;t-&gt;dep) { e-&gt;t-&gt;dep = v-&gt;dep + 1; e-&gt;t-&gt;dist = v-&gt;dist ^ e-&gt;w; e-&gt;t-&gt;fa = v; q.push(e-&gt;t); } else if (e-&gt;t != v-&gt;fa) { circles.push_back(e-&gt;t-&gt;dist ^ v-&gt;dist ^ e-&gt;w); } } } return circles; } struct LinearBasis { std::vector&lt;long long&gt; v; void build(std::vector&lt;long long&gt; x) { std::vector&lt;long long&gt; a(MAXL + 1); for (int i = 0; i &lt; int(x.size()); i++) { long long t = x[i]; for (int j = MAXL; j &gt;= 0; j--) { if (!(t &amp; (1ll &lt;&lt; j))) continue; if (a[j]) t ^= a[j]; else { for (int k = 0; k &lt; j; k++) if (t &amp; (1ll &lt;&lt; k)) t ^= a[k]; for (int k = j + 1; k &lt;= MAXL; k++) if (a[k] &amp; (1ll &lt;&lt; j)) a[k] ^= t; a[j] = t; break; } } } v.clear(); for (int i = 0; i &lt;= MAXL; i++) if (a[i]) v.push_back(a[i]); } long long queryMaxWith(long long x) { long long res = x; for (int i = 0; i &lt; int(v.size()); i++) if ((res ^ v[i]) &gt; res) res ^= v[i]; return res; } } lb; int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); while (m--) { int u, v; long long w; scanf("%d %d %lld", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); } std::vector&lt;long long&gt; circles = bfs(); lb.build(circles); printf("%lld\n", lb.queryMaxWith(N[n].dist)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU 3949」XOR - 线性基]]></title>
    <url>%2Fhdu-3949%2F</url>
    <content type="text"><![CDATA[给一组正整数，求其第 小的子集异或和。 链接 HDU 3949（Virtual Judge） 题解 首先，求出这个集合的线性基 ，选择线性基的一个非空子集共有 种方案。如果 ，则说明至少有一个没有被插入到线性基中的数可以被线性基中的数表示出来，选择线性基中的一些数与这个数，可以得到其异或和为 ，这样有 种方案。 然后，考虑给出线性基，求选择若干（至少一个）数可以组成的第 小（ 从 开始，第 小为 ）的数。 将 表示为一个长度为 的二进制数（范围为 ；如不足，可在高位补 ）。 的二进制排列符合以下性质： 高位上的 比低位上的 更能使 更大； 低位上的 一定会使 更大。 线性基的 个元素控制了异或后结果的 个二进制位，而二进制数的规律恰好与从线性基中选数的两条规律相对应： 选择「控制较高位上的 的元素」更能使异或和更大； 选择「控制较高位上的 的元素」后，再选择「控制更低位上 的元素」一定会使异或和更大。 解法就比较显然了 —— 枚举 所有为 的二进制位，如果第 位为 ，则将线性基中控制的第 小的二进制位的元素异或到答案中。 代码 #include &lt;cstdio&gt; #include &lt;vector&gt; const int MAXN = 100000; const int MAXL = 50; struct LinearBasis { std::vector&lt;long long&gt; v; int n; void build(long long *x, int n) { this-&gt;n = n; std::vector&lt;long long&gt; a(MAXL + 1); for (int i = 1; i &lt;= n; i++) { long long t = x[i]; for (int j = MAXL; j &gt;= 0; j--) { if ((t &amp; (1ll &lt;&lt; j)) == 0) continue; if (a[j]) t ^= a[j]; else { for (int k = 0; k &lt; j; k++) if (t &amp; (1ll &lt;&lt; k)) t ^= a[k]; for (int k = j + 1; k &lt;= MAXL; k++) if (a[k] &amp; (1ll &lt;&lt; j)) a[k] ^= t; a[j] = t; break; } } /* printf("insert(%d):\n", t); print(); */ } v.clear(); for (int i = 0; i &lt;= MAXL; i++) if (a[i]) v.push_back(a[i]); } long long query(long long k) { if (int(v.size()) != n) { // 可能是 0 k--; } // 如果 k 超过的所有不同异或和的数量 if (k &gt; (1ll &lt;&lt; v.size()) - 1) return -1; long long ans = 0; for (size_t i = 0; i &lt; v.size(); i++) { if (k &amp; (1ll &lt;&lt; i)) { ans ^= v[i]; } } return ans; } /* void print() { for (int i = 0; i &lt;= MAXL; i++) { for (int j = 0; j &lt;= MAXL; j++) printf(j == MAXL ? "%d\n" : "%d", (a[i] &amp; (1 &lt;&lt; j)) ? 1 : 0); } } */ } lb; int main() { int n; scanf("%d", &amp;n); static long long a[MAXN + 1]; for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;a[i]); lb.build(a, n); int m; scanf("%d", &amp;m); while (m--) { long long k; scanf("%lld", &amp;k); printf("%lld\n", lb.query(k)); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线性基</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性基学习笔记]]></title>
    <url>%2Flinear-basis-notes%2F</url>
    <content type="text"><![CDATA[线性基是竞赛中常用来解决子集异或一类题目的算法。 定义 异或和 设 为一无符号整数集（下文中除非特殊说明，集合均指「无符号整数集」），定义其异或和 。 张成 设 ，所有这样的子集 的异或和组成的集合称为集合 的张成，记作 。即，在 中选出任意多个数，其异或和的所有可能的结果组成的集合。 线性相关 对于一个集合 ，如果存在一个元素 ，使得， 在去除这个元素后得到的集合 的张成 中包含 ，即，，则称集合 线性相关。 更形象地，可以表示为，存在一个元素 ，可以用其它若干个元素异或起来得到。 相对的，如果不存在这样的元素 ，则称集合 线性无关。 一个显然的结论是，对于这个线性相关的集合 ，去除这个元素后，集合的张成不变。 线性基 我们称集合 是集合 的线性基，当且仅当： ，即 是 的张成的子集； 是线性无关的。 集合 中元素的个数，称为线性基的长度。 线性基有以下基本性质： 是极小的满足线性基性质的集合，它的任何真子集都不可能是线性基； 中的任意元素都可以唯一表示为 中若干个元素异或起来的结果。 构造与性质 这里讲解一种线性基的构造方法，及其特殊性质，之后，我们将讨论这种构造方法的正确性。下文中「线性基」均指这种方法构造出的线性基。 设集合 中最大的数在二进制意义下有 位，我们使用一个 的数组 来储存线性基。 这种线性基的构造方法保证了一个特殊性质，对于每一个 ， 有以下两种可能： ，并且 只有满足 的 （即，位于 后面的所有 ）的第 个二进制位可能为 ； ，并且 整个 数组中只有 的第 个二进制位为 ； 更高的二进制位（ 的二进制位）一定为 ； 更低的二进制位（ 的二进制位）可能为 ； 我们称第 位存在于线性基中，当且仅当 。 举个例子，我们的构造方法可能得到一个这样的数组 （右侧为最低二进制位），其中被标为蓝色的元素为上述的第 2 种情况，绿色的元素为上述的第 1 种情况。 举两个反例： 首先，线性基是动态构造的，我们只需要从空的 开始，每次考虑在一个已存在的线性基中插入一个数 即可。 从 最高位上的 开始考虑，设这是第 位，如果这一位已经存在于线性基中，则我们需要将 中的这一位消掉（将 异或上 ），才可以继续插入（因为只有 的第 位可以为 ）。 如果这一位不存在于线性基中，则可以将 插入到 的位置上，但插入时需要保证： 中比第 位更高的已经存在于线性基中的二进制位上必须为 ，而这时候 的最高位上的 一定是第 位（更高位上即使原本有，也被消掉了），所以无需考虑； 中比第 位更低的已经存在于线性基中的二进制位上必须为 ，对于这一点，我们可以枚举 中为 的这些二进制位 （）对应的元素 ，并用类似上面的方式将 异或上 ，以消掉这些位上的 ； 中必须只有 的第 位为 ： 中在 前面的元素的第 位必须为 ，这一点必定已经满足，假设存在一个 满足 的第 位为 ，则 在插入时就应该被插入到 的位置上，所以无需考虑； 中在 后面的元素的第 位必须为 ，对于这一点，我们可以枚举 后面的元素 （），将每个第 位为 的 异或上 。 流程 逆序枚举 所有为 的二进制位 ，对于每个 如果 ，则令 如果 ，则 枚举 ，如果 的第 位为 ，则令 枚举 ，如果 的第 位为 ，则令 令 ，结束插入过程 代码 const int MAXL = 60; struct LinearBasis { long long a[MAXL + 1]; LinearBasis() { std::fill(a, a + MAXL + 1, 0); } void insert(long long t) { // 逆序枚举二进制位 for (int j = MAXL; j &gt;= 0; j--) { // 如果 t 的第 j 位为 0，则跳过 if (!(t &amp; (1ll &lt;&lt; j))) continue; // 如果 a[j] != 0，则用 a[j] 消去 t 的第 j 位上的 1 if (a[j]) t ^= a[j]; else { // 找到可以插入 a[j] 的位置 // 用 a[0...j - 1] 消去 t 的第 [0, j) 位上的 1 // 如果某一个 a[k] = 0 也无须担心，因为这时候第 k 位不存在于线性基中，不需要保证 t 的第 k 位为 0 for (int k = 0; k &lt; j; k++) if (t &amp; (1ll &lt;&lt; k)) t ^= a[k]; // 用 t 消去 a[j + 1...L] 的第 j 位上的 1 for (int k = j + 1; k &lt;= MAXL; k++) if (a[k] &amp; (1ll &lt;&lt; j)) a[k] ^= t; // 插入到 a[j] 的位置上 a[j] = t; // 不要忘记，结束插入过程 return; } // 此时 t 的第 j 位为 0，继续寻找其最高位上的 1 } // 如果没有插入到任何一个位置上，则表明 t 可以由 a 中若干个元素的异或和表示出，即 t 在 span(a) 中 } }; 证明 首先，根据归纳法，可以得出其特殊性质是满足的。 我们枚举 中的所有元素作为 ，分别插入，并将数组 转化为一个集合 （只需要去除重复的为 的元素即可，显然不为 的元素不会重复），此时 就是 的线性基： 首先，在插入的过程中，我们每次找到 最高位上的 ，然后把它消去，如果最终全部被消去，则表示要插入的 已经可以由 中一些元素的异或和表示出，此时不需要插入。这样保证了 是线性无关的。 对于被实际插入到 中的元素，它们在实际插入之前做了一些变换，这些变换都是使它异或上 中已存在的元素，或者使 中已存在的元素异或上它 —— 这些变换都是可逆的，所以用 中一些元素的异或和可以表示出这些（实际被插入的）元素。 同时，显然该算法的时间复杂度为 单次插入，空间复杂度同样为 。 合并 两个集合的线性基可以在 的时间内进行合并，合并后得到的线性基为两个集合的并的线性基。 合并只需要将一个线性基中的所有元素插入到另一个线性基中即可。 void mergeFrom(const LinearBasis &amp;other) { for (int i = 0; i &lt;= MAXL; i++) insert(other.a[i]); } static LinearBasis merge(const LinearBasis &amp;a, const LinearBasis &amp;b) { LinearBasis res = a; for (int i = 0; i &lt;= MAXL; i++) res.insert(b.a[i]); return res; } 应用 线性基最基本的应用，就是子集最大异或和问题： 给一个集合 ，求它的一个子集 ，使得 最大，求出这个最大值。 首先，求出 的线性基 ，问题转化为选择 的一个子集。从高到低考虑在线性基中的二进制位 ，如果第 位存在于线性基中，则考虑到线性基中只有惟一一个元素的第 位为 ，所以之前加入到 中的元素的异或和的第 位一定为 ，即，将这个元素加入到 中一定会使答案更大 —— 所以，求出线性基中所有元素的异或和，即为答案。 long long queryMax() { long long res = 0; for (int i = 0; i &lt;= MAXL; i++) res ^= a[i]; return res; } 子集 大异或和：HDU 3949 最大路径异或和：WC2011 Xor 求子集异或值排名：BZOJ 2844 树上两点间子集最大异或和：SCOI2016 幸运数字 模板 一 不显式构造出集合 ，支持动态插入。 struct LinearBasis { long long a[MAXL + 1]; LinearBasis() { std::fill(a, a + MAXL + 1, 0); } LinearBasis(long long *x, int n) { build(x, n); } void insert(long long t) { for (int j = MAXL; j &gt;= 0; j--) { if (!t) return; if (!(t &amp; (1ll &lt;&lt; j))) continue; if (a[j]) t ^= a[j]; else { for (int k = 0; k &lt; j; k++) if (t &amp; (1ll &lt;&lt; k)) t ^= a[k]; for (int k = j + 1; k &lt;= MAXL; k++) if (a[k] &amp; (1ll &lt;&lt; j)) a[k] ^= t; a[j] = t; break; } } } // 数组 x 表示集合 S，下标范围 [1...n] void build(long long *x, int n) { std::fill(a, a + MAXL + 1, 0); for (int i = 1; i &lt;= n; i++) { insert(x[i]); } } long long queryMax() { long long res = 0; for (int i = 0; i &lt;= MAXL; i++) res ^= a[i]; return res; } void mergeFrom(const LinearBasis &amp;other) { for (int i = 0; i &lt;= MAXL; i++) insert(other.a[i]); } static LinearBasis merge(const LinearBasis &amp;a, const LinearBasis &amp;b) { LinearBasis res = a; for (int i = 0; i &lt;= MAXL; i++) res.insert(b.a[i]); return res; } }; 二 显式构造出集合 （代码中的 ），不支持动态插入。 struct LinearBasis { std::vector&lt;long long&gt; v; int n; // 原有集合 S 的大小 // 数组 x 表示集合 S，下标范围 [1...n] void build(long long *x, int n) { this-&gt;n = n; std::vector&lt;long long&gt; a(MAXL + 1); for (int i = 1; i &lt;= n; i++) { long long t = x[i]; for (int j = MAXL; j &gt;= 0; j--) { if ((t &amp; (1ll &lt;&lt; j)) == 0) continue; if (a[j]) t ^= a[j]; else { for (int k = 0; k &lt; j; k++) if (t &amp; (1ll &lt;&lt; k)) t ^= a[k]; for (int k = j + 1; k &lt;= MAXL; k++) if (a[k] &amp; (1ll &lt;&lt; j)) a[k] ^= t; a[j] = t; break; } } } v.clear(); for (int i = 0; i &lt;= MAXL; i++) if (a[i]) v.push_back(a[i]); } long long queryMax() { long long x = 0; for (size_t i = 0; i &lt; v.size(); i++) x ^= v[i]; return x; } };]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2016」美味 - 贪心 + 主席树]]></title>
    <url>%2Fscoi2016-food%2F</url>
    <content type="text"><![CDATA[一家餐厅有 道菜，编号 ，大家对第 道菜的评价值为 （）。有 位顾客，第 位顾客的期望值为 ，而他的偏好值为 。因此，第 位顾客认为第 道菜的美味度为 （ 表示异或运算）。第 位顾客希望从这些菜中挑出他认为最美味的菜，即美味值最大的菜，但由于价格等因素，他只能从第 道到第 道中选择。请你帮助他们找出最美味的菜。 链接 BZOJ 4571 题解 先考虑问题的一个简化版本 —— 给一个序列 ，第 个询问为 。这个问题可以使用 Trie 树存储序列 的所有数，从高位到低位贪心解决。 Trie 树上从高位到低位贪心的实质是，对于前面若干位考虑过的值为 ，考虑第 位，查询序列 中是否有数在 和 这两个区间内，所以我们可以把 Trie 树换成权值线段树。这一步转化十分关键。 继续考虑一个更接近原问题的简化版本 —— 给一个序列 ，第 个询问为 。即，每次查询前对整个 序列加上一个数 。考虑到权值线段树无法整体将所有值加上一个数（因为整体右移整棵树会改变树的形态），一个显然的思路是每次查询 和 这两个区间时，将要查询的区间整体左移，即改为查询 和 这两个区间。 现在回到原问题，给一个序列 ，第 个询问为 。我们只需要在前一个问题的基础上，把普通的线段树改为主席树即可。 代码 #include &lt;cstdio&gt; const int MAXN = 2e5; const int MAXM = 1e5; const int HIGHEST_BIT = 17; struct PSegT { struct SegT { int l, r; SegT *lc, *rc; int cnt; SegT() {} SegT(int l, int r, SegT *lc, SegT *rc, int cnt) : l(l), r(r), lc(lc), rc(rc), cnt(cnt) {} SegT(int l, int r, SegT *lc, SegT *rc) : l(l), r(r), lc(lc), rc(rc), cnt(lc-&gt;cnt + rc-&gt;cnt) {} int query(int l, int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return cnt; else return lc-&gt;query(l, r) + rc-&gt;query(l, r); } } *rt[MAXN + 1], *null; PSegT() { null = new SegT(-1, -1, NULL, NULL, 0); rt[0] = null-&gt;lc = null-&gt;rc = null; } SegT *insert(SegT *v, int l, int r, int x) { if (l == r) return new SegT(l, r, null, null, v-&gt;cnt + 1); int mid = l + (r - l) / 2; if (x &gt; mid) return new SegT(l, r, v-&gt;lc, insert(v-&gt;rc, mid + 1, r, x)); else return new SegT(l, r, insert(v-&gt;lc, l, mid, x), v-&gt;rc); } void build(int *a, int n) { for (int i = 1; i &lt;= n; i++) { rt[i] = insert(rt[i - 1], 0, MAXN - 1, a[i]); } } int maxAddXor(int ql, int qr, int add, int x) { SegT *tr = rt[qr], *tl = rt[ql - 1]; int ans = 0, xorWith = 0; for (int i = HIGHEST_BIT; i &gt;= 0; i--) { int k = 1 &lt;&lt; i; if (k &amp; x) { // The k-th lower bit of `x` is 1 bool canZero = tr-&gt;query(xorWith - add, xorWith + k - 1 - add) - tl-&gt;query(xorWith - add, xorWith + k - 1 - add) != 0; if (canZero) { ans |= k; } else { xorWith |= k; } } else { // The k-th lower bit of `x` is 0 bool canOne = tr-&gt;query(xorWith + k - add, xorWith + 2 * k - 1 - add) - tl-&gt;query(xorWith + k - add, xorWith + 2 * k - 1 - add) != 0; if (canOne) { ans |= k; xorWith |= k; } } } return ans; } } ps; int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); static int a[MAXN + 1]; for (int i = 1; i &lt;= n; i++) { scanf("%d", &amp;a[i]); } ps.build(a, n); while (m--) { int b, x, l, r; scanf("%d %d %d %d", &amp;b, &amp;x, &amp;l, &amp;r); printf("%d\n", ps.maxAddXor(l, r, x, b)); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>贪心</tag>
        <tag>主席树</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CQOI2015」任务查询系统 - 主席树]]></title>
    <url>%2Fcqoi2015-query%2F</url>
    <content type="text"><![CDATA[最近实验室正在为其管理的超级计算机编制一套任务管理系统，而你被安排完成其中的查询部分。超级计算机中的任务用三元组 描述， 表示任务从第 秒开始，在第 秒后结束（第 秒和 秒任务也在运行），其优先级为 。同一时间可能有多个任务同时执行，它们的优先级可能相同，也可能不同。调度系统会经常向查询系统询问，第 秒正在运行的任务中，优先级最小的 个任务（即将任务按照优先级从小到大排序后取前 个）的优先级之和是多少。特别的，如果 大于第 秒正在运行的任务总数，则直接回答第 秒正在运行的任务优先级之和。上述所有参数均为整数，时间的范围在 到 之间（包含 和 ）。 链接 BZOJ 3932 题解 如果题目没有强制在线，则有一种显然的思路 —— 对于每个任务，将它拆分为在 时间加入一个数 ，在 时间删去一个数 。将询问按照 排序，按照时间顺序，使用平衡树或线段树等数据结构维护当前时间点的所有数即可。 之后，在线的思路也比较显然了 —— 建立 棵可持久化线段树，预处理出每个时间点上的线段树，然后依次处理每个询问即可。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; const int MAXN = 100000; const int MAXX = 10000000; struct Tag { int x; bool del; Tag(int x, bool del) : x(x), del(del) {} }; extern struct SegT *null; struct SegT { SegT *lc, *rc; int cnt; long long sum; SegT() : lc(this), rc(this), cnt(0), sum(0) {} SegT(SegT *lc, SegT *rc) : lc(lc), rc(rc), cnt(lc-&gt;cnt + rc-&gt;cnt), sum(lc-&gt;sum + rc-&gt;sum) {} SegT(SegT *lc, SegT *rc, int cnt, long long sum) : lc(lc), rc(rc), cnt(cnt), sum(sum) {} SegT *insert(int l, int r, int x, int delta) { int mid = l + (r - l) / 2; if (l == r) return new SegT(null, null, cnt + delta, sum + (long long)delta * l); if (x &lt;= mid) return new SegT(lc-&gt;insert(l, mid, x, delta), rc); else return new SegT(lc, rc-&gt;insert(mid + 1, r, x, delta)); } long long query(int l, int r, int k) { int mid = l + (r - l) / 2; if (k &gt; cnt) return sum; else if (l == r) return (long long)k * l; else if (k == lc-&gt;cnt) return lc-&gt;sum; else if (k &gt; lc-&gt;cnt) return lc-&gt;sum + rc-&gt;query(mid + 1, r, k - lc-&gt;cnt); else return lc-&gt;query(l, mid, k); } } *rt[MAXN + 1], *null; inline void init() { null = new SegT(); } int m, n; std::vector&lt;Tag&gt; tags[MAXN + 1]; inline void build() { rt[0] = null; for (int i = 1; i &lt;= n; i++) { SegT *v = rt[i - 1]; for (std::vector&lt;Tag&gt;::iterator it = tags[i].begin(); it != tags[i].end(); it++) { v = v-&gt;insert(1, MAXX, it-&gt;x, it-&gt;del ? -1 : 1); } rt[i] = v; } } int main() { scanf("%d %d", &amp;m, &amp;n); for (int i = 1; i &lt;= m; i++) { int l, r, x; scanf("%d %d %d", &amp;l, &amp;r, &amp;x); tags[l].push_back(Tag(x, false)); if (r + 1 &lt;= n) tags[r + 1].push_back(Tag(x, true)); } init(); build(); long long lastAns = 1; for (int i = 1; i &lt;= n; i++) { int x, a, b, c; scanf("%d %d %d %d", &amp;x, &amp;a, &amp;b, &amp;c); int k = 1 + (a * lastAns + b) % c; lastAns = rt[x]-&gt;query(1, MAXX, k); printf("%lld\n", lastAns); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>BZOJ</tag>
        <tag>主席树</tag>
        <tag>CQOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CQOI2009」跳舞 - 网络流]]></title>
    <url>%2Fcqoi2009-dance%2F</url>
    <content type="text"><![CDATA[一次舞会有 个男孩和 个女孩。每首曲子开始时，所有男孩和女孩恰好配成 对跳交谊舞。每个男孩都不会和同一个女孩跳两首（或更多）舞曲。有一些男孩女孩相互喜欢，而其他相互不喜欢（不会「单向喜欢」）。每个男孩最多只愿意和 个不喜欢的女孩跳舞，而每个女孩也最多只愿意和 个不喜欢的男孩跳舞。给出每对男孩女孩是否相互喜欢的信息，舞会最多能有几首舞曲？ 链接 BZOJ 1305 题解 二分答案。 对于每个男孩 建两个点 和 ，其中 连出的边表示和喜欢的女孩跳舞， 连出的边表示和不喜欢的女孩跳舞； 对于每个女孩 建两个点 和 ，其中 连入的边表示和喜欢的男孩跳舞， 连入的边表示和不喜欢的女孩跳舞； 从每个 和 分别向 和 连一条容量为 的边，表示最多只能和 个不喜欢的人跳舞； 建立源点 与汇点 ，对于每个 ，连容量为答案的边 与 ，表示每个男孩或女孩可以跳舞无限次。 最大流即为每个男生能跳的舞的数量的和，如果最大流为答案的 倍，则答案合法。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;queue&gt; #include &lt;vector&gt; const int MAXN = 50; const int MAX_ANS = 10000; struct Node { std::vector&lt;struct Edge&gt; edges; struct Edge *currEdge; int l; } N[MAXN * 4 + 2]; struct Edge { Node *s, *t; int flow, cap, rev; Edge(Node *s, Node *t, int cap, int rev) : s(s), t(t), flow(0), cap(cap), rev(rev) {} }; inline void addEdge(int s, int t, int cap) { N[s].edges.push_back(Edge(&amp;N[s], &amp;N[t], cap, N[t].edges.size())); N[t].edges.push_back(Edge(&amp;N[t], &amp;N[s], 0, N[s].edges.size() - 1)); } struct Dinic { bool level(Node *s, Node *t, int n) { for (int i = 0; i &lt; n; i++) { N[i].l = 0; N[i].currEdge = &amp;N[i].edges.front(); } std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = &amp;v-&gt;edges.front(); e &lt;= &amp;v-&gt;edges.back(); e++) { if (e-&gt;flow &lt; e-&gt;cap &amp;&amp; !e-&gt;t-&gt;l) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } } return false; } int findPath(Node *s, Node *t, int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;currEdge; e &lt;= &amp;s-&gt;edges.back(); e++) { if (e-&gt;flow &lt; e-&gt;cap &amp;&amp; e-&gt;t-&gt;l == s-&gt;l + 1) { int flow = findPath(e-&gt;t, t, std::min(limit, e-&gt;cap - e-&gt;flow)); if (flow) { e-&gt;flow += flow; e-&gt;t-&gt;edges[e-&gt;rev].flow -= flow; return flow; } } } return 0; } int operator()(int s, int t, int n) { int res = 0; while (level(&amp;N[s], &amp;N[t], n)) { int flow; while ((flow = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += flow; } return res; } } dinic; int n, k; char s[MAXN + 1][MAXN + 2]; inline bool check(int limit) { for (int i = 0; i &lt; n * 4 + 2; i++) N[i].edges.clear(); for (int i = 1; i &lt;= n; i++) { addEdge(i, i + n * 2, k); } for (int i = n + 1; i &lt;= n * 2; i++) { addEdge(i + n * 2, i, k); } int s = 0, t = n * 4 + 1; for (int i = 1; i &lt;= n; i++) { addEdge(s, i, limit); } for (int i = n + 1; i &lt;= n * 2; i++) { addEdge(i, t, limit); } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (::s[i][j] == 'Y') { addEdge(i, n + j, 1); } else { addEdge(i + n * 2, n + j + n * 2, 1); } } } return dinic(s, t, n * 4 + 2) == limit * n; } int main() { scanf("%d %d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) { scanf("%s", s[i] + 1); } int l = 0, r = MAX_ANS; while (l &lt; r) { int mid = l + (r - l) / 2 + 1; if (check(mid)) l = mid; else r = mid - 1; } printf("%d\n", l); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>二分答案</tag>
        <tag>CQOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TJOI2015」组合数学 - DP + 结论]]></title>
    <url>%2Ftjoi2015-math%2F</url>
    <content type="text"><![CDATA[给出一个网格图，其中某些格子有财宝，每次从左上角出发，只能向下或右走。问至少走多少次才能将财宝捡完。此对此问题变形，假设每个格子中有好多财宝，而每一次经过一个格子至多只能捡走一块财宝，至少走多少次才能把财宝全部捡完。 链接 BZOJ 3997 题解 结论题。 答案是，满足每一个点都在前一个点的严格右下方的最长链长度。 所以，从右上角到左下角做一遍以下 DP 即可。 答案即为 。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 1000; int main() { int T; scanf("%d", &amp;T); while (T--) { int n, m; scanf("%d %d", &amp;n, &amp;m); static int a[MAXN + 1][MAXN + 1]; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { scanf("%d", &amp;a[i][j]); } } static int dp[MAXN + 1][MAXN + 1]; memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= n; i++) { for (int j = m; j &gt;= 1; j--) { dp[i][j] = std::max(dp[i - 1][j + 1] + a[i][j], std::max(dp[i - 1][j], dp[i][j + 1])); } } printf("%d\n", dp[n][1]); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>TJOI</tag>
        <tag>结论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3062」Taxi - 贪心]]></title>
    <url>%2Fbzoj-3062%2F</url>
    <content type="text"><![CDATA[Bessie 在农场上为其他奶牛提供出租车服务。这些奶牛已经在沿着长度为 的栅栏上不同的地点聚集等候。不幸的是，他们已经厌倦了他们当前所在的位置并且每只奶牛都想要沿着栅栏去别的地方走走。Bessie 必须赶到这些奶牛的起始位置，并把他们带到它们的目的地。Bessie 的车很小，所以她只能一次只能搭载一头奶牛。奶牛可以在同一时刻完成上车和下车。 为了节省燃气，Bessie 想以尽可能少的燃料完成这次任务。 只奶牛的起始位置和结束为止都是已知的，请确定 Bessie 的最少行程。Bessie 意识到，要使所得到的行程最短，Bessie 可能将在沿途中让奶牛上车或下车而并不一定将一头奶牛从起点直接送到中点。 Bessie 的起点是围栏的最左端，位置记为 。终点在篱笆的最右边，位置记为 。 链接 BZOJ 3062 题解 设 表示第 头牛的起点， 表示第 头牛的终点。 首先，对于每头奶牛，一定需要将其从起点送到终点，这部份对答案的贡献固定为 。 每次送完一头牛后，都需要去到另一头牛的起点，即每次都要从一个 位置去到 ，考虑到在开始和结束时要从 到 ，即将 作为一个 ， 作为一个 。 考虑如何安排可以使这个行程最短 —— 尝试将 数组和 数组分别从小到大排序，每次从 走到 一定是一组最优方案。反证法，交换 或 中任意两个数不会使答案更小。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 100000; int main() { static int n, m, s[MAXN + 1], t[MAXN + 1]; scanf("%d %d", &amp;n, &amp;m); long long ans = 0; for (int i = 1; i &lt;= n; i++) scanf("%d %d", &amp;s[i], &amp;t[i]), ans += abs(s[i] - t[i]); s[0] = m, t[0] = 0; std::sort(s, s + n + 1); std::sort(t, t + n + 1); for (int i = 0; i &lt;= n; i++) ans += abs(s[i] - t[i]); printf("%lld\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3376」Cube Stacking - 带权并查集]]></title>
    <url>%2Fbzoj-3376%2F</url>
    <content type="text"><![CDATA[约翰和贝茜在玩一个方块游戏。编号为 到 的 个方块正放在地上．每个构成一个立方柱。 游戏开始后，约翰会给贝茜发出 个指令。指令有两种： 移动：将包含 的立方柱移动到包含 的立方柱上； 统计：统计名含 的立方柱中，在 下方的方块数目。 写个程序帮贝茜完成游戏。 链接 BZOJ 3376 题解 带权并查集，以每堆方块最下面的方块为并查集的树根，记录每堆方块最上面的方块编号，每次合并将 块的根的父节点置为 所在堆最上面的方块。记 为从 （包含）到 的父节点（不包含）之间的方块数量。每次查询将 取一个前缀和即可。 注意路径压缩时的处理。 代码 #include &lt;cstdio&gt; const int MAXN = 300000; struct UFS { int f[MAXN + 1], d[MAXN + 1], h[MAXN + 1]; void init(int n) { for (int i = 1; i &lt;= n; i++) f[i] = i, h[i] = i; } int find(int x) { if (f[x] == x) { return x; } int y = find(f[x]); // printf("d[%d] = %d\n", x, d[x]); d[x] += d[f[x]]; f[x] = y; // h[x] = h[y]; return y; } void merge(int fa, int ch) { // printf("merge %d to %d\n", ch, fa); h[find(fa)] = h[find(ch)]; f[ch] = fa; d[ch] = 1; } } ufs; int main() { ufs.init(MAXN); int m; scanf("%d", &amp;m); while (m--) { char s[2]; scanf("%s", s); if (*s == 'M') { int x, y; scanf("%d %d", &amp;x, &amp;y); ufs.merge(ufs.h[ufs.find(y)], ufs.find(x)); } else { int x; scanf("%d", &amp;x); ufs.find(x); printf("%d\n", ufs.d[x]); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>BZOJ</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「集训队互测 2015」未来程序 · 改 - 编译原理]]></title>
    <url>%2Fuoj-98%2F</url>
    <content type="text"><![CDATA[在 2111 年，第 128 届全国青少年信息学奥林匹克冬令营前夕，Z 君找到了 2015 年，第 32 届冬令营的题目来练习。 他打开了第三题「未来程序」这道题目： 「本题是一道提交答案题，一共 10 个测试点。 对于每个测试点，你会得到一段程序的源代码和这段程序的输入。你要运行这个程序，并保存这个程序的输出。 遗憾的是这些程序都效率极其低下，无法在比赛的 5 个小时内得到输出。」 Z 君想了一下，决定用 2111 年的计算机来试着运行这个题目，但是问题来了，Z 君已经找不到 96 年前的那次比赛的测试数据了 …… 没有给出输入数据的提交答案题就不成其「提交答案题」之名，为了解决这个问题，Z 君决定将这个题目改造成传统题。 Z 君知道 96 年前的计算机的性能比现在差多了，所以这道题的测试数据中，输入数据的规模被设计成很小，从而，做这道题的选手只需要暴力模拟源代码的工作流程就可以通过它。 现在这道题摆到了你的面前。 本题是一道传统题，一共有 10 个测试点。 对于每个测试点，你的程序会得到一段程序的源代码和这段程序的输入。你的程序需要运行这段程序，并输出这段程序的输出。 链接 UOJ #98 题解 题目要求编写一个 C++（的子集）解释器，一个可行的思路是，将 C++ 代码编译为等价的 Python 代码，然后调用 exec() 执行 Python 代码；同时，Python 的字符串处理非常方便，对于这道题来说是一个不错的选择。 先说 Parser。 从顶层做起，顶层只可能是函数或者全局变量定义，并且一定以一个 int 开始。向后读，读到 (、, 或 ; 停止，如果读到了 (，表示这是一个函数定义，接下来读到 ) 停止，得到参数列表，以 , 分割并解析参数列表，然后读取并解析函数体即可；如果读到 ,，表示这是一条全局变量定义，并且定义了多个全局变量，接下来继续读到 ; 停止，可以读取出定义的所有的变量，以 , 分割并解析变量列表即可；如果读到 ;，则表示是单条变量定义，直接解析即可。 我们可以将函数体看作一个「复合语句」，接下来只需要考虑语句的解析即可。 对于一个语句的分析，首先从头开始读到空白字符停止。 如果读到了 {，则这是一个复合语句，向后读匹配的括号，读到 } 停止，即可得到整个复合语句，去除外层的花括号，继续递归处理里面的语句即可。 如果读到了 if，读匹配括号取出判断条件，对于之后的部分递归处理一个语句，如果接下来是 else，则再递归处理一个语句。 如果读到了 while 或者 for，读括号内部的内容，对于 for，可以直接用 ; 分割三个语句，之后递归处理一个语句。 如果读到了 int，则这是一个变量定义，读到 ;，以 , 分割即可。 否则，这是一个普通语句，读到 ; 停止即可。 注意到，给出的代码中没有字符串常量，所以读到某符号停止不会受到干扰。 这样，我们就得到了一棵语句级别的 AST，接下来考虑表达式语法的处理。 对于普通变量，这里的方法是，定义一个变量容器的类型，重载它的一些运算符。=、&amp;&amp;、||、! 四个运算符找不到对应优先级的可重载的 Python 运算符，前三个的解决方法是将其转化为函数调用，对于 !，可以替换为 X **，其中 X 是一个对象，我们定义 X ** a 的返回值为将 a 取反 —— 因为 ** 运算符没有被用到，并且它的优先级类似于 !。对于 cin、cout 的 &gt;&gt; 和 &lt;&lt;，可以替换它们，在两边加上括号，如 cin &gt;&gt; &lt;expr&gt; &gt;&gt; &lt;expr2&gt; 替换为 (cin) &gt;&gt; (&lt;expr&gt;) &gt;&gt; (&lt;expr2&gt;)。 数组，对于多维数组，我们可以计算其大小，并为其写一个寻址器，每一维的 [] 会返回下一维的寻址器，最后一维的 [] 返回变量的容器。这里还有一个小小的 Trick —— 对于没有访问到的数组，不实际为其分配空间，可以节省很多时间。 再接下来，我们需要生成与 AST 等价的 Python 代码。 具体的思路仍然是递归，对于一个复合语句，在需要增加一级缩进。变量的定义需要被生成为变量容器的构造。 一个问题是变量的作用域，复合语句内部的变量会遮蔽外部的变量 —— 解决方法是给每次变量定义分配一个唯一的 ID，将所有语句变量名替换为 ID + 原变量名即可。 for 语句的处理，对于一个这样的 for 语句： for (int i; i &lt; n; i = i + 1) { s = s + i; cout &lt;&lt; i &lt;&lt; endl; } 转化为： if (1) { int i; while (i &lt; n) { s = s + i; cout &lt;&lt; i &lt;&lt; endl; } i = i + 1; } 注意全局变量必须在每个函数开头声明 global VAR，如果某一个全局变量与参数重名，则不再声明这个全局变量。 题目中的递归深度很大，可以通过 sys.setrecursionlimit(1000000) 增大 Python 的递归深度限制。 代码 #!/usr/bin/python3 # 用于辅助代码执行的类与函数 class IntegerVariable: def __init__(self, x): if (isinstance(x, IntegerVariable)): self.val = x.val else: self.val = int(x) def __repr__(self): return repr(self.val) def __add__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(self.val + x.val) def __radd__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(x.val + self.val) def __sub__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(self.val - x.val) def __rsub__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(x.val - self.val) def __mul__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(self.val * x.val) def __rmul__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(x.val * self.val) def __floordiv__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(self.val // x.val) def __rfloordiv__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(x.val // self.val) def __mod__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(self.val % x.val) def __rmod__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(x.val % self.val) def __lt__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(self.val &lt; x.val) def __le__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(self.val &lt;= x.val) def __eq__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(self.val == x.val) def __ne__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(self.val != x.val) def __gt__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(self.val &gt; x.val) def __ge__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(self.val &gt;= x.val) def __xor__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(self.val ^ x.val) def __rxor__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) return IntegerVariable(x.val ^ self.val) def assign_with(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) self.val = x.val return self def logical_and(x, y): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) if (not isinstance(y, IntegerVariable)): y = IntegerVariable(y) return IntegerVariable((x.val != 0) and (y.val != 0)) def logical_or(x, y): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) if (not isinstance(y, IntegerVariable)): y = IntegerVariable(y) return IntegerVariable((x.val != 0) or (y.val != 0)) # 将逻辑非（'!'）运算符转化为乘方（'**'）运算符 class LogicalNotHelper: def __pow__(self, x): if (not isinstance(x, IntegerVariable)): x = IntegerVariable(int(x)) return IntegerVariable(int(not x.val)) logical_not = LogicalNotHelper() class ArrayAccessProxy: def __init__(self, l, length, lengths, curr_dim, curr_pos): self.l = l self.length = length self.lengths = lengths self.curr_dim = curr_dim self.curr_pos = curr_pos def __getitem__(self, x): new_length = self.length // self.lengths[self.curr_dim] new_pos = self.curr_pos + x * new_length if self.curr_dim + 1 == len(self.lengths): return self.l[new_pos] else: return ArrayAccessProxy(self.l, new_length, self.lengths, self.curr_dim + 1, new_pos) def __setitem__(self, x, val): new_length = self.length // self.lengths[self.curr_dim] new_pos = self.curr_pos + x * new_length if self.curr_dim + 1 == len(self.lengths): self.l[new_pos] = IntegerVariable(val) else: raise TypeError('Assign to a Array') class Array: def __init__(self, lengths): self.lengths = lengths self.length = 1 for i in lengths: self.length *= i self.l = None def __repr__(self): return repr(self.l) def construct(self): if not self.l: self.l = [IntegerVariable(0) for i in range(0, self.length)] def __getitem__(self, x): if not self.l: self.construct() if isinstance(x, IntegerVariable): x = x.val if len(self.lengths) == 1: return self.l[x] else: new_length = self.length // self.lengths[0] new_pos = x * new_length return ArrayAccessProxy(self.l, new_length, self.lengths, 1, new_pos) def __setitem__(self, x, val): if not self.l: self.construct() if (not isinstance(x, IntegerVariable)): x = IntegerVariable(x) if len(self.lengths) == 1: self.l[x.val] = val else: raise TypeError('Assign to a Array') class OutputStream: def __lshift__(self, x): if isinstance(x, EndLine): print('\n', end = '') elif isinstance(x, IntegerVariable): print(x.val, end = '') else: print(x, end = '') return self class InputStream: def __init__(self): self.index = 0 def __rshift__(self, x): x.val = self.data[self.index] self.index += 1 return self class EndLine: def __init__(self): pass cout = OutputStream() cin = InputStream() endl = EndLine() def variable(array_lengths): if array_lengths == None or len(array_lengths) == 0: return IntegerVariable(0) else: return Array(array_lengths) def get_value(x): if not isinstance(x, IntegerVariable): return x else: return x.val def init_arg(x): if isinstance(x, IntegerVariable): return IntegerVariable(x.val) else: return IntegerVariable(int(x)) def putchar(ch): print(chr(get_value(ch)), end = '') # 读取输入数据，初始化 cin 输入流 def init_input_stream(): def read_integers(): return list(map(int, str(input()).split(' '))) a = read_integers() data = [] n = a.pop(0) for i in range(0, n): if len(a) == 0: a = read_integers() data.append(a.pop(0)) cin.data = data # 从字符串最右边向左取出尽量多的字符，直到下一个字符会导致括号不能匹配或【下一个字符为逗号（','）且当前的括号是匹配的】 def left_until_nearest_unmatched_bracket_or_comma(s): right_bracket_count = 0 res = '' while len(s) &gt; 0: ch = s[-1:] if ch == ',': if right_bracket_count == 0: break elif ch in ')]}': right_bracket_count += 1 elif ch in '([{': right_bracket_count -= 1 if right_bracket_count &lt; 0: break res = ch + res s = s[:-1] return s, res # 从字符串最左边向右取出尽量多的字符，直到下一个字符会导致括号不能匹配或【下一个字符为逗号（','）且当前的括号是匹配的】 def right_until_nearest_unmatched_bracket_or_comma(s): left_bracket_count = 0 res = '' while len(s) &gt; 0: ch = s[:1] if ch == ',': if left_bracket_count == 0: break elif ch in '([{': left_bracket_count += 1 elif ch in ')]}': left_bracket_count -= 1 if left_bracket_count &lt; 0: break res += ch s = s[1:] return s, res # 转化赋值运算符为函数调用 def transform_expression_assignment(s): s = s.strip() pos = s.find('=') # 找到的等号是不等于（!=）、等于（==）、大于等于（&gt;=）、小于等于（&lt;=）运算符的一部分 while pos != -1 and (s[pos + 1] == '=' or s[pos - 1] in '!&gt;&lt;'): pos = s.find('=', pos + 2) # 找不到赋值运算符 if pos == -1: return s left = s[:pos].strip() left, left_exp = left_until_nearest_unmatched_bracket_or_comma(left) right = s[pos + 1:].strip() right, right_exp = right_until_nearest_unmatched_bracket_or_comma(right) return '%s((%s).assign_with(%s))%s' % (left, left_exp, transform_expression_assignment(right_exp), transform_expression_assignment(right)) # 转化逻辑运算符为函数调用 def transform_expression_logical_operators(s, op, function_name): s = s.strip() pos = s.find(op) # 找不到对应的运算符 if pos == -1: return s left = s[:pos].strip() left, left_exp = left_until_nearest_unmatched_bracket_or_comma(left) right = s[pos + 2:].strip() right, right_exp = right_until_nearest_unmatched_bracket_or_comma(right) # print('transform_expression_logical_operators(%s): left = "%s", right = "%s"' % (op, left, right)) return '%s(%s(%s, %s))%s' % (left, function_name, left_exp, transform_expression_logical_operators(right_exp, op, function_name), transform_expression_logical_operators(right, op, function_name)) # 转化运算符 def transform_expression_operators(s): # 将 '!exp' 替换为 'logical_not ** exp' s = s.replace('!=', ' ) s = s.replace('!', 'logical_not ** ') s = s.replace(' , '!=') # 将 '/' 替换为 '//' # 保证之前替换过的不会再次替换 s = s.replace('//', '/') s = s.replace('/', '//') return s # 对表达式进行转化 def transform_expression(s): def transform(s): s = transform_expression_operators(s) s = transform_expression_logical_operators(s, '||', 'logical_or') s = transform_expression_logical_operators(s, '&amp;&amp;', 'logical_and') s = transform_expression_assignment(s) return s last_l = len(s) last_r = 0 while True: # 从右向左找更靠右的圆括号（'('）或方括号（'['） l_round = s.rfind('(', 0, last_l) l_box = s.rfind('[', 0, last_l) if l_round == -1 and l_box == -1: break # 优先处理更靠右的 right_bracket = ')' if l_round &gt; l_box else ']' l = l_round if l_round &gt; l_box else l_box left = s[:l + 1] right, mid = right_until_nearest_unmatched_bracket_or_comma(s[l + 1:]) # r = s.find(right_bracket, l + 1) # print('transform_expression(): Find expression %s' % s[l + 1:r]) # s = s[:l + 1] + transform(s[l + 1:r]) + s[r:] s = left + transform(mid) + right last_l = l return transform(s) # 跳过开头的 3 行 def skip_header(): for i in range(0, 3): input() # 读代码，即从当前标准输入读到文件结束 def read_code(): code = '' while True: try: code += input() + '\n' except EOFError: break return code # 判断一个字符（串）是否为空字符 def is_empty(str): return not str.strip() # 增加一级缩进（4 个空格） def indent(code): return '\n'.join(list(map(lambda s: ' ' + s, code.split('\n')))) # 文本处理器 class Tokenizer: def __init__(self, s): self.s = s self.pos = 0 # 读取下一个字符，但不改变当前位置 def peek(self): if self.pos == len(self.s): raise IndexError('peek() reached end of string') return self.s[self.pos] # 读取下一个字符，并将当前位置向后移动一个字符 def next(self): if self.pos == len(self.s): raise IndexError('next() reached end of string') ch = self.s[self.pos] self.pos += 1 return ch # 将当前位置向前移动一个字符 def back(self): if self.pos == 0: raise IndexError('back() reached begin of string') self.pos -= 1 # 向后读取，直到读到空白字符 def next_until_empty(self): s = '' while is_empty(self.peek()): self.next() while self.pos &lt; len(self.s) and (not is_empty(self.peek())): s += self.next() return s # 向后读取，直到读到空白字符，不改变当前位置 def peek_until_empty(self): pos_bak = self.pos res = self.next_until_empty() self.pos = pos_bak return res # 向后读取，直到读到 `strings` 中的任何一个字符串停止，不改变当前位置 # 返回一个二元组，读到的字符串（不包含结束字符串）和结束字符串 def peek_until(self, strings): pos_bak = self.pos res = self.next_until(strings) self.pos = pos_bak return res # 向后读取，直到读到 `strings` 中的任何一个字符串停止 # 返回一个二元组，读到的字符串（不包含结束字符串）和结束字符串 def next_until(self, strings): s = '' while is_empty(self.peek()): self.next() while True: for i in strings: if s.endswith(i): return s[:len(s) - len(i)], i s += self.next() # 向后读取一个括号匹配的块 # 这里并没有保证对应匹配（即比如 ] 可以匹配 (），因为题目保证源代码合法 def next_brackets_block(self): left_count = 0 s = '' while True: ch = self.next() s += ch if ch in '([{': left_count += 1 elif ch in '}])': left_count -= 1 if left_count == 0: return s.strip() # 替换整个 Token def replace_token(s, to_replace, replace_with): def is_part_of_token(ch): if ord(ch) &gt;= ord('A') and ord(ch) &lt;= ord('Z'): return True if ord(ch) &gt;= ord('a') and ord(ch) &lt;= ord('z'): return True if ord(ch) &gt;= ord('0') and ord(ch) &lt;= ord('9'): return True if ch == '_': return True return False last_l = len(s) while True: l = s.rfind(to_replace, 0, last_l) if l == -1: break last_l = l r = l + len(to_replace) - 1 if (l - 1 &gt;= 0 and is_part_of_token(s[l - 1])) or (r + 1 &lt; len(s) and is_part_of_token(s[r + 1])): continue s_l = s[:l] s_r = s[r + 1:] s = s_l + replace_with + s_r return s # 应用变量名映射 def apply_var_map(expression, var_map): for x in var_map: expression = replace_token(expression, x, var_map[x]) return expression # 生成表达式 def generate_expression(expression, var_map): return transform_expression(apply_var_map(expression, var_map)) # 一些语句相关的结构体 global_variables = [] # 变量或数组变量 class VariableDeclaration: def __init__(self, name, array_lengths): self.name = name self.array_lengths = array_lengths def __repr__(self): return '&lt;VariableDeclaration name=%s array_lengths=%s&gt;' % (repr(self.name), repr(self.array_lengths)) def generate(self, var_map): # 如果 var_map 为 None，则表示这是一条全局变量定义 name = self.name if var_map == None else var_map[self.name] if self.array_lengths == None: # 非数组变量 return '%s = variable(None)' % name else: # 数组变量 array_lengths = ', '.join(list(map(lambda x: str(x), self.array_lengths))) return '%s = variable([%s])' % (name, array_lengths) # 表达式语句 class ExpressionStatement: def __init__(self, expression): self.expression = expression def __repr__(self): return '&lt;ExpressionStatement expression=%s&gt;' % repr(self.expression) def generate(self, var_map): expression = generate_expression(self.expression, var_map) if expression.find('&lt;&lt;') != -1: expression = '(%s)' % expression.replace('&lt;&lt;', ') &lt;&lt; (') elif expression.find('&gt;&gt;') != -1: expression = '(%s)' % expression.replace('&gt;&gt;', ') &gt;&gt; (') return expression def get_var_map(self): return {} # 返回语句 # 将可能返回的常数值转换为 IntegerVariable class ReturnStatement: def __init__(self, return_value): self.return_value = return_value def __repr__(self): return '&lt;ReturnStatement return_value=%s&gt;' % repr(self.return_value) def generate(self, var_map): if self.return_value == '': return 'return' else: return 'return IntegerVariable(%s)' % generate_expression(self.return_value, var_map) def get_var_map(self): return {} # if 语句 # condition 为 'if ()' 括号里面的表达式 # statement_true 为 'if ()' 后跟的语句 # statement_false 为 'else' 后跟的语句（如果没有 'else'，则为 None） class IfStatement: def __init__(self, condition, statement_true, statement_false): self.condition = condition self.statement_true = statement_true self.statement_false = statement_false def __repr__(self): return '&lt;IfStatement condition=%s statement_true=%s statement_false=%s&gt;' % (repr(self.condition), repr(self.statement_true), repr(self.statement_false)) def generate(self, var_map): condition = generate_expression(self.condition, var_map) statement_true = indent(self.statement_true.generate(var_map)) if self.statement_false: statement_false = indent(self.statement_false.generate(var_map)) return 'if get_value(%s):\n%s\nelse:\n%s' % (condition, statement_true, statement_false) else: return 'if get_value(%s):\n%s' % (condition, statement_true) def get_var_map(self): return {} # while 语句 # condition 为 'while ()' 括号里面的表达式 # statement 为 'while ()' 后跟的语句 class WhileStatement: def __init__(self, condition, statement): self.condition = condition self.statement = statement def __repr__(self): return '&lt;WhileStatement condition=%s statement=%s&gt;' % (repr(self.condition), repr(self.statement)) def generate(self, var_map): condition = generate_expression(self.condition, var_map) statement = indent(self.statement.generate(var_map)) return 'while get_value(%s):\n%s' % (condition, statement) def get_var_map(self): return {} # for 语句 # control_statements 为 'for ()' 括号里面的三个语句，表示为一个列表 # statement 为 'for ()' 后跟的语句 class ForStatement: def __init__(self, control_statements, statement): assert len(control_statements) == 3 self.control_statements = control_statements self.statement = statement def __repr__(self): return '&lt;ForStatement control_statements=%s statement=%s&gt;' % (repr(self.control_statements), repr(self.statement)) def generate(self, var_map): while_condition = self.control_statements[1].expression if self.control_statements[1] else '1' while_inner_statements = [self.statement] + ([self.control_statements[2]] if self.control_statements[2] else []) while_statement = WhileStatement(while_condition, CompoundStatement(while_inner_statements)) if_wrapper = IfStatement('1', CompoundStatement([self.control_statements[0], while_statement]), None) return if_wrapper.generate(var_map) def get_var_map(self): return {} # 复合语句 class CompoundStatement: def __init__(self, statements): self.statements = statements def __repr__(self): return '&lt;CompoundStatement statements=%s&gt;' % repr(self.statements) def generate(self, var_map): res = '' curr_var_map = dict(var_map) for statement in self.statements: curr_var_map = dict(curr_var_map, **statement.get_var_map()) res += statement.generate(curr_var_map) + '\n' return res def get_var_map(self): return {} # 变量定义 variables_declaration_id = 0 class VariablesDeclaration: def __init__(self, var_list): global variables_declaration_id variables_declaration_id += 1 self.var_list = var_list self.id = variables_declaration_id def __repr__(self): return '&lt;VariablesDeclaration var_list=%s&gt;' % repr(self.var_list) def generate(self, var_map = None): # 如果 var_map 为 None，则表示这是一条全局变量定义 return '\n'.join(list(map(lambda var: var.generate(var_map), self.var_list))) def get_var_map(self): return {variable.name: '__local_var_%d_%s' % (self.id, variable.name) for variable in self.var_list} # 函数 class Function: def __init__(self, name, arg_list, body): self.name = name self.arg_list = arg_list self.body = body def __repr__(self): return '&lt;Function name=%s arg_list=%s body=%s&gt;' % (repr(self.name), repr(self.arg_list), repr(self.body)) def generate(self): args = ', '.join(self.arg_list) init_args = '\n'.join(['%s = init_arg(%s)' % (arg, arg) for arg in self.arg_list]) + '\n' declare_global_variables = '\n'.join(['global %s' % variable for variable in global_variables if variable not in self.arg_list]) + '\n' body = indent(init_args + declare_global_variables + self.body.generate({}) + '\nreturn 0\n') return 'def %s(%s):\n%s' % (self.name, args, body) # 解释器 class Parser: def __init__(self, code): self.tokenizer = Tokenizer(code) self.pos = 0 # 解析参数列表 def parse_arg_list(self, s): if (not s.strip()): return [] # 解析参数，去掉参数类型 int def parse_arg(s): s = s.strip() return s[s.find(' '):].strip() return list(map(parse_arg, s.split(','))) # 解析变量列表 def parse_var_list(self, s): if (not s.strip()): return [] # 解析数组变量 def parse_var(s): s = s.strip() try: tokenizer = Tokenizer(s) name, ends_with = tokenizer.next_until(['[']) lengths = [] try: tokenizer.back() while True: # print(tokenizer.s[tokenizer.pos:]) length = tokenizer.next_brackets_block().strip() length = int(length[1:-1].strip()) lengths.append(length) except IndexError: pass return VariableDeclaration(name, lengths) except IndexError: return VariableDeclaration(s, None) return list(map(parse_var, s.split(','))) # 解析一个普通语句（或声明） def parse_normal_statement(self, statement): if statement.startswith('int '): # 变量定义 var_list = self.parse_var_list(statement[4:]) # print('Variable Declaration: %s' % var_list) return VariablesDeclaration(var_list) elif statement.startswith('return '): # 单独处理 return 语句，原因见 ReturnStatement 的定义 return ReturnStatement(statement[7:].strip()) else: # 表达式语句 # print('Normal Statement: "%s"' % statement) return ExpressionStatement(statement) # 解析下一个语句 def next_statement(self, tokenizer): t = tokenizer.peek_until_empty() # 判断流程控制语句 if t == 'if': # 读取圆括号中的内容（condition） tokenizer.next_until(['(']) tokenizer.back() condition = tokenizer.next_brackets_block()[1:-1] # 读取 'if ()' 后跟的语句 statement_true = self.next_statement(tokenizer) # 读取 'else' 及其后跟的语句 statement_false = None try: if tokenizer.peek_until_empty() == 'else': tokenizer.next_until_empty() statement_false = self.next_statement(tokenizer) except IndexError: pass # print('If Statement: condition = "%s", statement_true = "%s", statement_false = "%s"' % (condition, statement_true, statement_false)) return IfStatement(condition, statement_true, statement_false) elif t == 'while': # 读取圆括号中的内容（condition） tokenizer.next_until(['(']) tokenizer.back() condition = tokenizer.next_brackets_block()[1:-1] # 读取 'while ()' 后跟的语句 statement = self.next_statement(tokenizer) # print('While Statement: condition = "%s", statement = "%s"' % (condition, statement)) return WhileStatement(condition, statement) elif t == 'for': # 读取圆括号中的内容（control_statements） tokenizer.next_until(['(']) tokenizer.back() in_bracket = tokenizer.next_brackets_block()[1:-1] control_statements = list(map(lambda s: self.parse_normal_statement(s.strip()), in_bracket.split(';'))) # 读取 'for ()' 后跟的语句 statement = self.next_statement(tokenizer) # print('For Statement: control_statements = "%s", statement = "%s"' % (control_statements, statement)) return ForStatement(control_statements, statement) # 判断复合语句 elif t.startswith('{'): tokenizer.next_until_empty() for i in range(0, len(t)): tokenizer.back() s = tokenizer.next_brackets_block() statement = self.parse_compound(s) # print('Compound Statement: "%s", [parsed] = "%s"' % (s, statement)) return statement else: # 表达式语句（或声明） # 直接读到分号 ';' 即为一条语句 statement, ends_with = tokenizer.next_until([';']) return self.parse_normal_statement(statement) # 解析一个复合语句 def parse_compound(self, content): # 去除最外侧花括号 content = content.strip() content = content[1:-1].strip() # 编译每一条语句（或声明） tokenizer = Tokenizer(content) statements = [] try: while True: statements.append(self.next_statement(tokenizer)) except IndexError: pass return CompoundStatement(statements) # 解析顶层（全局变量与全局函数） def parse_top_level(self): global global_variables l = [] try: while True: # 顶层可包含变量定义与函数定义 # 变量定义与函数定义的开头均为类型名 t = self.tokenizer.next_until_empty() # 读取函数或变量名 name, ends_with = self.tokenizer.peek_until(['(', ',', ';']) if ends_with == '(': # 以 '(' 结束了一个函数名 self.tokenizer.next_until(['(', ',', ';']) # 读到 ')'，获取参数列表 arg_list, ends_with = self.tokenizer.next_until([')']) arg_list = self.parse_arg_list(arg_list) body = self.tokenizer.next_brackets_block() body = self.parse_compound(body) l.append(Function(name, arg_list, body)) else: # 变量定义 statement, ends_with = self.tokenizer.next_until([';']) var_list = self.parse_var_list(statement) global_variables += [variable.name for variable in var_list] l.append(VariablesDeclaration(var_list)) except IndexError: pass return l def parse(self): ast = self.parse_top_level() return ast # 生成 Python 代码 def generate_pycode(ast): pycode = '' for node in ast: pycode += node.generate() + '\n' return pycode import sys # sys.stdin = open('program10.in', 'r') sys.setrecursionlimit(1000000) # 读入 init_input_stream() skip_header() code = read_code() # 编译 parser = Parser(code) ast = parser.parse() # print(ast) # 生成代码 pycode = generate_pycode(ast) # print('\n\n\n\n\n') # print(pycode) try: exec(pycode) main() except Exception as e: # print(e) raise e # print(transform_expression('putchar(c = a * b[7], 233, k * 5 + 0)'))]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>Python</tag>
        <tag>编译原理</tag>
        <tag>集训队互测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上下界网络流学习笔记]]></title>
    <url>%2Fnetwork-flow-with-bounds%2F</url>
    <content type="text"><![CDATA[在普通的网络流问题中，给定单一的源点与汇点，每条边有流量上界（容量），在其它所有点满足流量平衡条件，且流出 的流量等于流入 的流量的前提下，求 到 的最大流。而有一类网络流问题，每条边不仅有流量上界，还有流量下界，这类问题需要转化求解。 无源汇可行流 给定 个点、 条边，每条边 从 指向 ，它的的流量必须在 内，没有源点与汇点，要求所有点满足流量平衡条件，判断是否有解，并求一组可行解。 初步转化 为了转化问题，我们添加一个超级源点 和超级汇点 。 考虑一条边 ，它的流量至少要为 ，即无论如何， 至少要流出 的流量，而 至少要流入 —— 为了满足这个下界，我们从超级源点 向 连一条容量为 的边，从 向超级汇点 连一条容量为 的边。现在这条边的下界已经满足，而又因为它的上界为 ，所以它有 的流量是「可流可不流」的，这部分流量被称为自由流。即，从 向 连一条容量为 的边。 总结一下，对于一条边 ，转化为以下三类边： 从超级源点 到 ，容量为 ，为了使 一定有 的流量流入； 从 到超级汇点 ，容量为 ，为了使 一定有 的流量流出； 从 到 ，容量为 。 求出转化后的图中 到 的最大流，如果从 出发的边全部满流，则说明所有边的下界均已满足，即原问题有解。所有转化后的容量为原边自由流的边（上述第三类边）的流量加上其各自的流量下界即为一组解。 第二步转化 考虑到转化后的图中，可能会有这种情况 对于某个点 ，在转化的过程中，有一条边（或多条边的和）由 连向 ，容量为 ；另一条边（或多条边的和）由 连向 ，容量为 。 假设 ，我们可以用一条由 连向 的容量为 的边代替，因为从 到 的最大流显然至少要流 的流量。 同理，如果 ，我们可以用一条由 连向 的容量为 的边代替。 所有，对于 到 或者 到 的多条重复的边，可以合并成一条。合并方法是，维护每个点需要额外流入的流量 —— 对于原图中的每条边 ，对 增加 ，对 减少 。 对于每一个点 ，如果 ，说明 需要额外流入一些流量，才能满足与其相关的边的下界，即连一条由 到 的容量为 的边；否则，说明 需要额外流出一些流量，即连一条由 到 的容量为 的边。 这样便完成了无源汇可行流的转化。 struct Node { struct Edge *firstEdge, *currEdge; int level, extraIn; } N[MAXN + 2]; struct Edge { Node *from, *to; int cap, flow, lower; Edge *next, *revEdge; Edge(Node *from, Node *to, int cap) : from(from), to(to), cap(cap), flow(0), lower(0), next(from-&gt;firstEdge) {} }; inline Edge *addEdge(int from, int to, int lower, int upper) { int cap = upper - lower; Edge *e = addEdge(from, to, cap); e-&gt;lower = lower; N[to].extraIn += lower; N[from].extraIn -= lower; return e; } inline bool solve(int n) { int S = 0, T = n + 1; int sum = 0; for (int i = 1; i &lt;= n; i++) { if (N[i].extraIn &gt; 0) { addEdge(S, i, 0, N[i].extraIn); sum += N[i].extraIn; // 记录由 S 出发的边的容量总和 } else if (N[i].extraIn &lt; 0) { addEdge(i, T, 0, -N[i].extraIn); } } int flow = dinic(S, T, n + 2); if (flow &lt; sum) return false; // 如果从 S 出发的边没有全部满流 return true; } 注意，求无源汇可行流时， 到 的最大流的意义是，超级源点 向所有需要补充流量的节点实际补充的流量的总和，而没有其它意义。 有源汇可行流 给定 个点、 条边，每条边 从 指向 ，它的的流量必须在 内，给定源点 与汇点 ，要求除源汇点外所有点满足流量平衡条件，流出源点的流量等于流入汇点的流量，判断是否有解，并求一组可行解。 有源汇可行流可以看做无源汇可行流中加入两个特殊点 与 ，且流出 的流量比如等于流入 的流量 —— 我们增加一条从 到 的容量为 的边，使 与 也满足流量平衡条件，即可转化为无源汇可行流。 inline bool flow(int s, int t, int n) { int S = 0, T = n + 1; // 加一条 t 到 s 的容量为正无穷的边 addEdge(t, s, INT_MAX); int sum = 0; for (int i = 1; i &lt;= n; i++) { if (N[i].extraIn &gt; 0) { addEdge(S, i, N[i].extraIn); sum += N[i].extraIn; } else if (N[i].extraIn &lt; 0) { addEdge(i, T, -N[i].extraIn); } } return dinic(S, T, n + 2) == sum; } 有源汇最大流 给定 个点、 条边，每条边 从 指向 ，它的的流量必须在 内，给定源点 与汇点 ，要求除源汇点外所有点满足流量平衡条件，流出源点的流量等于流入汇点的流量，判断是否有解，并求出 到 的最大流。 首先，使用有源汇可行流算法，判断是否有解。如果有解，残量网络的状态即为一组可行解。此时所有原图中边的下界均已满足，而这些下界的满足是由与超级源汇点 与 相连的边实现的。考虑直接从 向 增广 —— 因为 没有入边，并且 没有出边，所以 到 的增广路不可能经过 或 。并且 到 的边也不会影响增广。即，直接从 向 增广不会破坏已经满足的下界，且答案一定合法。 在求出可行流之后，直接在残量网络上求 到 的最大流即可。 inline int flow(int s, int t, int n) { addEdge(t, s, INT_MAX); int S = 0, T = n + 1; int sum = 0; for (int i = 1; i &lt;= n; i++) { if (N[i].extraIn &gt; 0) { addEdge(S, i, N[i].extraIn); sum += N[i].extraIn; } else if (N[i].extraIn &lt; 0) { addEdge(i, T, -N[i].extraIn); } } // 求可行流，满足下界 int flow = dinic(S, T, n + 2); if (flow &lt; sum) return -1; // 直接增广得到最大流 return dinic(s, t, n + 2); } 有源汇最小流 给定 个点、 条边，每条边 从 指向 ，它的的流量必须在 内，给定源点 与汇点 ，要求除源汇点外所有点满足流量平衡条件，流出源点的流量等于流入汇点的流量，判断是否有解，并求出 到 的最小流。 类似最大流，首先也要求出可行流，并且得到 到 的流量，即求可行流时连接的从 到 的边的流量。 我们的最优化目标是使 到 的流量最小，即希望从可行流中尽量减去一些从 到 的流量，为了求出在满足流量平衡的情况下能减少的流量，我们从 向 增广，此时得到的 到 的最大流即为 到 的流量中能减去的最大的流量。 在求解可行流时，多加入的 到 的边会使 到 的最大流总是正无穷，我们必须删掉这条边，才能保证从 到 增广时只经过原图中的边。 inline int flow(int s, int t, int n) { Edge *e = addEdge(t, s, INT_MAX); int S = 0, T = n + 1; int sum = 0; for (int i = 1; i &lt;= n; i++) { if (N[i].extraIn &gt; 0) { addEdge(S, i, N[i].extraIn); sum += N[i].extraIn; } else if (N[i].extraIn &lt; 0) { addEdge(i, T, -N[i].extraIn); } } // 求可行流，满足下界 int flow = dinic(S, T, n + 2); if (flow &lt; sum) return -1; int realFlow = e-&gt;flow; e-&gt;cap = e-&gt;revEdge-&gt;cap = 0; // 将容量置为零，相当于将边删除 // 减去能退掉的流量 return realFlow - dinic(t, s, n + 2); } 总结 无源汇可行流是上下界网络流的基础，其它几种模型都需要转化为这种模型来求解。 求解有源汇上下界网络流时，常用 表示原图中的点， 表示超级源点 ， 表示超级汇点 。如果原图中有 号点，则通常将所有点编号 。最终网络流建图的点编号仍是从 开始。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 TeX 书写伪代码]]></title>
    <url>%2Fwrite-fake-code-with-tex%2F</url>
    <content type="text"><![CDATA[举个栗子，矩阵乘法 + 快速幂（不要问我为什么是这个 ……） TeX 代码： \renewcommand{\tab}[1]{\hskip{#1 em}\hskip{#1 em}} \renewcommand{\func}{\text} \renewcommand{\if}{\textbf{If} ~~} \renewcommand{\then}{\textbf{Then} ~~} \renewcommand{\for}{\textbf{For} ~~} \renewcommand{\while}{\textbf{While} ~~} \renewcommand{\return}{\textbf{Return} ~~} \renewcommand{\assert}{\textbf{Assert} ~~} \renewcommand{\to}{~~ \textbf{To} ~~} \renewcommand{\not}{\textbf{Not} ~} \renewcommand{\and}{~ \textbf{And} ~} \renewcommand{\or}{~ \textbf{Or} ~} \renewcommand{\bnot}{\textbf{Bitwise-Not} ~} \renewcommand{\band}{~ \textbf{Bitwise-And} ~} \renewcommand{\bor}{~ \textbf{Bitwise-Or} ~} \renewcommand{\xor}{~ \textbf{Bitwise-Xor} ~} \renewcommand{\shr}{~ \textbf{Right-Shift} ~} \renewcommand{\shl}{~ \textbf{Left-Shift} ~} \renewcommand{\type}[1]{\textbf {#1} ~} \begin{aligned} &amp; \tab{0} \func{Matrix-Multiple}(\type{Matrix} A, \type{Matrix} B) \\ &amp; \tab{1} \assert \func{column}(A) = \func{row}(B) \\ &amp; \tab{1} C \leftarrow \type{Zero-Matrix}(\func{row}(A), \func{column}(B)) \\ &amp; \tab{1} \for i \leftarrow 1 \to \func{row}(A) \\ &amp; \tab{2} \for j \leftarrow 1 \to \func{column}(B) \\ &amp; \tab{3} \for k \leftarrow 1 \to \func{column}(A) \\ &amp; \tab{4} C(i, j) \leftarrow C(i, j) + A(i, k) \times B(k, j) \\ &amp; \tab{1} \return C \\ \\ &amp; \tab{0} \func{Matrix-Power}(\type{Matrix} M, \type{Integer} n) \\ &amp; \tab{1} \assert \func{row}(M) = \func{column}(M) \\ &amp; \tab{1} C \leftarrow \type{Unit-Matrix}(\func{row}(M), \func{column}(M)) \\ &amp; \tab{1} \while n \neq 0 \\ &amp; \tab{2} \if n \band 1 = 1 \\ &amp; \tab{3} C \leftarrow \func{Matrix-Multiple}(C, M) \\ &amp; \tab{2} M \leftarrow \func{Matrix-Multiple}(M, M) \\ &amp; \tab{2} n \leftarrow n \shr 1 \\ &amp; \tab{1} \return C \end{aligned}]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>TeX</tag>
        <tag>伪代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2009」HH 的项链 - 莫队]]></title>
    <url>%2Fsdoi2009-diff%2F</url>
    <content type="text"><![CDATA[给一个长度为 的序列，每次查询一个区间中不同的数的个数。 链接 BZOJ 1878 题解 莫队模板题。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; const int MAXN = 50000; const int MAXM = 200000; const int MAXX = 1000000; int n, m, blockSize, a[MAXN + 1], cnt[MAXX + 1]; struct Query { int l, r, *ans; // 以左端点所在块为第一关键字，右端点为第二关键字 bool operator&lt;(const Query &amp;other) const { if (l / blockSize == other.l / blockSize) return r &lt; other.r; else return l / blockSize &lt; other.l / blockSize; } } Q[MAXM + 1]; // extend - 莫队扩展的通用写法 // 对于 [l, r] 这段区间，要把左端点（left = true）还是 // 右端点（left = false）加入（d = 1）答案或从答案中删去（d = -1） inline int extend(int l, int r, bool left, int d) { if (left) { if (d == 1) { if (++cnt[a[l]] == 1) return 1; else return 0; } else { if (--cnt[a[l]] == 0) return -1; else return 0; } } else { if (d == 1) { if (++cnt[a[r]] == 1) return 1; else return 0; } else { if (--cnt[a[r]] == 0) return -1; else return 0; } } } // 莫队主过程 inline void solve() { // 因为先扩展右端点，所以第一次一定是 r 变为 1，变成一个合法区间的答案 int l = 1, r = 0, ans = 0; // ans 表示当前 [l, r] 区间的答案 for (int i = 1; i &lt;= m; i++) { const Query &amp;q = Q[i]; // 扩展右端点 while (r &lt; q.r) ans += extend(l, ++r, false, 1); while (r &gt; q.r) ans += extend(l, r--, false, -1); // 扩展左端点 while (l &gt; q.l) ans += extend(--l, r, true, 1); while (l &lt; q.l) ans += extend(l++, r, true, -1); // 记录答案 // 将 ans 写入到 q.ans 指向的变量中 *q.ans = ans; } } int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); // 求块大小 sqrt(n) blockSize = ceil(sqrt(n)); scanf("%d", &amp;m); // 记录答案的数组 // 因为询问被排序，而要根据原顺序输出 static int ans[MAXM + 1]; for (int i = 1; i &lt;= m; i++) { scanf("%d %d", &amp;Q[i].l, &amp;Q[i].r); Q[i].ans = &amp;ans[i]; // 无论怎么排序，第 i 个询问的答案要存到 ans[i] 里 } std::sort(Q + 1, Q + m + 1); solve(); for (int i = 1; i &lt;= m; i++) printf("%d\n", ans[i]); } 精简版： #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; const int MAXN = 50000; const int MAXM = 200000; const int MAXX = 1000000; int n, m, blockSize, a[MAXN + 1], cnt[MAXX + 1]; struct Query { int l, r, *ans; // 以左端点所在块为第一关键字，右端点为第二关键字 bool operator&lt;(const Query &amp;other) const { if (l / blockSize == other.l / blockSize) return r &lt; other.r; else return l / blockSize &lt; other.l / blockSize; } } Q[MAXM + 1]; // extend - 本题莫队扩展的精简写法 // 把 x 这个数加入答案（d = 1）或从答案中删去（d = -1） inline int extend(int x, int d) { if (d == 1) { return ++cnt[x] == 1 ? 1 : 0; // 如果加入一个 x 后，x 的出现次数为 1，说明 x 首次出现，答案 +1 } else { return --cnt[x] == 0 ? -1 : 0; // 如果删去一个 x 后，x 的出现次数为 0，说明原有的 x 全部被删除，答案 -1 } } // 莫队主过程 inline void solve() { // 因为先扩展右端点，所以第一次一定是 r 变为 1，变成一个合法区间的答案 int l = 1, r = 0, ans = 0; // ans 表示当前 [l, r] 区间的答案 for (int i = 1; i &lt;= m; i++) { const Query &amp;q = Q[i]; // 扩展右端点 while (r &lt; q.r) ans += extend(a[++r], 1); while (r &gt; q.r) ans += extend(a[r--], -1); // 扩展左端点 while (l &gt; q.l) ans += extend(a[--l], 1); while (l &lt; q.l) ans += extend(a[l++], -1); // 记录答案 // 将 ans 写入到 q.ans 指向的变量中 *q.ans = ans; } } int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); // 求块大小 sqrt(n) blockSize = ceil(sqrt(n)); scanf("%d", &amp;m); // 记录答案的数组 // 因为询问被排序，而要根据原顺序输出 static int ans[MAXM + 1]; for (int i = 1; i &lt;= m; i++) { scanf("%d %d", &amp;Q[i].l, &amp;Q[i].r); Q[i].ans = &amp;ans[i]; // 无论怎么排序，第 i 个询问的答案要存到 ans[i] 里 } std::sort(Q + 1, Q + m + 1); solve(); for (int i = 1; i &lt;= m; i++) printf("%d\n", ans[i]); }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>BZOJ</tag>
        <tag>莫队</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「WC2013」糖果公园 - 树链剖分 + 莫队]]></title>
    <url>%2Fwc2013-candy%2F</url>
    <content type="text"><![CDATA[Candyland 有一座糖果公园，公园里不仅有美丽的风景、好玩的游乐项目，还有许多免费糖果的发放点，这引来了许多贪吃的小朋友来糖果公园玩。 糖果公园的结构十分奇特，它由 个游览点构成，每个游览点都有一个糖果发放处，我们可以依次将游览点编号为 至 。有 条双向道路连接着这些游览点，并且整个糖果公园都是连通的，即从任何一个游览点出发都可以通过这些道路到达公园里的所有其它游览点。 糖果公园所发放的糖果种类非常丰富，总共 种，它们的编号依次为 至 。每一个糖果发放处都只发放某种特定的糖果，我们用 来表示 号游览点的糖果。 来到公园里游玩的游客都不喜欢走回头路，他们总是从某个特定的游览点出发前往另一个特定的游览点，并游览途中的景点，这条路线一定是唯一的。他们经过每个游览点，都可以品尝到一颗对应种类的糖果。 大家对不同类型的糖果的喜爱程度都不尽相同。根据游客们的反馈打分，我们得到了糖果的美味指数，第 种糖果的美味指数为 。另外，如果一位游客反复地品尝同一种类的糖果，他肯定会觉得有一些腻。根据量化统计，我们得到了游客第 次品尝某类糖果的新奇指数 ，如果一位游客第 次品尝第 种糖果，那么他的愉悦指数 将会增加对应的美味指数与新奇指数的乘积，即 。这位游客游览公园的愉悦指数最终将是这些乘积的和。 当然，公园中每个糖果发放点所发放的糖果种类不一定是一成不变的。有时，一些糖果点所发放的糖果种类可能会更改（也只会是 种中的一种），这样的目的是能够让游客们总是感受到惊喜。糖果公园的工作人员小 A 接到了一个任务，那就是根据公园最近的数据统计出每位游客游玩公园的愉悦指数。但数学不好的小 A 一看到密密麻麻的数字就觉得头晕，作为小 A 最好的朋友，你决定帮他一把。 链接 BZOJ 3052 题解 带修改树上莫队模板题。 对树分块，排序。 维护两点 间的路径上不包含 的点的贡献和，每次转移到 时，将 和 路径上的点的是否在答案中取反。对于 单独考虑即可。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; const int MAXN = 100000; struct Node { struct Edge *e; Node *fa, *top, *ch; int blockID, depth, w, size; bool added, vis; } N[MAXN + 1]; struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {} }; inline void addEdge(int s, int t) { N[s].e = new Edge(&amp;N[s], &amp;N[t]); N[t].e = new Edge(&amp;N[t], &amp;N[s]); } struct Update { Node *v; int oldVal, newVal; } U[MAXN + 1]; struct Query { int time; long long *ans; Node *u, *v; bool operator&lt;(const Query &amp;other) const { if (u-&gt;blockID &lt; other.u-&gt;blockID) return true; else if (u-&gt;blockID == other.u-&gt;blockID &amp;&amp; v-&gt;blockID &lt; other.v-&gt;blockID) return true; else if (u-&gt;blockID == other.u-&gt;blockID &amp;&amp; v-&gt;blockID == other.v-&gt;blockID &amp;&amp; time &lt; other.time) return true; else return false; } } Q[MAXN + 1]; int n, max, m, cntQuery, cntUpdate, v[MAXN + 1], w[MAXN + 1], cnt[MAXN + 1], blockSize, blockCount; std::stack&lt;Node *&gt; s; inline void dfs(Node *v) { size_t status = s.size(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;t != v-&gt;fa) { e-&gt;t-&gt;fa = v; e-&gt;t-&gt;depth = v-&gt;depth + 1; dfs(e-&gt;t); if (int(s.size() - status) &gt;= blockSize) { v-&gt;blockID = ++blockCount; while (s.size() != status) { Node *u = s.top(); s.pop(); u-&gt;blockID = blockCount; } } } } s.push(v); } inline void assignBlocks() { N[1].fa = NULL; N[1].depth = 1; dfs(&amp;N[1]); while (!s.empty()) { Node *u = s.top(); s.pop(); u-&gt;blockID = blockCount; } } inline void prepare() { static int newC[MAXN + 1]; for (int i = 1; i &lt;= n; i++) newC[i] = N[i].w; for (int i = 1; i &lt;= cntUpdate; i++) { U[i].oldVal = newC[U[i].v - N]; newC[U[i].v - N] = U[i].newVal; } } inline void split() { std::stack&lt;Node *&gt; s; s.push(&amp;N[1]); while (!s.empty()) { Node *v = s.top(); if (!v-&gt;vis) { v-&gt;vis = true; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;t-&gt;fa == v) { s.push(e-&gt;t); } } } else { v-&gt;size = 1; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { v-&gt;size += e-&gt;t-&gt;size; if (!v-&gt;ch || v-&gt;ch-&gt;size &lt; e-&gt;t-&gt;size) v-&gt;ch = e-&gt;t; } s.pop(); } } s.push(&amp;N[1]); while (!s.empty()) { Node *v = s.top(); s.pop(); v-&gt;top = (!v-&gt;fa || v != v-&gt;fa-&gt;ch) ? v : v-&gt;fa-&gt;top; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;t-&gt;fa == v) { s.push(e-&gt;t); } } } } inline Node *lca(Node *u, Node *v) { while (u-&gt;top != v-&gt;top) { if (u-&gt;top-&gt;depth &lt; v-&gt;top-&gt;depth) std::swap(u, v); u = u-&gt;top-&gt;fa; } return u-&gt;depth &lt; v-&gt;depth ? u : v; } inline void reverse(Node *v, long long &amp;ans) { if (!v-&gt;added) { #ifdef DBG printf("add(%lu)\n", v - N); #endif ans += (long long)::v[v-&gt;w] * w[++cnt[v-&gt;w]]; } else { #ifdef DBG printf("del(%lu)\n", v - N); #endif ans -= (long long)::v[v-&gt;w] * w[cnt[v-&gt;w]--]; } v-&gt;added ^= 1; } inline void extend(Node *&amp;s, Node *t, long long &amp;ans) { Node *p = lca(s, t); for (Node *v = s; v != p; v = v-&gt;fa) reverse(v, ans); for (Node *v = t; v != p; v = v-&gt;fa) reverse(v, ans); s = t; } inline void apply(int time, int d, long long &amp;ans) { bool flag = U[time].v-&gt;added; if (flag) reverse(U[time].v, ans); #ifdef DBG printf("apply(time = %d, d = %d), N[%lu].w = %d =&gt; ", time, d, U[time].v - N, U[time].v-&gt;w); #endif if (d == 1) { U[time].v-&gt;w = U[time].newVal; } else { U[time].v-&gt;w = U[time].oldVal; } #ifdef DBG printf("%d\n", U[time].v-&gt;w); #endif if (flag) reverse(U[time].v, ans); } inline void update(int &amp;fromTime, int toTime, long long &amp;ans) { #ifdef DBG long long _ans = ans; #endif if (fromTime &lt; toTime) { for (int i = fromTime + 1; i &lt;= toTime; i++) apply(i, 1, ans); } else if (fromTime &gt; toTime) { for (int i = fromTime; i &gt;= toTime + 1; i--) apply(i, -1, ans); } #ifdef DBG printf("update(%d to %d), ans = %lld =&gt; %lld\n", fromTime, toTime, _ans, ans); #endif fromTime = toTime; } inline void solve() { int time = 0; Node *u = &amp;N[1], *v = &amp;N[1]; long long ans = 0; for (int i = 1; i &lt;= cntQuery; i++) { const Query &amp;q = Q[i]; extend(u, q.u, ans); extend(v, q.v, ans); update(time, q.time, ans); Node *p = lca(u, v); reverse(p, ans); *q.ans = ans; reverse(p, ans); #ifdef DBG printf("query(%lu, %lu) = %lld\n", u - N, v - N, *q.ans); printf("added:"); for (int i = 1; i &lt;= n; i++) if (N[i].added) printf(" %d", i); puts(""); #endif } } int main() { scanf("%d %d %d", &amp;n, &amp;max, &amp;m); blockSize = pow(n, 2.0 / 3); for (int i = 1; i &lt;= max; i++) scanf("%d", &amp;v[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;w[i]); for (int i = 1; i &lt;= n - 1; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v); addEdge(u, v); } for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;N[i].w); static long long ans[MAXN + 1]; for (int i = 1; i &lt;= m; i++) { int t, x, y; scanf("%d %d %d", &amp;t, &amp;x, &amp;y); if (t == 0) { ++cntUpdate; U[cntUpdate].v = &amp;N[x]; U[cntUpdate].newVal = y; } else { if (x &gt; y) std::swap(x, y); ++cntQuery; Q[cntQuery].u = &amp;N[x]; Q[cntQuery].v = &amp;N[y]; Q[cntQuery].time = cntUpdate; Q[cntQuery].ans = &amp;ans[cntQuery]; } } assignBlocks(); split(); prepare(); std::sort(Q + 1, Q + cntQuery + 1); solve(); for (int i = 1; i &lt;= cntQuery; i++) printf("%lld\n", ans[i]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
        <tag>BZOJ</tag>
        <tag>最近公共祖先</tag>
        <tag>莫队</tag>
        <tag>WC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2724」蒲公英 - 分块]]></title>
    <url>%2Fbzoj-2724%2F</url>
    <content type="text"><![CDATA[给一个长度为 的序列，每次查询一个区间 内的众数（如果有多个众数，取最小的一个），强制在线。 链接 BZOJ 2724 题解 离散化，将序列分为 块，维护 表示第 块到第 块之间的答案， 表示 这个数在前 个块中的出现次数。 每次查询，对于中间完整的块，取出其答案。对于两边不是完整的块的部分，遍历一遍求出其出现次数，加上这些数在中间块的出现次数（由前缀和得到），并尝试更新答案。 代码 #include &lt;cstdio&gt; // #include &lt;cstring&gt; // #include &lt;cassert&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; const int MAXN = 40000; const int MAXN_SQRT = 200; const int MAXM = 50000; // 离散化用到的 set（集合）和 tot（不重复的数字数量） int n, a[MAXN + 1], set[MAXN + 1], tot; // 块大小、块数量、cnt[x][i] 表示 x 这个数在前 i 个块中的出现次数，ans[l][r] 表示第 l 个块到第 r 个块的答案 int blockSize, blockCnt, cnt[MAXN + 1][MAXN_SQRT + 1], ans[MAXN_SQRT + 1][MAXN_SQRT + 1]; // 离散化 inline void discrete() { std::copy(a + 1, a + n + 1, set + 1); std::sort(set + 1, set + n + 1); int *end = std::unique(set + 1, set + n + 1); for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(set + 1, end, a[i]) - set; tot = end - (set + 1); // 区间 [set + 1, end) 的长度 } // 给一个位置，求所在块编号 inline int blockID(int i) { return (i - 1) / blockSize + 1; } // 给一个块编号，求其区间 inline void blockInterval(int i, int &amp;l, int &amp;r) { l = (i - 1) * blockSize + 1; r = i * blockSize; // 防止越界 r = std::min(r, n); } // 预处理 inline void prepare() { // 以根号 n 分块 blockSize = ceil(sqrt(n)); blockCnt = blockID(n); // cnt[x][i] 表示 x 这个数在第 i 个块中的出现次数 for (int i = 1; i &lt;= n; i++) { int bi = blockID(i); cnt[a[i]][bi]++; } // 做前缀和 for (int i = 1; i &lt;= blockCnt; i++) { for (int j = 1; j &lt;= tot; j++) cnt[j][i] += cnt[j][i - 1]; } // 求 ans[l][r] for (int i = 1; i &lt;= blockCnt; i++) { // cnt[x] 表示 x 这个数在第 [i, j] 这个块区间内的出现次数 static int cnt[MAXN + 1]; std::fill(cnt + 1, cnt + tot + 1, 0); // 清空 cnt int tmp = 0; // 表示当前答案 for (int j = i; j &lt;= blockCnt; j++) // j 从 i 开始枚举，每次向后扩充一个块 { // 将第 j 个块加入到答案中 int l, r; blockInterval(j, l, r); // 枚举第 j 个块的所有数 for (int k = l; k &lt;= r; k++) { cnt[a[k]]++; // 更新答案 // 注意，根据题意，出现次数相同时取较小值 if (!tmp || cnt[a[k]] &gt; cnt[tmp] || (cnt[a[k]] == cnt[tmp] &amp;&amp; a[k] &lt; tmp)) tmp = a[k]; } // 记录答案 ans[i][j] = tmp; } } } // 暴力计算 [l, r] 的答案 inline int force(int l, int r) { static int cnt[MAXN + 1]; int ans = 0; for (int i = l; i &lt;= r; i++) { cnt[a[i]]++; // 更新答案 if (!ans || cnt[a[i]] &gt; cnt[ans] || (cnt[a[i]] == cnt[ans] &amp;&amp; a[i] &lt; ans)) ans = a[i]; } // 清空 cnt，注意不能 memset 或者 std::fill // 因为我们需要 force() 的时间复杂度与 [l, r] 的区间长度有关，与序列中总数的数量无关 for (int i = l; i &lt;= r; i++) cnt[a[i]]--; return ans; } // 计算 a 中的 n 个数的答案（这些数是在查询时不在块内的数） // 统计数的出现次数时，额外加入每个数在 [lb, rb] 这些（完整的）块内的出现次数 // 并将新答案与旧答案 oldAns 取较优 inline int calcPart(int lb, int rb, int *a, int n, int &amp;oldAns, int &amp;oldAnsCnt) { static int cnt[MAXN + 1]; // 加入这些数在块内的出现次数 for (int i = 1; i &lt;= n; i++) { cnt[a[i]] = ::cnt[a[i]][rb] - ::cnt[a[i]][lb - 1]; // 注意不能是 +=，因为数可能重复，避免重复加入 } for (int i = 1; i &lt;= n; i++) { cnt[a[i]]++; // 统计出现次数 } int ans = oldAns, ansCnt = oldAnsCnt; for (int i = 1; i &lt;= n; i++) { int newCnt = cnt[a[i]]; // 更新答案 if (!ans || newCnt &gt; ansCnt || (newCnt == ansCnt &amp;&amp; a[i] &lt; ans)) { ans = a[i]; ansCnt = newCnt; } } // 清空 cnt for (int i = 1; i &lt;= n; i++) { cnt[a[i]] = 0; } return ans; } // 求块 [lb, rb] 内的答案 inline void blockAns(int lb, int rb, int &amp;ans, int &amp;ansCnt) { ans = ::ans[lb][rb]; ansCnt = cnt[ans][rb] - cnt[ans][lb - 1]; // 前缀和作差 } // 查询 [l, r] 间的答案 inline int query(int l, int r) { int lb = blockID(l), rb = blockID(r); if (lb == rb || lb + 1 == rb) // 如果两端点在同一块或相邻块，则暴力计算 { return force(l, r); } // 先计算块内的部分 int ans, ansCnt; // [lb + 1, rb - 1] 是完整的块，lb 和 rb 不是完整的块 blockAns(lb + 1, rb - 1, ans, ansCnt); // 取出块之外的数 int cnt = 0; // 块之外的数的数量 static int tmp[MAXN + 1]; // 块之外的数 int ll, lr; blockInterval(lb, ll, lr); // 左半边块之外的 for (int i = l; i &lt;= lr; i++) tmp[++cnt] = a[i]; int rl, rr; blockInterval(rb, rl, rr); // 右半边块之外的 for (int i = rl; i &lt;= r; i++) tmp[++cnt] = a[i]; // 计算块外的部分，更新答案 // [lb + 1, rb - 1] 是完整的块 return calcPart(lb + 1, rb - 1, tmp, cnt, ans, ansCnt); } int main() { int m; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); discrete(); prepare(); int lastAns = 0; // 上一次的答案 while (m--) { int l, r; scanf("%d %d", &amp;l, &amp;r); // 强制在线 l = (l + lastAns - 1) % n + 1; r = (r + lastAns - 1) % n + 1; if (l &gt; r) std::swap(l, r); // 将离散化后的值对应到原值 printf("%d\n", lastAns = set[query(l, r)]); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分块</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2005」维修数列 - Splay]]></title>
    <url>%2Fnoi2005-sequence%2F</url>
    <content type="text"><![CDATA[请写一个程序，要求维护一个数列，支持以下 种操作。 操作 输入格式 说明 插入 INSERT pos cnt a[1] a[2] ...... a[cnt] 在当前数列的第 个数字后插入 个数字：，如果 ，则在首部插入 删除 DELETE pos cnt 从当前数列的第 个数字开始，删除连续的 个数字 修改 MAKE-SAME pos cnt x 将当前数列的第 个数字开始的连续 个数字统一修改为 翻转 REVERSE pos cnt 取出当前数列的第 个数字开始的连续 个数字，翻转后放入原来的位置 求和 GET-SUM pos cnt x 计算从当前数列的第 个数字开始的连续 个数字的和并输出 最大子段和 MAX-SUM 求出当前数列中和最大的一段子序列，并输出其和 链接 BZOJ 1500 题解 求最大子段和时，维护整体的最大子段和，强制包含左端点的最大子段和，强制包含右端点的最大子段和，整体和，即可合并。 修改时打标记即可。 注意提取区间，打标记后要即使维护前两层节点的信息。 代码 #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 500000; struct Data { int sum, maxSum, lMaxSum, rMaxSum; Data(int x = INT_MIN) : sum(x), maxSum(x), lMaxSum(x), rMaxSum(x) {} static Data merge(const Data &amp;l, const Data &amp;r) { Data res; // printf("merge(%d, %d)\n", l.sum, r.sum); res.sum = l.sum + r.sum; res.lMaxSum = std::max(std::max(l.lMaxSum, l.sum + r.lMaxSum), res.sum); res.rMaxSum = std::max(std::max(r.rMaxSum, l.rMaxSum + r.sum), res.sum); res.maxSum = std::max(std::max(l.maxSum, r.maxSum), std::max(l.rMaxSum + r.lMaxSum, res.sum)); return res; } static Data merge(const Data &amp;l, int x, const Data &amp;r) { if (l.sum == INT_MIN &amp;&amp; r.sum == INT_MIN) return x; else { if (l.sum == INT_MIN) { if (x == INT_MIN) { return r; } else { return merge(x, r); } } else if (r.sum == INT_MIN) { if (x == INT_MIN) { return l; } else { return merge(l, x); } } else { if (x == INT_MIN) { return merge(l, r); } else { return merge(merge(l, x), r); } } } } }; struct Splay { struct Node { Node *c[2], *fa, **root; int x, size, realSize, tagAssign; bool rev; Data data; bool bound; Node(Node *fa, int x, Node **root, bool bound = false) : fa(fa), root(root), x(x), size(1), realSize(!bound), tagAssign(INT_MIN), rev(false), data(x), bound(bound) {} ~Node() { if (c[0]) delete c[0]; if (c[1]) delete c[1]; } void maintain() { size = (c[0] ? c[0]-&gt;size : 0) + (c[1] ? c[1]-&gt;size : 0) + 1; realSize = (c[0] ? c[0]-&gt;realSize : 0) + (c[1] ? c[1]-&gt;realSize : 0) + 1; Data ld = INT_MIN, rd = INT_MIN; if (c[0]) ld = c[0]-&gt;data; if (c[1]) rd = c[1]-&gt;data; data = Data::merge(ld, bound ? INT_MIN : x, rd); } void pushDown() { if (rev) { std::swap(c[0], c[1]); if (c[0]) c[0]-&gt;reverse(); if (c[1]) c[1]-&gt;reverse(); rev = false; } if (tagAssign != INT_MIN) { if (c[0]) c[0]-&gt;assign(tagAssign); if (c[1]) c[1]-&gt;assign(tagAssign); tagAssign = INT_MIN; } } int relation() { return this == fa-&gt;c[1]; } void rotate() { pushDown(); int x = relation(); Node *o = fa; fa = o-&gt;fa; if (fa) fa-&gt;c[o-&gt;relation()] = this; o-&gt;c[x] = c[x ^ 1]; if (c[x ^ 1]) c[x ^ 1]-&gt;fa = o; c[x ^ 1] = o; o-&gt;fa = this; o-&gt;maintain(); maintain(); if (!fa) { *root = this; } } void splay(Node *targetFa = NULL) { while (fa != targetFa) { if (fa-&gt;fa) fa-&gt;fa-&gt;pushDown(); fa-&gt;pushDown(); if (fa-&gt;fa == targetFa) rotate(); else if (fa-&gt;relation() == relation()) fa-&gt;rotate(), rotate(); else rotate(), rotate(); } } void assign(int x) { if (bound) { if (c[0]) c[0]-&gt;assign(x); if (c[1]) c[1]-&gt;assign(x); } else { this-&gt;x = tagAssign = x; data = Data(x * realSize); } } void reverse() { rev ^= 1; std::swap(data.lMaxSum, data.rMaxSum); } int lSize() { return c[0] ? c[0]-&gt;size : 0; } void normalize() { pushDown(); if (c[0]) c[0]-&gt;normalize(); if (c[1]) c[1]-&gt;normalize(); maintain(); } } *root; Splay() : root(NULL) { buildBound(); } void buildBound() { root = new Node(NULL, INT_MIN, &amp;root, true); root-&gt;c[1] = new Node(root, INT_MIN, &amp;root, true); root-&gt;size = 2; } Node *select(int k) { // printf("select(%d) = ", k); Node *v = root; while (v-&gt;pushDown(), k != v-&gt;lSize()) { if (k &lt; v-&gt;lSize()) { v = v-&gt;c[0]; } else { k -= v-&gt;lSize() + 1; v = v-&gt;c[1]; } } // printf("%d\n", v-&gt;x); return v; } Node *select(int l, int r) { Node *pred = select(l - 1), *succ = select(r + 1); pred-&gt;splay(); succ-&gt;splay(pred); return succ-&gt;c[0]; } Node *build(int *l, int *r, Node *fa) { if (l &gt; r) return NULL; int *mid = l + (r - l) / 2; Node *v = new Node(fa, *mid, &amp;root); v-&gt;c[0] = build(l, mid - 1, v); v-&gt;c[1] = build(mid + 1, r, v); v-&gt;maintain(); return v; } void insert(int pos, int *a, int n) { Node *pred = select(pos), *succ = select(pos + 1); pred-&gt;splay(); succ-&gt;splay(pred); succ-&gt;c[0] = build(a + 1, a + n, succ); succ-&gt;maintain(); pred-&gt;maintain(); } void erase(int l, int r) { Node *pred = select(l - 1), *succ = select(r + 1); pred-&gt;splay(); succ-&gt;splay(pred); delete succ-&gt;c[0]; succ-&gt;c[0] = NULL; succ-&gt;maintain(); pred-&gt;maintain(); } void reverse(int l, int r) { Node *pred = select(l - 1), *succ = select(r + 1); pred-&gt;splay(); succ-&gt;splay(pred); succ-&gt;c[0]-&gt;reverse(); succ-&gt;maintain(); pred-&gt;maintain(); } int sum(int l, int r) { return select(l, r)-&gt;data.sum; } int maxSum() { return root-&gt;data.maxSum; } void assign(int l, int r, int x) { Node *pred = select(l - 1), *succ = select(r + 1); pred-&gt;splay(); succ-&gt;splay(pred); succ-&gt;c[0]-&gt;assign(x); succ-&gt;maintain(); pred-&gt;maintain(); } void print(Node *v, int dep = 0) { if (!v) return; v-&gt;pushDown(); print(v-&gt;c[0], dep + 1); for (int i = 0; i &lt; dep * 2; i++) putchar(' '); if (v-&gt;bound) puts("[[Bound]]"); else printf("%d -&gt; sum = %d, maxSum = %d, lMaxSum = %d, rMaxSum = %d\n", v-&gt;x, v-&gt;data.sum, v-&gt;data.maxSum, v-&gt;data.lMaxSum, v-&gt;data.rMaxSum); print(v-&gt;c[1], dep + 1); } } splay; int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); static int a[MAXN + 1]; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); splay.insert(0, a, n); while (m--) { /* puts("------------------------------------------------------------------------"); splay.print(splay.root); puts("------------------------------------------------------------------------"); */ // splay.root-&gt;normalize(); char s[sizeof("MAKE-SAME")]; scanf("%s", s); if (s[2] == 'S') { int pos, cnt; scanf("%d %d", &amp;pos, &amp;cnt); for (int i = 1; i &lt;= cnt; i++) scanf("%d", &amp;a[i]); splay.insert(pos, a, cnt); } else if (s[2] == 'L') { int pos, cnt; scanf("%d %d", &amp;pos, &amp;cnt); splay.erase(pos, pos + cnt - 1); } else if (s[2] == 'K') { int pos, cnt, x; scanf("%d %d %d", &amp;pos, &amp;cnt, &amp;x); /* for (int i = 1; i &lt;= cnt; i++) a[i] = x; splay.erase(pos, pos + cnt - 1); splay.insert(pos - 1, a, cnt); */ splay.assign(pos, pos + cnt - 1, x); } else if (s[2] == 'V') { int pos, cnt; scanf("%d %d", &amp;pos, &amp;cnt); splay.reverse(pos, pos + cnt - 1); } else if (s[2] == 'T') { int pos, cnt; scanf("%d %d", &amp;pos, &amp;cnt); if (cnt == 0) puts("0"); else printf("%d\n", splay.sum(pos, pos + cnt - 1)); } else { printf("%d\n", splay.maxSum()); } } }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>BZOJ</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3674」可持久化并查集加强版 - 可持久化线段树]]></title>
    <url>%2Fbzoj-3674%2F</url>
    <content type="text"><![CDATA[个集合， 个操作： 1 a b 合并 、 所在集合； 2 k 回到第 次操作之后的状态（查询算作操作）； 3 a b 询问 、 是否属于同一集合，是则输出 否则输出 。 链接 BZOJ 3674 题解 可持久化线段树实现可持久化数组，然后实现可持久化并查集。 注意时间的映射关系。 代码 #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;new&gt; const int MAXN = 2e5; const int MAXM = 2e5; struct PSegT { struct Node { int l, r; Node *lc, *rc; int val; Node() {} Node(int l, int r, Node *lc, Node *rc, int val) : l(l), r(r), lc(lc), rc(rc), val(val) {} int query(int pos) { if (pos &lt; l || pos &gt; r) return 0; else if (l == r) return val; else { return lc-&gt;query(pos) + rc-&gt;query(pos); } } } *roots[MAXM * 10 + 1], *null, _pool[MAXN * 30], *_cur; int time, l, r; PSegT() : time(0) { null = new Node(-1, -1, NULL, NULL, 0); null-&gt;lc = null; null-&gt;rc = null; } Node *insert(Node *v, int l, int r, int pos, int val) { if (pos &lt; l || pos &gt; r) { return v; } else if (l == r) { return new (_cur++) Node(l, r, null, null, val); } else { int mid = l + (r - l) / 2; return new (_cur++) Node(l, r, insert(v-&gt;lc, l, mid, pos, val), insert(v-&gt;rc, mid + 1, r, pos, val), 0); } } void init(int l, int r) { this-&gt;l = l; this-&gt;r = r; time = 0; roots[0] = null; _cur = _pool; } void update(int fromTime, int pos, int val) { roots[++time] = insert(roots[fromTime], l, r, pos, val); } int query(int fromTime, int pos) { return roots[fromTime]-&gt;query(pos); } int getTime() { return time; } }; struct UFS { PSegT fa, rank; int timeFa[MAXM + 1], timeRank[MAXM + 1]; int time; void init(int n) { fa.init(1, n); rank.init(1, n); for (int i = 1; i &lt;= n; i++) { int t = fa.getTime(); fa.update(t, i, i); rank.update(t, i, 1); } time = 0; timeFa[time] = fa.getTime(); timeRank[time] = rank.getTime(); } int find(int fromTime, int x) { int tmp = fa.query(timeFa[fromTime], x); if (tmp == x) return x; else return find(fromTime, tmp); } int merge(int fromTime, int x, int y) { time++; int a = find(fromTime, x), b = find(fromTime, y); int ra = rank.query(timeRank[fromTime], a), rb = rank.query(timeRank[fromTime], b); if (ra &gt; rb) { std::swap(a, b); } if (ra == rb) { rank.update(timeRank[fromTime], b, rb + 1); } fa.update(timeFa[fromTime], a, b); timeFa[time] = fa.getTime(); timeRank[time] = rank.getTime(); return time; } int getTime() { return time; } } ufs; int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); static int time[MAXM + 1]; ufs.init(n); time[0] = ufs.getTime(); int lastAns = 0; for (int i = 1; i &lt;= m; i++) { int c, a; scanf("%d %d", &amp;c, &amp;a); a ^= lastAns; if (c == 1) { int b; scanf("%d", &amp;b); b ^= lastAns; time[i] = ufs.merge(time[i - 1], a, b); } else if (c == 2) { time[i] = time[a]; } else { int b; scanf("%d", &amp;b); b ^= lastAns; int fa = ufs.find(time[i - 1], a), fb = ufs.find(time[i - 1], b); int res = fa == fb; printf("%d\n", res); lastAns = res; time[i] = time[i - 1]; } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>BZOJ</tag>
        <tag>可持久化并查集</tag>
        <tag>可持久化数据结构</tag>
        <tag>可持久化线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3673」可持久化并查集 - 可持久化线段树]]></title>
    <url>%2Fbzoj-3673%2F</url>
    <content type="text"><![CDATA[个集合， 个操作： 1 a b 合并 、 所在集合； 2 k 回到第 次操作之后的状态（查询算作操作）； 3 a b 询问 、 是否属于同一集合，是则输出 否则输出 。 链接 BZOJ 3673 题解 可持久化线段树实现可持久化数组，然后实现可持久化并查集。 注意时间的映射关系。 代码 #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;new&gt; const int MAXN = 2e4; const int MAXM = 2e4; struct PSegT { struct Node { int l, r; Node *lc, *rc; int val; Node() {} Node(int l, int r, Node *lc, Node *rc, int val) : l(l), r(r), lc(lc), rc(rc), val(val) {} int query(int pos) { if (pos &lt; l || pos &gt; r) return 0; else if (l == r) return val; else { return lc-&gt;query(pos) + rc-&gt;query(pos); } } } *roots[MAXM * 10 + 1], *null, _pool[MAXN * 30], *_cur; int time, l, r; PSegT() : time(0) { null = new Node(-1, -1, NULL, NULL, 0); null-&gt;lc = null; null-&gt;rc = null; } Node *insert(Node *v, int l, int r, int pos, int val) { if (pos &lt; l || pos &gt; r) { return v; } else if (l == r) { return new (_cur++) Node(l, r, null, null, val); } else { int mid = l + (r - l) / 2; return new (_cur++) Node(l, r, insert(v-&gt;lc, l, mid, pos, val), insert(v-&gt;rc, mid + 1, r, pos, val), 0); } } void init(int l, int r) { this-&gt;l = l; this-&gt;r = r; time = 0; roots[0] = null; _cur = _pool; } void update(int fromTime, int pos, int val) { roots[++time] = insert(roots[fromTime], l, r, pos, val); } int query(int fromTime, int pos) { return roots[fromTime]-&gt;query(pos); } int getTime() { return time; } }; struct UFS { PSegT fa, rank; int timeFa[MAXM + 1], timeRank[MAXM + 1]; int time; void init(int n) { fa.init(1, n); rank.init(1, n); for (int i = 1; i &lt;= n; i++) { int t = fa.getTime(); fa.update(t, i, i); rank.update(t, i, 1); } time = 0; timeFa[time] = fa.getTime(); timeRank[time] = rank.getTime(); } int find(int fromTime, int x) { int tmp = fa.query(timeFa[fromTime], x); if (tmp == x) return x; else return find(fromTime, tmp); } int merge(int fromTime, int x, int y) { time++; int a = find(fromTime, x), b = find(fromTime, y); int ra = rank.query(timeRank[fromTime], a), rb = rank.query(timeRank[fromTime], b); if (ra &lt; rb) { std::swap(a, b); } if (ra == rb) { rank.update(timeRank[fromTime], b, rb + 1); } fa.update(timeFa[fromTime], a, b); timeFa[time] = fa.getTime(); timeRank[time] = rank.getTime(); return time; } int getTime() { return time; } } ufs; int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); static int time[MAXM + 1]; ufs.init(n); time[0] = ufs.getTime(); for (int i = 1; i &lt;= m; i++) { int c, a; scanf("%d %d", &amp;c, &amp;a); if (c == 1) { int b; scanf("%d", &amp;b); time[i] = ufs.merge(time[i - 1], a, b); } else if (c == 2) { time[i] = time[a]; } else { int b; scanf("%d", &amp;b); int fa = ufs.find(time[i - 1], a), fb = ufs.find(time[i - 1], b); int res = fa == fb; printf("%d\n", res); time[i] = time[i - 1]; } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>BZOJ</tag>
        <tag>可持久化并查集</tag>
        <tag>可持久化数据结构</tag>
        <tag>可持久化线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Menci's Code Style for OI]]></title>
    <url>%2Fcode-style-oi%2F</url>
    <content type="text"><![CDATA[本文介绍本人在 OI 中常用的代码规范。 概览 所有的 #include 指令必须放置于整个程序开头。 不应该使用 using namespace std;。 main 函数应该放置于整个程序末尾。 不应该使用 int 代替 bool 表示逻辑值。 预编译指令 #include 中，C 标准库头文件必须使用 c 前缀，而不是 .h 后缀。 #include 中，C 标准库头文件应该放置于 C++ 标准库头文件前，其它头文件（如果有）应放置于最后。 所有的预编译指令（包括 #ifdef 等）不能缩进。 缩进 对于每个代码块，使用 4 空格或等长的 Tab 缩进。 花括号 花括号必须遵循以下两种写法之一，前一种被称为「花括号不换行」，后一种被称为「花括号换行」。 对于「花括号不换行」，左花括号的左边必须有且仅有一个空格。 对于「花括号换行」，左花括号必须与上一级代码块的缩进相同。 所有右花括号必须与上一级代码块的缩进相同。 // 1 if (condition) { } else { } // 2 if (condition) { } else { } 行 除 for 中的三个语句外，每行不能有超过一个语句。如果需要一行内求值多个表达式，可以使用等效的逗号表达式替代。 多个意义独立的代码块之间应该用空行隔开。 右花括号前不应该有多余的空行。 不应该有两个连续的空行。 非空行尾不应该有多余的空格。 所有的 #include 指令之后必须有一个空行。 如果有 using namespace std;，则必须紧跟在 #include 后的空行后，之后必须一个空行。 函数、成员函数、结构体、全局变量块之间必须用空行隔开。 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 100; const int MAXM = 200; int n, m, a[MAXN + 1]; double p, q, x, y; int main() { p = 1, q = 2; return 0; } 函数 main 函数的返回值类型必须是 int，可以省略 return 0;。 空函数体可以使用 {}。 传参时，应该根据实际需要使用「引用」、「const 引用」和「值传递」。 变量 应该尽量少使用全局变量。 局部变量必须在用时定义，变量名不应该与上一个块中的变量重名，可以与全局变量重名。 只在一个函数内使用到的需要全局空间（如大数组）或生命周期的变量，必须定义为 static 的局部变量。 空格 逗号 , 与 for 中的分号 ; 后面必须有一个空格，前面不能有空格。 左圆（方）括号后、右圆（方）括号前，在书写长表达式时，为了便于阅读，可以加一个空格，如 f[i][j] = f[ f[i][j - 1] ][j - 1] 双目运算符、三目运算符的两侧必须有一个空格。 单目运算符的两侧不能有空格。 冒号的两侧必须有一个空格。 struct Edge { int x; Edge() : x(0) {} } 流程控制关键字之后，左圆括号前必须有一个空格，函数名之后，左圆括号前不能有空格。 对于「花括号不换行」，do-while 结构的 do 之后，左花括号前必须有一个空格，while 前必须有一个空格。 模板参数表中，如果右方括号前不得不加一个空格，则可以在对应的左方括号后加一个空格，为了对称。 .、-&gt;、:: 的两边不能有空格。 指针与引用 在描述类型名时，指针符号 * 和引用符号 &amp; 与左侧的类型名之间必须有一个空格，与右侧的其它关键字之间不能有空格，如 char *const 或 int *&amp;。 在定义变量、函数返回值、参数时，指针符号 * 和引用符号 &amp; 与左侧的类型名之间必须有一个空格，与右侧的变量、函数、参数名之间不能有空格。 命名 所有结构体、函数、变量、参数名必须使用驼峰命名法，其中结构体名首字母必须大写，其它首字母必须小写。 为方便，命名中的单词可以使用缩写，函数、变量、参数名可以用一个小写字母代替。全局数组可以命名为一个大写字母。 int aVarWithVeryLongName; struct Node { int dep, s; } struct SegT { SegT *lc, *rc; } bool getAns(std::vector&lt;std::string&gt; &amp;res);]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算几何学习笔记]]></title>
    <url>%2Fgeometry-notes%2F</url>
    <content type="text"><![CDATA[计算几何（Computational Geometry），是一系列使用计算机解决几何问题的算法。与解析几何相比，计算几何更适合计算机运算，精度较高，运算速度较快，并且易于编写。 本文只包含二维计算几何在 OI 中的部分应用。 浮点误差 程序设计中，考虑到浮点数 double 有精度误差，在比较时，通常允许一定的误差，即对于两个数 、，如果 ，则认为 。一般根据题目要求，（代码中命名为 EPS）取一个较小值，如 。 const double EPS = 1e-8; // 带误差比较，返回 x 是否等于 y inline bool dcmp(double x, double y = 0) { return fabs(x - y) &lt;= EPS; } 向量 向量（vector）是一个有大小和方向的量，在几何中，它被表示为带箭头的线段。向量可以用起点和终点的坐标来表示 —— 从点 到点 的向量表示为 。 向量的书写，两个大写字母上加一个箭头（表示方向），或者加粗的小写字母 。 向量没有位置，即向量可以在平面内任意平移而保持其本身的性质不变 —— 所以我们可以将向量平移至其起点与原点 重合，用终点坐标表示这个向量，下文称此方法为坐标表示法，除特殊说明外，下文表示向量均使用此方法。 两个向量的夹角 定义为从 旋转到 所经过的角度，逆时针为正，顺时针为负。 向量范数（norm），这里简单定义向量 的范数为 ，即长度的平方 。这样定义的好处是，可以方便地比较两个向量的长度，而不需要开平方。 与向量相对的概念是标量（scalar），标量只有大小没有方向。 向量的基本运算 两个向量相加，遵循平行四边形定则（或三角形定则），。 两个向量相减与相加类似，除此之外，点可以加减一个向量，表示将点按照向量所指向的方向进行平移。 向量的数乘，将一个向量乘或除以 ，表示将向量所对应的有向线段长度变为原来的 倍或 分之一。 可以发现，向量和点的运算是相似的，在程序中，可以使用同一种类型来表示向量和点： /* * 向量（Vector）或点 * * 使用原点到一个点 (x, y) 的有向线段表示向量 * 从点 A 到点 B 的向量表示为 A - B */ typedef struct Vec { double x, y; Vec(double x = 0, double y = 0) : x(x), y(y) {} // 相加 Vec operator+(const Vec &amp;v) const { return Vec(x + v.x, y + v.y); } // 相减 Vec operator-(const Vec &amp;v) const { return Vec(x - v.x, y - v.y); } // 数乘（伸长、缩短） Vec operator*(double d) const { return Vec(x * d, y * d); } Vec operator/(const double d) const { return Vec(x / d, y / d); } // 范数，用来比较长度，等于长度的平方 double norm() const { return x * x + y * y; } } Pt; 为了方便阅读，我们定义类型点 Pt 为向量 Vec 的别名，在代码中区别「点」和「向量」。同时，应记住点与向量的运算中的类型： 向量 向量 向量 点 向量 点 向量 数 向量 向量乘法 向量的乘法分为两种 —— 点乘（Dot）和叉乘（Cross）。 点乘 向量的点乘表示为 ，设 ，则 点乘的结果是一个标量，它表示 在 所在直线上的投影长度与 长度的乘积，即 从上式中可以看出，因为 ，所以 ，即点乘满足交换律。 叉乘 向量的叉乘表示为 ，设 ，则 叉乘的结果是一个标量，它表示以 与 为邻边的平行四边形的（有向）面积，即 这个平行四边形可以以 为底，底边上的高即为 。 结果的符号与 相同，即当 在 逆时针方向时，结果为正。 如果需要求以两向量为两边的三角形面积，可以求出平行四边形面积后除以二。 代码实现 // 点乘 double dot(const Vec &amp;a, const Vec &amp;b) { return a.x * b.x + a.y * b.y; } // 叉乘 double cross(const Vec &amp;a, const Vec &amp;b) { return a.x * b.y - a.y * b.x; } 直线与线段 用直线上的两个点表示直线，用线段的两端点表示线段。 直线上的两个点组成的向量，被称为这条直线的一个方向向量。 点在直线上的判定 如果点 在直线上，则以 、 为邻边的平行四边形不存在（面积为零），即 。 bool include(const Pt &amp;p) const { return dcmp(cross(a - p, b - p)); } 判断两直线关系 如果一条直线上的两个点都在另一条实现上，则两条直线重合； 如果不重合的两条直线的方向向量叉乘得零（无法组成平行四边形），则两条直线平行。 // 两直线关系（交点个数） // 0 表示平行（无交点） // 1 表示相交（一个交点） // -1 表示重合（无数个交点） static int relation(const Line &amp;a, const Line &amp;b) { if (a.include(b.a) &amp;&amp; a.include(b.b)) return -1; else if (dcmp(cross(a.b - a.a, b.b - b.a))) return 0; else return 1; } 求两直线交点 在判断相交后，可以求两直线 、 的交点。设其交点为 ，分别过点 、 作 的垂线，连接 、、、。作向量 ，只需要求出 ，即可得到 。 因为 所以 所以 即 用叉乘计算面积，求出向量 即可，注意计算面积时的方向。 // 求两直线交点（需要保证两直线有交点） static Pt intersect(const Line &amp;a, const Line &amp;b) { double s1 = cross(b.a - a.a, b.b - a.a), s2 = cross(b.b - a.b, b.a - a.b); return a.a + (a.b - a.a) * s1 / (s1 + s2); } 点在线段上的判定 如果点 在线段 所在的直线上，则以 、 为邻边的平行四边形不存在（面积为零），即 。 此时还需判断 是否在 与 之间。 如果 ，则表示 （）； 如果 ，则表示 （）； 如果 ，则表示 或 ，即 与 或 重合。 后两种情况表明点 在 上。 // 线段包含点（点在线段上） bool include(const Pt &amp;p) const { // PA × PB = 0：PA 与 PB 共线，即点在线段所在的直线上 // PA · PB &lt; 0：PA 与 PB 方向不同（A 和 B 分别在 P 的两边），如果 PA · PB = 0 则 P = A 或 P = B return dcmp(cross(a - p, b - p)) &amp;&amp; dot(a - p, b - p) &lt;= 0; } 线段相交 / 求交点 求对应所在直线的交点，判断是否在线段上即可。 多边形 多边形（polygon）通常用顺时针或逆时针排列的顶点来表示。 struct Poly { std::vector&lt;Pt&gt; pts; }; 点在多边形内的判定 判断点是否在多边形内部，常使用射线法，即从该点引一条平行于 轴的射线，如果它与多边形有奇数个交点，则该点在多边形内，否则在多边形外。 考虑相邻两个顶点 与 ，判断由 引出的水平向右的射线有没有与线段 相交。作向量 ，分别过 、 作 轴的垂线，垂足分别为 、，设 如果 在 的顺时针方向上，即 ，则需要 在 上方， 在 下方，即 注意到 可以为 ，即射线穿过 被认为与当前边相交，因为可能会有这种情况 此时不应认为 在多边形内，如果因为 被认为被射线穿过了一次，则会误判。解决方案是对于每一条边，只将射线穿过上方点（也可以取下方点）的情况下认为射线与边相交，这样 会被统计两次（或零次），不会影响判断。 如果 在 的逆时针方向上，即 ，则需要 在 下方， 在 上方，即 。 代码实现 struct Poly { std::vector&lt;Pt&gt; pts; bool include(const Pt &amp;p) const { int cnt = 0; // 判断与每条边有没有交点 for (size_t i = 0; i &lt; pts.size(); i++) { // 枚举相邻的每两个点 const Pt &amp;a = pts[i], &amp;b = pts[(i + 1) % pts.size()]; // 如果点 P 在边 AB 上 if (Seg(a, b).include(p)) return true; // 详见图 double d1 = a.y - p.y, d2 = b.y - p.y, tmp = cross(a - p, b - p); if ((tmp &gt;= 0 &amp;&amp; d1 &gt;= 0 &amp;&amp; d2 &lt; 0) || (tmp &lt;= 0 &amp;&amp; d1 &lt; 0 &amp;&amp; d2 &gt;= 0)) cnt++; } // 奇数的交点 return cnt % 2 == 1; } }; 多边形面积 按顺序枚举每两个相邻的顶点，将每两个相邻的顶点与原点围成的三角形面积累加起来。因为所有不包含在多边形内的区域都被一正一负计算了偶数次，所以最终结果只包含多边形内的部分。 如图，浅蓝色部分被计算了两次，点 左下深色部分，在多边形内的部分被计算了三次，不在多边形内的部分被计算了四次，其它在多边形内部的部分被计算了一次。 如果按照逆时针顺序枚举，则结果为正，否则结果为负。 // 多边形面积（有向面积） double area() const { double res = 0; for (size_t i = 0; i &lt; pts.size(); i++) { // 枚举每两个点 const Pt &amp;a = pts[i], &amp;b = pts[(i + 1) % pts.size()]; res += cross(a, b); } return res / 2; } 凸包 在平面内，对于给定的一些点，包含这些点的最小凸多边形被称为凸包（Convex Hull）。 求凸包的一种方法是 Graham's Scan，算法的流程为： 选出横坐标最小（横坐标相同时纵座标最小）的点，作为极点，该点一定在凸包上； 对其它点按照与极点的极角排序，极角相同的按照与极点的距离排序； 用栈维护当前在凸包上的点，按顺序考虑每一个点是否可以替换栈顶的点。 这里极角是指，过极点 作水平向右的向量 ，则点 的极角为 。比较两个点 、 的极角，如果 经过逆时针旋转到 ，即 ，则 极角序较小。 枚举每一个点，考虑新加入一个点的影响： 当前已被加入到凸包中的点为 （极点）、、、，考虑新加入点 的影响 —— 相对于 向顺时针方向旋转了（即 ），此时这些边一定无法组成一个凸多边形。所以要将 点从凸包中删除，加入 点。这种情况我们称 的连线不合法。 加入一个点时，应当考虑与栈顶点的连线是否合法，如果不合法，则将栈顶点删除，继续考虑栈顶点，直到栈中只剩一个点或连线合法。 // 求凸包用的点 int n; Pt a[MAXN + 1]; // 凸包极角排序的比较函数 inline bool compare(const Pt &amp;a, const Pt &amp;b) { // 两个向量 Vec va = a - ::a[1], vb = b - ::a[1]; double t = cross(va, vb); if (!dcmp(t)) return t &gt; 0; // OA -&gt; OB 是逆时针，则 A 极角序在先 else return va.norm() &lt; vb.norm(); // norm 较小的长度较小 } struct Poly { std::vector&lt;Pt&gt; pts; // 求凸包（Convex），结果储存在自身 pts 中 void convex() { // 找出最左下角的点 int id = 1; for (int i = 1; i &lt;= n; i++) { if (a[i].x &lt; a[id].x || (a[i].x == a[id].x &amp;&amp; a[i].y &lt; a[id].y)) id = i; } if (id != 1) std::swap(a[1], a[id]); // 排序 std::sort(a + 2, a + n + 1, &amp;compare); // 极角序扫描 pts.push_back(a[1]); for (int i = 2; i &lt;= n; i++) { // 比较，如果最后一个点需要被删掉则弹出（pop_back） while (pts.size() &gt;= 2 &amp;&amp; cross(pts.back() - pts[pts.size() - 2], a[i] - pts.back()) &lt;= 0) pts.pop_back(); pts.push_back(a[i]); } } }; 完整代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; const int MAXN = 100000; const double EPS = 1e-8; // 带误差比较 inline bool dcmp(double x, double y = 0) { return fabs(x - y) &lt;= EPS; } /* * 向量（Vector）或点 * * 使用原点到一个点 (x, y) 的有向线段表示向量 * 从点 A 到点 B 的向量表示为 A - B */ typedef struct Vec { double x, y; Vec(double x = 0, double y = 0) : x(x), y(y) {} // 相加 Vec operator+(const Vec &amp;v) const { return Vec(x + v.x, y + v.y); } // 相减 Vec operator-(const Vec &amp;v) const { return Vec(x - v.x, y - v.y); } // 数乘（伸长、缩短） Vec operator*(double d) const { return Vec(x * d, y * d); } Vec operator/(const double d) const { return Vec(x / d, y / d); } // 范数，用来比较长度，等于长度的平方 double norm() const { return x * x + y * y; } } Pt; // 点乘 double dot(const Vec &amp;a, const Vec &amp;b) { return a.x * b.x + a.y * b.y; } // 叉乘 double cross(const Vec &amp;a, const Vec &amp;b) { return a.x * b.y - a.y * b.x; } // 线段（Segment），用两个点表示 struct Seg { Pt a, b; Seg(const Pt &amp;a, const Pt &amp;b) : a(a), b(b) {} // 线段包含点（点在线段上） bool include(const Pt &amp;p) { // PA × PB = 0：PA 与 PB 共线，即点在线段所在的直线上 // PA · PB = 0：PA 与 PB 方向不同（A 和 B 分别在 P 的两边），如果 PA · PB = 0 则 P = A 或 P = B return dcmp(cross(a - p, b - p)) &amp;&amp; dot(a - p, b - p) &lt;= 0; } }; // 直线，用两个点表示 struct Line { Pt a, b; Line() {} // 提供一个不需要参数的构造函数 Line(const Pt &amp;a, const Pt &amp;b) : a(a), b(b) {} bool include(const Pt &amp;p) const { return dcmp(cross(a - p, b - p)); } // 两直线关系（交点个数） // 0 表示平行（无交点） // 1 表示相交（一个交点） // -1 表示重合（无数个交点） static int relation(const Line &amp;a, const Line &amp;b) { if (a.include(b.a) &amp;&amp; a.include(b.b)) return -1; else if (dcmp(cross(a.b - a.a, b.b - b.a))) return 0; else return 1; } // 求两直线交点（需要保证两直线有交点） static Pt intersect(const Line &amp;a, const Line &amp;b) { double s1 = cross(b.a - a.a, b.b - a.a), s2 = cross(b.b - a.b, b.a - a.b); return a.a + (a.b - a.a) * s1 / (s1 + s2); } }; // 求凸包用的点 int n; Pt a[MAXN + 1]; // 凸包极角排序的比较函数 inline bool compare(const Pt &amp;a, const Pt &amp;b) { // 两个向量 Vec va = a - ::a[1], vb = b - ::a[1]; double t = cross(va, vb); if (!dcmp(t)) return t &gt; 0; // OA -&gt; OB 是逆时针，则 A 极角序在先 else return va.norm() &lt; vb.norm(); // norm 较小的长度较小 } struct Poly { std::vector&lt;Pt&gt; pts; bool include(const Pt &amp;p) const { int cnt = 0; // 判断与每条边有没有交点 for (size_t i = 0; i &lt; pts.size(); i++) { // 枚举相邻的每两个点 const Pt &amp;a = pts[i], &amp;b = pts[(i + 1) % pts.size()]; // 如果点 P 在边 AB 上 if (Seg(a, b).include(p)) return true; // 详见图 double d1 = a.y - p.y, d2 = b.y - p.y, tmp = cross(a - p, b - p); if ((tmp &gt;= 0 &amp;&amp; d1 &gt;= 0 &amp;&amp; d2 &lt; 0) || (tmp &lt;= 0 &amp;&amp; d1 &lt; 0 &amp;&amp; d2 &gt;= 0)) cnt++; } // 奇数的交点 return cnt % 2 == 1; } // 多边形面积（有向面积） double area() const { double res = 0; for (size_t i = 0; i &lt; pts.size(); i++) { // 枚举每两个点 const Pt &amp;a = pts[i], &amp;b = pts[(i + 1) % pts.size()]; res += cross(a, b); } return res / 2; } // 求凸包（Convex），结果储存在自身 pts 中 void convex() { // 找出最左下角的点 int id = 1; for (int i = 1; i &lt;= n; i++) { if (a[i].x &lt; a[id].x || (a[i].x == a[id].x &amp;&amp; a[i].y &lt; a[id].y)) id = i; } if (id != 1) std::swap(a[1], a[id]); // 排序 std::sort(a + 2, a + n + 1, &amp;compare); // 极角序扫描 pts.push_back(a[1]); for (int i = 2; i &lt;= n; i++) { // 比较，如果最后一个点需要被删掉则弹出（pop_back） while (pts.size() &gt;= 2 &amp;&amp; cross(a[i] - pts[pts.size() - 2], pts.back() - pts[pts.size() - 2]) &gt;= 0) pts.pop_back(); pts.push_back(a[i]); } } };]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「APIO2012」Dispatching - 左偏树]]></title>
    <url>%2Fapio2012-dispatching%2F</url>
    <content type="text"><![CDATA[给定一棵 个点的有根树，每个点有两个属性 与 ，现在你要指定一个点 ，并在 的子树内选取若干点（可以选取 自己），使得这些点的 的和不超过 ，而一个选取方案的价值为选取人数 ，求选取方案的最大价值。 链接 BZOJ 2809 题解 坑。 代码 #include &lt;cstdio&gt; #include &lt;queue&gt; const int MAXN = 100000; struct LeftTree { LeftTree *lc, *rc; long long dist, sum, x, size; LeftTree(long long x) : lc(NULL), rc(NULL), dist(0), sum(x), x(x), size(1) {} // 维护 size 和 sum void maintain() { size = (lc ? lc-&gt;size : 0) + (rc ? rc-&gt;size : 0) + 1; sum = (lc ? lc-&gt;sum : 0) + (rc ? rc-&gt;sum : 0) + x; } // 合并 a、b 两棵左偏树，将 a 作为根返回 static LeftTree *merge(LeftTree *a, LeftTree *b) { if (!a) return b; if (!b) return a; if (a-&gt;x &lt; b-&gt;x) std::swap(a, b); // 保证根 &gt;= 儿子 // 递归合并右子树 a-&gt;rc = merge(a-&gt;rc, b); // 如果右儿子距离更大了，需要交换左右儿子 if (!a-&gt;lc || a-&gt;lc-&gt;dist &lt; a-&gt;rc-&gt;dist) std::swap(a-&gt;lc, a-&gt;rc); // 计算新根的距离 a-&gt;dist = a-&gt;rc ? a-&gt;rc-&gt;dist + 1 : 0; a-&gt;maintain(); return a; } }; struct Node { struct Edge *e; long long c, l; LeftTree *lt; } N[MAXN + 1], *seq[MAXN + 1]; // 记录 BFS 序 struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {} }; inline void addEdge(int s, int t) { N[s].e = new Edge(&amp;N[s], &amp;N[t]); } inline void bfs() { std::queue&lt;Node *&gt; q; q.push(&amp;N[1]); int cnt = 0; while (!q.empty()) { Node *v = q.front(); q.pop(); // 记录 BFS 序 seq[++cnt] = v; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { q.push(e-&gt;t); } } } int main() { int n; long long m; scanf("%d %lld", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { int fa; scanf("%d", &amp;fa); if (fa) addEdge(fa, i); scanf("%lld %lld", &amp;N[i].c, &amp;N[i].l); // 创建左偏树 N[i].lt = new LeftTree(N[i].c); } bfs(); long long ans = 0; for (int i = n; i &gt;= 1; i--) { Node *v = seq[i]; // 将所有子节点加入 for (Edge *e = v-&gt;e; e; e = e-&gt;next) { v-&gt;lt = LeftTree::merge(v-&gt;lt, e-&gt;t-&gt;lt); } // 删除最大的节点，直到总和 &lt;= M while (v-&gt;lt-&gt;sum &gt; m) v-&gt;lt = LeftTree::merge(v-&gt;lt-&gt;lc, v-&gt;lt-&gt;rc); ans = std::max(ans, v-&gt;lt-&gt;size * v-&gt;l); } printf("%lld\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>BZOJ</tag>
        <tag>APIO</tag>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manacher 学习笔记]]></title>
    <url>%2Fmanacher-notes%2F</url>
    <content type="text"><![CDATA[Manacher 可在 的时间内求出一个字符串以每个位置为中心的最长回文子串。 为了避免分类讨论，在字符串的首部的尾部添加两个不同的在串中没有出现过的字符（这里分别使用 @ 和空白字符 \0），每两个字符之间加入另一个在串中没有出现过的字符（这里使用 $）。这样，原串中长度为奇数和偶数的回文串的长度均变为奇数，且原串中回文串的长度为新串回文串半径减一。 设置两个状态 和 ， 表示当前已找到的回文串中，向右延伸最远的中心位置， 表示其右端点。 设 表示（新串中）第 个位置的回文半径（回文串长度的一半，包括第 个字符）按从左到右的顺序求解，枚举到第 个字符时，分三种情况考虑： 设 为 关于 的对称点，即 。 ，即向右延伸最远的回文子串（黑色）没有覆盖 ，此时只有 。 且 ，即向右延伸最远的回文子串（黑色）覆盖了 ，并且以 为中心的最长回文子串完全与以 为中心的最长回文子串对称（蓝色），此时一定有 ，即 。 且 ，即向右延伸最远的回文子串（黑色）覆盖了 ，但没有覆盖以 为中心的最长回文子串的对称位置串，所以 只能取被覆盖的（黄色）一部分，即 。 代码（POJ 3974） #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 1000000; // s1 原串，s2 新串 char s1[MAXN + 2], s2[MAXN * 2 + 3]; int n, len, r[MAXN * 2 + 3]; inline void prepare() { n = strlen(s1); s2[++len] = '@'; // 边界字符 s2[++len] = ' ; for (int i = 0; i &lt; n; i++) { s2[++len] = s1[i]; s2[++len] = ' ; } s2[len + 1] = '\0'; // 使用 0 作为结束字符和边界字符 } inline void manacher() { // 新字符串首部为 '@'，尾部为 '\0'（空字符），中间为 ' int right = 0, mid = 0; // right 当前回文最右点，mid 是 right 对应的回文中心 for (int i = 1; i &lt;= len; i++) { int x; if (right &lt; i) x = 1; else x = std::min(r[mid * 2 - i], right - i); // 逐位匹配 while (s2[i + x] == s2[i - x]) ++x; // 更新最右点 if (i + x &gt; right) { right = i + x; mid = i; } r[i] = x; } } int main() { int T = 0; while (scanf("%s", s1), memcmp(s1, "END", 4) != 0) { prepare(); manacher(); // printf("%s\n", s2 + 1); // for (int i = 1; i &lt;= len; i++) printf("%d%c", r[i], i == len ? '\n' : ' '); int ans = 0; for (int i = 1; i &lt;= len; i++) ans = std::max(ans, r[i] - 1); printf("Case %d: %d\n", ++T, ans); len = 0; } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2565」最长双回文串 - Manacher]]></title>
    <url>%2Fbzoj-2565%2F</url>
    <content type="text"><![CDATA[输入串 ，求 的最长双回文子串 ，即可将 分为两部分 、（）且 和 都是回文串。 链接 BZOJ 2565 题解 首先用 Manacher 求出以每个位置为中心的最长回文半径 。 用 表示以第 个位置为最右字符的最长回文串长度， 表示以第 个位置为最左字符的最长回文串长度。扫描 ，更新每个回文串的两端点。 此时只有以每个位置为中心的最长回文子串的左右端点的 和 有效。注意到 一定不小于 ，对于 也有相似的结论。正反分别扫一遍，更新 和 即可。 最后枚举每一个分隔符 #，统计答案即可。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 1e5; char s1[MAXN + 2], s2[MAXN * 2 + 2]; int n, len, r[MAXN * 2 + 2]; inline void prepare() { n = strlen(s1 + 1); s2[++len] = '@'; s2[++len] = '#'; for (int i = 1; i &lt;= n; i++) { s2[++len] = s1[i]; s2[++len] = '#'; } s2[++len] = '\0'; } inline void manacher() { int right = 0, pos = -1; for (int i = 1; i &lt;= len; i++) { int x; if (right &lt; i) x = 1; else x = std::min(r[2 * pos - i], right - i); while (s2[i - x] == s2[i + x]) x++; if (x + i &gt; right) { right = x + i; pos = i; } r[i] = x; } } int main() { scanf("%s", s1 + 1); prepare(); manacher(); // puts(s2 + 1); // for (int i = 1; i &lt;= len; i++) printf("%d%c", r[i], i == len ? '\n' : ' '); // for (int i = 1; i &lt;= len; i++) printf("%c%c", s2[i], i == len ? '\n' : ' '); static int right[MAXN * 2 + 2], left[MAXN * 2 + 2]; for (int i = 1; i &lt;= len; i++) { if (i + r[i] - 1 &lt;= len) right[i + r[i] - 1] = std::max(right[i + r[i] - 1], r[i] - 1); if (i - r[i] + 1 &gt;= 0) left[i - r[i] + 1] = std::max(left[i - r[i] + 1], r[i] - 1); } for (int i = 2; i &lt;= len; i++) { left[i] = std::max(left[i], left[i - 1] - 1); // if (s2[i - 1 - right[i - 1]] == s2[i + 1]) right[i] = std::max(right[i], right[i - 1] + 1); } for (int i = len - 1; i &gt;= 1; i--) { right[i] = std::max(right[i], right[i + 1] - 1); // if (s2[i + 1 + left[i + 1]] == s2[i - 1]) left[i] = std::max(left[i], left[i + 1] + 1); } // for (int i = 1; i &lt;= len; i++) printf("%d%c", right[i], i == len ? '\n' : ' '); // for (int i = 1; i &lt;= len; i++) printf("%d%c", left[i], i == len ? '\n' : ' '); int ans = 0; for (int i = 1; i &lt;= len; i++) { if (s2[i] == '#') { ans = std::max(ans, right[i] + left[i]); } } printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 3630」Phone List - Trie]]></title>
    <url>%2Fpoj-3630%2F</url>
    <content type="text"><![CDATA[给 个字符串，求有没有一个字符串是另一个字符串的前缀。 链接 POJ 3630 题解 建立 Trie，依次插入每个字符串，在插入时判断。 判断当前字符串的前缀已被插入：插入时在路径上遇到一个单词节点。 判断当前字符串是已插入字符串的前缀：插入时最后一个节点已存在。 为防止 TLE，需要内存池。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;new&gt; const int MAXN = 10000; struct Node { Node *ch[10]; bool isWord; Node(bool isWord = false) : isWord(isWord) { for (int i = 0; i &lt; 10; i++) ch[i] = NULL; } } *root, _pool[MAXN * 10], *_curr; bool insert(char *begin, char *end) { Node **v = &amp;root; bool res = false; for (char *p = begin; p != end; p++) { if (!*v) *v = new (_curr++) Node(false); else if ((*v)-&gt;isWord) res = true; v = &amp;(*v)-&gt;ch[*p]; } if (!*v) *v = new (_curr++) Node(true); else res = true; return res; } void init() { root = NULL; _curr = _pool; } int main() { int T; scanf("%d", &amp;T); while (T--) { int n; scanf("%d", &amp;n); init(); bool ans = false; while (n--) { static char s[10 + 2]; scanf("%s", s + 1); int len = strlen(s + 1); for (int i = 1; i &lt;= len; i++) s[i] -= '0'; if (insert(s + 1, s + len + 1)) ans = true; } puts(ans ? "NO" : "YES"); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Trie</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[风景这边独好]]></title>
    <url>%2Fhere-the-best-sight%2F</url>
    <content type="text"><![CDATA[晚饭后回到学校，在楼前停了下来，驻足观赏着这里的夜景。自己学校的风景早已习以为常，而对这边的一草一木，都有一种莫名的向往。 大概这是一种自然的美，好像已经很久没有这样接近自然了。闷在屋子里久了，出来走走，也是一种不一样的心情吧。 周围一个人都没有，虫鸣声声声入耳，显得格外的清静。好像一下子远离了周围的繁华街市。 似乎一切不快乐的事都忘掉了，不需要去想任何事，仿佛置身于这个忙碌的世界之外，来到了心中的仙境一般。 突然感觉，自己的压力太大了，从来没有过什么机会去放松，这样散一散心，的确轻快了许多。大概，只有这片天空，会一直陪伴着我，见证我的成长吧。 这便是最简单，而又最难得的，幸福吧。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[欧拉回路学习笔记]]></title>
    <url>%2Feuler-circuit-notes%2F</url>
    <content type="text"><![CDATA[若图 中存在这样一个环，使得 中每条边都恰好在环上出现一次，则称为欧拉回路。 具有欧拉回路的图称为欧拉图。 欧拉图的判定 一个无向图是欧拉图，当且仅当该图所有节点度均为偶数，且除孤立点（度为零的点）外是连通图。 一个有向图是欧拉图，当且仅当该图所有节点入度等于出度，且除孤立点（度为零的点）外是连通图。 求欧拉回路 从一个非孤立点开始 DFS，点可以重复经过，每次任意走一条边并将这条边从邻接表中删除（如果是无向图，其反向边也要被标记为删除），最终所有边一定会都会被经过。 DFS 回溯时记录每一条边，最终将记录的逆序即为欧拉回路。 代码（UOJ #117） #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; const int MAXN = 1e5; struct Node { struct Edge *e; int deg; // 无向图 int inDeg, outDeg; // 有向图 } N[MAXN + 1]; struct Edge { int id; Node *s, *t; bool vis; Edge *next, *revEdge; Edge(int id, Node *s, Node *t) : id(id), s(s), t(t), vis(false), next(s-&gt;e) {} }; int T; inline void addEdge(int id, int s, int t) { Edge *e1 = N[s].e = new Edge(id, &amp;N[s], &amp;N[t]); if (T == 1) { Edge *e2 = N[t].e = new Edge(-id, &amp;N[t], &amp;N[s]); e1-&gt;revEdge = e2; e2-&gt;revEdge = e1; // 因为有自环，不能简单地 N[s]-&gt;firstEdge-&gt;revEdge = N[t].e，此时正向边已经不是 firstEdge 了 N[s].deg++; N[t].deg++; } else { N[s].outDeg++; N[t].inDeg++; } } std::vector&lt;Edge *&gt; path; // 无向图 inline void dfs1(Node *v) { while (v-&gt;e) { Edge *e = v-&gt;e; v-&gt;e = v-&gt;e-&gt;next; // 从邻接表中删边，但实际上未释放内存 if (e-&gt;vis) continue; // 如果它的反向边被删掉了，它的 vis 会被赋值为 true e-&gt;revEdge-&gt;vis = true; // 标记反向边已被访问 dfs1(e-&gt;t); path.push_back(e); } } // 有向图 inline void dfs2(Node *v) { while (v-&gt;e) { Edge *e = v-&gt;e; v-&gt;e = v-&gt;e-&gt;next; // 从邻接表中删边，但实际上未释放内存 dfs2(e-&gt;t); path.push_back(e); } } int main() { scanf("%d", &amp;T); int n, m; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v); addEdge(i, u, v); // 带编号加边 } int haveAns = true; if (T == 1) { for (int i = 1; i &lt;= n; i++) { if (N[i].deg % 2 == 1) // 度为奇数 { haveAns = false; break; } } } else { for (int i = 1; i &lt;= n; i++) { if (N[i].inDeg != N[i].outDeg) // 入度不等于出度 { haveAns = false; break; } } } if (!haveAns) puts("NO"); else { if (T == 1) { for (int i = 1; i &lt;= n; i++) { if (N[i].deg) // 从一个非孤立点开始搜 { dfs1(&amp;N[i]); break; } } } else { for (int i = 1; i &lt;= n; i++) { if (N[i].outDeg) // 从一个非孤立点开始搜 { dfs2(&amp;N[i]); break; } } } if (path.size() != m) // 如果不能经过所有边 { puts("NO"); } else { puts("YES"); for (int i = path.size() - 1; i &gt;= 0; i--) { printf("%d%c", path[i]-&gt;id, i == 0 ? '\n' : ' '); } } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>图论</tag>
        <tag>欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1718」Redundant Paths - 割边]]></title>
    <url>%2Fbzoj-1718%2F</url>
    <content type="text"><![CDATA[给一个无向连通图，求至少加多少条边使得每两个点之间都存在至少两条路径，即使图没有割边。 链接 BZOJ 1718 POJ 3177 题解 求出边双连通分量后缩点，设叶子数量为 ，则答案为 。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 5000; const int MAXM = 10000; struct Node { struct Edge *firstEdge, *inEdge; int dfn, low, deg; bool vis; Node *fa; } N[MAXN + 1]; struct Edge { Node *from, *to; bool isCut; Edge *next, *revEdge; /* 不要忘记初始化 */ Edge(Node *from, Node *to) : from(from), to(to), isCut(false), next(from-&gt;firstEdge) {} } *E[MAXM + 1]; // 数组里存边的指针 inline Edge *addEdge(int from, int to) { N[from].firstEdge = new Edge(&amp;N[from], &amp;N[to]); N[to].firstEdge = new Edge(&amp;N[to], &amp;N[from]); N[from].firstEdge-&gt;revEdge = N[to].firstEdge; N[to].firstEdge-&gt;revEdge = N[from].firstEdge; return N[from].firstEdge; // 返回一条边 } int n, cnt; inline void tarjan(Node *v) { static int ts; v-&gt;dfn = v-&gt;low = ++ts; v-&gt;vis = true; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;revEdge == v-&gt;inEdge) continue; // 判掉通过同一条边（互为反向边的两条有向边）走回去的情况 if (!e-&gt;to-&gt;vis) { e-&gt;to-&gt;fa = v; e-&gt;to-&gt;inEdge = e; tarjan(e-&gt;to); v-&gt;low = std::min(v-&gt;low, e-&gt;to-&gt;low); if (e-&gt;to-&gt;low &gt; v-&gt;dfn) // 注意没有等于，如果 e-&gt;to 通过其子节点的返祖边走到 v，e 就不是割边 { // 或者当 v 和 e-&gt;to 之间有多条重边时，都不会是割边 e-&gt;isCut = e-&gt;revEdge-&gt;isCut = true; } } else { v-&gt;low = std::min(v-&gt;low, e-&gt;to-&gt;dfn); } } } // 并查集 struct UFS { int fa[MAXN + 1]; void init(int n) { for (int i = 1; i &lt;= n; i++) fa[i] = i; } int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); } void merge(int x, int y) { fa[find(x)] = find(y); } } ufs; int main() { int m; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v); // 存储每一条 u 到 v 的边 E[i] = addEdge(u, v); } for (int i = 1; i &lt;= n; i++) { if (!N[i].vis) { tarjan(&amp;N[i]); } } ufs.init(n); // 并查集不要忘记初始化 for (int i = 1; i &lt;= m; i++) { // 并查集实现缩点，把非割边的两端点合并 if (!E[i]-&gt;isCut) ufs.merge(E[i]-&gt;from - N, E[i]-&gt;to - N); } for (int i = 1; i &lt;= m; i++) // 数组中只存了一个方向的边，不需处理正向反向边的问题 { // 将割边加入到新图中，统计每个节点的度 if (E[i]-&gt;isCut) { // printf("cutEdge: (%lu, %lu)\n", E[i]-&gt;from - N, E[i]-&gt;to - N); N[ufs.find(E[i]-&gt;from - N)].deg++; N[ufs.find(E[i]-&gt;to - N)].deg++; } } int leaves = 0; for (int i = 1; i &lt;= n; i++) { if (ufs.find(i) == i) // 枚举每个连通块（用并查集中的每个根节点代表每个连通块，即每个边双连通分量） { if (N[i].deg == 1) // 统计叶子节点的数量 { leaves++; } } } // printf("leaves = %d\n", leaves); printf("%d\n", (leaves + 1) / 2); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>USACO</tag>
        <tag>割边</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tarjan 点双连通分量学习笔记]]></title>
    <url>%2Ftarjan-bcc-notes%2F</url>
    <content type="text"><![CDATA[点双连通分量是一个极大的子图，满足图中删去任何一个点都不会改变图的连通性。 性质 点双连通分量中没有割点。 若干个点双连通分量以割点相连接。 原图中的每个割点可能属于多个点双连通分量，其它点只可能属于一个点双连通分量。 算法 Tarjan 求割点过程中维护一个栈，每次找到一条边（树边或非树边）时将边入栈。回溯时找到一个割点后，将栈顶的边直到当前走到割点的这条边全部出栈，这些边的邻接点构成了一个点双连通分量。 代码（POJ 1523） #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;stack&gt; #include &lt;algorithm&gt; const int MAXN = 1000; struct Node { struct Edge *firstEdge, *inEdge; int dfn, low; bool vis, isCut; Node *fa; std::vector&lt;struct BCC *&gt; inBCC; // 一个点所属于的双连通分量们（只有割点会属于多个双连通分量） } N[MAXN + 1]; struct Edge { Node *from, *to; Edge *next, *revEdge; // 记录反向边 Edge(Node *from, Node *to) : from(from), to(to), next(from-&gt;firstEdge) {} }; struct BCC { std::vector&lt;Node *&gt; nodes; // 可以记录，如，双连通分量中有哪些点 } bccs[MAXN + 1]; int cnt; inline void addEdge(int from, int to) { N[from].firstEdge = new Edge(&amp;N[from], &amp;N[to]); N[to].firstEdge = new Edge(&amp;N[to], &amp;N[from]); N[from].firstEdge-&gt;revEdge = N[to].firstEdge; N[to].firstEdge-&gt;revEdge = N[from].firstEdge; } inline void tarjan(Node *v) { static int ts = 0; static std::stack&lt;Edge *&gt; s; v-&gt;dfn = v-&gt;low = ++ts; v-&gt;vis = true; int childCnt = 0; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;revEdge == v-&gt;inEdge) continue; // 判断由父节点到该节点的边的反向边走回父节点 if (!e-&gt;to-&gt;vis) { s.push(e); // 树边入栈 childCnt++; e-&gt;to-&gt;fa = v; e-&gt;to-&gt;inEdge = e; // 记录入边 tarjan(e-&gt;to); v-&gt;low = std::min(v-&gt;low, e-&gt;to-&gt;low); if (e-&gt;to-&gt;low &gt;= v-&gt;dfn) // 找到割点 { v-&gt;isCut = true; // 根总是会在这里被认为是割点，稍后判断根是否为真正的割点 // 记录点双连通分量 Edge *tmp; BCC *bcc = &amp;bccs[++cnt]; do { tmp = s.top(); s.pop(); // 如果这个点「所属于的最后一个双连通分量」不是「当前的双连通分量 bcc」 // 因为这些边可能枚举到重复的点，为了不重复记录一个点所属于的双连通分量 if (tmp-&gt;from-&gt;inBCC.empty() || tmp-&gt;from-&gt;inBCC.back() != bcc) { tmp-&gt;from-&gt;inBCC.push_back(bcc); bcc-&gt;nodes.push_back(tmp-&gt;from); } // 同理 if (tmp-&gt;to-&gt;inBCC.empty() || tmp-&gt;to-&gt;inBCC.back() != bcc) { tmp-&gt;to-&gt;inBCC.push_back(bcc); bcc-&gt;nodes.push_back(tmp-&gt;to); } } while (tmp != e); // 直到当前边为止，类比强连通分量的求法 } } else { s.push(e); // 返祖边入栈 v-&gt;low = std::min(v-&gt;low, e-&gt;to-&gt;dfn); } } if (!v-&gt;fa &amp;&amp; childCnt &lt; 2) v-&gt;isCut = false; // 如果根的子节点数量不够 2，则它不是一个割点 } int main() { int T = 0; while (1) { ++T; int n = 0; while (1) { int u, v; scanf("%d", &amp;u); if (u == 0) break; scanf("%d", &amp;v); n = std::max(n, u); n = std::max(n, v); addEdge(u, v); } if (n == 0) break; for (int i = 1; i &lt;= n; i++) { if (!N[i].vis) tarjan(&amp;N[i]); } if (T != 1) putchar('\n'); printf("Network #%d\n", T); bool flag = false; for (int i = 1; i &lt;= n; i++) { if (N[i].isCut) { printf(" SPF node %d leaves %d subnets\n", i, int(N[i].inBCC.size())); flag = true; } } if (!flag) puts(" No SPF nodes"); for (int i = 1; i &lt;= n; i++) { for (Edge *&amp;e = N[i].firstEdge, *next; e; next = e-&gt;next, delete e, e = next); N[i].dfn = N[i].low = 0; N[i].isCut = N[i].vis = false; N[i].fa = NULL; N[i].inEdge = NULL; N[i].inBCC.clear(); } for (int i = 1; i &lt;= cnt; i++) { bccs[i].nodes.clear(); } cnt = 0; if (n == 0) break; } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>Tarjan</tag>
        <tag>图论</tag>
        <tag>双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2005」王室联邦 - 树分块]]></title>
    <url>%2Fscoi2005-royal%2F</url>
    <content type="text"><![CDATA[他想把他的国家划分成若干个省，每个省都由他们王室联邦的一个成员来管理。他的国家有 个城市，编号为 。一些城市之间有道路相连，任意两个不同的城市之间有且仅有一条直接或间接的道路。 每个省至少要有 个城市，最多只有 个城市。 每个省必须有一个省会，这个省会可以位于省内，也可以在该省外。但是该省的任意一个城市到达省会所经过的道路上的城市（除了最后一个城市，即该省省会）都必须属于该省。 一个城市可以作为多个省的省会。 链接 BZOJ 1086 题解 DFS 整棵树，处理每个节点时，将其一部分子节点分块，将未被分块的子节点返回。 枚举 每个子节点 ，递归处理子树后将每个子节点返回的未被分块的节点（下文有解释）累加到集合 中，一但累加的数量达到 ，就把集合 中的点作为一个新的块，并将当前节点 作为该块的「省会」，然后清空 继续枚举下一棵子树。 处理完所有子树后，将 自身也加入集合 ，此时剩余在集合 中的节点为「未被分块的节点」，这些节点被返回到上一层。显然， 大小最大为 （ 个子树上的节点加上 本身）。 即，使用上述分块方法，整棵树 DFS 完成时，每个块的大小最大为 。 DFS 完成整棵树后，剩余在集合 中的点最多有 个，将这些点加入到最后一个块（DFS 根节点时创建的最后一个块）中，这个块的大小最大为 。 集合 可以用一个栈来维护，用进入节点时的栈顶到当前栈顶之间的元素表示集合 。 代码 #include &lt;cstdio&gt; #include &lt;stack&gt; const int MAXN = 1000; struct Node { struct Edge *e; struct Block *block; } N[MAXN + 1]; struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {} }; struct Block { Node *top; } blocks[MAXN + 1]; inline void addEdge(int s, int t) { N[s].e = new Edge(&amp;N[s], &amp;N[t]); N[t].e = new Edge(&amp;N[t], &amp;N[s]); } int n, b, blockCount; std::stack&lt;Node *&gt; s; inline void dfs(Node *v, Node *fa) { size_t status = s.size(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;t != fa) { dfs(e-&gt;t, v); if (int(s.size() - status) &gt;= b) { blocks[++blockCount].top = v; while (s.size() != status) { Node *u = s.top(); s.pop(); u-&gt;block = &amp;blocks[blockCount]; } } } } s.push(v); } inline void solve() { dfs(&amp;N[1], NULL); while (!s.empty()) { Node *u = s.top(); s.pop(); u-&gt;block = &amp;blocks[blockCount]; } } int main() { scanf("%d %d", &amp;n, &amp;b); for (int i = 1; i &lt;= n - 1; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v); addEdge(u, v); } solve(); printf("%d\n", blockCount); for (int i = 1; i &lt;= n; i++) printf("%lu%c", N[i].block - blocks, i == n ? '\n' : ' '); for (int i = 1; i &lt;= blockCount; i++) printf("%lu%c", blocks[i].top - N, i == blockCount ? '\n' : ' '); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分块</tag>
        <tag>BZOJ</tag>
        <tag>SCOI</tag>
        <tag>树分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2013」作业 - 莫队]]></title>
    <url>%2Fahoi2013-homework%2F</url>
    <content type="text"><![CDATA[给一个长度为 的序列，每次查询一个区间 内满足 的 的数量和不重复的 的数量。 链接 BZOJ 3236 题解 莫队处理询问，用一个树状数组维护当前区间的所有数。用一个数组维护当前区间每个数的出现次数，用另一个树状数组维护当前区间不重复的数，仅在每个数第一次出现或最后一次删除的时候对树状数组操作。 需要离散化。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;utility&gt; #include &lt;algorithm&gt; const int MAXN = 100000; const int MAXM = 1000000; int blockSize; struct Query { int l, r, a, b; std::pair&lt;int, int&gt; *ans; bool operator&lt;(const Query &amp;other) const { if (l / blockSize == other.l / blockSize) return r &lt; other.r; else return l / blockSize &lt; other.l / blockSize; } } Q[MAXM + 1]; int n, m, a[MAXN + 1]; struct BIT { int a[MAXN + MAXM * 2 + 1], n; void init(int n) { this-&gt;n = n; } static int lowbit(int x) { return x &amp; -x; } void update(int pos, int x) { for (int i = pos; i &lt;= n; i += lowbit(i)) a[i] += x; } int query(int pos) { int res = 0; for (int i = pos; i &gt; 0; i -= lowbit(i)) res += a[i]; return res; } int query(int l, int r) { return query(r) - query(l - 1); } } bit1, bit2; inline std::pair&lt;int, int&gt; calc(int a, int b) { return std::make_pair(bit1.query(a, b), bit2.query(a, b)); } int cnt[MAXN + MAXM + 2 + 1]; inline void extend(int l, int r, bool left, int d) { int pos = left ? l : r; bit1.update(a[pos], d); if (d == 1) { if (++cnt[a[pos]] == 1) bit2.update(a[pos], 1); } else { if (--cnt[a[pos]] == 0) bit2.update(a[pos], -1); } } inline void solve() { int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) { while (r &lt; Q[i].r) extend(l, ++r, false, 1); while (r &gt; Q[i].r) extend(l, r--, false, -1); while (l &gt; Q[i].l) extend(--l, r, true, 1); while (l &lt; Q[i].l) extend(l++, r, true, -1); *Q[i].ans = calc(Q[i].a, Q[i].b); } } inline void prepare() { static int set[MAXN + MAXM * 2 + 1]; std::copy(a + 1, a + n + 1, set + 1); for (int i = 1; i &lt;= m; i++) set[n + i] = Q[i].a; for (int i = 1; i &lt;= m; i++) set[n + m + i] = Q[i].b; std::sort(set + 1, set + n + m * 2 + 1); int *end = std::unique(set + 1, set + n + m * 2 + 1); for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(set + 1, end, a[i]) - set; for (int i = 1; i &lt;= m; i++) Q[i].a = std::lower_bound(set + 1, end, Q[i].a) - set; for (int i = 1; i &lt;= m; i++) Q[i].b = std::lower_bound(set + 1, end, Q[i].b) - set; int cnt = end - (set + 1); bit1.init(cnt); bit2.init(cnt); } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); static std::pair&lt;int, int&gt; ans[MAXN + 1]; for (int i = 1; i &lt;= m; i++) { scanf("%d %d %d %d", &amp;Q[i].l, &amp;Q[i].r, &amp;Q[i].a, &amp;Q[i].b); Q[i].ans = &amp;ans[i]; } prepare(); blockSize = floor(sqrt(n) + 1); std::sort(Q + 1, Q + m + 1); solve(); for (int i = 1; i &lt;= m; i++) printf("%d %d\n", ans[i].first, ans[i].second); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>AHOI</tag>
        <tag>BZOJ</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3289」Mato 的文件管理 - 莫队]]></title>
    <url>%2Fbzoj-3289%2F</url>
    <content type="text"><![CDATA[给一个长度为 的序列，每次求一个区间 的逆序对数。 链接 BZOJ 3289 题解 对序列离散化，应用莫队算法，用树状数组维护当前区间的数，每次左边或右边加入一个数时在树状数组中查询小于或大于该数的数量来统计答案。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;utility&gt; #include &lt;algorithm&gt; const int MAXN = 100000; const int MAXM = 1000000; int blockSize; struct Query { int l, r, a, b; std::pair&lt;int, int&gt; *ans; bool operator&lt;(const Query &amp;other) const { if (l / blockSize == other.l / blockSize) return r &lt; other.r; else return l / blockSize &lt; other.l / blockSize; } } Q[MAXM + 1]; int n, m, a[MAXN + 1]; struct BIT { int a[MAXN + MAXM * 2 + 1], n; void init(int n) { this-&gt;n = n; } static int lowbit(int x) { return x &amp; -x; } void update(int pos, int x) { for (int i = pos; i &lt;= n; i += lowbit(i)) a[i] += x; } int query(int pos) { int res = 0; for (int i = pos; i &gt; 0; i -= lowbit(i)) res += a[i]; return res; } int query(int l, int r) { return query(r) - query(l - 1); } } bit1, bit2; inline std::pair&lt;int, int&gt; calc(int a, int b) { return std::make_pair(bit1.query(a, b), bit2.query(a, b)); } int cnt[MAXN + MAXM + 2 + 1]; inline void extend(int l, int r, bool left, int d) { int pos = left ? l : r; bit1.update(a[pos], d); if (d == 1) { if (++cnt[a[pos]] == 1) bit2.update(a[pos], 1); } else { if (--cnt[a[pos]] == 0) bit2.update(a[pos], -1); } } inline void solve() { int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) { while (r &lt; Q[i].r) extend(l, ++r, false, 1); while (r &gt; Q[i].r) extend(l, r--, false, -1); while (l &gt; Q[i].l) extend(--l, r, true, 1); while (l &lt; Q[i].l) extend(l++, r, true, -1); *Q[i].ans = calc(Q[i].a, Q[i].b); } } inline void prepare() { static int set[MAXN + MAXM * 2 + 1]; std::copy(a + 1, a + n + 1, set + 1); for (int i = 1; i &lt;= m; i++) set[n + i] = Q[i].a; for (int i = 1; i &lt;= m; i++) set[n + m + i] = Q[i].b; std::sort(set + 1, set + n + m * 2 + 1); int *end = std::unique(set + 1, set + n + m * 2 + 1); for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(set + 1, end, a[i]) - set; for (int i = 1; i &lt;= m; i++) Q[i].a = std::lower_bound(set + 1, end, Q[i].a) - set; for (int i = 1; i &lt;= m; i++) Q[i].b = std::lower_bound(set + 1, end, Q[i].b) - set; int cnt = end - (set + 1); bit1.init(cnt); bit2.init(cnt); } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); static std::pair&lt;int, int&gt; ans[MAXN + 1]; for (int i = 1; i &lt;= m; i++) { scanf("%d %d %d %d", &amp;Q[i].l, &amp;Q[i].r, &amp;Q[i].a, &amp;Q[i].b); Q[i].ans = &amp;ans[i]; } prepare(); blockSize = floor(sqrt(n) + 1); std::sort(Q + 1, Q + m + 1); solve(); for (int i = 1; i &lt;= m; i++) printf("%d %d\n", ans[i].first, ans[i].second); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>BZOJ</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2120」数颜色 - 带修改莫队]]></title>
    <url>%2Fbzoj-2120%2F</url>
    <content type="text"><![CDATA[墨墨购买了一套 支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。 墨墨会像你发布如下指令： Q L R 代表询问你从第 支画笔到第 支画笔中共有几种不同颜色的画笔。 R P Col 把第 支画笔替换为颜色 。 为了满足墨墨的要求，你知道你需要干什么了吗？ 链接 BZOJ 2120 题解 为每个修改操作分配一个时刻，为每个查询记录其时刻，即受到了前多少次修改的影响。 将序列分块，每块 ，将询问排序，左端点所在块为第一关键字，右端点所在块为第二关键字，查询时刻为第三关键字，莫队转移即可。 注意需要记录每次修改的旧值，以便撤销。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; const int MAXN = 10000; const int MAXM = 10000; const int MAXX = 1e6; int n, a[MAXN + 1], blockSize; struct Update { int pos, oldVal, newVal; } b[MAXM + 1]; int q, ans[MAXM + 1], cnt[MAXX + 1]; struct Query { int id, l, r, time, block; bool operator&lt;(const Query &amp;other) const { if (l / blockSize == other.l / blockSize) { if (r / blockSize == other.r / blockSize) { return time &lt; other.time; } else return r / blockSize &lt; other.r / blockSize; } else return l / blockSize &lt; other.l / blockSize; } } Q[MAXM + 1]; inline int extend(int l, int r, bool left, int d) { if (left) { if (d == 1) { if (++cnt[a[l]] == 1) return 1; else return 0; } else { if (--cnt[a[l]] == 0) return -1; else return 0; } } else { if (d == 1) { if (++cnt[a[r]] == 1) return 1; else return 0; } else { if (--cnt[a[r]] == 0) return -1; else return 0; } } } inline int update(int l, int r, int time, int d) { Update x = b[time]; int res = 0; if (d == 1) { a[x.pos] = x.newVal; if (x.pos &gt;= l &amp;&amp; x.pos &lt;= r) { if (--cnt[x.oldVal] == 0) res--; if (++cnt[x.newVal] == 1) res++; } } else { if (x.pos &gt;= l &amp;&amp; x.pos &lt;= r) { if (--cnt[x.newVal] == 0) res--; if (++cnt[x.oldVal] == 1) res++; } a[x.pos] = x.oldVal; } return res; } inline void prepare(int t) { static int newA[MAXN + 1]; std::copy(a + 1, a + n + 1, newA + 1); for (int i = 1; i &lt;= t; i++) { b[i].oldVal = newA[b[i].pos]; newA[b[i].pos] = b[i].newVal; } } inline void solve() { int l = 1, r = 0, time = 0, ans = 0; for (int i = 1; i &lt;= q; i++) { while (r &lt; Q[i].r) ans += extend(l, ++r, false, 1); while (r &gt; Q[i].r) ans += extend(l, r--, false, -1); while (l &gt; Q[i].l) ans += extend(--l, r, true, 1); while (l &lt; Q[i].l) ans += extend(l++, r, true, -1); while (time &lt; Q[i].time) ans += update(l, r, ++time, 1); while (time &gt; Q[i].time) ans += update(l, r, time--, -1); ::ans[Q[i].id] = ans; } } int main() { int m, t = 0; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= m; i++) { char cmd[2]; scanf("%s", cmd); if (cmd[0] == 'Q') { q++; Q[q].id = q; scanf("%d %d", &amp;Q[q].l, &amp;Q[q].r); Q[q].time = t; } else { t++; scanf("%d %d", &amp;b[t].pos, &amp;b[t].newVal); } } prepare(t); blockSize = floor(pow(n, 2.0 / 3) + 1); std::sort(Q + 1, Q + q + 1); solve(); for (int i = 1; i &lt;= q; i++) printf("%d\n", ans[i]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>BZOJ</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RMQ 模板]]></title>
    <url>%2Frmq-template%2F</url>
    <content type="text"><![CDATA[RMQ 稀疏表（Sparse Table）的模板。 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 100000; const int MAXN_LOG = 17; // Math.log2(100000) = 16.609640474436812 int n, a[MAXN + 1], st[MAXN + 1][MAXN_LOG + 1], logx[MAXN + 1]; // 不能直接叫 log inline void sparseTable() { for (int i = 1; i &lt;= n; i++) { int t = 0; while ((1 &lt;&lt; (t + 1)) &lt;= i) t++; logx[i] = t; } for (int i = 1; i &lt;= n; i++) st[i][0] = a[i]; // 初始值，以每个位置开始 2 ^ 0 = 1 长度的区间，即自身 for (int j = 1; j &lt;= logx[n]; j++) { for (int i = 1; i &lt;= n; i++) { // 判断当前要计算的区间是否越界 if (i + (1 &lt;&lt; (j - 1)) &lt;= n) st[i][j] = std::max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); else st[i][j] = st[i][j - 1]; } } } inline int rmq(int l, int r) { int t = logx[r - l]; return std::max(st[l][t], st[r - (1 &lt;&lt; t) + 1][t]); // 左右两个区间，恰好覆盖 } int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); sparseTable(); int m; scanf("%d", &amp;m); for (int i = 1; i &lt;= m; i++) { int l, r; scanf("%d %d", &amp;l, &amp;r); printf("%d\n", rmq(l, r)); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法模板</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2008」糖果雨 - 坐标变换 + 二维树状数组]]></title>
    <url>%2Fnoi2008-candy%2F</url>
    <content type="text"><![CDATA[在一个长度为 的区间上，有以下操作： 在 时刻，出现一条线段 ，这条线段将要向左或向右移动； 在 时刻查询与线段 有公共点的线段有多少； 在 时刻某条线段消失。 每一时刻，每条线段都会移动，线段的左端点最小为 ，当一条向左移动的线段左端点碰到 时，下一时刻它会改为向右移动；当一条向右移动的线段左端点碰到 时，下一时刻它会改为向左移动。 链接 BZOJ 1062 题解 首先，考虑将整个区间翻倍，变成 。原本向右移动的线段，仍然在原来的位置上；原本移动到当线段左端点触碰右边界时改变移动方向，现在使这些线段继续向右移动，直到左端点触碰到 ，立即回到 位置。这样转化保证了以 为周期的性质不变。 对于一条在 时刻出现的线段 ，我们可以求出它到达 位置（在模 的意义下）时的时刻，设它为 （）。如果线段向右移动，则 ，否则 。设 ，即线段长度。这样，所有线段均可化为 的形式。 考虑对每一次查询有贡献的点，在 时刻查询与 有公共点的线段数量，首先考虑当 时的简化问题，并且只考虑题意中在 时刻向右运动的线段（转化后左端点在 内）： 如果一条线段在 时刻出现在 位置，那么它的长度至少需要至少 ； 如果一条线段在 时刻出现在 位置，注意这里是模意义下的 时刻，实际上它可能是在整体时间的前一个周期的 时刻出现在 位置，这个周期的 时刻，它移动到 位置，所以只需要长度至少为 ； 如果在 位置，以此类推，需要线段的长度至少为 。 …… 如果在 时刻出现，需要线段的长度至少为 ； …… 如果在 时刻出现，需要线段的长度至少为 ； 如果在 时刻出现，这个周期的 时刻，它移动到 位置，已经越过查询的区间，此时这条线段对答案没有贡献。 对答案有贡献的区域在平面上组成了一个五边形，它是由一个矩形去掉一个等腰三角形后得到的（图中的棕黄色部分）。在它的上边和下边分别补上一个三角形，得到一个如下的平行四边形： 继续考虑正时刻出现的线段，如果一条线段 在 时刻出现在 位置，并开始向右移动，那么考虑原题中对移动方向的描述，假设有另一条线段 在 时刻出现在 位置，那么最初向右移动时， 总在 左边一个单位处（ 较早开始移动）。 移动到右边界时，比 早一个单位时间开始变为向左移动，所以，在向左移动的过程中， 总在 右边一个单位处。 线段 一定是在上一个周期或之前周期的 时刻出现的，在这个周期的 时刻，它移动了 个单位，到达 处，而这里恰好对应了原题中向左移动且左端点在 位置处。这时线段 的长度至少要 才能对答案有贡献。 以此类推： 如果一条线段在 时刻出现在 位置，那么它的长度至少需要 ； …… 如果在 时刻出现，需要线段的长度为 ； …… 如果在 时刻出现，需要线段的长度为 ； 如果在 时刻出现，这个周期的 时刻，它移动到 位置，还没有到达查询的区间，此时这条线段对答案没有贡献。 对答案有贡献的区域在平面上组成了一个与之前的五边形对称的图形，使用类似的方法将其补为一个平行四边形： 现在考虑查询 的情况，显然在模意义下，。如果查询 时刻的某个区间，则相当于让所有线段多移动 个单位时间，然后查询 时刻的这个区间，即相当于所有线段的产生时间都早了一个单位时间，即把坐标系内所有点向左平移一个单位 —— 将查询的平行四边形向右平移一个单位即可。 在上图的坐标系中，横坐标表示线段出现在 位置的时刻，而时刻是关于 取模的，所以我们可以把左边的平行四边形向右平移 个单位，即： **注意：**右边的平行四边形在 时，右边会有一部分不在 内，但是在模的意义下，这一部分应该对应左边紧靠 的一部分，为了保证这一部分能计算出正确结果，我们把坐标系的 复制到 。 当查询的 时，两个平行四边形在有一条公共边，如下图： 为了不重复统计，需要把右边的平行四边形的左边界 。 当查询的 时，两个平行四边形均退化成线段，并且重合，此时可以直接忽略掉右边的平行四边形。 现在问题转化为，在平面内，每次插入或删除一个点，查询两个平行四边形的并的点的数量。 平行四边形很难用数据结构来维护，所以考虑变换坐标，将平行四边形变成矩形 —— 因为两个平行四边形除与 轴平行的边以外，斜率均为 或 。所以将左边平行四边形的所有点纵座标加上横坐标，右边平行四边形上所有点的纵座标减去横坐标，得到两个矩形： 发现右边的矩形在第四象限内，为了使它的坐标全部为正，我们对其纵座标全部加上 。 如果将原坐标系的内容复制一份接到右边，则需要加上 才能使四个矩形的纵座标全部为正，此时整个坐标系的范围长宽均为 。 因为两边的平行四边形坐标变换的方式不完全相同，所以需要两个坐标系，分别对所有插入的点做对应的坐标变换。 问题最终转化为，在平面内插入一个点，删除一个点，查询一个矩形范围内的点的数量 —— 使用二维树状数组解决即可。 时间复杂度为 ，空间复杂度为 ，空间大约带一个 倍的常数。 代码 无调试代码版： #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;cstring&gt; const int MAXLEN = 1000; const int MAXC = 1000000; struct BinaryIndexedTree { int a[MAXLEN * 4 + 10][MAXLEN * 4 + 10], n, m; static int lowbit(int x) { return x &amp; -x; } void init(int n, int m) { this-&gt;n = n, this-&gt;m = m; } void update(int x, int y, int delta) { for (int i = x + 1; i &lt;= n + 5; i += lowbit(i)) { for (int j = y + 1; j &lt;= m + 5; j += lowbit(j)) { a[i - 1][j - 1] += delta; } } } int query(int x, int y) { int res = 0; for (int i = x + 1; i &gt; 0; i -= lowbit(i)) { for (int j = y + 1; j &gt; 0; j -= lowbit(j)) { res += a[i - 1][j - 1]; } } return res; } int query(int x1, int y1, int x2, int y2) { int res = query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1); return res; } } bit1, bit2; struct Cloud { int t, l, r, d; } cloud[MAXC + 1]; int len; inline void transform(int &amp;x, int &amp;y, int i) { if (i == 1) { y += x; } else { y += 4 * len - x; } } inline void add(int x, int y) { int newX, newY; newX = x, newY = y; transform(newX, newY, 1); bit1.update(newX, newY, 1); newX = x + len * 2, newY = y; transform(newX, newY, 1); bit1.update(newX, newY, 1); newX = x, newY = y; transform(newX, newY, 2); bit2.update(newX, newY, 1); newX = x + len * 2, newY = y; transform(newX, newY, 2); bit2.update(newX, newY, 1); } inline void add(int t, int c, int l, int r, int d) { int y = r - l; if (d == 1) { t -= l; } else { t += l; } t = (t % (len * 2) + (len * 2)) % (len * 2); cloud[c].t = t, cloud[c].l = l, cloud[c].r = r, cloud[c].d = d; add(t, y); } inline void del(int x, int y) { int newX, newY; newX = x, newY = y; transform(newX, newY, 1); bit1.update(newX, newY, -1); newX = x + len * 2, newY = y; transform(newX, newY, 1); bit1.update(newX, newY, -1); newX = x, newY = y; transform(newX, newY, 2); bit2.update(newX, newY, -1); newX = x + len * 2, newY = y; transform(newX, newY, 2); bit2.update(newX, newY, -1); } inline void del(int c) { del(cloud[c].t, cloud[c].r - cloud[c].l); } inline int query(int t, int l, int r) { t %= (len * 2); int ans = 0; int x1, x2, y1, y2; x1 = t, y1 = l, x2 = t + r, y2 = len; transform(x1, y1, 1), transform(x2, y2, 1); ans += bit1.query(x1, y1, x2, y2); if (r != 0) { x1 = 2 * len - r + t, y1 = l - r, x2 = 2 * len + t - 1, y2 = len + r; transform(x1, y1, 2), transform(x2, y2, 2); if (r == len) x1++; ans += bit2.query(x1, y1, x2, y2); } return ans; } int main() { int n; scanf("%d %d", &amp;n, &amp;len); bit1.init(len * 4 + 1, len * 4 + 1); bit2.init(len * 4 + 1, len * 4 + 1); while (n--) { int cmd; scanf("%d", &amp;cmd); if (cmd == 1) { int t, c, l, r, d; scanf("%d %d %d %d %d", &amp;t, &amp;c, &amp;l, &amp;r, &amp;d); add(t, c, l, r, d); } else if (cmd == 2) { int t, l, r; scanf("%d %d %d", &amp;t, &amp;l, &amp;r); printf("%d\n", query(t, l, r)); } else { int t, c; scanf("%d %d", &amp;t, &amp;c); del(c); } } return 0; } 带调试代码版： #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;cstring&gt; const int MAXLEN = 1000; const int MAXC = 1000000; #ifndef FORCE struct BinaryIndexedTree; BinaryIndexedTree *_bit1, *_bit2; struct BinaryIndexedTree { int a[MAXLEN * 4 + 10][MAXLEN * 4 + 10], n, m; static int lowbit(int x) { return x &amp; -x; } void init(int n, int m) { #ifdef DBG_BIT printf("init(%d, %d)\n", n, m); #endif this-&gt;n = n, this-&gt;m = m; } void update(int x, int y, int delta) { #ifdef DBG_BIT printf("update(%d, %d, %d, %d)\n", this == ::_bit1 ? 1 : 2, x, y, delta); #endif assert(x &gt;= 0); assert(y &gt;= 0); #ifdef FORCE_BIT a[x][y] += delta; #else for (int i = x + 1; i &lt;= n + 5; i += lowbit(i)) { for (int j = y + 1; j &lt;= m + 5; j += lowbit(j)) { a[i - 1][j - 1] += delta; } } #endif } int query(int x, int y) { int res = 0; #ifdef FORCE_BIT for (int i = x; i &gt;= 0; i--) { for (int j = y; j &gt;= 0; j--) { res += a[i][j]; } } #else for (int i = x + 1; i &gt; 0; i -= lowbit(i)) { for (int j = y + 1; j &gt; 0; j -= lowbit(j)) { res += a[i - 1][j - 1]; } } #endif return res; } int query(int x1, int y1, int x2, int y2) { #ifdef FORCE_BIT int res = 0; for (int i = x1; i &lt;= x2; i++) { for (int j = y1; j &lt;= y2; j++) { res += a[i][j]; } } #else int res = query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1); #endif #ifdef DBG_BIT printf("query(%d, %d, %d, %d, %d) = %d\n", this == ::_bit1 ? 1 : 2, x1, y1, x2, y2, res); #endif return res; } } bit1, bit2; #endif struct Cloud { int t, l, r, d; } cloud[MAXC + 1]; int len; #ifdef FORCE int a[MAXLEN * 4 + 5][MAXLEN * 2 + 5]; #endif inline void transform(int &amp;x, int &amp;y, int i) { #ifdef DBG printf("transform(%d, %d, %d) = ", x, y, i); #endif if (i == 1) { y += x; } else { y += 4 * len - x; } #ifdef DBG printf("(%d, %d)\n", x, y); #endif } inline void add(int x, int y) { // printf("add(%d, %d)\n", x, y); #ifdef FORCE a[x][y]++; // a[x + len * 2][y]++; #else #ifdef DBG printf("add(%d, %d)\n", x, y); #endif int newX, newY; newX = x, newY = y; transform(newX, newY, 1); bit1.update(newX, newY, 1); newX = x + len * 2, newY = y; transform(newX, newY, 1); bit1.update(newX, newY, 1); newX = x, newY = y; transform(newX, newY, 2); bit2.update(newX, newY, 1); newX = x + len * 2, newY = y; transform(newX, newY, 2); bit2.update(newX, newY, 1); /* bit1.update(x, y + x, 1); bit2.update(x, y + (len * 2 - x), 1); bit1.update(x + len * 2, y + x, 1); bit2.update(x + len * 2, y + (len * 2 - x), 1); */ #endif } inline void add(int t, int c, int l, int r, int d) { int y = r - l; if (d == 1) { t -= l; } else { t += l; } t = (t % (len * 2) + (len * 2)) % (len * 2); cloud[c].t = t, cloud[c].l = l, cloud[c].r = r, cloud[c].d = d; add(t, y); } inline void del(int x, int y) { #ifdef FORCE a[x][y]--; // a[x + len * 2][y]--; #else int newX, newY; newX = x, newY = y; transform(newX, newY, 1); bit1.update(newX, newY, -1); newX = x + len * 2, newY = y; transform(newX, newY, 1); bit1.update(newX, newY, -1); newX = x, newY = y; transform(newX, newY, 2); bit2.update(newX, newY, -1); newX = x + len * 2, newY = y; transform(newX, newY, 2); bit2.update(newX, newY, -1); #endif } inline void del(int c) { del(cloud[c].t, cloud[c].r - cloud[c].l); } inline int query(int t, int l, int r) { t %= (len * 2); #ifdef FORCE // printf("query(%d, %d, %d)\n", t, l, r); static bool added[MAXLEN * 2 + 5][MAXLEN + 5]; memset(added, 0, sizeof(added)); int ans = 0; for (int i = 0, start = l; i &lt;= r; i++, start--) { for (int j = start; j &lt;= start + (len + r - l); j++) { if (j &gt;= 0) { // printf("[%d, %d]\n", (i + t) % (len * 2), j); int tmp = (i + t) % (len * 2); if (a[tmp][j] &amp;&amp; !added[tmp][j]) { ans++; added[tmp][j] = true; // printf("query(%d, %d, %d) [%d, %d]\n", t, l, r, (i + t) % (len * 2), j); } } } } for (int i = len * 2, start = l; i &gt;= len * 2 - r; i--, start--) { for (int j = start; j &lt;= start + (len + r - l); j++) { if (j &gt;= 0) { // printf("[%d, %d]\n", (i + t) % (len * 2), j); int tmp = (i + t) % (len * 2); if (a[tmp][j] &amp;&amp; !added[tmp][j]) { ans++; added[tmp][j] = true; // printf("query(%d, %d, %d) [%d, %d]\n", t, l, r, (i + t) % (len * 2), j); } } } } return ans; #else #ifdef DBG printf("query([%d, %d], [%d, %d], [%d, %d], [%d, %d])\n", 0 + t, len + r, // 0 + t, l, // r + t, len, // r + t, l - r); // printf("query([%d, %d], [%d, %d], [%d, %d], [%d, %d])\n", 2 * len - r + t, len, // 2 * len - r + t, l - r, // 2 * len + t, l, // 2 * len + t, len + r);// #endif int ans = 0; int x1, x2, y1, y2; x1 = t, y1 = l, x2 = t + r, y2 = len; transform(x1, y1, 1), transform(x2, y2, 1); ans += bit1.query(x1, y1, x2, y2); if (r != 0) { x1 = 2 * len - r + t, y1 = l - r, x2 = 2 * len + t - 1, y2 = len + r; transform(x1, y1, 2), transform(x2, y2, 2); if (r == len) x1++; ans += bit2.query(x1, y1, x2, y2); } return ans; #endif } int main() { int n; scanf("%d %d", &amp;n, &amp;len); #ifndef FORCE_BIT bit1.init(len * 4 + 1, len * 4 + 1); bit2.init(len * 4 + 1, len * 4 + 1); _bit1 = &amp;bit1, _bit2 = &amp;bit2; #endif while (n--) { int cmd; scanf("%d", &amp;cmd); if (cmd == 1) { int t, c, l, r, d; scanf("%d %d %d %d %d", &amp;t, &amp;c, &amp;l, &amp;r, &amp;d); add(t, c, l, r, d); } else if (cmd == 2) { int t, l, r; scanf("%d %d %d", &amp;t, &amp;l, &amp;r); printf("%d\n", query(t, l, r)); } else { int t, c; scanf("%d %d", &amp;t, &amp;c); del(c); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>BZOJ</tag>
        <tag>NOI</tag>
        <tag>二维树状数组</tag>
        <tag>坐标变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 Docker 容器的沙盒化评测系统]]></title>
    <url>%2Fdocker-sandbox-judger%2F</url>
    <content type="text"><![CDATA[在线评测系统（Online Judge）允许用户提交代码，在评测机上运行，并返回运行结果。而用户提交的代码有时是不安全的，它可能会无限创建进程或文件消耗评测机资源，或者建立到远程服务器的连接，给攻击者提供后门。保证评测机安全的方法之一，是使用沙盒（Sandbox）。 资源的限制 一般的评测系统都会限制程序的运行资源，如内存、时间用量，进程、线程数量。资源的限制通常使用 setrlimit()（Set Resource Limit）来完成。 setrlimit() 的帮助文档（Man Page）非常详细，此处不多做介绍。但值得一提的是，setrlimit() 限制的时间（RLIMIT_RTTIME）是 CPU 时间，而线程被挂起的时间并不计算在内 —— 如调用 sleep() 时的延时和 scanf() 等待用户输入的时间。为了正确限制目标程序的时间，我们创建一个监视线程，在指定的时间后将目标进程杀死。 系统调用的限制 程序的一切与操作系统有关的操作，比如输入输出，创建进程，获取系统信息等，都需要系统调用（System Call）。如果不限制系统调用，目标程序也可能会有一些危险的行为。比如，目标程序可以获得文件系统的一部分目录结构，如果它运行在与评测系统或 Web 服务器相同的用户下，可能会获取或修改一些影响服务器安全的信息。 目前常用的两个限制系统调用的方案是 ptrace() 和 seccamp，前者的原理是在目标程序每次尝试进行系统调用时通知评测程序，如果发现危险的系统调用，可以及时将目标程序杀死。但 ptrace() 在每次系统调用时都会产生两次中断（进入系统调用前一次，系统调用返回后一次），影响效率。相比之下 seccamp 可能是更好的选择。 使用 ptrace() 的评测系统有：HustOJ、UOJ； 使用 seccamp 的评测系统有：QDUOJ、TJudger。 基于 Docker 的沙盒 保护系统安全的另一种思路是将目标程序与系统环境隔离，形成一个沙盒（Sandbox）环境。如 chroot 可以保证程序只能访问某个目录下的内容，而 Docker 则可以实现完全隔离的容器。 每次运行目标程序时，创建一个 Docker 容器，将输入数据与目标程序的可执行文件传入，创建一个监视进程，fork() 出子进程调用 setrlimit() 后使用 exec 载入目标程序。 对于需要运行环境的语言（如基于 .Net 的语言和 Python 等脚本语言），我们需要把系统中的库目录映射到容器中 —— 一般不需要考虑这样做的安全性，因为容器中的目标程序也是以普通用户运行的，对系统目录没有写权限；而库目录中一般没有可以读到的配置文件等敏感信息。 Docker 提供的网络功能可以用来禁止容器中的目标程序联网。 因为命令行参数拼接可能导致命令注入，所以在实现中没有直接调用 docker 命令行工具，而是使用了 dockerode 库与 Docker 服务进行通信。 基于 Docker 的沙盒的优点在于不需要限制系统调用，因为一些语言的运行库（如基于 .Net 的语言）或解释器（如 Python 等脚本语言）需要额外的系统调用，而使用对 C++ 等低级语言的限制方法来限制这些语言的程序，可能会将这些系统调用误认为恶意程序而杀死。 缺点在于，创建 Docker 容器需要一定开销，经过测试每次运行需要额外的大约一秒的时间。并且，Docker 不能在 32 位操作系统下运行。 评测程序的实现 沙盒只是评测系统的一部分，我们还需要一个评测程序来完成与沙盒和后端 Web 服务器的交互。 评测程序的主要工作是： 循环请求 Web 服务器获取等待评测的记录； 如果需要，从 Web 服务器下载测试数据并解压； 根据语言选择编译器进行编译； 调用沙盒运行目标程序； 检验程序输出并评分； 将评测结果上传回 Web 服务器。 最后，用一张图来描述整个评测系统的大致架构：]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>评测系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2007」棋盘制作 - 悬线法]]></title>
    <url>%2Fzjoi2007-chess%2F</url>
    <content type="text"><![CDATA[在一个 的 矩阵中，求面积最大的相邻位置数字不同的矩形和正方形。 链接 BZOJ 1057 题解 定义「极大合法子矩阵」为满足题目要求（相邻位置数字不同）的每一条边都不能向外扩展的子矩阵。面积最大的合法矩形一定是一个极大合法子矩阵。而面积最大的合法正方形一定是以一个极大和法子矩阵为边长的正方形。 对于每个位置，求出从这个位置向上能延伸到的满足题目要求（相邻位置数字不同）的最高点，用一条线连结，称这条线为「悬线」。求出悬线向左向右能延伸到的最远位置，则悬线左右移动的轨迹为一个合法子矩阵，且这个子矩阵的上边、左边、右边不能延伸。如果它的下边可以延伸，则在接下来的枚举中，延伸得到的矩阵可以被枚举到，否则它就是一个极大合法子矩阵。 这种枚举的方法可以枚举到所有高度（上边到下边距离，即悬线的长度）的极大合法子矩阵，所以不会漏解。 求每个位置向上、向左、向右能延伸到的最高点可以使用递推，而悬线向左或向右延伸的最远位置是一个后缀最小值，也可以递推。时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 2000; inline int sqr(int x) { return x * x; } int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); static int a[MAXN + 1][MAXN + 1]; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { scanf("%d", &amp;a[i][j]); } } // for (int i = 1; i &lt;= n; i++) f[i][0] = -1; // for (int j = 1; j &lt;= m; j++) f[0][j] = -1; static int f[MAXN + 1][MAXN + 1], g[MAXN + 1][MAXN + 1]; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (j == 1 || a[i][j] == a[i][j - 1]) { f[i][j] = 1; } else { f[i][j] = f[i][j - 1] + 1; } // printf("f(%d, %d) = %d\n", i, j, f[i][j]); } for (int j = m; j &gt;= 1; j--) { if (j == m || a[i][j] == a[i][j + 1]) { g[i][j] = 1; } else { g[i][j] = g[i][j + 1] + 1; } } } int ansSquare = 1, ansRectangle = 1; for (int j = 1; j &lt;= m; j++) { int up = 0, left = 0, right = 0; for (int i = 1; i &lt;= n; i++) { if (i == 1 || a[i][j] == a[i - 1][j]) { up = 1; left = f[i][j]; right = g[i][j]; } else { up++; left = std::min(left, f[i][j]); right = std::min(right, g[i][j]); } // printf("up = %d, left = %d, right = %d\n", up, left, right); ansRectangle = std::max(ansRectangle, up * (left + right - 1)); ansSquare = std::max(ansSquare, sqr(std::min(up, left + right - 1))); } } printf("%d\n%d\n", ansSquare, ansRectangle); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>ZJOI</tag>
        <tag>悬线法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2008」排名系统 - map + Splay]]></title>
    <url>%2Fhaoi2008-rank%2F</url>
    <content type="text"><![CDATA[排名系统通常要应付三种请求：上传一条新的得分记录、查询某个玩家的当前排名以及返回某个区段内的排名记录。当某个玩家上传自己最新的得分记录时，他原有的得分记录会被删除。为了减轻服务器负担，在返回某个区段内的排名记录时，最多返回 条记录。对于得分相同的，上传时间早的排名高。 链接 BZOJ 1056 题解 使用 Splay 存储每个用户的分数，查询记录时提取区间即可。使用 map 建立从用户名到 Splay 节点指针的关系。 代码 #include &lt;cstdio&gt; // #include &lt;cassert&gt; #include &lt;climits&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;iostream&gt; struct Splay { struct Node { Node *c[2], *fa, **root; const std::map&lt;std::string, Node *&gt;::iterator it; std::pair&lt;int, int&gt; x; int size; Node(Node **root, Node *fa, const std::pair&lt;int, int&gt; &amp;x, const std::map&lt;std::string, Node *&gt;::iterator it) : fa(fa), root(root), it(it), x(x), size(0) { c[0] = c[1] = NULL; } void maintain() { size = (c[0] ? c[0]-&gt;size : 0) + (c[1] ? c[1]-&gt;size : 0) + 1; } int relation() { return this == fa-&gt;c[1]; } void rotate() { Node *o = fa; int x = relation(); if (o-&gt;fa) o-&gt;fa-&gt;c[o-&gt;relation()] = this; fa = o-&gt;fa; o-&gt;c[x] = c[x ^ 1]; if (c[x ^ 1]) c[x ^ 1]-&gt;fa = o; c[x ^ 1] = o; o-&gt;fa = this; o-&gt;maintain(), maintain(); if (!fa) *root = this; } Node *splay(Node *target = NULL) { while (fa != target) { if (fa-&gt;fa == target) rotate(); else if (relation() == fa-&gt;relation()) fa-&gt;rotate(), rotate(); else rotate(), rotate(); } return this; } Node *prev() { Node *v = splay()-&gt;c[0]; while (v-&gt;c[1]) v = v-&gt;c[1]; return v; } Node *succ() { Node *v = splay()-&gt;c[1]; while (v-&gt;c[0]) v = v-&gt;c[0]; return v; } int rank() { return c[0] ? c[0]-&gt;size : 0; } } *root; Splay(const std::map&lt;std::string, Node *&gt;::iterator null) : root(NULL) { insert(std::make_pair(INT_MIN, INT_MIN), null); insert(std::make_pair(INT_MAX, INT_MAX), null); } Node *insert(const std::pair&lt;int, int&gt; &amp;x, std::map&lt;std::string, Node *&gt;::iterator it) { Node **v = &amp;root, *fa = NULL; while (*v) { fa = *v; fa-&gt;size++; v = &amp;fa-&gt;c[x &gt; fa-&gt;x]; } *v = new Node(&amp;root, fa, x, it); return (*v)-&gt;splay(); } void erase(Node *v) { Node *l = v-&gt;prev(), *r = v-&gt;succ(); r-&gt;splay(); l-&gt;splay(r); // assert(v == l-&gt;c[1]); delete v; l-&gt;c[1] = NULL; l-&gt;size--, r-&gt;size--; } Node *select(int k) { int x = k; Node *v = root; while (v-&gt;rank() != x) { if (v-&gt;rank() &gt; x) v = v-&gt;c[0]; else x -= v-&gt;rank() + 1, v = v-&gt;c[1]; } return v-&gt;splay(); } Node *select(int l, int r) { Node *prev = select(l - 1), *succ = select(r + 1); succ-&gt;splay(); prev-&gt;splay(succ); return prev-&gt;c[1]; } int size() { return root-&gt;size - 2; } }; std::map&lt;std::string, Splay::Node *&gt; map; Splay splay(map.end()); void dfs(Splay::Node *v, std::vector&lt;const std::string *&gt; &amp;vec) { if (!v) return; dfs(v-&gt;c[0], vec); if (v-&gt;it != map.end()) vec.push_back(&amp;v-&gt;it-&gt;first); dfs(v-&gt;c[1], vec); } inline int parseInt(std::string s) { int x = 0; for (std::string::iterator it = s.begin(); it != s.end(); it++) x = x * 10 + (*it - '0'); return x; } int main() { int n; scanf("%d", &amp;n); while (n--) { std::string cmd; std::cin &gt;&gt; cmd; if (cmd[0] == '+') { std::string name = cmd.substr(1, cmd.length() - 1); int x; scanf("%d", &amp;x); std::map&lt;std::string, Splay::Node *&gt;::iterator it = map.find(name); if (it != map.end()) { splay.erase(it-&gt;second); } else { it = map.insert(std::make_pair(name, static_cast&lt;Splay::Node *&gt;(NULL))).first; } it-&gt;second = splay.insert(std::make_pair(-x, -n), it); } else if (cmd[0] == '?') { std::string arg = cmd.substr(1, cmd.length() - 1); if (arg[0] &gt;= '0' &amp;&amp; arg[0] &lt;= '9') { int x = parseInt(arg); Splay::Node *v = splay.select(x, std::min(splay.size(), x + 10 - 1)); std::vector&lt;const std::string *&gt; vec; dfs(v, vec); for (std::vector&lt;const std::string *&gt;::iterator it = vec.begin(); it != vec.end(); it++) std::cout &lt;&lt; **it &lt;&lt; (it == vec.end() - 1 ? '\n' : ' '); } else { Splay::Node *v = map[arg]; printf("%d\n", v-&gt;splay()-&gt;rank()); } } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>BZOJ</tag>
        <tag>Splay</tag>
        <tag>map</tag>
        <tag>HAOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2008」移动玩具 - 状态压缩 + BFS]]></title>
    <url>%2Fhaoi2008-move%2F</url>
    <content type="text"><![CDATA[在一个 的方框内摆放了若干个相同的玩具，要将这些玩具重新摆放成为理想的状态，规定移动时只能将玩具向上下左右四个方向移动，并且移动到的位置不能有玩具，求最小移动次数。 链接 BZOJ 1054 题解 将所有 个方框的状态存入一个整数的二进制位中，BFS 即可。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;queue&gt; const int MAXN = 16; inline unsigned int read() { unsigned int res = 0; for (int i = 0; i &lt; 4; i++) { char s[4 + 1]; scanf("%s", s); for (int j = 0; j &lt; 4; j++) { if (s[j] == '1') res |= (1 &lt;&lt; (4 * i + j)); } } return res; } inline int bfs(unsigned int s, unsigned int t) { static int dist[1 &lt;&lt; MAXN]; for (int i = 0; i &lt; (1 &lt;&lt; MAXN); i++) dist[i] = INT_MAX; std::queue&lt;unsigned int&gt; q; dist[s] = 0; q.push(s); while (!q.empty()) { unsigned int v = q.front(); q.pop(); if (v == t) return dist[v]; for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { int a = 4 * i + j; unsigned int va = !!(v &amp; (1 &lt;&lt; a)); if (i != 3) { int b = 4 * (i + 1) + j; unsigned int vb = !!(v &amp; (1 &lt;&lt; b)); if (va != vb) { unsigned int u = v; if (vb) u |= (1 &lt;&lt; a); else u &amp;= ~(1 &lt;&lt; a); if (va) u |= (1 &lt;&lt; b); else u &amp;= ~(1 &lt;&lt; b); if (dist[u] &gt; dist[v] + 1) { dist[u] = dist[v] + 1; q.push(u); } } } if (j != 3) { int b = 4 * i + (j + 1); unsigned int vb = !!(v &amp; (1 &lt;&lt; b)); if (va != vb) { unsigned int u = v; if (vb) u |= (1 &lt;&lt; a); else u &amp;= ~(1 &lt;&lt; a); if (va) u |= (1 &lt;&lt; b); else u &amp;= ~(1 &lt;&lt; b); if (dist[u] &gt; dist[v] + 1) { dist[u] = dist[v] + 1; q.push(u); } } } } } } return -1; } int main() { unsigned int s = read(), t = read(); printf("%d\n", bfs(s, t)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>HAOI</tag>
        <tag>BFS</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2007」反素数 - 搜索]]></title>
    <url>%2Fhaoi2007-ant%2F</url>
    <content type="text"><![CDATA[对于任何正整数 ，其约数的个数记作 ，例如 、。如果某个正整数 对于任何 都满足 ，则称 为反质数。 给定一个数 ，求最大的不超过 的反质数。 链接 BZOJ 1053 题解 一个反质数 一定是 内约数个数最多的数，并且不存在一个 使 的约数个数与 的相等。 所以，对于因子数量相同的数，较小的才有可能是反质数。由此可知，反质数的质因子一定是从 开始连续的若干个质数。 设 的唯一分解式为 。则 的约数个数 。假设存在一个 满足 和 不是连续的质数，则令 为 的下一个质数， 向后顺延，这样得到的唯一分解式中， 不变，而 变小了。上述推论得证。 所以，本题的答案的质因子一定是前若干个质数，通过计算可知，前 个质数（）的积大于 。 搜索每个质数的次数，如果得到一个比当前答案约数数量更多的数，或者得到一个与当前答案约数数量相等但本身更小的数，则更新答案。 代码 #include &lt;cstdio&gt; const int MAXN = 2e9; const int PRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 }; const int PRIMES_CNT = 11; int n, cntAns; long long ans; inline void search(int i, long long x, int cnt) { if (i == PRIMES_CNT) { if ((cnt == cntAns &amp;&amp; x &lt; ans) || (cnt &gt; cntAns)) { ans = x; cntAns = cnt; // printf("%lld\n", ans); } return; } long long t = 1; for (int j = 0; x * t &lt;= n; j++) { search(i + 1, x * t, cnt * (j + 1)); t *= PRIMES[i]; } } int main() { scanf("%d", &amp;n); search(0, 1, 1); printf("%lld\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>搜索</tag>
        <tag>HAOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2007」覆盖问题 - 二分答案 + 枚举]]></title>
    <url>%2Fhaoi2007-cover%2F</url>
    <content type="text"><![CDATA[用三个 的正方形覆盖一些点，使最大正方形的边长最小。 链接 BZOJ 1052 题解 二分答案，考虑如何检验。 首先，求出一个能覆盖所有点的最小矩形。 考虑到第一个正方形一定放在一个角上（第一个正方形不放在角上一定不会比放在角上更优），枚举四个角，将覆盖到的点做标记后再求出能覆盖剩下所有点的最小矩形，再枚举这个矩形的四个角，放置第二个正方形，之后只需要判定剩余的点是否可以被一个正方形围住即可。 时间复杂度 。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 20000; struct Point { int x, y; bool covered[2]; } a[MAXN + 1]; struct Rectangle { int x1, y1, x2, y2; }; int n; inline Rectangle getBound() { Rectangle rect; rect.x1 = rect.y1 = INT_MAX, rect.x2 = rect.y2 = INT_MIN; for (int i = 1; i &lt;= n; i++) { if (a[i].covered[0] || a[i].covered[1]) continue; rect.x1 = std::min(rect.x1, a[i].x); rect.y1 = std::min(rect.y1, a[i].y); rect.x2 = std::max(rect.x2, a[i].x); rect.y2 = std::max(rect.y2, a[i].y); } return rect; } inline void cover(int x, int y, int len, int index, bool flag) { for (int i = 1; i &lt;= n; i++) { if (a[i].x &gt;= x &amp;&amp; a[i].x &lt;= x + len &amp;&amp; a[i].y &gt;= y &amp;&amp; a[i].y &lt;= y + len) { a[i].covered[index] = flag; } } } inline void cover(Rectangle rect, int limit, int corner, int index, bool flag) { if (corner == 1) cover(rect.x1, rect.y1, limit, index, flag); else if (corner == 2) cover(rect.x2 - limit, rect.y1, limit, index, flag); else if (corner == 3) cover(rect.x2 - limit, rect.y2 - limit, limit, index, flag); else cover(rect.x1, rect.y2 - limit, limit, index, flag); } inline bool check(int limit) { for (int i = 1; i &lt;= n; i++) { a[i].covered[0] = a[i].covered[1] = false; } Rectangle rect1 = getBound(); for (int i = 1; i &lt;= 4; i++) { cover(rect1, limit, i, 0, true); Rectangle rect2 = getBound(); for (int j = 1; j &lt;= 4; j++) { cover(rect2, limit, j, 1, true); Rectangle rect3 = getBound(); if (std::max(rect3.x2 - rect3.x1, rect3.y2 - rect3.y1) &lt;= limit) return true; cover(rect2, limit, j, 1, false); } cover(rect1, limit, i, 0, false); } return false; } int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf("%d %d", &amp;a[i].x, &amp;a[i].y); } Rectangle rect = getBound(); int l = 0, r = std::max(rect.x2 - rect.x1, rect.y2 - rect.y1); while (l &lt; r) { int mid = l + (r - l) / 2; if (check(mid)) r = mid; else l = mid + 1; } printf("%d\n", l); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>二分答案</tag>
        <tag>HAOI</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2006」数字序列 - DP]]></title>
    <url>%2Fhaoi2006-sequence%2F</url>
    <content type="text"><![CDATA[现在我们有一个长度为 的整数序列 。我们希望把它变成一个单调严格上升的序列。但是不希望改变过多的数，也不希望改变的幅度太大。 链接 BZOJ 1049 题解 为了方便处理边界，我们在序列最左侧添加一个 ，最右侧添加一个 。 第一问，在一个单调上升序列中，对于每一个 ，它至少要比它左边的第 个数大 ，即 。如果我们确定了一个子序列满足该条件，则只需修改剩余的数，设 表示前 个数中最长的满足该条件的序列，可以写出 DP 方程 第一问答案即为 。 第二问要求在第一问的前提下使修改幅度最小，即我们需要保证有一个最长的满足原单调上升条件的子序列不变。 考虑将每个数 减去 ，即令 ，显然如果 为单调不下降序列，则 为单调上升序列。问题转化为求在保证 的一个最长单调不下降子序列不变的前提下，使 单调不下降的最小修改幅度。 设 表示在 位置和 位置不变的前提下，将 一段区间修改为单调不下降序列的最小修改幅度。设 为保证 位置不变的前提下，将 修改为单调不下降序列的最小修改幅度。 注意到对于方程中任意一对 ，不可能存在一个 满足 ，即对于任意的 ，满足 或 ，即 所以最优策略一定是令左边若干个改变为 ，右边若干个改变为 ，即 枚举中间这条扫描线，维护左边若干个改变为 ，右边若干个改变为 的最小代价，更新 。 时间复杂度（上界）为 ，但实际上远远达不到这个上界。 代码 #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;climits&gt; #include &lt;cstdlib&gt; #include &lt;algorithm&gt; const int MAXN = 35000; int main() { int n; scanf("%d", &amp;n); static int a[MAXN + 1]; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); static int b[MAXN + 2]; for (int i = 1; i &lt;= n; i++) { b[i] = a[i] - i; b[0] = std::min(b[0], b[i]); b[n + 1] = std::max(b[n + 1], b[i]); } static int f[MAXN + 2]; int maxLen = 1; for (int i = 1; i &lt;= n + 1; i++) { for (int j = 0; j &lt; i; j++) { if (b[j] &lt;= b[i] &amp;&amp; f[j] + 1 &gt; f[i]) { f[i] = f[j] + 1; maxLen = std::max(maxLen, f[i]); } } #ifdef DBG printf("b[%d] = %d, f[%d] = %d\n", i, b[i], i, f[i]); #endif } printf("%d\n", n - f[n + 1] + 1); static int g[MAXN + 2]; for (int i = 1; i &lt;= n + 1; i++) { g[i] = INT_MAX; for (int j = 0; j &lt; i; j++) { if (b[j] &lt;= b[i] &amp;&amp; f[j] + 1 == f[i]) { int w = 0; for (int k = i - 1; k &gt; j; k--) w += abs(b[k] - b[j]); g[i] = std::min(g[i], g[j] + w); for (int k = i - 1; k &gt; j; k--) { w -= abs(b[k] - b[j]); w += abs(b[k] - b[i]); g[i] = std::min(g[i], g[j] + w); } } } assert(g[i] != INT_MAX); #ifdef DBG printf("g[%d] = %d\n", i, g[i]); #endif } printf("%d\n", g[n + 1]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>HAOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2007」分割矩阵 - 搜索]]></title>
    <url>%2Fhaoi2007-separation%2F</url>
    <content type="text"><![CDATA[将一个 的数字矩阵进行如下分割：将原矩阵沿某一条直线分割成两个矩阵，再将生成的两个矩阵继续如此分割（当然也可以只分割其中的一个），这样分割了 次后，原矩阵被分割成了 个矩阵。（每次分割都只能沿着数字间的缝隙进行）原矩阵中每一位置上有一个分值，一个矩阵的总分为其所含各位置上分值之和。现在需要把矩阵按上述规则分割成 个矩阵，并使各矩阵总分的均方差最小。请编程对给出的矩阵及 ，求出均方差的最小值。 链接 BZOJ 1048 题解 设答案为 ，分割出的所有矩阵分数分别为 ，设总和 平均值 ，则有 最小化 ，即每一块的平方和，即可。 记忆化搜索， 表示左上角为 ，右下角为 的矩阵，切 刀得到的每一块的平方和的最小值。转移时枚举横切或纵切的位置，枚举切出的两块继续切的次数。 与 同阶，时间复杂度为 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 10; int n, m, k, a[MAXN + 1][MAXN + 1], s[MAXN + 1][MAXN + 1]; inline int sum(int i1, int j1, int i2, int j2) { return s[i2][j2] - s[i1 - 1][j2] - s[i2][j1 - 1] + s[i1 - 1][j1 - 1]; } inline void prepare() { for (int i = 1; i &lt;= n; i++) { int sumLine = 0; for (int j = 1; j &lt;= m; j++) { sumLine += a[i][j]; s[i][j] = s[i - 1][j] + sumLine; } } } template &lt;typename T&gt; T sqr(T x) { return x * x; } inline int search(int i1, int j1, int i2, int j2, int cnt) { static int mem[MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1]; static bool calced[MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1]; int &amp;ans = mem[i1][j1][i2][j2][cnt]; if (calced[i1][j1][i2][j2][cnt]) return ans; calced[i1][j1][i2][j2][cnt] = true; if (!cnt) { return ans = sqr(sum(i1, j1, i2, j2)); } ans = INT_MAX; for (int i = i1; i &lt; i2; i++) { for (int l = 0; l &lt; cnt; l++) { int x1 = search(i + 1, j1, i2, j2, l); int x2 = search(i1, j1, i, j2, cnt - l - 1); if (x1 != INT_MAX &amp;&amp; x2 != INT_MAX) ans = std::min(ans, x1 + x2); } } for (int j = j1; j &lt; j2; j++) { for (int l = 0; l &lt; cnt; l++) { int x1 = search(i1, j + 1, i2, j2, l); int x2 = search(i1, j1, i2, j, cnt - l - 1); if (x1 != INT_MAX &amp;&amp; x2 != INT_MAX) ans = std::min(ans, x1 + x2); } } // printf("search(%d, %d, %d, %d, %d) = %d\n", i1, j1, i2, j2, cnt, ans); return ans; } int main() { scanf("%d %d %d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { scanf("%d", &amp;a[i][j]); } } prepare(); int ans = search(1, 1, n, m, k - 1); // printf("%d\n", ans); printf("%.2lf\n", sqrt((ans * k - sqr(s[n][m])) / static_cast&lt;double&gt;(sqr(k)))); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>搜索</tag>
        <tag>HAOI</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2007」理想的正方形 - 单调队列]]></title>
    <url>%2Fhaoi2007-square%2F</url>
    <content type="text"><![CDATA[有一个 的整数组成的矩阵，现请你从中找出一个 的正方形区域，使得该区域所有数中的最大值和最小值的差最小。 链接 BZOJ 1047 题解 对每一行应用单调队列，求出 （即每个数向左 个数以内的最大值）。对每一列应用单调队列，求出 （即每个数向上 个数以内的最大值）。两次操作的结果是每个数向上 个数以内的每个数向左 个数以内的最大值，即一个 的正方形的最大值。 用相同的方法求出最小值，枚举每个 的正方形，即可得到答案。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;functional&gt; const int MAXN = 1000; int n, m, k, a[MAXN + 1][MAXN + 1]; template &lt;typename T&gt; inline void workColumns(int a[MAXN + 1][MAXN + 1], int b[MAXN + 1][MAXN + 1], T comp) { static int q[MAXN + 1]; for (int i = 1; i &lt;= n; i++) { int *l = q, *r = q - 1; for (int j = 1; j &lt;= m; j++) { while (l &lt;= r &amp;&amp; j - *l &gt;= k) l++; while (l &lt;= r &amp;&amp; comp(a[i][j], a[i][*r])) r--; *++r = j; b[i][j] = a[i][*l]; #ifdef DBG printf("%d%c", b[i][j], j == m ? '\n' : ' '); #endif } } } template &lt;typename T&gt; inline void workRows(int a[MAXN + 1][MAXN + 1], int b[MAXN + 1][MAXN + 1], T comp) { static int q[MAXN + 1]; for (int i = 1; i &lt;= m; i++) { int *l = q, *r = q - 1; for (int j = 1; j &lt;= n; j++) { while (l &lt;= r &amp;&amp; j - *l &gt;= k) l++; while (l &lt;= r &amp;&amp; comp(a[j][i], a[*r][i])) r--; *++r = j; b[j][i] = a[*l][i]; } } #ifdef DBG for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) printf("%d%c", b[i][j], j == m ? '\n' : ' '); #endif } int main() { scanf("%d %d %d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { scanf("%d", &amp;a[i][j]); } } static int columnMax[MAXN + 1][MAXN + 1], rowMax[MAXN + 1][MAXN + 1]; workColumns(a, columnMax, std::greater&lt;int&gt;()); workRows(columnMax, rowMax, std::greater&lt;int&gt;()); static int columnMin[MAXN + 1][MAXN + 1], rowMin[MAXN + 1][MAXN + 1]; workColumns(a, columnMin, std::less&lt;int&gt;()); workRows(columnMin, rowMin, std::less&lt;int&gt;()); int ans = INT_MAX; for (int i = k; i &lt;= n; i++) for (int j = k; j &lt;= m; j++) ans = std::min(ans, rowMax[i][j] - rowMin[i][j]); printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>单调队列</tag>
        <tag>HAOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2007」上升序列 - DP + 贪心]]></title>
    <url>%2Fhaoi2007-lis%2F</url>
    <content type="text"><![CDATA[对于一个给定的 ，若有 ，满足 且 ，那么就称 为 的一个上升序列。如果有多个 满足条件，那么我们想求字典序最小的那个。 任务给出 序列，给出若干询问。对于第 个询问，求出长度为 的上升序列，如有多个，求出下标字典序最小的那个。 链接 BZOJ 1046 题解 动态规划求出 表示以第 个数开始的最长上升子序列长度，即 对于每个询问，按顺序扫描整个序列，如果从当前位置开始的最长上升序列长度 ，则将当前位置的数加入答案序列中，并将 减去 。如果最终 ，则无解。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 10000; int main() { int n; scanf("%d", &amp;n); static int a[MAXN + 1]; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); static int f[MAXN + 1]; for (int i = n; i &gt;= 1; i--) { f[i] = 1; for (int j = i + 1; j &lt;= n; j++) { if (a[i] &lt; a[j] &amp;&amp; f[j] + 1 &gt; f[i]) f[i] = f[j] + 1; } #ifdef DBG printf("f[%d] = %d\n", i, f[i]); #endif } int m; scanf("%d", &amp;m); while (m--) { int l; scanf("%d", &amp;l); static int tmp[MAXN + 1]; int cnt = 0; int last = 0; for (int i = 1; i &lt;= n; i++) { if (f[i] &gt;= l &amp;&amp; a[i] &gt; last) { l--; last = a[i]; tmp[++cnt] = a[i]; } if (!l) break; } if (l) puts("Impossible"); else for (int i = 1; i &lt;= cnt; i++) printf("%d%c", tmp[i], i == cnt ? '\n' : ' '); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>贪心</tag>
        <tag>HAOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2016」愤怒的小鸟 - 状态压缩 + BFS]]></title>
    <url>%2Fnoip2016-angrybirds%2F</url>
    <content type="text"><![CDATA[Kiana 最近沉迷于一款神奇的游戏无法自拔。 简单来说，这款游戏是在一个平面上进行的。 有一架弹弓位于 处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 的曲线，其中 ， 是 Kiana 指定的参数，且必须满足 。 当小鸟落回地面（即 轴）时，它就会瞬间消失。 在游戏的某个关卡里，平面的第一象限中有 只绿色的小猪，其中第 只小猪所在的坐标为 。 如果某只小鸟的飞行轨迹经过了，那么第 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行； 如果一只小鸟的飞行轨迹没有经过，那么这只小鸟飞行的全过程就不会对第 只小猪产生任何影响。 例如，若两只小猪分别位于 和 ，Kiana 可以选择发射一只飞行轨迹为 的小鸟，这样两只小猪就会被这只小鸟一起消灭。 而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。 这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在「输入格式」中详述。 假设这款游戏一共有 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。 链接 Luogu 2831 LYOI #104 题解 在 中，考虑到 为常数，两个点即可确定这条抛物线。枚举每两个点，计算过这两个点的抛物线，如果 则舍去，得到 条抛物线。枚举每条抛物线，计算有哪些猪在这条抛物线上（即一次操作可以消灭的猪的集合），使用一个二进制数存储。另外，对于不在任何一个合法抛物线上的猪，新增加一条「只过这个猪」的「虚拟」抛物线。 以「当前剩余的猪的集合」为点，每个抛物线为边，建立状态图，BFS 即可得到答案。 时间复杂度 。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 18 + 3; const int MAXSTATUS = (1 &lt;&lt; (MAXN + 1)); const double EPS = 1e-6; struct Point { double x, y; Point(double x = 0, double y = 0) : x(x), y(y) {} } a[MAXN]; inline bool dcmp(double x) { return fabs(x) &lt;= EPS; } inline bool dcmp(double x, double y) { return dcmp(x - y); } struct Line { double a, b; bool valid; unsigned int kill; Line(unsigned int kill = 0) : a(0), b(0), valid(true), kill(kill) {} bool operator&lt;(const Line &amp;other) const { return kill &gt; other.kill; } bool operator==(const Line &amp;other) const { return kill == other.kill; } } lines[MAXN * MAXN]; struct Node { bool visited; int dist; } N[MAXSTATUS]; int n, cmd, limit, lineCnt; /* #ifdef DBG inline void print(int s) { for (int i = 0; i &lt; n; i++) putchar((s &amp; (1u &lt;&lt; i)) ? '1' : '0'); } #endif */ inline int bfs(int status) { if (!status) return 0; std::queue&lt;int&gt; q; q.push(status); N[status].visited = true; N[status].dist = 0; while (!q.empty()) { int v = q.front(); q.pop(); if (N[v].dist == limit) continue; for (int i = 1; i &lt;= lineCnt; i++) { Line &amp;l = lines[i]; if (l.valid &amp;&amp; (l.kill &amp; status)) { int u = v; u &amp;= ~l.kill; if (!N[u].visited) { N[u].visited = true; N[u].dist = N[v].dist + 1; if (!u) return N[u].dist; q.push(u); } } } } return n; } /* inline void massert(bool x) { if (!x) { int b = 0; b = 1; b = 2; } } */ inline Line getLine(const Point &amp;a, const Point &amp;b) { Line l; // printf("%lf %lf %u\n", l.a, l.b, l.kill); // a = (x1 * y2 - x2 * y1) / (x1 * x2 ^ 2 - x2 * x1 ^ 2) l.a = (a.x * b.y - b.x * a.y) / (a.x * b.x * b.x - b.x * a.x * a.x); // b = (y1 - a * x1 ^ 2) / x1 l.b = (a.y - l.a * a.x * a.x) / a.x; // printf("%lf %lf %u\n", l.a, l.b, l.kill); // if (!dcmp(l.b, (b.y - l.a * b.x * b.x) / b.x)) { // printf("ERROR: %lf %lf\n", l.b, (b.y - l.a * b.x * b.x) / b.x); // } return l; } inline bool onLine(const Line &amp;l, const Point &amp;a) { return dcmp(l.a * a.x * a.x + l.b * a.x, a.y); } inline int solve() { bool flags[MAXN]; for (int i = 1; i &lt;= n; i++) flags[i] = false; for (int i = 1; i &lt;= n; i++) { for (int j = i + 1; j &lt;= n; j++) { if (dcmp(a[i].x, a[j].x)) continue; Line l = getLine(a[i], a[j]); if (l.a &gt;= 0) continue; flags[i] = flags[j] = true; lines[++lineCnt] = l; } } for (int i = 1; i &lt;= lineCnt; i++) { for (int j = 1; j &lt;= n; j++) { if (onLine(lines[i], a[j])) { lines[i].kill |= (1u &lt;&lt; (j - 1)); } } /* #ifdef DBG printf("[a = %lf, b = %lf]: ", lines[i].a, lines[i].b); print(lines[i].kill); putchar('\n'); #endif */ } for (int i = 1; i &lt;= n; i++) { if (!flags[i]) { lines[++lineCnt] = Line(1u &lt;&lt; (i - 1)); } } std::sort(lines + 1, lines + lineCnt + 1); for (int i = 1; i &lt;= lineCnt; i++) { for (int j = i + 1; j &lt;= lineCnt; j++) { if ((lines[i].kill | lines[j].kill) == lines[i].kill) { lines[j].valid = false; } } } for (unsigned int i = 0; i &lt; (1u &lt;&lt; n); i++) { N[i].visited = false; } return bfs((1u &lt;&lt; n) - 1); } int main() { freopen("angrybirds.in", "r", stdin); freopen("angrybirds.out", "w", stdout); int t; scanf("%d", &amp;t); while (t--) { scanf("%d %d", &amp;n, &amp;cmd); for (int i = 1; i &lt;= n; i++) { scanf("%lf %lf", &amp;a[i].x, &amp;a[i].y); } lineCnt = 0; if (cmd == 1) { limit = ceil(double(n) / 3 + 1); } else { limit = n; } printf("%d\n", solve()); } fclose(stdin); fclose(stdout); }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>BFS</tag>
        <tag>状态压缩</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2016」蚯蚓 - 队列]]></title>
    <url>%2Fnoip2016-earthworm%2F</url>
    <content type="text"><![CDATA[本题中，我们将用符号 表示对 向下取整，例如：。 蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。 蛐蛐国里现在共有 只蚯蚓（ 为正整数）。每只蚯蚓拥有长度，我们设第 只蚯蚓的长度为 （），并保证所有的长度都是非负整数（即：可能存在长度为 的蚯蚓）。 每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 （是满足 的有理数）决定，设这只蚯蚓长度为 ，神刀手会将其切成两只长度分别为 和 的蚯蚓。特殊地，如果这两个数的其中一个等于 ，则这个长度为 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 （是一个非负整常数）。 蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 秒才能到来 ……（ 为非负整数） 蛐蛐国王希望知道这 秒内的战况。具体来说，他希望知道： 秒内，每一秒被切断的蚯蚓被切断前的长度（有 个数）； 秒后，所有蚯蚓的长度（有 个数）。 蛐蛐国王当然知道怎么做啦！但是他想考考你 …… 链接 Luogu 2827 LYOI #103 题解 当 时，如果我们将每次切开后得到的蚯蚓分别放到两个序列中，则这两个序列都是单调的。将最初的蚯蚓排序，作为另一个序列。每次从三个序列中寻找最大值，删除，计算新蚯蚓插入到两个序列中即可。 当 时，每次只有两个新蚯蚓不增加长度，我们可以记录所有的蚯蚓被统一增加的长度，对每次不增加的减去这个长度。显然，单调性仍然满足。 时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 100000; const int MAXM = 7000000; template &lt;typename T&gt; struct Queue { T a[MAXN + MAXM], *l, *r; Queue() : l(a), r(a - 1) {} void push(const T &amp;x) { *++r = x; } void pop() { ++l; } T &amp;front() { return *l; } bool empty() const { return l &gt; r; } }; #ifdef DBG std::queue&lt;int&gt; q[3]; #else Queue&lt;int&gt; q[3]; #endif inline int getMax() { int res = -1; for (int i = 0; i &lt; 3; i++) if (!q[i].empty() &amp;&amp; (res == -1 || q[i].front() &gt; q[res].front())) res = i; return res; } #ifdef DBG inline void printAll(int d) { std::vector&lt;int&gt; v; for (int i = 0; i &lt; 3; i++) { std::queue&lt;int&gt; a = ::q[i]; while (!a.empty()) v.push_back(a.front()), a.pop(); } std::sort(v.begin(), v.end()); printf("%lu: ", v.size()); for (std::vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) printf("%d%c", *it, it == --v.end() ? '\n' : ' '); } #endif int main() { freopen("earthworm.in", "r", stdin); freopen("earthworm.out", "w", stdout); int n, m, k, u, v, t; scanf("%d %d %d %d %d %d", &amp;n, &amp;m, &amp;k, &amp;u, &amp;v, &amp;t); static int a[MAXN + 1]; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); std::sort(a + 1, a + n + 1); for (int i = n; i &gt;= 1; i--) q[0].push(a[i]); int d = 0; for (int i = 1; i &lt;= m; i++) { int j = getMax(); int x = q[j].front(); q[j].pop(); x += d; if (i % t == 0) printf("%d ", x); int a = static_cast&lt;long long&gt;(x) * u / v, b = x - a; d += k; a -= d, b -= d; q[1].push(a), q[2].push(b); } putchar('\n'); for (int i = 1; i &lt;= n + m; i++) { int j = getMax(); int x = q[j].front(); q[j].pop(); x += d; if (i % t == 0) printf("%d ", x); } putchar('\n'); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2016」组合数问题 - 递推 + 前缀和]]></title>
    <url>%2Fnoip2016-problem%2F</url>
    <content type="text"><![CDATA[组合数表示的是从 个物品中选出 个物品的方案数。举个例子，从 三个物品中选择两个物品可以有 ，， 这三种选择方法。 根据组合数的定义，我们可以给出计算组合数的一般公式： 其中 。 小葱想知道如果给定 ， 和 ，对于所有的 ， 有多少对 满足是 的倍数。 链接 Luogu 2822 LYOI #102 题解 根据 Pascal 定理，有 预处理出每个 ，前缀和 统计对于 ，有多少 。每次询问 的在前缀和中求和即可。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 2000 + 10; int C[MAXN + 1][MAXN + 1], cnt[MAXN + 1][MAXN + 1]; int main() { freopen("problem.in", "r", stdin); freopen("problem.out", "w", stdout); int t, k; scanf("%d %d", &amp;t, &amp;k); for (int i = 1; i &lt;= MAXN; i++) { C[i][0] = C[i][i] = 1; for (int j = 1; j &lt; i; j++) { C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % k; } for (int j = 1; j &lt;= i; j++) { cnt[i][j] = cnt[i][j - 1]; if (C[i][j] == 0) cnt[i][j]++; } } while (t--) { int n, m; scanf("%d %d", &amp;n, &amp;m); int ans = 0; for (int i = 1; i &lt;= n; i++) { ans += cnt[i][std::min(i, m)]; } printf("%d\n", ans); } fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>组合数</tag>
        <tag>NOIP</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2016」换教室 - Floyd + DP + 概率与期望]]></title>
    <url>%2Fnoip2016-classroom%2F</url>
    <content type="text"><![CDATA[对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。 在可以选择的课程中，有 节课程安排在 个时间段上。在第 （）个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室 上课，而另一节课程在教室 进行。 在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的 节安排好的课程。如果学生想更换第i节课程的教室，则需要提出申请。若申请通过，学生就可以在第 个时间段去教室 上课，否则仍然在教室 上课。 由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第 节课程的教室时，申请被通过的概率是一个已知的实数 ，并且对于不同课程的申请，被通过的概率是互相独立的。 学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多 节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请白己最希望更换教室的 门课程，也可以不用完这 个申请的机会，甚至可以一门课程都不申请。 因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课问时间从一间教室赶到另一间教室。 牛牛所在的大学有 个教室，有 条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第 （）节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。 现在牛牛想知道，申请哪几门课程可以使他因在教室问移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。 链接 Luogu 1850 LYOI #101 题解 使用 Floyd 算法求出任意两点间的最短路。考虑到某一节课的教室只会影响到最近两段路程，设 表示前 节课，使用了 次申请交换， 表示第 次是否申请交换的最小期望。 首先考虑 的转移。上一次可以申请，也可以不申请，取较小值： 的转移稍微复杂一些 边界 时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;cfloat&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXCNT = 2000; const int MAXN = 300; int cnt, max, n, c[MAXCNT + 1], d[MAXCNT + 1], g[MAXN + 1][MAXN + 1]; double k[MAXCNT + 1]; int main() { freopen("classroom.in", "r", stdin); freopen("classroom.out", "w", stdout); int m; scanf("%d %d %d %d", &amp;cnt, &amp;max, &amp;n, &amp;m); for (int i = 1; i &lt;= cnt; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt;= cnt; i++) scanf("%d", &amp;d[i]); for (int i = 1; i &lt;= cnt; i++) scanf("%lf", &amp;k[i]); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { g[i][j] = INT_MAX; } } while (m--) { int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); g[u][v] = g[v][u] = std::min(g[u][v], w); } for (int k = 1; k &lt;= n; k++) { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (g[i][k] != INT_MAX &amp;&amp; g[k][j] != INT_MAX &amp;&amp; g[i][j] &gt; g[i][k] + g[k][j]) { g[i][j] = g[i][k] + g[k][j]; } } } } for (int i = 1; i &lt;= n; i++) g[i][i] = 0; static double f[MAXCNT + 1][MAXCNT + 1][2]; f[1][0][0] = 0; f[1][0][1] = DBL_MAX; for (int i = 2; i &lt;= cnt; i++) { f[i][0][0] = f[i - 1][0][0] + g[c[i - 1]][c[i]]; f[i][0][1] = DBL_MAX; for (int j = 1; j &lt;= max; j++) { f[i][j][0] = f[i][j][1] = DBL_MAX; if (f[i - 1][j][0] != DBL_MAX) { f[i][j][0] = std::min(f[i][j][0], f[i - 1][j][0] + g[c[i - 1]][c[i]]); } if (f[i - 1][j][1] != DBL_MAX) { f[i][j][0] = std::min(f[i][j][0], f[i - 1][j][1] + (g[d[i - 1]][c[i]] * k[i - 1]) + (g[c[i - 1]][c[i]] * (1 - k[i - 1])) ); } if (f[i - 1][j - 1][0] != DBL_MAX) { f[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][0] + (g[c[i - 1]][d[i]] * k[i]) + (g[c[i - 1]][c[i]] * (1 - k[i])) ); } if (f[i - 1][j - 1][1] != DBL_MAX) { f[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][1] + (g[d[i - 1]][d[i]] * k[i - 1] * k[i]) + (g[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i]) + (g[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i])) + (g[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i])) ); } } #ifdef DBG for (int j = 0; j &lt;= max; j++) { printf("f[%d][%d][0] = %.4lf\n", i, j, f[i][j][0]); printf("f[%d][%d][1] = %.4lf\n", i, j, f[i][j][1]); } #endif } double ans = DBL_MAX; for (int i = 0; i &lt;= max; i++) { ans = std::min(ans, f[cnt][i][0]); ans = std::min(ans, f[cnt][i][1]); } printf("%.2lf\n", ans); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率与期望</tag>
        <tag>Floyd</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2016」天天爱跑步 - 树链剖分 + 前缀和]]></title>
    <url>%2Fnoip2016-running%2F</url>
    <content type="text"><![CDATA[小 C 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。 这个游戏的地图可以看作一棵包含 个结点和 条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从 到 的连续正整数。 现在有 个玩家，第 个玩家的起点为 ，终点为 。每天打卡任务开始时，所有玩家在第 秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的） 小 C 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 的观察员会选择在第 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 秒也理到达了结点 。小 C 想知道每个观察员会观察到多少人？ 注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一段时间后再被观察员观察到。即对于把结点 作为终点的玩家：若他在第 秒前到达终点，则在结点 的观察员不能观察到该玩家；若他正好在第 秒到达终点，则在结点 的观察员可以观察到这个玩家。 链接 Luogu 1600 LYOI #100 题解 考虑链的情况，在一个长度为 的链 上，有一个玩家从 走到 （），则第 个点能观测到该玩家的条件是 。 特别地，当 时，这个结论仍然成立。 对于 的情况，结论变为 。 同理， 时结论仍然成立，图略。 将上面的结论式子移项，当 时，，对于一个确定的 ，式子右边是一个常数。设 ，问题转化为： 每次在 的每个位置加入一个数； 询问对于每个 ，其位置上共有多少数等于 。 同理，当 时，，设 即可。 这个问题可以通过差分前缀和来解决，在 加入一个添加标记，在 加入一个删除标记。维护一个数组表示当前每个数的出现次数，按顺序枚举 ，对于每个 ，将这个位置上所有添加标记添加的数的计数加一，统计答案后将这个位置上所有删除标记删除的数的计数减一。 序列上的情况可以在 时间内解决，对于树上的情况，对树进行树链剖分，每个玩家的路线可以被分到最多 条重链上，将每条重链看作一个上述序列，以链上深度最小的点为 。从最近公共祖先处将路径分成两半，一半相当于序列上 的情况，另一半相当于序列上 的情况。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;stack&gt; const int MAXN = 299998; struct Tag { #ifdef FORCE int s, t, x; Tag(int s, int t, int x) : s(s), t(t), x(x) { #ifdef DBG printf("Tag(%d, %d, %d)\n", s, t, x); #endif } #else int x; bool remove; Tag(int x, bool remove) : x(x), remove(remove) {} #endif }; struct Node { struct Edge *e; Node *parent, *child; int depth, size, w, index, x, ans; bool visited; struct Chain *chain; #ifndef FORCE std::vector&lt;Tag&gt; tagsForward, tagsBackward; #endif } N[MAXN + 1]; struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {} }; struct Chain { Node *top, *bottom; std::vector&lt;Node *&gt; nodes; #ifdef FORCE std::vector&lt;Tag&gt; tagsForward, tagsBackward; #endif int len; } chains[MAXN + 1]; inline void addEdge(int s, int t) { N[s].e = new Edge(&amp;N[s], &amp;N[t]); N[t].e = new Edge(&amp;N[t], &amp;N[s]); } int n, chainCnt; inline void split() { std::stack&lt;Node *&gt; s; N[1].depth = 1; s.push(&amp;N[1]); while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (!e-&gt;t-&gt;depth) { e-&gt;t-&gt;depth = v-&gt;depth + 1; e-&gt;t-&gt;parent = v; s.push(e-&gt;t); } } } else { v-&gt;size = 1; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { v-&gt;size += e-&gt;t-&gt;size; if (!v-&gt;child || v-&gt;child-&gt;size &lt; e-&gt;t-&gt;size) v-&gt;child = e-&gt;t; } s.pop(); } } for (int i = 1; i &lt;= n; i++) N[i].visited = false; N[1].depth = 1; s.push(&amp;N[1]); while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; if (!v-&gt;parent || v != v-&gt;parent-&gt;child) { v-&gt;chain = &amp;chains[++chainCnt]; v-&gt;chain-&gt;top = v; v-&gt;index = 0; } else { v-&gt;chain = v-&gt;parent-&gt;chain; v-&gt;index = v-&gt;parent-&gt;index + 1; } v-&gt;chain-&gt;nodes.push_back(v); v-&gt;chain-&gt;bottom = v; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;t-&gt;parent == v) { s.push(e-&gt;t); } } } else { s.pop(); } } for (int i = 1; i &lt;= chainCnt; i++) chains[i].len = chains[i].nodes.size(); #ifdef DBG for (int i = 1; i &lt;= chainCnt; i++) { printf("chains[%d]: top = %lu, bottom = %lu, nodes = [", i, chains[i].top - N, chains[i].bottom - N); for (int j = 0; j &lt; chains[i].len; j++) { printf("%lu%s", chains[i].nodes[j] - N, j == chains[i].len - 1 ? "]\n" : ", "); } } #endif } inline Node *lca(Node *u, Node *v) { while (u-&gt;chain != v-&gt;chain) { if (u-&gt;chain-&gt;top-&gt;depth &lt; v-&gt;chain-&gt;top-&gt;depth) std::swap(u, v); u = u-&gt;chain-&gt;top-&gt;parent; } if (u-&gt;depth &gt; v-&gt;depth) return v; else return u; } inline int dist(Node *u, Node *v, Node *p) { return u-&gt;depth + v-&gt;depth - p-&gt;depth * 2; } inline void addTag(bool forward, Chain *chain, int s, int t, int x) { #ifdef FORCE if (forward) { chain-&gt;tagsForward.push_back(Tag(s, t, x)); } else { chain-&gt;tagsBackward.push_back(Tag(s, t, x)); } #else if (forward) { if (s &gt; t) return; chain-&gt;nodes[s]-&gt;tagsForward.push_back(Tag(x, false)); chain-&gt;nodes[t]-&gt;tagsForward.push_back(Tag(x, true)); } else { if (t &gt; s) return; chain-&gt;nodes[s]-&gt;tagsBackward.push_back(Tag(x, false)); chain-&gt;nodes[t]-&gt;tagsBackward.push_back(Tag(x, true)); } #ifdef DBG printf("addTag(forward = %d, chain = %lu, s = %d, t = %d, x = %d)\n", forward, chain - chains, s, t, x); #endif #endif } inline void play(Node *s, Node *t) { if (s == t) { if (s-&gt;w == 0) s-&gt;ans++; return; } Node *p = lca(s, t), *u = s, *v = t; if (dist(s, p, p) == p-&gt;w) p-&gt;ans++; #ifdef DBG printf("play(s = %lu, t = %lu, p = %lu)\n", s - N, t - N, p - N); #endif if (p != s) { #ifdef DBG puts("[backward]"); #endif // S -&gt; P, backward on chain while (u-&gt;chain != p-&gt;chain) { #ifdef DBG printf("chains[%lu]: ", u-&gt;chain - chains); #endif addTag(false, u-&gt;chain, u-&gt;index, 0, s-&gt;depth - u-&gt;chain-&gt;bottom-&gt;depth); u = u-&gt;chain-&gt;top-&gt;parent; } #ifdef DBG printf("chains[%lu]: ", u-&gt;chain - chains); #endif addTag(false, u-&gt;chain, u-&gt;index, p-&gt;index + 1, s-&gt;depth - u-&gt;chain-&gt;bottom-&gt;depth); } if (p != t) { #ifdef DBG puts("[forward]"); #endif // P -&gt; T, forward on chain while (v-&gt;chain != p-&gt;chain) { #ifdef DBG printf("chains[%lu]: ", v-&gt;chain - chains); #endif addTag(true, v-&gt;chain, 0, v-&gt;index, (s-&gt;depth - p-&gt;depth) + (v-&gt;chain-&gt;top-&gt;depth - p-&gt;depth)); v = v-&gt;chain-&gt;top-&gt;parent; } #ifdef DBG printf("chains[%lu]: ", v-&gt;chain - chains); #endif addTag(true, v-&gt;chain, p-&gt;index + 1, v-&gt;index, (s-&gt;depth - p-&gt;depth) + (v-&gt;chain-&gt;top-&gt;depth - p-&gt;depth)); } } inline void solve() { #ifdef FORCE for (int i = 1; i &lt;= chainCnt; i++) { Chain &amp;chain = chains[i]; #ifdef DBG printf("solve(): chains[%d]\n", i); #endif #ifdef DBG puts("[forward]"); #endif for (std::vector&lt;Tag&gt;::const_iterator it = chain.tagsForward.begin(); it != chain.tagsForward.end(); it++) { for (int j = it-&gt;s; j &lt;= it-&gt;t; j++) { if (chain.nodes[j]-&gt;w - j == it-&gt;x) { #ifdef DBG printf("ans(%lu)++\n", chain.nodes[j] - N); #endif chain.nodes[j]-&gt;ans++; } } } #ifdef DBG puts("[backward]"); #endif for (std::vector&lt;Tag&gt;::const_iterator it = chain.tagsBackward.begin(); it != chain.tagsBackward.end(); it++) { for (int j = it-&gt;s; j &gt;= it-&gt;t; j--) { if (chain.nodes[j]-&gt;w - chain.len + j + 1 == it-&gt;x) { #ifdef DBG printf("ans(%lu)++\n", chain.nodes[j] - N); #endif chain.nodes[j]-&gt;ans++; } } } } #else for (int i = 1; i &lt;= chainCnt; i++) { Chain &amp;chain = chains[i]; #ifdef DBG printf("solve(): chains[%d]\n", i); #endif static int _cnt[MAXN * 2 + 1], *cnt = _cnt + MAXN; // forward for (int j = 0; j &lt; chain.len; j++) { for (std::vector&lt;Tag&gt;::const_iterator it = chain.nodes[j]-&gt;tagsForward.begin(); it != chain.nodes[j]-&gt;tagsForward.end(); it++) { if (!it-&gt;remove) cnt[it-&gt;x]++; } chain.nodes[j]-&gt;ans += cnt[chain.nodes[j]-&gt;w - j]; #ifdef DBG printf("ans(%lu, i = %d, j = %d) += %d, x = %d\n", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]-&gt;w - j], chain.nodes[j]-&gt;w - j); #endif for (std::vector&lt;Tag&gt;::const_iterator it = chain.nodes[j]-&gt;tagsForward.begin(); it != chain.nodes[j]-&gt;tagsForward.end(); it++) { if (it-&gt;remove) cnt[it-&gt;x]--; } } // backward for (int j = chain.len - 1; j &gt;= 0; j--) { for (std::vector&lt;Tag&gt;::const_iterator it = chain.nodes[j]-&gt;tagsBackward.begin(); it != chain.nodes[j]-&gt;tagsBackward.end(); it++) { if (!it-&gt;remove) cnt[it-&gt;x]++; } chain.nodes[j]-&gt;ans += cnt[chain.nodes[j]-&gt;w - chain.len + j + 1]; #ifdef DBG printf("ans(%lu, i = %d, j = %d) += %d, x = %d\n", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]-&gt;w - chain.len + j + 1], chain.nodes[j]-&gt;w - chain.len + j + 1); #endif for (std::vector&lt;Tag&gt;::const_iterator it = chain.nodes[j]-&gt;tagsBackward.begin(); it != chain.nodes[j]-&gt;tagsBackward.end(); it++) { if (it-&gt;remove) cnt[it-&gt;x]--; } } } #endif } int main() { freopen("running.in", "r", stdin); freopen("running.out", "w", stdout); int m; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n - 1; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v); addEdge(u, v); } for (int i = 1; i &lt;= n; i++) { scanf("%d", &amp;N[i].w); } split(); while (m--) { int s, t; scanf("%d %d", &amp;s, &amp;t); play(&amp;N[s], &amp;N[t]); } solve(); for (int i = 1; i &lt;= n; i++) printf("%d%c", N[i].ans, i == n ? '\n' : ' '); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>NOIP</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2016」玩具谜题 - 模拟]]></title>
    <url>%2Fnoip2016-toy%2F</url>
    <content type="text"><![CDATA[小南有一套可爱的玩具小人，它们各有不同的职业。 有一天，这些玩具小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外。 这时 singer 告诉小南一个谜题：「眼镜藏在我左数第 个玩具小人的右数第 个玩具小人的左数第 个玩具小人那里。」 小南发现，这个谜题中玩具小人的朝向非常关键，因为朝内和朝外的玩具小人的左右方向是相反的：面朝圈内的玩具小人，它的左边是顺时针方向，右边是逆时针方向；而面向圈外的玩具小人，它的左边是逆时针方向，右边是顺时针方向。 小南一边艰难地辨认着玩具小人，一边数着： singer 朝内，左数第 个是 archer。 archer 朝外，右数第 个是 thinker。 thinker 朝外，左数第 个是 writer。 所以眼镜藏在 writer 这里！ 虽然成功找回了眼镜，但小南并没有放心。如果下次有更多的玩具小人藏他的眼镜，或是谜题的长度更长，他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。这样的谜题具体可以描述为： 有 个玩具小人围成一圈，已知它们的职业和朝向。现在第 个玩具小人告诉小南一个包含 条指令的谜题。其中第 条指令形如「左数/右数第 个玩具小人」。你需要输出依次数完这些指令后，到达的玩具小人的职业。 链接 Luogu 1563 LYOI #99 题解 维护当前是第几个小人，通过每个小人的朝向和指令方向判断下标的增减，每次增减下标后对 取模。 代码 #include &lt;cstdio&gt; const int MAXN = 1e5 + 10; const int MAXM = 1e5 + 10; int main() { freopen("toy.in", "r", stdin); freopen("toy.out", "w", stdout); int n, m; scanf("%d %d", &amp;n, &amp;m); static struct Node { char name[10 + 1]; int opposite; } a[MAXN]; for (int i = 0; i &lt; n; i++) { scanf("%d %s", &amp;a[i].opposite, a[i].name); } int curr = 0; while (m--) { // printf("%d: %s\n", curr, a[curr].name); int k, s; scanf("%d %d", &amp;k, &amp;s); int d = (k ^ a[curr].opposite) ? 1 : -1; (((curr += d * s) %= n) += n) %= n; } printf("%s\n", a[curr].name); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016 行纪]]></title>
    <url>%2Fnoip2016%2F</url>
    <content type="text"><![CDATA[第二次 NOIP。 倒数第二次 NOIP。 Day0 上午在机房玩了一会，十点半坐上了去日照的车，在车上打了三局狼人。 到了日照一中，报名排队好久，遇见了 lwyz 的神犇们，果断 % 一发。抽到了 10 考场，要去曲师大 …… 下午在阶梯教室遇见了省实验大佬 zyz、wjh 和 xzy 还有 Erii。 晚上试机，Dev-C++ 用着还算可以，竟然有 VC6，代码补全非常强！重启发现有 Linux，果断单用户 root 登录，格掉 sda3 发现是可以正常和 Windows 共享文件的，可惜命令行没法看题 …… Day1 早上吃完饭就做车去曲师大了。lyx 说突然就不慌了，但我自己还是有些紧张，毕竟高二了 …… 进了考场，解压密码是无意义字符串，感觉有些紧张。看了下题，感觉一三题都可做。 写了一下第一题，放在那里没管，然后去看第二题 …… 想到能把一条链拆成两段然后分别推一个式子，在 DFS 的时候统计答案 …… 写完之后过了样例 …… 可惜发现是完全错的，不是同一棵子树也会统计进去。已经浪费了两个多小时了，果断打了暴力 + 的部分分。 写第三题的时候只剩下半个多小时了，写了个 Floyd，特判了 和 。细节错误调了一会，最后没时间写 和 了 …… 想到的 DP 也没时间写了。 回去问了问 zyz，说 T2 我的想法已经接近正解了 …… T3 我想的 DP 状态是对的 …… 感觉药丸了 …… 一下午完全没有状态 …… 不想颓废也不想学习 …… 感觉这一年好像就要完了 …… 晚上和 zyz 聊了一会，感觉好些了。和省实验大佬们打了几局狼人，回去睡觉了。 Day2 早上状态还不错，进了考场没有前一天那么紧张了。 第一题一眼看出可以 Pascal 定理 + 前缀和做到 ，写完后打了暴力拍了一下，没问题。感觉 lyx 和 lyh 应该只能打暴力了 …… 考前没讲数学是我的锅啊 QAQ 第二题一眼看出可以全局表示 + 堆，然而这个复杂度在 CCF 评测机是过不了的 …… 没仔细想线性做法，怕和前一天犯一样的错误，去写第三题吧。 第三题一眼看出可以状压搜索，刚开始细节出了点问题，加上 GDB 在 Windows 下的 Bug，浪费了一些时间，DFS 写完后发现 会 T，果断改成 BFS 后时间可以接受了。复杂度应该是 的。 总体上来说，不是特别好，也不是特别差。 Day1 算是很差了，Day2 算不算翻盘？ 还是很害怕细节出问题，毕竟高二了 …… 没机会了 …… 「这一次就算考差，也并不能代表什么 ……」 「现在和高一的时候心情肯定是不一样的，到了高三再来的时候，又会是另外一种心情。」 「不还有一天吗，放开打就是了。还有二百天无所畏惧啊。」]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2012」疫情控制 - 二分 + 倍增 + 贪心]]></title>
    <url>%2Fnoip2012-blockade%2F</url>
    <content type="text"><![CDATA[H 国有 个城市，这 个城市用 条双向道路相互连通构成一棵树， 号城市是首都，也是树中的根节点。 H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。 现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。 请问最少需要多少个小时才能控制疫情。注意，不同的军队可以同时移动。 链接 CodeVS 1218 题解 首先二分答案 ，检验能否在 时间之内控制疫情。 倍增求出每个军队能到达的最高（深度最小的）点，考虑根节点的每棵子树，如果这棵子树无法被未能到达根的军队完全覆盖，则需要将一个到达根的军队移动到这棵子树上，或者让一个原本能从这棵子树移动到根军队回到这棵子树。 求出每个能到达根的军队的剩余时间（设它们为 集），和根到每个需要额外军队的子树的边权（设它们为 集）。 问题转化为，用 集去覆盖 集， 集中的每个元素可以覆盖 集中不大于它的元素，并且 中的每个元素可以额外覆盖 集中的一个元素，求能否覆盖。 分别将 集和 集排序，从小到大枚举 集中的每个元素，如果它可以额外覆盖的 集元素未被覆盖，则去覆盖这个元素，否则覆盖最小未被覆盖的 集元素。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;list&gt; const int MAXN = 50000; const int MAXN_LOG = 16; // Math.log2(50000) = 15.609640474436812 struct Node { struct Edge *e; Node *parent; bool visited, settled, childSettled; std::vector&lt;int&gt; arrived; } N[MAXN + 1], *seq[MAXN + 1]; struct Edge { Node *s, *t; Edge *next; int w; bool visited; std::list&lt;Edge *&gt;::iterator it; Edge(Node *s, Node *t, int w) : s(s), t(t), next(s-&gt;e), w(w) {} }; inline void addEdge(int s, int t, int w) { N[s].e = new Edge(&amp;N[s], &amp;N[t], w); N[t].e = new Edge(&amp;N[t], &amp;N[s], w); } int n, m, a[MAXN + 1], logn; int f[MAXN + 1][MAXN_LOG + 1]; long long g[MAXN + 1][MAXN_LOG + 1]; inline void prepare() { std::queue&lt;Node *&gt; q; N[1].visited = true; f[1][0] = 1; g[1][0] = 0; q.push(&amp;N[1]); int cnt = 0; while (!q.empty()) { Node *v = q.front(); q.pop(); seq[++cnt] = v; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (!e-&gt;t-&gt;visited) { e-&gt;t-&gt;visited = true; e-&gt;t-&gt;parent = v; f[e-&gt;t - N][0] = v - N; g[e-&gt;t - N][0] = e-&gt;w; q.push(e-&gt;t); } } } while ((1 &lt;&lt; logn) &lt;= n) logn++; logn--; for (int j = 1; j &lt;= logn; j++) { for (int i = 1; i &lt;= n; i++) { f[i][j] = f[f[i][j - 1]][j - 1]; g[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1]; } } } inline bool compare(Edge *a, Edge *b) { return a-&gt;w &lt; b-&gt;w; } inline bool check(long long limit) { for (int i = 1; i &lt;= n; i++) { N[i].arrived.clear(); N[i].settled = false; N[i].childSettled = false; } for (int i = 1; i &lt;= m; i++) { int u = a[i]; long long dist = 0; for (int j = logn; j &gt;= 0; j--) { if (dist + g[u][j] &lt;= limit &amp;&amp; f[u][j] != 1) { dist += g[u][j]; u = f[u][j]; } } N[u].arrived.push_back(limit - dist); } for (int i = n; i &gt;= 1; i--) { if (seq[i]-&gt;e-&gt;next || i == 1) { // It's not a leaf seq[i]-&gt;childSettled = true; for (Edge *e = seq[i]-&gt;e; e; e = e-&gt;next) { if (e-&gt;t == seq[i]-&gt;parent) continue; if (!e-&gt;t-&gt;settled) { seq[i]-&gt;childSettled = false; break; } } } #ifdef DBG printf("%lu: childSettled = %d, settled = %d\n", seq[i] - N, seq[i]-&gt;childSettled, seq[i]-&gt;settled); #endif seq[i]-&gt;settled = seq[i]-&gt;childSettled; if (seq[i]-&gt;arrived.size()) { seq[i]-&gt;settled = true; } } if (N[1].settled) return true; std::list&lt; std::pair&lt;int, Edge *&gt; &gt; atRoot; std::list&lt;Edge *&gt; needSettle; for (Edge *e = N[1].e; e; e = e-&gt;next) { #ifdef DBG printf("%lu: childSettled = %d\n", e-&gt;t - N, e-&gt;t-&gt;childSettled); #endif std::vector&lt;int&gt; &amp;vec = e-&gt;t-&gt;arrived; std::sort(vec.begin(), vec.end()); bool remain = e-&gt;t-&gt;childSettled; for (size_t i = 0; i &lt; vec.size(); i++) { if (vec[i] &gt;= e-&gt;w) atRoot.push_back(std::make_pair(vec[i] - e-&gt;w, e)); else remain = true; } if (remain) { e-&gt;visited = true; } else { needSettle.push_back(e); e-&gt;it = --needSettle.end(); e-&gt;visited = false; } } atRoot.sort(); needSettle.sort(&amp;compare); #ifdef DBG std::vector&lt; std::pair&lt;int, Edge *&gt; &gt; _atRoot(atRoot.begin(), atRoot.end()); std::vector&lt;Edge *&gt; _needSettle(needSettle.begin(), needSettle.end()); #endif // std::sort(needSettle.begin(), needSettle.end(), &amp;compare); for (std::list&lt; std::pair&lt;int, Edge *&gt; &gt;::iterator it = atRoot.begin(); it != atRoot.end(); it++) { if (needSettle.empty()) break; if (!it-&gt;second-&gt;visited) { it-&gt;second-&gt;visited = true; needSettle.erase(it-&gt;second-&gt;it); } else { if (needSettle.front()-&gt;w &lt;= it-&gt;first) { needSettle.front()-&gt;visited = true; needSettle.pop_front(); } } } return needSettle.empty(); } int main() { scanf("%d", &amp;n); long long sum = 0; for (int i = 1; i &lt;= n - 1; i++) { int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); sum += w; addEdge(u, v, w); } prepare(); scanf("%d", &amp;m); for (int i = 1; i &lt;= m; i++) { scanf("%d", &amp;a[i]); } int cnt = 0; for (Edge *e = N[1].e; e; e = e-&gt;next) cnt++; if (cnt &gt; m) puts("-1"); else { int l = 0, r = sum; while (l &lt; r) { int mid = l + (r - l) / 2; #ifdef DBG printf("[%d, %d], mid = %d\n", l, r, mid); #endif if (check(mid)) r = mid; else l = mid + 1; } printf("%d\n", l); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>CodeVS</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2010」引水入城 - BFS + DP]]></title>
    <url>%2Fnoip2010-flow%2F</url>
    <content type="text"><![CDATA[在一个遥远的国度，一侧是风景秀美的湖泊，另一侧则是漫无边际的沙漠。该国的行政区划十分特殊，刚好构成一个 行 列的矩形，如上图所示，其中每个格子都代表一座城市，每座城市都有一个海拔高度。 为了使居民们都尽可能饮用到清澈的湖水，现在要在某些城市建造水利设施。水利设施有两种，分别为蓄水厂和输水站。蓄水厂的功能是利用水泵将湖泊中的水抽取到所在城市的蓄水池中。因此，只有与湖泊毗邻的第 行的城市可以建造蓄水厂。而输水站的功能则是通过输水管线利用高度落差，将湖水从高处向低处输送。故一座城市能建造输水站的前提，是存在比它海拔更高且拥有公共边的相邻城市，已经建有水利设施。 由于第 行的城市靠近沙漠，是该国的干旱区，所以要求其中的每座城市都建有水利设施。那么，这个要求能否满足呢？如果能，请计算最少建造几个蓄水厂；如果不能，求干旱区中不可能建有水利设施的城市数目。 链接 CodeVS 1066 题解 对于第一问，以第一行为起点，做 Floodfill，如果最后一行均能访问到，则能满足。 对于第二问，分别以第一行每个点为起点，做 Floodfill，得到它能到达的最后一行的所有点，这些点一定构成了一个连续的区间（证明略）。得到 个区间，问题转化为选择尽量少的区间，覆盖整个区域 —— 排序后 DP 即可。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;queue&gt; const int MAXN = 500; const int di[] = { 0, 1, 0, -1 }; const int dj[] = { -1, 0, 1, 0 }; struct Node { int height; bool visited; } map[MAXN + 2][MAXN + 2]; int n, m; struct Point { int i, j; Point(int i = 0, int j = 0) : i(i), j(j) {} Point move(int x) { return Point(i + di[x], j + dj[x]); } bool valid() { return i &gt; 0 &amp;&amp; j &gt; 0 &amp;&amp; i &lt;= n &amp;&amp; j &lt;= m; } Node *operator-&gt;() const { return &amp;map[i][j]; } }; struct Interval { int l, r; Interval(int l = 0, int r = 0) : l(l), r(r) {} bool operator&lt;(const Interval &amp;other) const { return (l == other.l) ? (r &lt; other.r) : (l &lt; other.l); } }; inline int bfs(Point start, Interval &amp;interval) { for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) map[i][j].visited = false; std::queue&lt;Point&gt; q; if (start.i == 0 &amp;&amp; start.j == 0) { for (int i = 1; i &lt;= m; i++) { map[1][i].visited = true; q.push(Point(1, i)); } } else { q.push(start); start-&gt;visited = true; } while (!q.empty()) { Point v = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) { Point u = v.move(i); if (!u.valid()) continue; if (u-&gt;height &lt; v-&gt;height &amp;&amp; !u-&gt;visited) { u-&gt;visited = true; q.push(u); } } } if (start.i == 0 &amp;&amp; start.j == 0) { int cnt = 0; for (int i = 1; i &lt;= m; i++) if (!map[n][i].visited) cnt++; return cnt; } bool flag = false; #ifdef DBG printf("%d:", start.j); #endif for (int i = 1; i &lt;= m + 1; i++) { #ifdef DBG if (map[n][i].visited) { printf(" %d", i); } #endif if (!flag &amp;&amp; map[n][i].visited) { interval.l = i; flag = true; } else if (flag &amp;&amp; !map[n][i].visited) { interval.r = i - 1; break; } } #ifdef DBG printf(" = [%d, %d]\n", interval.l, interval.r); #endif return flag; } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) scanf("%d", &amp;map[i][j].height); Interval tmp; int cnt = bfs(Point(0, 0), tmp); if (cnt) { printf("0\n%d\n", cnt); } else { static Interval a[MAXN + 1]; int k = 0; for (int i = 1; i &lt;= m; i++) { Interval interval; if (bfs(Point(1, i), interval)) { a[++k] = interval; } } std::sort(a + 1, a + k+ 1); static int f[MAXN + 1]; int ans = INT_MAX; for (int i = 1; i &lt;= k; i++) { f[i] = INT_MAX; for (int j = 0; j &lt; i; j++) { if (a[j].r &gt;= a[i].l - 1) { f[i] = std::min(f[i], f[j] + 1); } } if (a[i].r == m) ans = std::min(ans, f[i]); } printf("1\n%d\n", ans); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>CodeVS</tag>
        <tag>线性 DP</tag>
        <tag>BFS</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2012」开车旅行 - 倍增]]></title>
    <url>%2Fnoip2012-drive%2F</url>
    <content type="text"><![CDATA[小 A 和小 B 决定利用假期外出旅行，他们将想去的城市从 到 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 的海拔高度为 ，城市 和城市 之间的距离 恰好是这两个城市海拔高度之差的绝对值，即 。 旅行过程中，小 A 和小 B 轮流开车，第一天小 A 开车，之后每天轮换一次。他们计划选择一个城市 作为起点，一直向东行驶，并且最多行驶 公里就结束旅行。小 A 和小 B 的驾驶风格不同，小 B 总是沿着前进方向选择一个最近的城市作为目的地，而小 A 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 公里，他们就会结束旅行。 在启程之前，小 A 想知道两个问题： 对于一个给定的 ，从哪一个城市出发，小 A 开车行驶的路程总数与小 B 行驶的路程总数的比值最小（如果小 B 的行驶路程为 ，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 A 开车行驶的路程总数与小 B 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。 对任意给定的 和出发城市 ，小 A 开车行驶的路程总数以及小 B 行驶的路程总数。 链接 CodeVS 1199 题解 使用排序 + 链表求出在以个点为起点时，小 A 和小 B 开车到达的地点。 设 表示以小 A（）或小 B（）开始，以 为起点， 天后到达的地点； 表示以小 A（）或小 B（）开始，以 为起点， 天内，小 A（）或小 B（）或二者之和 的路程。 对于第一问，枚举起点即可。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;list&gt; const int MAXN = 100000; const int MAXN_LOG = 17; // Math.log2(100000) = 16.609640474436812 const int MAXM = 10000; struct Node { long long x; Node *nextA, *nextB; std::list&lt;Node *&gt;::iterator it; } N[MAXN + 1]; int n, logn, f[2][MAXN + 1][MAXN_LOG + 1]; long long g[2][MAXN + 1][MAXN_LOG + 1][3]; inline bool compareNode(Node *a, Node *b) { return a-&gt;x &lt; b-&gt;x; } inline bool comparePair(const std::pair&lt;long long, Node *&gt; &amp;a, const std::pair&lt;long long, Node *&gt; &amp;b) { if (a.first == b.first) return a.second-&gt;x &lt; b.second-&gt;x; else return a.first &lt; b.first; } inline void prepare() { std::list&lt;Node *&gt; list; for (int i = 1; i &lt;= n; i++) { list.push_back(&amp;N[i]); N[i].it = --list.end(); } list.sort(&amp;compareNode); for (int i = 1; i &lt;= n; i++) { std::vector&lt; std::pair&lt;long long, Node *&gt; &gt; vec; std::list&lt;Node *&gt;::iterator near; near = N[i].it, near++; if (near != list.end()) { vec.push_back(std::make_pair(abs((*near)-&gt;x - N[i].x), *near)); if (++near != list.end()) { vec.push_back(std::make_pair(llabs((*near)-&gt;x - N[i].x), *near)); } } near = N[i].it; if (near != list.begin()) { near--; vec.push_back(std::make_pair(abs((*near)-&gt;x - N[i].x), *near)); if (near != list.begin()) { near--; vec.push_back(std::make_pair(llabs((*near)-&gt;x - N[i].x), *near)); } } std::sort(vec.begin(), vec.end(), comparePair); if (vec.size() &gt;= 2) { N[i].nextA = vec[1].second; #ifdef DBG printf("nextA(%lld) = %lld\n", N[i].x, N[i].nextA-&gt;x); #endif } else N[i].nextA = &amp;N[0]; if (vec.size() &gt;= 1) { N[i].nextB = vec[0].second; #ifdef DBG printf("nextB(%lld) = %lld\n", N[i].x, N[i].nextB-&gt;x); #endif } else N[i].nextB = &amp;N[0]; list.erase(N[i].it); } N[0].nextA = N[0].nextB = &amp;N[0]; // Build graph for (int i = 1; i &lt;= n; i++) { f[0][i][0] = N[i].nextA - N; f[0][i][1] = N[i].nextA-&gt;nextB - N; f[1][i][0] = N[i].nextB - N; f[1][i][1] = N[i].nextB-&gt;nextA - N; g[0][i][0][0] = g[0][i][0][2] = N[i].nextA == &amp;N[0] ? 0 : llabs(N[i].x - N[i].nextA-&gt;x); g[0][i][0][1] = 0; g[1][i][0][1] = g[1][i][0][2] = N[i].nextB == &amp;N[0] ? 0 : llabs(N[i].x - N[i].nextB-&gt;x); g[1][i][0][0] = 0; } for (int i = 1; i &lt;= n; i++) { g[0][i][1][0] = g[0][i][0][0]; g[0][i][1][1] = g[1][N[i].nextA - N][0][1]; g[0][i][1][2] = g[0][i][0][0] + g[1][N[i].nextA - N][0][1]; g[1][i][1][1] = g[1][i][0][1]; g[1][i][1][0] = g[0][N[i].nextB - N][0][0]; g[1][i][1][2] = g[1][i][0][1] + g[0][N[i].nextB - N][0][0]; } while ((1 &lt;&lt; logn) &lt;= n) logn++; logn--; for (int j = 2; j &lt;= logn; j++) { for (int i = 1; i &lt;= n; i++) { for (int k = 0; k &lt; 2; k++) { for (int l = 0; l &lt; 3; l++) { g[k][i][j][l] = g[k][i][j - 1][l] + g[k][f[k][i][j - 1]][j - 1][l]; } f[k][i][j] = f[k][f[k][i][j - 1]][j - 1]; } } } #ifdef DBG for (int j = 0; j &lt;= logn; j++) { for (int i = 1; i &lt;= n; i++) { for (int k = 0; k &lt; 2; k++) { printf("f(%d, %d, %d) = %d [%lld]\n\n", k, i, j, f[k][i][j], N[f[k][i][j]].x); for (int l = 0; l &lt; 3; l++) { printf("g(%d, %d, %d, %d) = %lld\n", k, i, j, l, g[k][i][j][l]); } putchar('\n'); } } } #endif } inline long long solve(int start, long long limit, long long &amp;sumA, long long &amp;sumB) { int curr = start; long long sum = sumA = sumB = 0; for (int i = logn; i &gt;= 1 &amp;&amp; curr != 0; i--) { while (curr &amp;&amp; limit &gt;= sum + g[0][curr][i][2]) { sum += g[0][curr][i][2]; sumA += g[0][curr][i][0]; sumB += g[0][curr][i][1]; curr = f[0][curr][i]; } } if (curr &amp;&amp; limit &gt;= sum + g[0][curr][0][0]) { sumA += g[0][curr][0][0]; sum += g[0][curr][0][0]; } return sum; } inline int solve(long long limit) { int ans = 0; double k = -1; for (int i = 1; i &lt;= n; i++) { long long tmpA, tmpB; solve(i, limit, tmpA, tmpB); double t = static_cast&lt;double&gt;(tmpA) / static_cast&lt;double&gt;(tmpB); if (k == -1 || t &lt; k || (t == k &amp;&amp; N[i].x &gt; N[ans].x)) { k = t; ans = i; } } return ans; } int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;N[i].x); prepare(); long long limit; scanf("%lld", &amp;limit); printf("%d\n", solve(limit)); int m; scanf("%d", &amp;m); while (m--) { int start; long long limit; scanf("%d %lld", &amp;start, &amp;limit); long long sumA, sumB; solve(start, limit, sumA, sumB); printf("%lld %lld\n", sumA, sumB); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>CodeVS</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2013」华容道 - BFS + SPFA]]></title>
    <url>%2Fnoip2013-puzzle%2F</url>
    <content type="text"><![CDATA[在一个 棋盘上有 个格子，其中有且只有一个格子是空白的，其余 个格子上每个格子上有一个棋子，每个棋子的大小都是 的； 有些棋子是固定的，有些棋子则是可以移动的； 任何与空白的格子相邻（有公共的边）的格子上的棋子都可以移动到空白格子上。游戏的目的是把某个指定位置可以活动的棋子移动到目标位置。 给定一个棋盘，游戏可以玩 次，当然，每次棋盘上固定的格子是不会变的，但是棋盘上空白的格子的初始位置、指定的可移动的棋子的初始位置和目标位置却可能不同。第 次玩的时候，空白的格子在第 行第 列，指定的可移动棋子的初始位置为第 行第 列，目标位置为第 行第 列。 假设小 B 每秒钟能进行一次移动棋子的操作，而其他操作的时间都可以忽略不计。请你告诉小 B 每一次游戏所需要的最少时间，或者告诉他不可能完成游戏。 链接 CodeVS 1218 题解 一次游戏可以分为两个过程 —— 将空白格子移动到目标棋子的周围，将空白格子和目标棋子一起移动。显然，第二个过程中，每一步都是先将空白格子和目标格子交换，再将空白格子移动到目标格子的另一个相邻位置，下一步继续交换。 预处理出 表示当目标棋子在 ，空白格子在它的 相邻方向上，（保持目标棋子不动）将空白格子移动到 相邻方向上，所需的最小代价。 对于一次游戏，首先枚举将空白格子移动到目标棋子的哪个方向上，之后循环进行以下两个操作： 交换空白格子和目标棋子； 将空白格子移动到目标棋子的另一个相邻方向上。 我们可以用 描述一个状态 —— 目标棋子在 上，空白格子在它的 相邻方向上。结合预处理出的 ，在状态图上求最短路即可。 注意起点与终点相同的特判。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 30; const int MAXQ = 500; const int di[] = { 1, 0, 0, -1 }; const int dj[] = { 0, 1, -1, 0 }; int n, m; struct Node { bool invalid; int cost[4][4]; int dist; // BFS prepare struct { int dist; bool inq; } v[4]; // SPFA } map[MAXN + 1][MAXN + 1]; struct Point { int i, j; Point() {} Point(int i, int j) : i(i), j(j) {} Point move(int x) { return Point(i + di[x], j + dj[x]); } Node *operator-&gt;() const { return &amp;map[i][j]; } bool valid() const { return i &gt; 0 &amp;&amp; j &gt; 0 &amp;&amp; i &lt;= n &amp;&amp; j &lt;= m; } bool operator==(const Point &amp;other) const { return i == other.i &amp;&amp; j == other.j; } }; struct Status { Point p; int d; Status(Point p, int d) : p(p), d(d) {} }; inline int bfs(Point s, Point t, Point p) { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { map[i][j].dist = INT_MAX; } } std::queue&lt;Point&gt; q; s-&gt;dist = 0; q.push(s); while (!q.empty()) { Point v = q.front(); q.pop(); if (v == t) return v-&gt;dist; for (int i = 0; i &lt; 4; i++) { Point u = v.move(i); if (u-&gt;invalid || u == p) continue; if (u-&gt;dist &gt; v-&gt;dist + 1) { u-&gt;dist = v-&gt;dist + 1; q.push(u); } } } return INT_MAX; } inline void prepare() { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (map[i][j].invalid) continue; Point v(i, j); for (int s = 0; s &lt; 4; s++) { Point ps = v.move(s); for (int t = s + 1; t &lt; 4; t++) { Point pt = v.move(t); if (!ps.valid() || ps-&gt;invalid || !pt.valid() || pt-&gt;invalid) v-&gt;cost[s][t] = v-&gt;cost[t][s] = INT_MAX; else v-&gt;cost[s][t] = v-&gt;cost[t][s] = bfs(ps, pt, v); #ifdef DBG printf("[%d, %d] %d =&gt; %d = %d\n", v.i, v.j, s, t, v-&gt;cost[s][t]); #endif } } } } } inline int spfa(Status s, Point t) { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { for (int k = 0; k &lt; 4; k++) { map[i][j].v[k].dist = INT_MAX; map[i][j].v[k].inq = false; } } } std::queue&lt;Status&gt; q; q.push(s); s.p-&gt;v[s.d].dist = 0; while (!q.empty()) { Status status = q.front(); q.pop(); Point &amp;v = status.p; int &amp;d = status.d; v-&gt;v[d].inq = false; // Move the empty block for (int i = 0; i &lt; 4; i++) { if (i == d || v-&gt;cost[d][i] == INT_MAX) continue; if (v-&gt;v[i].dist &gt; v-&gt;v[d].dist + v-&gt;cost[d][i]) { v-&gt;v[i].dist = v-&gt;v[d].dist + v-&gt;cost[d][i]; #ifdef DBG printf("[%d, %d]-&gt;v[%d]-&gt;dist = %d\n", v.i, v.j, i, v-&gt;v[i].dist); #endif if (!v-&gt;v[i].inq) { v-&gt;v[i].inq = true; q.push(Status(v, i)); } } } // Swap if (v-&gt;v[d].dist != INT_MAX) { Point u = v.move(d); int t = 3 - d; if (u-&gt;v[t].dist &gt; v-&gt;v[d].dist + 1) { u-&gt;v[t].dist = v-&gt;v[d].dist + 1; if (!u-&gt;v[t].inq) { u-&gt;v[t].inq = true; q.push(Status(u, t)); } } } } int res = INT_MAX; for (int i = 0; i &lt; 4; i++) { res = std::min(res, t-&gt;v[i].dist); } return res; } int main() { int q; scanf("%d %d %d", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { int x; scanf("%d", &amp;x); map[i][j].invalid = (x == 0); } } prepare(); while (q--) { Point empty, s, t; scanf("%d %d %d %d %d %d", &amp;empty.i, &amp;empty.j, &amp;s.i, &amp;s.j, &amp;t.i, &amp;t.j); if (s == t) { puts("0"); continue; } int ans = INT_MAX; for (int i = 0; i &lt; 4; i++) { Point v = s.move(i); if (!v.valid()) continue; int d1 = bfs(empty, v, s); if (d1 == INT_MAX) continue; int d2 = spfa(Status(s, i), t); if (d2 == INT_MAX) continue; ans = std::min(ans, d1 + d2); } printf("%d\n", ans == INT_MAX ? -1 : ans); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>CodeVS</tag>
        <tag>最短路</tag>
        <tag>BFS</tag>
        <tag>NOIP</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2008」糖果传递 - 数学]]></title>
    <url>%2Fhaoi2008-candy%2F</url>
    <content type="text"><![CDATA[有 个小朋友坐成一圈，每人有 个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为 。求使所有人获得均等糖果的最小代价。 链接 BZOJ 1045 题解 设 ， 表示第 个人给第 个人的数量，则有 即 我们的目标是最小化 。 设 ，则 即，最小化 问题转化为，在数轴上找一个点，到给定一些点的距离之和最小。答案即为 的中位数。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 1000000; int main() { int n; scanf("%d", &amp;n); static long long a[MAXN]; long long sum = 0; for (int i = 0; i &lt; n; i++) { scanf("%lld", &amp;a[i]); sum += a[i]; } long long avg = sum / n; static long long c[MAXN]; c[0] = 0; for (int i = 1; i &lt; n; i++) c[i] = c[i - 1] - a[i] + avg; std::sort(c, c + n); long long mid = c[n / 2], ans = 0; for (int i = 0; i &lt; n; i++) ans += llabs(c[i] - mid); printf("%lld\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>HAOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2008」木棍分割 - 二分 + DP]]></title>
    <url>%2Fhaoi2008-stick%2F</url>
    <content type="text"><![CDATA[有 根木棍，第 根木棍的长度为 ， 根木棍依次连结了一起，总共有 个连接处。现在允许你最多砍断 个连接处，砍完后 根木棍被分成了很多段，要求满足总长度最大的一段长度最小，和有多少种砍的方法使得总长度最大的一段长度最小。 链接 BZOJ 1044 题解 第一问，求最大一段长度最小，二分答案，设答案为 。 第二问，求方案数，设 表示前 根木棍，分成 段，最大长度不大于 的方案数。 设前缀和 为前 根木棍的和 显然，满足条件的 一定是紧贴着 的连续的一段，并且对于同一个 ，最小的 是不降的。 对 的 做前缀和，每次找到满足条件的 即可。 需要滚动数组。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 50000; const int MAXM = 1000; const int MO = 10007; int n, m, a[MAXN + 1], s[MAXN + 1]; inline bool check(int limit) { int k = m, s = 0; for (int i = 1; i &lt;= n; i++) { if (s + a[i] &gt; limit) k--, s = a[i]; else s += a[i]; } return k &gt;= 1; } int main() { scanf("%d %d", &amp;n, &amp;m), m++; int max = 0; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), max = std::max(max, a[i]); for (int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + a[i]; int l = max, r = s[n]; while (r - l &gt;= 5) { int mid = l + (r - l) / 2; // printf("[%d, %d, %d]\n", l, r, mid); if (check(mid)) r = mid; else l = mid; } int ans; for (int i = l; i &lt;= r; i++) { if (check(i)) { ans = i; break; } } printf("%d ", ans); int tot = 0; static int f[MAXN + 1][2]; for (int i = 1; i &lt;= n; i++) f[i][1] = s[i] &lt;= ans ? 1 : 0; for (int j = 2; j &lt;= m; j++) { for (int i = 1; i &lt;= n; i++) (f[i][(j - 1) &amp; 1] += f[i - 1][(j - 1) &amp; 1]) %= MO; for (int i = 1, k = j; i &lt;= n; i++) { f[i][j &amp; 1] = 0; while (k &lt;= i &amp;&amp; s[i] - s[k - 1] &gt; ans) k++; if (k &lt;= i &amp;&amp; s[i] - s[k - 1] &lt;= ans) { // printf("f(%d, %d) += f([%d, %d], %d)\n", i, j, i - 1, k - 1, j - 1); (f[i][j &amp; 1] += f[i - 1][(j - 1) &amp; 1] - f[k - 2][(j - 1) &amp; 1]) %= MO; } /* for (int k = j; k &lt;= i; k++) { if (s[i] - s[k - 1] &lt;= ans) { f[i][j] += f[k - 1][j - 1]; } } */ // printf("f(%d, %d) = %d\n", i, j, f[i][j]); // f[i][j] += f[i - 1][j]; } (tot += f[n][j &amp; 1]) %= MO; } // for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) printf("f(%d, %d) = %d\n", i, j, f[i][j]); printf("%d\n", (tot + MO) % MO); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>二分</tag>
        <tag>HAOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2008」硬币购物 - 背包 DP + 容斥原理]]></title>
    <url>%2Fhaoi2008-coins%2F</url>
    <content type="text"><![CDATA[一共有 种硬币。面值分别为 。某人去商店买东西，去了 次。每次带 枚 硬币，买 的价格的东西。请问每次有多少种付款方法？ 链接 BZOJ 1042 题解 首先，求出不限制使用次数，购买价值为 时的方案数，设它为 。 对于每次询问，我们可以用不限制使用次数，购买价值 的方案数，减去任意一种硬币超过限制的方案数。任意一种硬币超过限制的方案数可以使用容斥原理求出，即 —— 每一种硬币超过限制的方案数之和 - 每两种硬币超过限制的方案数之和 + 每三种硬币超过限制的方案数之和 - 四种硬币全部超过限制的方案数。 考虑如何求出第 种硬币超过限制的方案数 —— 我们至少要使用 个第 种硬币，剩余的 元可以任意选择，即 。多种硬币同理。 代码 #include &lt;cstdio&gt; const int MAXN = 1000; const int MAXM = 100000; int main() { int c[4 + 1], n; scanf("%d %d %d %d %d", &amp;c[1], &amp;c[2], &amp;c[3], &amp;c[4], &amp;n); static long long f[4 + 1][MAXM + 1]; f[0][0] = 1; for (int i = 1; i &lt;= 4; i++) { for (int j = 0; j &lt;= MAXM; j++) { if (j &lt; c[i]) f[i][j] = f[i - 1][j]; else f[i][j] = f[i - 1][j] + f[i][j - c[i]]; } } while (n--) { int d[4 + 1], m; scanf("%d %d %d %d %d", &amp;d[1], &amp;d[2], &amp;d[3], &amp;d[4], &amp;m); long long ans = f[4][m]; for (int i = 1; i &lt;= 4; i++) { if (m - (d[i] + 1) * c[i] &gt;= 0) ans -= f[4][m - (d[i] + 1) * c[i]]; } for (int i = 1; i &lt;= 4; i++) { for (int j = i + 1; j &lt;= 4; j++) { if (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] &gt;= 0) ans += f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j]]; } } for (int i = 1; i &lt;= 4; i++) { for (int j = i + 1; j &lt;= 4; j++) { for (int k = j + 1; k &lt;= 4; k++) { if (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k] &gt;= 0) ans -= f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k]]; } } } if (m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4] &gt;= 0) ans += f[4][m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4]]; printf("%lld\n", ans); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>背包 DP</tag>
        <tag>HAOI</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2008」圆上的整点 - 数学]]></title>
    <url>%2Fhaoi2008-cir%2F</url>
    <content type="text"><![CDATA[求一个给定的圆 ，在圆周上有多少个点的坐标是整数。 链接 BZOJ 1041 题解 设 ，，，必有 。 和 是完全平方数，所以 是完全平方数；又因为 ，所以 和 分别是完全平方数。 即，每一个整点都对应了一组 ，满足 和 是完全平方数，且 是 的约数。 枚举 ，枚举 ，求出 ，判断 即可。 这样求出的是第一象限的整点数量，设它为 ，则答案为 。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; const int MAXN = 2e9; const double EPS = 1e-6; int main() { long long r; scanf("%lld", &amp;r); // 2 * r = d * (a ^ 2 + b ^ 2) long long cnt = 0; for (long long i = 1; i * i &lt;= r * 2; i++) { if (2 * r % i != 0) continue; long long d = i; long long t = 2 * r / i; for (int j = 0; j &lt; 2; j++) { for (long long a = 1; a * a &lt; t / 2; a++) { double b = sqrt(t - a * a); long long _b = static_cast&lt;long long&gt;(b); if (fabs(b - _b) &lt;= EPS &amp;&amp; std::__gcd(a, _b) == 1) { // printf("d = %lld, a = %lld, b = %lld\n", d, a, _b); cnt++; } } if (t != d) std::swap(t, d); else break; } } printf("%lld\n", cnt * 4 + 4); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>HAOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2008」生日聚会 - DP]]></title>
    <url>%2Fzjoi2008-party%2F</url>
    <content type="text"><![CDATA[对于任意连续的一段，男孩与女孩的数目之差不超过 。假设参加 party 的人中共有 个男孩与 个女孩，求方案总数。 链接 BZOJ 1037 题解 设 表示前 个人中，有 个男孩，包含第 个人的连续区间中，男孩最多比女孩多 个，女孩最多比男孩多 个，的方案数。 如果第 个是男孩 如果第 个是男孩 答案即为 。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 150; const int MAXK = 20; const int MOD = 12345678; int main() { int n, m, k; scanf("%d %d %d", &amp;n, &amp;m, &amp;k); // f[i][j][p][q], left i, j boys, max(boys - girls) = p, max(girls - boys) = q static int f[MAXN * 2 + 1][MAXN + 1][MAXK + 2][MAXK + 2]; f[0][0][0][0] = 1; for (int i = 0; i &lt; n + m; i++) { for (int j = 0; j &lt;= n; j++) { for (int p = 0; p &lt;= k; p++) { for (int q = 0; q &lt;= k; q++) { // Add a boy (f[i + 1][j + 1][p + 1][std::max(q - 1, 0)] += f[i][j][p][q]) %= MOD; // Add a girl (f[i + 1][j][std::max(p - 1, 0)][q + 1] += f[i][j][p][q]) %= MOD; } } } } int ans = 0; for (int p = 0; p &lt;= k; p++) for (int q = 0; q &lt;= k; q++) (ans += f[n + m][n][p][q]) %= MOD; printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2008」泡泡堂 - 贪心]]></title>
    <url>%2Fzjoi2008-bnb%2F</url>
    <content type="text"><![CDATA[两队分别 个选手对战，已知每个选手的实力，实力强的选手一定获胜。每一场胜、平、败的得分分别为 。求一个队能获得的最高得分和最低得分。 链接 BZOJ 1034 题解 贪心，从弱到强考虑队伍 A 中的每一个人，如果它可以战胜 B 中的某一个人，则让它战胜 B 中它能战胜的最强的人。最后考虑 A 中剩余的人，尽量让这些人和 B 中的人平局。 证明略。 代码 #include &lt;cstdio&gt; #include &lt;set&gt; const int MAXN = 100000; int n; inline int solve(const int *a, const int *b) { std::multiset&lt;int&gt; sa, sb; for (int i = 0; i &lt; n; i++) sa.insert(a[i]), sb.insert(b[i]); int ans = 0; for (std::multiset&lt;int&gt;::iterator it = sa.begin(); it != sa.end(); ) { std::multiset&lt;int&gt;::iterator target = sb.lower_bound(*it); if (target == sb.begin()) { it++; } else { target--; sb.erase(target); sa.erase(it++); ans += 2; } } for (std::multiset&lt;int&gt;::iterator it = sa.begin(); it != sa.end(); it++) { std::multiset&lt;int&gt;::iterator target = sb.lower_bound(*it); if (*target == *it) sb.erase(target), ans++; } return ans; } int main() { scanf("%d", &amp;n); static int a[MAXN], b[MAXN]; for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;b[i]); /* std::sort(a, a + n); std::sort(b, b + n); */ printf("%d %d\n", solve(a, b), n * 2 - solve(b, a)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>贪心</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2007」建筑抢修 - 贪心]]></title>
    <url>%2Fjsoi2007-repair%2F</url>
    <content type="text"><![CDATA[部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。 链接 BZOJ 1029 题解 将所有建筑按照最晚修理时间排序，维护当前时间点，枚举每个建筑，如果当前安时间足够修理这个建筑，则修理这个建筑，并将当前时间加上修理所用时间。如果当前时间不足以修改这个建筑，则尝试替换之前修理的所用时间最多的一个建筑。因为当前建筑的最晚修理时间更大，且用时更短，所以这样替换一定合法，并且这样替换可以使答案不变的情况下当前时间点尽量小。 使用优先队列维护最大值。 代码 #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;utility&gt; #include &lt;algorithm&gt; const int MAXN = 150000; int main() { int n; scanf("%d", &amp;n); static std::pair&lt;int, int&gt; a[MAXN]; for (int i = 0; i &lt; n; i++) scanf("%d %d", &amp;a[i].second, &amp;a[i].first); std::sort(a, a + n); std::priority_queue&lt;int&gt; q; long long t = 0; int ans = 0; for (int i = 0; i &lt; n; i++) { if (t + a[i].second &lt;= a[i].first) { t += a[i].second; q.push(a[i].second); ans++; } else if (!q.empty() &amp;&amp; q.top() &gt; a[i].second) { t -= q.top(); t += a[i].second; q.pop(); q.push(a[i].second); } } printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>贪心</tag>
        <tag>JSOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2007」麻将 - 枚举 + 贪心]]></title>
    <url>%2Fjsoi2007-mahjong%2F</url>
    <content type="text"><![CDATA[在这种特殊的麻将里，没有字牌，花色也只有一种。但是，序数 不被限制在一到九的范围内，而是在 到 的范围内。同时，也没有每一种牌四张的限制。一组和了的牌由 张牌组成，其中两张组成对子，其余 张组成三张一组的 组，每组须为顺子或刻子。现给出一组 张的牌，要求判断该组牌是否为听牌（即还差一张就可以和牌）。如果是的话，输出所有可能的等待牌。 链接 BZOJ 1028 题解 枚举答案，将这种牌数量 ，枚举对子，判断剩余的牌能否出完，即优先出三张相同的牌，不足三张的判断能否与之后的牌组成顺子。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 400; const int MAXM = 1000; int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); static int a[MAXN]; for (int i = 0; i &lt; m * 3 + 1; i++) { int x; scanf("%d", &amp;x); a[x - 1]++; } static int ans[MAXN]; int cnt = 0; for (int i = 0; i &lt; n; i++) { static int b[MAXN]; std::copy(a, a + n, b); b[i]++; for (int j = 0; j &lt; n; j++) { if (b[j] &gt;= 2) { static int c[MAXN + 2]; std::copy(b, b + n, c); c[j] -= 2; for (int k = 0; k &lt; n; k++) { if (c[k] == 0) continue; c[k] %= 3; int x = std::min(std::min(c[k], c[k + 1]), c[k + 2]); if (x &lt; c[k]) goto fail; c[k] -= x, c[k + 1] -= x, c[k + 2] -= x; } goto success; fail:; } } continue; success: ans[cnt++] = i + 1; } if (cnt) { for (int i = 0; i &lt; cnt; i++) printf("%d%c", ans[i], i == cnt - 1 ? '\n' : ' '); } else puts("NO"); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>贪心</tag>
        <tag>枚举</tag>
        <tag>JSOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2009」游戏 - 群论 + 背包 DP]]></title>
    <url>%2Fscoi2009-game%2F</url>
    <content type="text"><![CDATA[windy 学会了一种游戏。对于 到 这 个数字，都有唯一且不同的 到 的数字与之对应。最开始 windy 把数字按顺序 写一排在纸上。然后再在这一排下面写上它们对应的数字。然后又在新的一排下面写上它们对应的数字。如此反复，直到序列再次变为 。 如： 对应的关系为 windy 的操作如下： 这时，我们就有若干排 到 的排列，上例中有 排。现在 windy 想知道，对于所有可能的对应关系，有多少种可能的排数。 链接 BZOJ 1025 题解 对于一个置换，我们可以将其分解为若干个循环，问题中的「排数」即为这些循环长度的最小公倍数。设这些循环长度分别为 对于某个 的一个质因子 ，它对 有贡献，当且仅当 在 的唯一分解式中的次数是所有 中最大的。 为了便于统计，我们只考虑每个 都是不同的质数的幂的情况（暂不考虑 的情况） 这种情况下，。而 是一组合法的循环长度，当且仅当 。因为我们可以任意添加长度为 的循环，而不对其最小公倍数产生影响，所以 即为合法方案。 现在的问题变成，有一些质数 ，每个质数可以不选，也可以选择一个特定的幂 。要求最终选择的所有数之和 ，求方案总数。这个问题可以转化为分组背包的方案计数问题 —— 第 组物品体积为 （），背包容量为 。 代码 #include &lt;cstdio&gt; const int MAXN = 1000; int primes[MAXN], isNotPrime[MAXN + 1], cnt; inline void getPrimes() { isNotPrime[0] = isNotPrime[1] = true; for (int i = 2; i &lt;= MAXN; i++) { if (!isNotPrime[i]) { primes[++cnt] = i; } for (int j = 1; j &lt;= cnt &amp;&amp; i * primes[j] &lt;= MAXN; j++) { isNotPrime[i * primes[j]] = true; if (i % primes[j] == 0) break; } } // for (int i = 0; i &lt; cnt; i++) printf("%d\n", primes[i]); } int main() { int n; scanf("%d", &amp;n); getPrimes(); static long long f[MAXN + 1][MAXN + 1]; f[0][0] = 1; for (int i = 1; i &lt;= cnt; i++) { for (int k = 0; k &lt;= n; k++) f[i][k] = f[i - 1][k]; for (int p = primes[i]; p &lt;= n; p *= primes[i]) { for (int k = p; k &lt;= n; k++) { f[i][k] += f[i - 1][k - p]; } } // for (int k = 0; k &lt;= n; k++) printf("f[%d][%d] = %d\n", i, k, f[i][k]); } long long ans = 0; for (int i = 0; i &lt;= n; i++) ans += f[cnt][i]; printf("%lld\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>背包 DP</tag>
        <tag>群论</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2009」生日快乐 - 搜索]]></title>
    <url>%2Fscoi2009-cake%2F</url>
    <content type="text"><![CDATA[windy 的生日到了，为了庆祝生日，他的朋友们帮他买了一个边长分别为 和 的矩形蛋糕。现在包括 windy，一共有 个人来分这块大蛋糕，要求每个人必须获得相同面积的蛋糕。windy 主刀，每一切只能平行于一块蛋糕的一边（任意一边），并且必须把这块蛋糕切成两块。这样，要切成 块蛋糕，windy 必须切 次。为了使得每块蛋糕看起来漂亮，我们要求 块蛋糕的长边与短边的比值的最大值最小。你能帮助 windy 求出这个比值么？ 链接 BZOJ 1024 题解 首先，为了保证每个人必须获得相同面积的蛋糕，假设某一次操作选择了蛋糕的一部分，这部分的面积为总面积的 ，我们必须在它的 等分点上切一刀，然后对切成的两个部分递归操作。 DFS 搜索每次切下的位置即可，分横切和纵切两种情况。 代码 #include &lt;cstdio&gt; #include &lt;cfloat&gt; #include &lt;algorithm&gt; const int MAXN = 10; double dfs(const int n, const double x, const double y) { if (n == 1) { return std::max(x, y) / std::min(x, y); } double res1 = DBL_MAX; for (int i = 1; i &lt;= n / 2; i++) { res1 = std::min(res1, std::max(dfs(i, i * x / n, y), dfs(n - i, (n - i) * x / n, y))); } double res2 = DBL_MAX; for (int i = 1; i &lt;= n / 2; i++) { res2 = std::min(res2, std::max(dfs(i, x, i * y / n), dfs(n - i, x, (n - i) * y / n))); } return std::min(res1, res2); } int main() { int x, y, n; scanf("%d %d %d", &amp;x, &amp;y, &amp;n); printf("%.6lf\n", dfs(n, x, y)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>搜索</tag>
        <tag>DFS</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SHOI2008」仙人掌图 - 仙人掌 DP]]></title>
    <url>%2Fshoi2008-cactus%2F</url>
    <content type="text"><![CDATA[求仙人掌图的直径。 链接 BZOJ 1023 题解 任选一个点为根，DFS 整棵树，设 表示 DFS 树中以 为根的子树在原图中的诱导子图中以 开始的最长路径。 如果直接树形 DP，得出的答案可能会偏大，因为环的存在会使树上两个点的距离变小。考虑进行树形 DP 时，不在同一个环上的点之间转移，即 求出的路径均不包含 点所在环内的路径。 在 DFS 过程中维护 和 ，在回溯时，对于 的邻接点 （ 不是 的父节点），如果 ，则表明 与 不在同一个环中，这种情况下可以由 转移到 ，并更新答案。如果 不是 的子节点且 ，则连接 与 的边是一条返祖边。 对于一个环，我们称环上深度最小的点（返祖边的一个端点）为环的最高点。找到返祖边之后，一直向父节点走，可以遍历整个环。对于这个环的最高点 ，根据 的定义，整个环是包含在以 为根的子树的诱导子图中的，也就是说这里的 可以包含环中的路径。考虑环上的另一个点 ， 一定是 的形式。 环上的点也可以更新答案，答案的形式是 的形式。这 为环上第 个点到第一个点的距离， 为环上第 个点的 值，则答案可表示为 的形式。将环拆成链，翻倍，使用单调队列维护 的最大值，并保证 不大于环的一半。注意这里更新答案需要在更新最高点的 值之前。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; const int MAXN = 50000; struct Node { struct Edge *e, *c, *in; Node *parent; int dfn, low, len; bool visited, pushed; } N[MAXN]; struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {} }; int n; inline void addEdge(const int s, const int t) { N[s].e = new Edge(&amp;N[s], &amp;N[t]); N[t].e = new Edge(&amp;N[t], &amp;N[s]); } inline void updateCircle(Node *top, Node *u, int &amp;ans) { #ifdef DBG printf("updateCircle(%lu, %lu)\n", top - N + 1, u - N + 1); #endif static Node *v[MAXN * 2]; int cnt = 0; while (1) { v[cnt++] = u; if (u == top) break; u = u-&gt;parent; } std::reverse(v, v + cnt); std::copy(v, v + cnt, v + cnt); int half = cnt / 2; static int q[MAXN * 2]; int *l = q, *r = q; *r = 0; // ans = max{ f[i] + f[j] + i - j } // maintain the max of f[j] - j for (int i = 1; i &lt; cnt * 2; i++) { while (i - *l &gt; half) l++; #ifdef DBG printf("updateCircle: ans &lt;- %d\n", v[*l]-&gt;len + v[i]-&gt;len + i - *l); #endif ans = std::max(ans, v[*l]-&gt;len + v[i]-&gt;len + i - *l); while (l &lt;= r &amp;&amp; v[i]-&gt;len - i &gt; v[*r]-&gt;len - *r) r--; *++r = i; } int res = 0; for (int i = 1; i &lt; cnt; i++) { // printf("updateCircle(%lu, %lu): (f[%lu] = %d) + min(%d, %d)\n", top - N + 1, u - N + 1, v[i] - N + 1, v[i]-&gt;len, i, cnt - i); res = std::max(res, v[i]-&gt;len + std::min(i, cnt - i)); } #ifdef CHECK printf("updateCircle(%lu, %lu) = %d\n", top - N + 1, u - N + 1, res); #endif top-&gt;len = std::max(top-&gt;len, res); } inline int tarjan() { std::stack&lt;Node *&gt; s; s.push(&amp;N[0]); N[0].pushed = true; int ts = 0, ans = 0; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; v-&gt;c = v-&gt;e; v-&gt;dfn = v-&gt;low = ++ts; } if (v-&gt;c &amp;&amp; v-&gt;c-&gt;t == v-&gt;parent) v-&gt;c = v-&gt;c-&gt;next; if (v-&gt;c) { Edge *&amp;e = v-&gt;c; if (e-&gt;t-&gt;dfn) { v-&gt;low = std::min(v-&gt;low, e-&gt;t-&gt;dfn); } else { e-&gt;t-&gt;pushed = true; e-&gt;t-&gt;parent = v; s.push(e-&gt;t); } e = e-&gt;next; } else { for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;t == v-&gt;parent) continue; if (e-&gt;t-&gt;low &gt; v-&gt;dfn) { #ifdef DBG printf("tarjan: ans &lt;- (f[%lu] = %d) + (f[%lu] = %d) + 1\n", v - N + 1, v-&gt;len, e-&gt;t - N + 1, e-&gt;t-&gt;len); #endif ans = std::max(ans, v-&gt;len + e-&gt;t-&gt;len + 1); v-&gt;len = std::max(v-&gt;len, e-&gt;t-&gt;len + 1); #ifdef DBG printf("tarjan: f[%lu] = %d\n", v - N + 1, v-&gt;len); #endif } if (e-&gt;t-&gt;parent != v &amp;&amp; e-&gt;t-&gt;dfn &gt; v-&gt;dfn) { updateCircle(v, e-&gt;t, ans); #ifdef DBG printf("tarjan: f[%lu] = %d (from circle)\n", v - N + 1, v-&gt;len); #endif } } if (v-&gt;parent) v-&gt;parent-&gt;low = std::min(v-&gt;parent-&gt;low, v-&gt;low); s.pop(); } } return ans; } int main() { int m; scanf("%d %d", &amp;n, &amp;m); while (m--) { int k, u; scanf("%d %d", &amp;k, &amp;u), u--, k--; while (k--) { int v; scanf("%d", &amp;v), v--; addEdge(u, v); u = v; } } printf("%d\n", tarjan()); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>Tarjan</tag>
        <tag>SHOI</tag>
        <tag>仙人掌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「IOI2008」岛屿 - 基环树 DP]]></title>
    <url>%2Fioi2008-island%2F</url>
    <content type="text"><![CDATA[给一个由多个基环树构成的图，求所有基环树最长链之和。 链接 BZOJ 1791 题解 首先，考虑没有环的情况，也就是说，求一棵树的最长链。 设 表示从节点 向子树延伸的最长路径，显然，对于 的每个子节点 ，。 对于每个节点，用两个不同的子树 、 的路径和 来更新答案。 如果没有环，则每个连通块就是一棵树，答案是从某一个点向下延伸的两条最长路径之和。有了环之后，拓扑排序找出环，以环为根做树形 DP，答案可能是环上两个点向下延伸的最长路径之和，加上这两个点在环上的距离。 任选一个节点开始，把环断成链，设 表示环上的第 个点的 值。 表示环上第 个点与第一个点的距离。答案可以表示为 走完 向下延伸的最长链，从 沿着链的方向走到 ，再走 向下延伸的最长链： 沿着环的另一个方向（顺时针、逆时针）从 走到 （ 表示整个环的长度）： 按照链的顺序扫描环上的节点，维护 的最大值，更新答案即可。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;vector&gt; const int MAXN = 1000000; struct Node { struct Edge *e, *c, *in; Node *parent; bool inCircle, solved, visited, pushed; int depth, inDegree; long long len; } N[MAXN]; struct Edge { Node *s, *t; long long w; Edge *next, *r; bool disabled; Edge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s-&gt;e) {} }; int n; inline void addEdge(const int s, const int t, const int w) { N[s].e = new Edge(&amp;N[s], &amp;N[t], w); N[t].e = new Edge(&amp;N[t], &amp;N[s], w); (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } inline std::vector&lt;Node *&gt; getBlock(Node *start) { std::queue&lt;Node *&gt; q; q.push(start); start-&gt;inDegree = 0; start-&gt;visited = true; std::vector&lt;Node *&gt; block; while (!q.empty()) { Node *v = q.front(); q.pop(); block.push_back(v); for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e == v-&gt;in || e-&gt;t-&gt;solved) continue; if (!e-&gt;t-&gt;visited) { e-&gt;t-&gt;visited = true; e-&gt;t-&gt;inDegree = 1; e-&gt;t-&gt;in = e; q.push(e-&gt;t); } else e-&gt;t-&gt;inDegree++; } } return block; } inline void toposort(std::vector&lt;Node *&gt; &amp;v) { std::queue&lt;Node *&gt; q; for (size_t i = 0; i &lt; v.size(); i++) { #ifdef DBG printf("toposort(): inDegree[%lu] = %d\n", v[i] - N + 1, v[i]-&gt;inDegree); #endif if (v[i]-&gt;inDegree == 1) q.push(v[i]); else v[i]-&gt;inCircle = true; } while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;inCircle = false; #ifdef CHECK printf("%lu\n", v - N); #endif for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;t-&gt;solved) continue; if (--e-&gt;t-&gt;inDegree == 1) { q.push(e-&gt;t); } } } } inline long long calcTree(std::vector&lt;Node *&gt; &amp;v) { for (size_t i = 0; i &lt; v.size(); i++) { v[i]-&gt;visited = false; v[i]-&gt;inDegree = 0; v[i]-&gt;depth = 0; } std::stack&lt;Node *&gt; s; for (size_t i = 0; i &lt; v.size(); i++) { if (v[i]-&gt;inCircle) { v[i]-&gt;depth = 1; s.push(v[i]); } } long long ans = 0; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; v-&gt;c = v-&gt;e; } while (v-&gt;c &amp;&amp; (v-&gt;c-&gt;t-&gt;inCircle || v-&gt;c-&gt;t-&gt;pushed || v-&gt;c-&gt;t-&gt;solved)) v-&gt;c = v-&gt;c-&gt;next; if (v-&gt;c) { Edge *&amp;e = v-&gt;c; e-&gt;t-&gt;pushed = true; e-&gt;t-&gt;parent = v; s.push(e-&gt;t); e = e-&gt;next; } else { v-&gt;len = 0; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;t-&gt;inCircle || e-&gt;t-&gt;parent != v) continue; ans = std::max(ans, v-&gt;len + e-&gt;t-&gt;len + e-&gt;w); v-&gt;len = std::max(v-&gt;len, e-&gt;t-&gt;len + e-&gt;w); } s.pop(); } } #ifdef DBG printf("calcTree(size = %lu) = %lld\n", v.size(), ans); #endif return ans; } inline long long calcCircle(std::vector&lt;Node *&gt; &amp;v) { Node *start; for (size_t i = 0; i &lt; v.size(); i++) v[i]-&gt;visited = false; for (size_t i = 0; i &lt; v.size(); i++) { if (v[i]-&gt;inCircle) { v[i]-&gt;visited = true; start = v[i]; break; } for (Edge *e = v[i]-&gt;e; e; e = e-&gt;next) e-&gt;disabled = false; } static Node *c[MAXN]; static long long s[MAXN]; int cnt = 0; long long sum = 0; #ifdef DBG for (int i = 0; i &lt; MAXN; i++) c[i] = NULL, s[i] = 0; #endif Node *u = start; c[cnt++] = u; while (1) { Node *next = NULL; for (Edge *e = u-&gt;e; e; e = e-&gt;next) { if (e-&gt;disabled || e-&gt;t-&gt;solved) continue; if (!e-&gt;t-&gt;visited &amp;&amp; e-&gt;t-&gt;inCircle) { c[cnt] = e-&gt;t; s[cnt] = e-&gt;w; sum += e-&gt;w; cnt++; e-&gt;t-&gt;visited = true; e-&gt;r-&gt;disabled = true; next = e-&gt;t; break; } } if (next) { u = next; } else { for (Edge *e = u-&gt;e; e; e = e-&gt;next) { if (e-&gt;disabled || e-&gt;t-&gt;solved) continue; if (e-&gt;t == start) { sum += e-&gt;w; break; } } break; } } if (n == 0) return 0; /* if (cnt == 2) { long long ans = c[0]-&gt;len + c[1]-&gt;len + std::max(s[1], sum - s[1]); #ifdef DBG printf("%lld %lld\n", s[1], sum); printf("calcCircle(size = 2) = %lld\n", ans); #endif return ans; } */ for (int i = 1; i &lt; cnt; i++) s[i] += s[i - 1]; // ans1 = f[a] + f[b] + s[a] - s[b] // ans2 = f[a] + f[b] + sum - (s[a] - s[b]) = sum + f[a] + f[b] - s[a] + s[b] // maintain the max of f[b] - s[b] and f[b] + s[b] long long ans = 0, max1 = LLONG_MIN, max2 = LLONG_MIN; for (int i = 0; i &lt; cnt; i++) { ans = std::max(ans, c[i]-&gt;len + s[i] + max1); ans = std::max(ans, sum + c[i]-&gt;len - s[i] + max2); max1 = std::max(max1, c[i]-&gt;len - s[i]); max2 = std::max(max2, c[i]-&gt;len + s[i]); #ifdef DBG printf("ans = %lld, max1 = %lld, max2 = %lld\n", ans, max1, max2); #endif } #ifdef DBG printf("calcCircle(size = %lu, cnt = %d) = %lld\n", v.size(), cnt, ans); #endif return ans; } inline long long solve() { long long ans = 0; for (int i = 0; i &lt; n; i++) { if (N[i].solved) continue; std::vector&lt;Node *&gt; block = getBlock(&amp;N[i]); toposort(block); long long tmp = calcTree(block); tmp = std::max(tmp, calcCircle(block)); ans += tmp; for (size_t i = 0; i &lt; block.size(); i++) block[i]-&gt;solved = true; } return ans; } int main() { scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) { int u, w; scanf("%d %d", &amp;u, &amp;w), u--; addEdge(i, u, w); } printf("%lld\n", solve()); #ifdef CHECK for (int i = 0; i &lt; n; i++) printf("f[%d] = %lld\n", i, N[i].len); #endif return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>Tarjan</tag>
        <tag>SHOI</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2015」运输计划 - 最近公共祖先 + 二分 + 树上路径交]]></title>
    <url>%2Fnoip2015-transport%2F</url>
    <content type="text"><![CDATA[在一棵树上，每条边有边权，给定 个路径 ，求将其中一条边的边权置为 ，使得 个路径的长度和最小。 链接 CodeVS 4632 CodeVS 5440 BZOJ 4326 题解 求出每条路径两个端点的最近公共祖先，进而求出每条路径的长度。二分一个答案 ，所有长度 的路径上都至少需要删去一条边。对这些路径求交，最优方案一定是删去路径交中长度最大的边，如果删去最大的边后，最长的路径仍不满足 ，则答案 不合法。 考虑如何求树上路径交。这里使用树上前缀和的方法，对于一条路径 ，设 ，在 和 上打上 标记，在 上打上 标记。从每个叶子节点向父节点走，走到根，路径上经过每一条边时的前缀和即为这条边被经过的次数。被每一条路径都经过的边组成的集合即为路径交。 代码 #pragma GCC optimize("O3") #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;new&gt; #define inline inline __attribute__((always_inline)) const int MAXN = 300000; const int MAXM = 300000; const int MAXN_LOG = 20; // Math.log2(600000) = 19.194602975157967 struct Node { struct Edge *e, *c, *in; bool visited; int pos, depth, cover, dist; } N[MAXN], *eulerTour[MAXN * 2], *dfsSequence[MAXN], *st[MAXN * 2][MAXN_LOG + 1]; struct Edge { Node *s, *t; int w, cover; Edge *next; Edge() {} Edge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s-&gt;e) {} } mEdges[MAXN * 2 - 2], *pEdge = mEdges, *E[MAXN - 1]; struct Path { Node *u, *v, *p; int dist; } a[MAXM]; inline void addEdge(const int s, const int t, const int w) { N[s].e = new (pEdge++) Edge(&amp;N[s], &amp;N[t], w); N[t].e = new (pEdge++) Edge(&amp;N[t], &amp;N[s], w); } int n, m, log[MAXN * 2 + 1], max, eulerTourLen; inline void dfs() { static Node *s[MAXN]; Node **top = s; *s = &amp;N[0]; N[0].depth = 1; int ts = 0; while (top &gt;= s) { Node *v = *top; if (!v-&gt;visited) { v-&gt;visited = true; v-&gt;c = v-&gt;e; v-&gt;pos = eulerTourLen; dfsSequence[ts++] = v; } eulerTour[eulerTourLen++] = v; while (v-&gt;c &amp;&amp; v-&gt;c-&gt;t-&gt;depth) v-&gt;c = v-&gt;c-&gt;next; if (v-&gt;c) { if (!v-&gt;c-&gt;t-&gt;depth) { v-&gt;c-&gt;t-&gt;depth = v-&gt;depth + 1; v-&gt;c-&gt;t-&gt;dist = v-&gt;dist + v-&gt;c-&gt;w; v-&gt;c-&gt;t-&gt;in = v-&gt;c; *++top = v-&gt;c-&gt;t; } v-&gt;c = v-&gt;c-&gt;next; } else { top--; } } for (int i = 1; i &lt; n; i++) E[i - 1] = N[i].in; } inline Node *min(Node *a, Node *b) { return a-&gt;depth &lt; b-&gt;depth ? a : b; } inline void sparseTable() { for (int i = 0; i &lt; eulerTourLen; i++) st[i][0] = eulerTour[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= eulerTourLen; j++) { for (int i = 0; i &lt; eulerTourLen; i++) { if (i + (1 &lt;&lt; (j - 1)) &lt; eulerTourLen) st[i][j] = min(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); else st[i][j] = st[i][j - 1]; } } for (int i = 0; i &lt;= eulerTourLen; i++) { int x = 0; while ((1 &lt;&lt; x) &lt;= i) x++; log[i] = x - 1; } } inline Node *rmq(const int l, const int r) { if (l == r) return st[l][0]; else { const int t = log[r - l]; return min(st[l][t], st[r - (1 &lt;&lt; t) + 1][t]); } } inline Node *lca(Node *u, Node *v) { return rmq(std::min(u-&gt;pos, v-&gt;pos), std::max(u-&gt;pos, v-&gt;pos)); } inline int distance(Node *u, Node *v, Node *p) { return u-&gt;dist + v-&gt;dist - p-&gt;dist * 2; } inline bool check(const int limit) { int cnt = 0; for (int i = 0; i &lt; m; i++) { if (a[i].dist &gt; limit) { a[i].p-&gt;cover -= 2; a[i].u-&gt;cover++; a[i].v-&gt;cover++; cnt++; } } for (int i = n - 1; i &gt;= 0; i--) { if (dfsSequence[i]-&gt;in) { dfsSequence[i]-&gt;in-&gt;cover = dfsSequence[i]-&gt;cover; dfsSequence[i]-&gt;in-&gt;s-&gt;cover += dfsSequence[i]-&gt;cover; } dfsSequence[i]-&gt;cover = 0; } Edge *maxEdge = NULL; for (int i = 0; i &lt; n - 1; i++) { if (E[i]-&gt;cover == cnt &amp;&amp; (!maxEdge || E[i]-&gt;w &gt; maxEdge-&gt;w)) maxEdge = E[i]; } return maxEdge &amp;&amp; max - maxEdge-&gt;w &lt;= limit; } template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; while (ch = getchar(), !(ch &gt;= '0' &amp;&amp; ch &lt;= '9')); do x = x * 10 + ch - '0'; while (ch = getchar(), (ch &gt;= '0' &amp;&amp; ch &lt;= '9')); } int main() { read(n), read(m); for (int i = 0; i &lt; n - 1; i++) { int u, v, w; read(u), read(v), read(w), u--, v--; addEdge(u, v, w); } dfs(); sparseTable(); for (int i = 0; i &lt; m; i++) { int u, v; read(u), read(v), u--, v--; a[i].u = &amp;N[u], a[i].v = &amp;N[v]; a[i].p = lca(a[i].u, a[i].v); a[i].dist = distance(a[i].u, a[i].v, a[i].p); max = std::max(max, a[i].dist); // printf("lca(%lu, %lu) = %lu\n", a[i].u - N + 1, a[i].v - N + 1, a[i].p - N + 1); } int l = 0, r = max; while (l &lt; r) { const int mid = l + (r - l) / 2; if (check(mid)) r = mid; else l = mid + 1; } // check(11); printf("%d\n", l); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>最近公共祖先</tag>
        <tag>CodeVS</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2015」子串 - DP]]></title>
    <url>%2Fnoip2015-substring%2F</url>
    <content type="text"><![CDATA[有两个仅包含小写英文字母的字符串 和 。现在要从字符串 中取出 个互不重叠的非空子串，然后把这 个子串按照其在字符串 中出现的顺序依次连接起来得到一个新的字符串，请问有多少种方案可以使得这个新串与字符串 相等？ 注意：子串取出的位置不同也认为是不同的方案。 链接 CodeVS 4560 题解 设 表示字符串 的前 位和字符串 的前 位（必选 ），取出 个子串的方案数； 表示字符串 的前 位和字符串 的前 位（不必选 ），取出 个子串的方案数。 计算 时，考虑匹配到前一个字符时的方案数（最后一个子串加一个字符），和单独作为一个子串的方案数。 比较显然 边界为 。 需要滚动数组。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 1000; const int MAXM = 200; const int MAXK = 200; const int MOD = 1e9 + 7; int main() { int n, m, k; scanf("%d %d %d", &amp;n, &amp;m, &amp;k); static char a[MAXN + 1], b[MAXM + 1]; scanf("%s\n%s", a, b); static int f[2][MAXM + 1][MAXK + 1], g[2][MAXM + 1][MAXK + 1]; g[0][0][0] = 1; for (int i = 1; i &lt;= n; i++) { const int curr = i % 2, prev = !curr; memset(f[curr], 0, sizeof(f[curr])); memset(g[curr], 0, sizeof(g[curr])); g[curr][0][0] = f[curr][0][0] = 1; for (int j = 1; j &lt;= m; j++) { for (int t = 1; t &lt;= std::min(j, k); t++) { if (a[i - 1] == b[j - 1]) { f[curr][j][t] = (f[prev][j - 1][t] + g[prev][j - 1][t - 1]) % MOD; g[curr][j][t] = (g[prev][j][t] + f[curr][j][t]) % MOD; #ifdef DBG printf("g[%d][%d][%d] = %d\n", i, j, t, g[curr][j][t]); printf("f[%d][%d][%d] = %d\n", i, j, t, f[curr][j][t]); #endif } else { f[curr][j][t] = 0; g[curr][j][t] = g[prev][j][t]; } } } } printf("%d\n", g[n % 2][m][k]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>CodeVS</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2015」斗地主 - 搜索]]></title>
    <url>%2Fnoip2015-landlords%2F</url>
    <content type="text"><![CDATA[给一组扑克牌，按照斗地主的规则出牌，求最少多少次出完。 链接 BZOJ 4325 CodeVS 4610 题解 以每种点数的牌的数量为状态（状态可压缩进一个 64 位整数中），搜索。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; const int MAXN = 13; const int CARD_JOKER = 0; const int CARD_2 = 1; const int CARD_3 = 2; const int CARD_4 = 3; const int CARD_5 = 4; const int CARD_6 = 5; const int CARD_7 = 6; const int CARD_8 = 7; const int CARD_9 = 8; const int CARD_10 = 9; const int CARD_J = 10; const int CARD_Q = 11; const int CARD_K = 12; const int CARD_A = 13; typedef unsigned long long Status; inline int id(const int x) { if (x == 1) return 13; return (x &gt;= 2 &amp;&amp; x &lt;= 13) ? (x - 1) : x; } inline int get(const Status &amp;s, const int index) { return (s &gt;&gt; (index &lt;&lt; 2)) &amp; 15ll; } #ifdef DBG inline void print(const Status &amp;s, const bool newLine = true) { // for (int i = 0; i &lt; 64; i++) putchar((s &amp; (1ll &lt;&lt; i)) ? '1' : '0'); for (int i = 0; i &lt; 14; i++) printf("%d ", get(s, i)); if (newLine) putchar('\n'); } #endif inline void set(Status &amp;s, const int index, const int val) { /* if (val &lt; 0) { puts("???"); } */ #ifdef DBG print(s, false); printf("=&gt; "); #endif s &amp;= ~(15ll &lt;&lt; (index &lt;&lt; 2)); s |= (val &amp; 15ll) &lt;&lt; (index &lt;&lt; 2); #ifdef DBG print(s); #endif } inline void change(Status &amp;s, const int index, const int delta) { set(s, index, get(s, index) + delta); } int n, ans; // std::tr1::unordered_map&lt;Status, int&gt; map; struct HashMap { const static int HASH_SIZE = 7979717; struct Node { Status key; int val, time; } N[HASH_SIZE]; int time; HashMap() : time(1) {} int locate(const Status &amp;key) { int i; for (i = key % HASH_SIZE; N[i].time == time &amp;&amp; N[i].key != key; (i &lt; HASH_SIZE - 1) ? (i++) : (i = 0)); if (N[i].time != time) { N[i].time = time; N[i].key = key; N[i].val = INT_MAX; } return i; } int &amp;operator[](const Status &amp;key) { return N[locate(key)].val; } void clear() { time++; } } map; inline void search(const Status &amp;s, const int step = 0) { #ifdef DBG print(s, false); printf("[%d, %d]\n", step, ans); #endif if (step &gt;= ans) return; int &amp;x = map[s]; if (step &gt;= x) return; x = step; /* std::tr1::unordered_map&lt;Status, int&gt;::iterator it = map.find(s); if (it != map.end() &amp;&amp; step &gt;= it-&gt;second) return; map[s] = step; */ if (!s) { ans = step; return; } // 333 444 for (int i = CARD_3; i &lt;= CARD_K; i++) { Status next = s; int x = get(next, i); if (x &lt; 3) { continue; } else set(next, i, x - 3); for (int j = i + 1; j &lt;= CARD_A; j++) { int x = get(next, j); if (x &lt; 3) { break; } else { set(next, j, x - 3); search(next, step + 1); } } } // 33 44 55 for (int i = CARD_3; i &lt;= CARD_Q; i++) { bool valid = true; Status next = s; for (int j = i; j &lt; i + 2; j++) { int x = get(next, j); if (x &lt; 2) { valid = false; break; } else set(next, j, x - 2); } if (!valid) continue; for (int j = i + 2; j &lt;= CARD_A; j++) { int x = get(next, j); if (x &lt; 2) { break; } else { set(next, j, x - 2); search(next, step + 1); } } } // 3 4 5 6 7 for (int i = CARD_3; i &lt;= CARD_10; i++) { bool valid = true; Status next = s; for (int j = i; j &lt; i + 4; j++) { int x = get(next, j); if (x &lt; 1) { valid = false; break; } else set(next, j, x - 1); } if (!valid) continue; for (int j = i + 4; j &lt;= CARD_A; j++) { int x = get(next, j); if (x &lt; 1) { break; } else { set(next, j, x - 1); search(next, step + 1); } } } std::vector&lt;int&gt; four, three, two, one; for (int i = CARD_JOKER; i &lt;= CARD_A; i++) { int x = get(s, i); if (x == 4) four.push_back(i); else if (x == 3) three.push_back(i); else if (x == 2) two.push_back(i); else if (x == 1) one.push_back(i); } // 2222 [3 4] / 2222 [33 44] for (std::vector&lt;int&gt;::const_iterator it = four.begin(); it != four.end(); it++) { Status tmp = s; set(tmp, *it, 0); for (std::vector&lt;int&gt;::const_iterator a = two.begin(); a != two.end(); a++) { if (*a == 0) continue; for (std::vector&lt;int&gt;::const_iterator b = a + 1; b != two.end(); b++) { if (*b == 0) continue; Status next = tmp; set(next, *a, 0); set(next, *b, 0); search(next, step + 1); } for (std::vector&lt;int&gt;::const_iterator b = three.begin(); b != three.end(); b++) { Status next = tmp; change(next, *a, -2); change(next, *b, -2); search(next, step + 1); } Status next = tmp; set(next, *a, 0); search(next, step + 1); } for (std::vector&lt;int&gt;::const_iterator a = four.begin(); a != four.end(); a++) { if (*a == *it) continue; Status next = tmp; set(next, *a, 0); search(next, step + 1); } for (std::vector&lt;int&gt;::const_iterator a = one.begin(); a != one.end(); a++) { for (std::vector&lt;int&gt;::const_iterator b = a + 1; b != one.end(); b++) { Status next = tmp; set(next, *a, 0); set(next, *b, 0); search(next, step + 1); } for (std::vector&lt;int&gt;::const_iterator b = three.begin(); b != three.end(); b++) { Status next = tmp; change(next, *a, -1); change(next, *b, -1); search(next, step + 1); } } search(tmp, step + 1); } // 222 [3] / 222 [33] for (std::vector&lt;int&gt;::const_iterator it = three.begin(); it != three.end(); it++) { Status tmp = s; set(tmp, *it, 0); for (std::vector&lt;int&gt;::const_iterator a = three.begin(); a != three.end(); a++) { if (*a == *it) continue; Status next = tmp; change(next, *a, -1); search(next, step + 1); change(next, *a, -1); search(next, step + 1); } for (std::vector&lt;int&gt;::const_iterator a = two.begin(); a != two.end(); a++) { if (*a == 0) { // Take only one joker Status next = tmp; set(next, *a, 1); search(next, step + 1); continue; } Status next = tmp; set(next, *a, 0); search(next, step + 1); } for (std::vector&lt;int&gt;::const_iterator a = one.begin(); a != one.end(); a++) { Status next = tmp; set(next, *a, 0); search(next, step + 1); } search(tmp, step + 1); } // 22 for (std::vector&lt;int&gt;::const_iterator it = two.begin(); it != two.end(); it++) { Status next = s; set(next, *it, 0); search(next, step + 1); } // 2 for (std::vector&lt;int&gt;::const_iterator it = one.begin(); it != one.end(); it++) { Status next = s; set(next, *it, 0); search(next, step + 1); } } int main() { int t; scanf("%d %d", &amp;t, &amp;n); while (t--) { Status init = 0; for (int i = 0; i &lt; n; i++) { int a, b; scanf("%d %d", &amp;a, &amp;b); change(init, id(a), 1); } map.clear(); ans = INT_MAX; search(init); printf("%d\n", ans); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>搜索</tag>
        <tag>CodeVS</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2014」解方程 - Hash]]></title>
    <url>%2Fnoip2014-equation%2F</url>
    <content type="text"><![CDATA[已知多项式方程： 求这个方程在 内的整数解。 链接 BZOJ 3751 CodeVS 4610 题解 设 ，我们对于一个质数 取模，如果 ，则一定有 。 求出所有满足 的 （根据拉格朗日定理，最多有 个解），则所有 均可能为原方程的解。在模另一个质数 的意义下检验，如果 ，则可以认为 是原方程的解。 时间复杂度为 ，取 时，复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;list&gt; const int MAXN = 100; const int MAXLEN = 10000 + 1; const int MAXM = 1000000; const int MOD = 21893; const int MOD2 = 18341629; int parse(const char *s, const int mod) { int res = 0, sgn = 1; if (*s == '-') s++, sgn = -1; for (const char *p = s; *p; p++) res = (res * 10 + *p - '0') % mod; return res * sgn; } int main() { static char s[MAXN + 1][MAXLEN + 1]; int n, m; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) { scanf("%s", s[i]); } static int a[MAXN + 1]; for (int i = 0; i &lt;= n; i++) a[i] = parse(s[i], MOD); std::list&lt;int&gt; roots; for (int i = 1; i &lt; MOD; i++) { long long pow = 1, val = 0; for (int j = 0; j &lt;= n; j++) { (val += a[j] * pow) %= MOD; pow = pow * i % MOD; } if (val == 0) { for (int j = i; j &lt;= m; j += MOD) roots.push_back(j); } } for (int j = 0; j &lt;= n; j++) a[j] = parse(s[j], MOD2); for (std::list&lt;int&gt;::iterator it = roots.begin(); it != roots.end(); ) { long long pow = 1, val = 0; for (int j = 0; j &lt;= n; j++) { (val += a[j] * pow) %= MOD2; pow = pow * *it % MOD2; } if (val != 0) it = roots.erase(it); else it++; } printf("%lu\n", roots.size()); roots.sort(); for (std::list&lt;int&gt;::iterator it = roots.begin(); it != roots.end(); it++) printf("%d\n", *it); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>CodeVS</tag>
        <tag>Hash</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SHOI2008」小约翰的游戏 - 博弈论]]></title>
    <url>%2Fshoi2008-john%2F</url>
    <content type="text"><![CDATA[桌子上有 堆石子，轮流取石子，每个人取的时候，可以随意选择一堆石子，在这堆石子中取走任意多的石子，但不能一粒石子也不取，我们规定取到最后一粒石子的人算输。求先手是否必胜。 链接 BZOJ 1022 题解 如果每堆石子都只有一个，则先手只能每次取一颗石子。如果有奇数堆，则先手必败，否则先手必胜。 如果至少有一堆石子不止有一个，则每堆石子数量的异或不为零时，先手必胜。 证明：如果当前每堆石子数量的异或和不为零，则先手玩家一定存在一种方案取走若干颗石子，使它们的异或和为零。下一次取时，后手玩家的任意方案均会使这个异或和变得不为零。最终，先手玩家存在一种方案，使得剩下一堆一个石子，后手玩家取到这颗石子后输。 代码 #include &lt;cstdio&gt; const int MAXN = 50; int main() { int t; scanf("%d", &amp;t); while (t--) { int n; scanf("%d", &amp;n); int s = 0; bool flag = false; while (n--) { int x; scanf("%d", &amp;x); s ^= x; if (x &gt; 1) flag = true; } puts(((!flag &amp;&amp; s == 0) || (flag &amp;&amp; s != 0)) ? "John" : "Brother"); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>SHOI</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SHOI2008」循环的债务 - DP]]></title>
    <url>%2Fshoi2008-debt%2F</url>
    <content type="text"><![CDATA[A、B、C 三个人之间互相有一些债务，每个人有每种面值 的钞票若干，求使他们把债务还清的最少交换的现金数量。 链接 BZOJ 1021 题解 设 表示考虑了前 种面值的钞票，使 A 拥有 元，B 拥有 元的最少交换次数。 每一次考虑一种面值的钞票，枚举以下几种转移方式，使用刷表转移： 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 1000; const int VAL[] = { -1, 1, 5, 10, 20, 50, 100 }; int main() { int a, b, c; scanf("%d %d %d", &amp;a, &amp;b, &amp;c); if (a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; c &gt; 0) { const int min = std::min(std::min(a, b), c); a -= min, b -= min, c -= min; } else if (a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; c &lt; 0) { const int max = std::max(std::max(a, b), c); a -= max, b -= max, c -= max; } int has[3][6 + 1]; int sum = 0, sums[3] = { 0, 0, 0 }; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 6; j++) { scanf("%d", &amp;has[i][6 - j]); sums[i] += has[i][6 - j] * VAL[6 - j]; #ifdef DBG for (int k = 0; k &lt; has[i][6 - j]; k++) printf("%d\n", VAL[6 - j]); #endif } sum += sums[i]; #ifdef DBG putchar('\n'); #endif } #ifdef DBG printf("%d %d %d\n", sums[0], sums[1], sums[2]); #endif static int f[6 + 1][MAXN + 1][MAXN + 1]; for (int i = 0; i &lt;= 6; i++) for (int j = 0; j &lt;= MAXN; j++) for (int k = 0; k &lt;= MAXN; k++) f[i][j][k] = INT_MAX; f[0][sums[0]][sums[1]] = 0; for (int i = 0; i &lt; 6; i++) { for (int a = 0; a &lt;= sum; a++) { for (int b = 0; b &lt;= sum - a; b++) { const int c = sum - a - b; if (f[i][a][b] == INT_MAX) continue; // a -&gt; b, c for (int tb = 0; tb &lt;= has[0][i + 1]; tb++) { for (int tc = 0; tc &lt;= has[0][i + 1] - tb; tc++) { if (tb + tc == 0) continue; const int _a = a - VAL[i + 1] * (tb + tc); const int _b = b + VAL[i + 1] * tb; const int _c = c + VAL[i + 1] * tc; if (_a &gt; sum || _b &lt; 0 || _c &lt; 0) continue; f[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + tb + tc); } } // b -&gt; a, c for (int ta = 0; ta &lt;= has[1][i + 1]; ta++) { for (int tc = 0; tc &lt;= has[1][i + 1] - ta; tc++) { if (ta + tc == 0) continue; const int _a = a + VAL[i + 1] * ta; const int _b = b - VAL[i + 1] * (ta + tc); const int _c = c + VAL[i + 1] * tc; if (_a &lt; 0 || _b &gt; sum || _c &lt; 0) continue; f[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tc); } } // c -&gt; a, b for (int ta = 0; ta &lt;= has[2][i + 1]; ta++) { for (int tb = 0; tb &lt;= has[2][i + 1] - ta; tb++) { if (ta + tb == 0) continue; const int _a = a + VAL[i + 1] * ta; const int _b = b + VAL[i + 1] * tb; const int _c = c - VAL[i + 1] * (ta + tb); if (_a &lt; 0 || _b &lt; 0 || _c &gt; sum) continue; f[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tb); } } // a, b -&gt; c for (int fa = 0; fa &lt;= has[0][i + 1]; fa++) { for (int fb = 0; fb &lt;= has[1][i + 1]; fb++) { if (fa + fb == 0) continue; const int _a = a - VAL[i + 1] * fa; const int _b = b - VAL[i + 1] * fb; const int _c = c + VAL[i + 1] * (fa + fb); if (_a &gt; sum || _b &gt; sum || _c &lt; 0) continue; f[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fb); } } // a, c -&gt; b for (int fa = 0; fa &lt;= has[0][i + 1]; fa++) { for (int fc = 0; fc &lt;= has[2][i + 1]; fc++) { if (fa + fc == 0) continue; const int _a = a - VAL[i + 1] * fa; const int _b = b + VAL[i + 1] * (fa + fc); const int _c = c - VAL[i + 1] * fc; if (_a &gt; sum || _b &lt; 0 || _c &gt; sum) continue; f[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fc); } } // b, c -&gt; a for (int fb = 0; fb &lt;= has[1][i + 1]; fb++) { for (int fc = 0; fc &lt;= has[2][i + 1]; fc++) { if (fb + fc == 0) continue; const int _a = a + VAL[i + 1] * (fb + fc); const int _b = b - VAL[i + 1] * fb; const int _c = c - VAL[i + 1] * fc; if (_a &lt; 0 || _b &gt; sum || _c &gt; sum) continue; f[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fb + fc); } } #ifdef DBG if (f[i + 1][a][b] != INT_MAX) printf("f(%d, %d, %d) = %d\n", i + 1, a, b, f[i + 1][a][b]); #endif f[i + 1][a][b] = std::min(f[i + 1][a][b], f[i][a][b]); } } } int resA = sums[0] - a + c, resB = sums[1] - b + a, resC = sums[2] - c + b; #ifdef DBG printf("%d %d %d\n", resA, resB, resC); #endif if (resA &lt; 0 || resB &lt; 0 || resC &lt; 0 || f[6][resA][resB] == INT_MAX) puts("impossible"); else printf("%d\n", f[6][resA][resB]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>SHOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SHOI2008」汉诺塔 - DP]]></title>
    <url>%2Fshoi2008-hannoi%2F</url>
    <content type="text"><![CDATA[在任何操作执行之前，我们以任意的次序为六种操作（AB、AC、BA、BC、CA 和 CB）赋予不同的优先级，然后，我们总是选择符合以下两个条件的操作来移动盘子，直到所有的盘子都从柱子 A 移动到另一根柱子： 这种操作是所有合法操作中优先级最高的； 这种操作所要移动的盘子不是上一次操作所移动的那个盘子。 可以证明，上述策略一定能完成汉诺塔游戏。 现在你的任务就是假设给定了每种操作的优先级，计算按照上述策略操作汉诺塔移动所需要的步骤数。 链接 BZOJ 1019 题解 设 表示只考虑柱子 上的最上面的 个盘子（不考虑下面更大的盘子和其它柱子上的盘子），将这些盘子移动到 上的步数。 根据汉诺塔的规则，我们需要先移动前 个盘子，需要 次操作，这些盘子被移动到 上。设 ，则另一个柱子 。我们需要把第 个盘子移动到 上。 继续考虑移动到 上的 个盘子，这些盘子需要移动到 上，如果 ，则直接将它们移到 上，此时 个盘子均已移动到 上，所以 ，。 如果 则需要将 个盘子移回 柱子，然后将最大的盘子移到 上，再将前 个盘子移到 上（因为 ）。所以 ， 代码 #include &lt;cstdio&gt; const int MAXN = 30; int main() { int n; scanf("%d", &amp;n); static int g[MAXN + 1][3]; g[1][0] = g[1][1] = g[1][2] = -1; for (int i = 0; i &lt; 6; i++) { char s[3]; scanf("%s", s); int a = s[0] - 'A', b = s[1] - 'A'; if (g[1][a] == -1) g[1][a] = b; } static long long f[MAXN + 1][3]; f[1][0] = f[1][1] = f[1][2] = 1; for (int j = 2; j &lt;= n; j++) { for (int i = 0; i &lt; 3; i++) { const int a = g[j - 1][i], b = 3 - a - i; if (g[j - 1][a] == b) { f[j][i] = f[j - 1][i] + 1 + f[j - 1][a]; g[j][i] = b; } else { f[j][i] = f[j - 1][i] + 1 + f[j - 1][a] + 1 + f[j - 1][i]; g[j][i] = a; } } } printf("%lld\n", f[n][0]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>SHOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SHOI2008」堵塞的交通 - 线段树]]></title>
    <url>%2Fshoi2008-traffic%2F</url>
    <content type="text"><![CDATA[整个国家的交通系统可以被看成是一个 行 列的矩形网格，网格上的每个点代表一个城市，相邻的城市之间有一条道路，所以总共有 个城市和 条道路。 交通信息可以分为以下几种格式： Close r1 c1 r2 c2，相邻的两座城市 和 之间的道路被堵塞了； Open r1 c1 r2 c2，相邻的两座城市 和 之间的道路被疏通了； Ask r1 c1 r2 c2，询问城市 和 是否连通。 链接 BZOJ 1018 题解 对所有列建立线段树，维护一个区间的连通性。我们用 和 分别表示第 列的上面和下面的位置。 线段树中 区间维护 分别与 的连通性。 如果第 列上下连通，则认为区间 的 与 、 与 连通。 合并 与 两个区间时，枚举经过 的上方还是下方的路径。 查询区间 列时，首先二分从 能到达的最左列 和 能到的的最右列 ，在线段树上查询 即可。 具体细节见代码。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 100000; int n; bool right[MAXN][2], middle[MAXN + 1]; struct Connectivity { bool a[2][2]; Connectivity(const bool init) { a[0][0] = a[0][1] = a[1][0] = a[1][1] = init; } bool &amp;operator()(const int i, const int j) { return a[i][j]; } bool operator()(const int i, const int j) const { return a[i][j]; } operator bool() const { return a[0][0] || a[0][1] || a[1][0] || a[1][1]; } }; Connectivity merge(Connectivity a, Connectivity b, const int mid) { Connectivity res(false); for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) { for (int k = 0; k &lt; 2; k++) { res(i, j) |= a(i, k) &amp;&amp; right[mid][k] &amp;&amp; b(k, j); } } } return res; } struct SegmentTree { int l, r, mid; SegmentTree *lc, *rc; Connectivity conn; SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), conn(l == r) {} void update(const int l, const int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (this-&gt;l == this-&gt;r) { conn(0, 0) = conn(1, 1) = true; conn(0, 1) = conn(1, 0) = middle[mid]; return; } else if (!(l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r)) { lc-&gt;update(l, r); rc-&gt;update(l, r); } else if (this-&gt;l == this-&gt;r - 1) lc-&gt;update(l, r), rc-&gt;update(l, r); conn = merge(lc-&gt;conn, rc-&gt;conn, mid); } Connectivity query(const int l, const int r) { if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return conn; else if (r &lt;= mid) return lc-&gt;query(l, r); else if (l &gt; mid) return rc-&gt;query(l, r); else return merge(lc-&gt;query(l, r), rc-&gt;query(l, r), mid); } static SegmentTree *build(const int l, const int r) { if (l &gt; r) return NULL; else if (l == r) return new SegmentTree(l, r, NULL, NULL); else { const int mid = l + (r - l) / 2; return new SegmentTree(l, r, build(l, mid), build(mid + 1, r)); } } } *segment; inline void update(int r1, int c1, int r2, int c2, const bool val) { if (r1 == r2) { right[std::min(c1, c2)][r1] = val; } else { middle[c1] = val; } segment-&gt;update(std::min(c1, c2), std::max(c1, c2)); } inline bool query(int r1, int c1, int r2, int c2) { int l, r; l = 1, r = c1; while (l &lt; r) { const int mid = l + (r - l) / 2; Connectivity res = segment-&gt;query(mid, c1); if (res(0, r1) || res(1, r1)) r = mid; else l = mid + 1; } const int lpos = l; Connectivity lconn = segment-&gt;query(lpos, c1); l = c2, r = n; while (l &lt; r) { const int mid = l + (r - l) / 2 + 1; Connectivity res = segment-&gt;query(c2, mid); if (res(r2, 0) || res(r2, 1)) l = mid; else r = mid - 1; } const int rpos = l; Connectivity rconn = segment-&gt;query(c2, rpos); Connectivity conn = segment-&gt;query(lpos, rpos); for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) { if (lconn(i, r1) &amp;&amp; rconn(r2, j) &amp;&amp; conn(i, j)) return true; } } return false; } int main() { scanf("%d", &amp;n); segment = SegmentTree::build(1, n); char cmd[5]; while (~scanf("%s", cmd)) { if (cmd[0] == 'E') break; else if (cmd[0] == 'O') { int r1, c1, r2, c2; scanf("%d %d %d %d", &amp;r1, &amp;c1, &amp;r2, &amp;c2); update(r1 - 1, c1, r2 - 1, c2, true); } else if (cmd[0] == 'C') { int r1, c1, r2, c2; scanf("%d %d %d %d", &amp;r1, &amp;c1, &amp;r2, &amp;c2); update(r1 - 1, c1, r2 - 1, c2, false); } else if (cmd[0] == 'A') { int r1, c1, r2, c2; scanf("%d %d %d %d", &amp;r1, &amp;c1, &amp;r2, &amp;c2); if (c1 &gt; c2) std::swap(c1, c2), std::swap(r1, r2); puts(query(r1 - 1, c1, r2 - 1, c2) ? "Y" : "N"); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>BZOJ</tag>
        <tag>SHOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2008」最小生成树计数 - 搜索]]></title>
    <url>%2Fjsoi2008-award%2F</url>
    <content type="text"><![CDATA[求一个图的不同的最小生成树的数量，保证相同权值的边数量 。 链接 BZOJ 1016 题解 对于一个最小生成树，使用相同数量的一些边替换掉其中与其权值相同的边，如果得到的图没有环，则仍然是一棵最小生成树。 详细证明见：https://blog.sengxian.com/solutions/bzoj-1016 对于每一种权值，枚举所有不在最小生成树中的边，乘法原理即可。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;map&gt; const int MAXN = 100; const int MAXM = 1000; const int MAXC = 1000000000; const int MOD = 31011; struct Edge { int u, v, w; bool used; bool operator&lt;(const Edge &amp;other) const { return w &lt; other.w; } } E[MAXM]; struct UnionFindSet { int a[MAXN]; void init(const int n) { for (int i = 0; i &lt; n; i++) a[i] = i; } int find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); } void merge(const int x, const int y) { a[find(x)] = find(y); } bool test(const int x, const int y) { return find(x) == find(y); } } ufs; struct EdgeGroup { int used; std::vector&lt;Edge&gt; edges; }; int n, m, graph[MAXN][MAXN]; std::map&lt;int, EdgeGroup&gt; groups; inline bool kruskal() { std::sort(E, E + m); ufs.init(n); int cnt = 0; for (int i = 0; i &lt; m; i++) { if (!ufs.test(E[i].u, E[i].v)) { ufs.merge(E[i].u, E[i].v); E[i].used = true; groups[E[i].w].used++; cnt++; } groups[E[i].w].edges.push_back(E[i]); } return cnt == n - 1; } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) { scanf("%d %d %d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].w), E[i].u--, E[i].v--; } if (!kruskal()) { puts("0"); } else { long long ans = 1; for (int i = 0; i &lt; m; i++) if (E[i].used) graph[E[i].u][E[i].v] = graph[E[i].v][E[i].u] = true; for (std::map&lt;int, EdgeGroup&gt;::const_iterator it = groups.begin(); it != groups.end(); it++) { if (it-&gt;second.used == 0) continue; int t = 0; for (unsigned int s = 1; s &lt; (1 &lt;&lt; it-&gt;second.edges.size()); s++) { int popcount = 0; for (unsigned int i = 0; i &lt; it-&gt;second.edges.size(); i++) if (s &amp; (1 &lt;&lt; i)) popcount++; if (popcount != it-&gt;second.used) continue; for (std::vector&lt;Edge&gt;::const_iterator e = it-&gt;second.edges.begin(); e != it-&gt;second.edges.end(); e++) { graph[e-&gt;u][e-&gt;v] = graph[e-&gt;v][e-&gt;u] = false; } for (std::vector&lt;Edge&gt;::const_iterator e = it-&gt;second.edges.begin(); e != it-&gt;second.edges.end(); e++) { if (!(s &amp; (1 &lt;&lt; (e - it-&gt;second.edges.begin())))) continue; graph[e-&gt;u][e-&gt;v] = graph[e-&gt;v][e-&gt;u] = true; } ufs.init(n); for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { if (graph[i][j]) { if (ufs.test(i, j)) { goto nextLoop; } ufs.merge(i, j); } } } t++; nextLoop:; } // printf("t = %d\n", t); (ans *= t) %= MOD; for (std::vector&lt;Edge&gt;::const_iterator e = it-&gt;second.edges.begin(); e != it-&gt;second.edges.end(); e++) { graph[e-&gt;u][e-&gt;v] = graph[e-&gt;v][e-&gt;u] = e-&gt;used; } } printf("%lld\n", ans); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>搜索</tag>
        <tag>最小生成树</tag>
        <tag>JSOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2008」星球大战 - 离线 + 并查集]]></title>
    <url>%2Fjsoi2008-starwar%2F</url>
    <content type="text"><![CDATA[给一个图，每次删除一个点，求连通块数量。 链接 BZOJ 1015 题解 记录所有被删除的点，将除这些点邻边之外所有的边加入并查集，将操作离线变为加边，每次加入一个点的一些邻边，当某个邻边指向的点已被加入时，加入这条边。 代码 #include &lt;cstdio&gt; #include &lt;vector&gt; const int MAXM = 200000; const int MAXN = 2 * MAXM; struct UnionFindSet { int a[MAXN], rk[MAXN]; void init(const int n) { for (int i = 0; i &lt; n; i++) a[i] = i, rk[i] = 1; } int find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); } bool test(const int x, const int y) { return find(x) == find(y); } void merge(const int x, const int y) { const int p = find(x), q = find(y); if (p == q) return; if (rk[p] &gt; rk[q]) a[q] = p; else if (rk[q] &gt; rk[p]) a[p] = q; else a[p] = q, rk[q]++; } } ufs; struct Edge { bool added; int u, v; } E[MAXM]; struct Node { std::vector&lt;Edge *&gt; e; bool added; bool willDelete; } N[MAXN]; inline void addAllEdge(Node *v, int &amp;ans) { ans++; for (std::vector&lt;Edge *&gt;::const_iterator it = v-&gt;e.begin(); it != v-&gt;e.end(); it++) { Edge *const &amp;e = *it; if (!e-&gt;added &amp;&amp; N[e-&gt;u].added &amp;&amp; N[e-&gt;v].added &amp;&amp; !ufs.test(e-&gt;u, e-&gt;v)) { ufs.merge(e-&gt;u, e-&gt;v); // printf("merge(%d, %d)\n", e-&gt;u, e-&gt;v); ans--; e-&gt;added = true; } } } int main() { int n, m, k, ans; static int a[MAXN]; scanf("%d %d", &amp;n, &amp;m), ans = 0; ufs.init(n); for (int i = 0; i &lt; m; i++) scanf("%d %d", &amp;E[i].u, &amp;E[i].v), N[E[i].u].e.push_back(&amp;E[i]), N[E[i].v].e.push_back(&amp;E[i]); scanf("%d", &amp;k); for (int i = k - 1; i &gt;= 0; i--) scanf("%d", &amp;a[i]), N[a[i]].willDelete = true; for (int i = 0; i &lt; n; i++) if (!N[i].willDelete) N[i].added = true, addAllEdge(&amp;N[i], ans); std::vector&lt;int&gt; anses; anses.push_back(ans); for (int i = 0; i &lt; k; i++) { // printf("before %d\n", a[i]); Node *v = &amp;N[a[i]]; v-&gt;added = true; addAllEdge(v, ans); anses.push_back(ans); } for (std::vector&lt;int&gt;::const_reverse_iterator it = anses.rbegin(); it != anses.rend(); it++) printf("%d\n", *it); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>并查集</tag>
        <tag>离线</tag>
        <tag>JSOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2008」火星人 - Splay + Hash]]></title>
    <url>%2Fjsoi2008-prefix%2F</url>
    <content type="text"><![CDATA[给定一个字符串，每次修改一个字符、插入一个字符、查询某两个后缀的最长公共前缀。 链接 BZOJ 1014 题解 使用 Splay 维护字符串 Hash，在每个节点上维护整棵子树的 Hash 值，合并两棵子树的 Hash 值时，右子树的 Hash 值乘以一个较高次幂。 二分求 LCP 即可。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 100000; const int MAXM = 150000; const unsigned long long BASE = 233; unsigned long long base[MAXN + 1]; struct Splay { struct Node { Node *c[2], *p, **r; int size; char val; unsigned long long hash; Node(Node *p, Node **r, const char val) : p(p), r(r), size(1), val(val), hash(val) { c[0] = c[1] = NULL; } int relation() { return this == p-&gt;c[0] ? 0 : 1; } void rotate() { Node *o = p; int x = relation(); p = o-&gt;p; if (o-&gt;p) o-&gt;p-&gt;c[o-&gt;relation()] = this; o-&gt;c[x] = c[x ^ 1]; if (c[x ^ 1]) c[x ^ 1]-&gt;p = o; c[x ^ 1] = o; o-&gt;p = this; o-&gt;maintain(), maintain(); if (!p) *r = this; } Node *splay(Node *targetParent = NULL) { while (p != targetParent) { if (p-&gt;p == targetParent) rotate(); else if (relation() == p-&gt;relation()) p-&gt;rotate(), rotate(); else rotate(), rotate(); } return this; } void maintain() { size = 1; if (c[0]) size += c[0]-&gt;size; if (c[1]) size += c[1]-&gt;size; hash = val; if (c[1]) hash += c[1]-&gt;hash * BASE; if (c[0]) hash = hash * base[c[0]-&gt;size] + c[0]-&gt;hash; } int lsize() { return c[0] ? c[0]-&gt;size : 0; } void print(const int depth = 0) { if (c[1]) c[1]-&gt;print(depth + 1); for (int i = 0; i &lt; depth; i++) putchar(' '); printf("%c\n", val == 0 ? ' ' : val); if (c[0]) c[0]-&gt;print(depth + 1); } } *r; Splay() : r(NULL) {} Node *build(const char *first, const char *last, Node *p) { if (first &gt; last) return NULL; if (first == last) return new Node(p, &amp;r, *first); else { const char *mid = first + (last - first) / 2; Node *v = new Node(p, &amp;r, *mid); v-&gt;c[0] = build(first, mid - 1, v); v-&gt;c[1] = build(mid + 1, last, v); v-&gt;maintain(); return v; } } void buildBounds(const int x) { Node *v = r; while (v-&gt;c[x]) v = v-&gt;c[x]; v-&gt;c[x] = new Node(v, &amp;r, 0); Node *u = v; do { u-&gt;maintain(); u = u-&gt;p; } while (u); v-&gt;c[x]-&gt;splay(); } void build(const char *first, const char *last) { r = build(first, last, NULL); buildBounds(0); buildBounds(1); } Node *select(const int k) { int x = k + 1; Node *v = r; while (x != v-&gt;lsize() + 1) { if (x &lt; v-&gt;lsize() + 1) v = v-&gt;c[0]; else x -= v-&gt;lsize() + 1, v = v-&gt;c[1]; } return v-&gt;splay(); } Node *select(const int l, const int r) { Node *a = select(l - 1), *b = select(r + 1); a-&gt;splay(); b-&gt;splay(a); return b-&gt;c[0]; } Node *insert(const int pos, const char ch) { Node *a = select(pos), *b = select(pos + 1); a-&gt;splay(); b-&gt;splay(a); b-&gt;c[0] = new Node(b, &amp;r, ch); Node *v = b-&gt;c[0]; do { v-&gt;maintain(); v = v-&gt;p; } while (v); return b-&gt;c[0]-&gt;splay(); } void update(const int pos, const char ch) { Node *v = select(pos); v-&gt;val = ch; v-&gt;maintain(); } unsigned long long query(const int l, const int r) { return select(l, r)-&gt;hash; } int size() { return r-&gt;size - 2; } } splay; inline void print() { splay.r-&gt;print(); puts("------------------------"); } inline int lcp(const int a, const int b) { int l = 0, r = std::min(splay.size() - a + 1, splay.size() - b + 1); while (l != r) { const int mid = l + (r - l) / 2 + 1; if (splay.query(a, a + mid - 1) == splay.query(b, b + mid - 1)) { l = mid; } else { r = mid - 1; } } return l; } int main() { base[0] = 1; for (int i = 1; i &lt;= MAXN; i++) base[i] = base[i - 1] * BASE; static char s[MAXN + 1]; scanf("%s", s); int n = strlen(s); splay.build(s, s + n - 1); int m; scanf("%d", &amp;m); while (m--) { char cmd[2]; scanf("%s", cmd); if (cmd[0] == 'Q') { int a, b; scanf("%d %d", &amp;a, &amp;b); printf("%d\n", lcp(a, b)); } else if (cmd[0] == 'R') { int pos; char ch[2]; scanf("%d %s", &amp;pos, ch); splay.update(pos, ch[0]); } else if (cmd[0] == 'I') { int pos; char ch[2]; scanf("%d %s", &amp;pos, ch); splay.insert(pos, ch[0]); } // print(); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>Splay</tag>
        <tag>JSOI</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2008」神奇的国度 - 最大势]]></title>
    <url>%2Fhnoi2008-kingdom%2F</url>
    <content type="text"><![CDATA[给一个弦图，求它的最小染色数。 链接 BZOJ 1006 题解 使用最大势（MCS）算法，求出一个弦图的完美消除序列，染色时，对完美消除序列从后向前染当前能染的最小颜色，即为最优方案。 最大势算法的流程是： 选一个点作为初始点，排在完美消除序列的最后一个； 将这个点邻接点的势 ； 从它的邻接点中选择一个势最大的，且未被选中过的点，作为完美消除序列的下一个点； 返回 (2)，直到完美消除序列构造完毕。 朴素算法的时间复杂度为 使用链表优化，可将时间复杂度降为 。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;set&gt; #include &lt;list&gt; const int MAXN = 10000; const int MAXM = 1000000; struct Node { struct Edge *e; int d, color; bool visited; std::list&lt;Node *&gt;::iterator iterator; } N[MAXN], *seq[MAXN]; struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t) { N[s].e = new Edge(&amp;N[s], &amp;N[t]); N[t].e = new Edge(&amp;N[t], &amp;N[s]); } int n, m; inline void mcs() { static std::list&lt;Node *&gt; lists[MAXN]; for (int i = 0; i &lt; n; i++) { N[i].d = 0; N[i].visited = false; lists[0].push_front(&amp;N[i]); N[i].iterator = lists[0].begin(); } int max = 0; for (int i = n - 1; i &gt;= 0; i--) { while (lists[max].empty()) max--; Node *v = lists[max].front(); lists[max].pop_front(); seq[i] = v; // printf("%lu\n", seq[i] - N + 1); v-&gt;visited = true; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (!e-&gt;t-&gt;visited) { lists[e-&gt;t-&gt;d].erase(e-&gt;t-&gt;iterator); e-&gt;t-&gt;d++; lists[e-&gt;t-&gt;d].push_front(e-&gt;t); e-&gt;t-&gt;iterator = lists[e-&gt;t-&gt;d].begin(); max = std::max(max, e-&gt;t-&gt;d); } } } } int main() { scanf("%d %d", &amp;n, &amp;m); while (m--) { int u, v; scanf("%d %d", &amp;u, &amp;v), u--, v--; addEdge(u, v); } mcs(); int ans = 0; for (int i = n - 1; i &gt;= 0; i--) { std::set&lt;int&gt; s; for (Edge *e = seq[i]-&gt;e; e; e = e-&gt;next) { if (e-&gt;t-&gt;color) s.insert(e-&gt;t-&gt;color); } s.insert(INT_MAX); int last = 0; for (std::set&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++) { if (last + 1 != *it) { seq[i]-&gt;color = last + 1; break; } last = *it; } ans = std::max(ans, seq[i]-&gt;color); } printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>HNOI</tag>
        <tag>弦图</tag>
        <tag>最大势</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2008」Cards - Burnside 引理]]></title>
    <url>%2Fhnoi2008-cards%2F</url>
    <content type="text"><![CDATA[给 张牌，3 种颜色，和 种洗牌方案，求本质不同的染色方案数。 链接 BZOJ 1004 题解 Burnside 引理，求出对于每一种洗牌方案，洗完牌后不变的方案数 —— 将每种洗牌方案拆成若干个循环，只需保证每个循环中的牌颜色相同即可，对每个循环的长度做背包即可。 求出这些方案数后，在模意义下除以 得到答案。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; const int MAXX = 20; const int MAXN = 60; const int MAXM = 60; int a, b, c, n, mod; inline int calc(const int *map) { bool flag[MAXM] = { false }; std::vector&lt;int&gt; v; for (int i = 0; i &lt; n; i++) { int x = 0; for (int t = i; !flag[t]; t = map[t]) { flag[t] = true; x++; } if (x) v.push_back(x); } static int f[MAXX + 1][MAXX + 1][MAXX + 1]; memset(f, 0, sizeof(f)); f[0][0][0] = 1; for (std::vector&lt;int&gt;::const_iterator it = v.begin(); it != v.end(); it++) { for (int i = a; i &gt;= 0; i--) { for (int j = b; j &gt;= 0; j--) { for (int k = c; k &gt;= 0; k--) { if (i &gt;= *it) (f[i][j][k] += f[i - *it][j][k]) %= mod; if (j &gt;= *it) (f[i][j][k] += f[i][j - *it][k]) %= mod; if (k &gt;= *it) (f[i][j][k] += f[i][j][k - *it]) %= mod; } } } } // printf("calc() = %d\n", f[a][b][c]); return f[a][b][c]; } inline void exgcd(const int a, const int b, int &amp;g, int &amp;x, int &amp;y) { if (!b) g = a, x = 1, y = 0; else exgcd(b, a % b, g, y, x), y -= x * (a / b); } inline int inv(const int x) { int tmp1, tmp2, res; exgcd(x, mod, tmp1, res, tmp2); return (res % mod + mod) % mod; } int main() { int m; scanf("%d %d %d %d %d", &amp;a, &amp;b, &amp;c, &amp;m, &amp;mod); n = a + b + c; int sum = 0; for (int i = 0; i &lt; m; i++) { int map[MAXN]; for (int j = 0; j &lt; n; j++) scanf("%d", &amp;map[j]), map[j]--; (sum += calc(map)) %= mod; } int map[MAXN]; for (int i = 0; i &lt; n; i++) map[i] = i; (sum += calc(map)) %= mod; int ans = sum * inv(m + 1) % mod; printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>HNOI</tag>
        <tag>Burnside 引理</tag>
        <tag>群论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「FJOI2007」轮状病毒 - 高精度]]></title>
    <url>%2Ffjoi2007-wheel%2F</url>
    <content type="text"><![CDATA[一个 轮状基由圆环上 个不同的基原子和圆心处一个核原子构成的，2 个原子之间的边表示这 2 个原子之间的信息通道。 轮状病毒的产生规律是在一个 轮状基中删去若干条边，使得各原子之间有唯一的信息通道，编程计算有多少个不同的 轮状病毒。 链接 BZOJ 1002 题解 公式： 需要高精度。 代码 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; const int MAXN = 100; struct BigInt { std::vector&lt;int&gt; v; BigInt(const int n = 0) { *this = n; } BigInt(const std::string &amp;s) { *this = s; } BigInt &amp;operator=(int x) { v.clear(); do v.push_back(x % 10); while (x /= 10); } BigInt &amp;operator=(const std::string &amp;s) { v.resize(s.length()); for (size_t i = 0; i &lt; s.length(); i++) v[i] = s[s.length() - i - 1] - '0'; } void print() { for (int i = v.size() - 1; i &gt;= 0; i--) printf("%d", v[i]); putchar('\n'); } }; BigInt operator+(const BigInt &amp;a, const BigInt &amp;b) { BigInt res; res.v.clear(); bool flag = false; for (size_t i = 0; i &lt; std::max(a.v.size(), b.v.size()); i++) { int t = 0; if (i &lt; a.v.size()) t += a.v[i]; if (i &lt; b.v.size()) t += b.v[i]; if (flag) t++, flag = false; if (t &gt;= 10) t -= 10, flag = true; res.v.push_back(t); } if (flag) res.v.push_back(1); return res; } BigInt operator-(const BigInt &amp;a, const BigInt &amp;b) { BigInt res; res.v.clear(); bool flag = false; for (size_t i = 0; i &lt; std::max(a.v.size(), b.v.size()); i++) { int t = 0; if (i &lt; a.v.size()) t += a.v[i]; if (i &lt; b.v.size()) t -= b.v[i]; if (flag) t--, flag = false; if (t &lt; 0) t += 10, flag = true; res.v.push_back(t); } return res; } BigInt operator*(const BigInt &amp;a, const BigInt &amp;b) { BigInt res; res.v.resize(a.v.size() + b.v.size() + 1); for (size_t i = 0; i &lt; a.v.size(); i++) { for (size_t j = 0; j &lt; b.v.size(); j++) { res.v[i + j] += a.v[i] * b.v[j]; res.v[i + j + 1] += res.v[i + j] / 10; res.v[i + j] %= 10; } } while (res.v.size() &gt; 1 &amp;&amp; res.v.back() == 0) res.v.pop_back(); return res; } int main() { int n; scanf("%d", &amp;n); BigInt f[MAXN + 1]; f[1] = 1, f[2] = 5; for (int i = 3; i &lt;= n; i++) f[i] = f[i - 1] * 3 - f[i - 2] + 2; f[n].print(); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>高精度</tag>
        <tag>FJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2013」花匠 - 贪心]]></title>
    <url>%2Fnoip2013-flower%2F</url>
    <content type="text"><![CDATA[花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。 具体而言，栋栋的花的高度可以看成一列整数 。设当一部分花被移走后，剩下的花的高度依次为 ，则栋栋希望下面两个条件中至少有一个满足： 条件 A：对于所有的 ， 且 ； 条件 B：对于所有的 ， 且 。 注意上面两个条件在 时同时满足，当 时最多有一个能满足。 请问，栋栋最多能将多少株花留在原地。 链接 CodeVS 3289 题解 最长波动子序列，贪心。 记录在当前情况下最长波动子序列的最后两个数，设它们为 和 ，考虑原序列最后加入一个 的影响。 如果 且 （ 且 ），则 可以接在当前最长波动子序列的后面，答案 。 如果 且 （ 且 ），则可以用 替换 ，这样一定不会使总的答案变差，并且可以使 之后一个（可能的）满足 的 接在 之后。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 100000; int main() { int n; scanf("%d", &amp;n); int prev, curr, ans = 1; scanf("%d", &amp;curr); for (int i = 1; i &lt; n; i++) { int x; scanf("%d", &amp;x); if (x == curr) continue; if (ans == 1 || (prev &lt; curr) != (curr &lt; x)) { ans++; prev = curr; curr = x; } else { if (prev &lt; curr) curr = std::max(curr, x); else curr = std::min(curr, x); } } printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeVS</tag>
        <tag>贪心</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2013」火柴排队 - 逆序对]]></title>
    <url>%2Fnoip2013-match%2F</url>
    <content type="text"><![CDATA[涵涵有两盒火柴，每盒装有 根火柴，每根火柴都有一个高度。现在将每盒中的火柴各自排成一列，同一列火柴的高度互不相同，两列火柴之间的距离定义为 其中 表示第一列火柴中第 个火柴的高度， 表示第二列火柴中第 个火柴的高度。 每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？ 链接 CodeVS 3286 题解 显然，最优方案为，对于每一个 ，第一列中的第 大和第二列中的第 大在相同位置上。 构造一个数组 ，对于第二列火柴中的第 个，设它为第二列中的第 大，设第一列火柴中的第 大为第 个，则 。求出 的逆序对数即为答案。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 100000; const int MOD = 99999997; struct Match { int index, rank, value, w; } a[MAXN + 1], b[MAXN + 1]; int n; struct BinaryIndexedTree { int a[MAXN + 1]; static int lowbit(int x) { return x &amp; -x; } int query(int pos) { int res = 0; for (int i = pos; i &gt; 0; i -= lowbit(i)) res += a[i]; return res; } int query(int l, int r) { return query(r) - query(l - 1); } void update(int pos, int delta) { for (int i = pos; i &lt;= n; i += lowbit(i)) a[i] += delta; } } bit; inline bool byVal(const Match &amp;a, const Match &amp;b) { return a.value &lt; b.value; } inline bool byID(const Match &amp;a, const Match &amp;b) { return a.index &lt; b.index; } int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i].value), a[i].index = i; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;b[i].value), b[i].index = i; std::sort(a + 1, a + n + 1, &amp;byVal); std::sort(b + 1, b + n + 1, &amp;byVal); for (int i = 1; i &lt;= n; i++) { a[i].rank = b[i].rank = i; } for (int i = 1; i &lt;= n; i++) { b[i].w = a[i].index; } std::sort(b + 1, b + n + 1, &amp;byID); // for (int i = 1; i &lt;= n; i++) printf("%d\n", b[i].w); long long ans = 0; for (int i = 1; i &lt;= n; i++) { ans += bit.query(b[i].w + 1, n); bit.update(b[i].w, 1); } printf("%lld\n", ans % MOD); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>CodeVS</tag>
        <tag>NOIP</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2008」明明的烦恼 - Prüfer 序列]]></title>
    <url>%2Fhnoi2008-tree%2F</url>
    <content type="text"><![CDATA[给出标号为 到 的点，以及某些点最终的度数，允许在任意两点间连线，求可产生多少棵度数满足要求的树。 链接 BZOJ 1005 题解 此题用到一个东西叫「Prufer 序列」，虽然不懂是什么东西，但只需要一个结论： 对于一个 个节点的树，其 Prufer 序列的长度为 ，且一个点的度数 等于它在 Prufer 序列中的出现次数。 设共有 个点被限制度， 表示节点 的度，。即被限制度的点共出现了 次。 考虑他们在 Prufer 序列中的出现位置，并乘上一个重复元素排列，即 继续考虑剩余的 个无度限制的点，剩余的 个位置可以任意放这些点，即 整理，得 代码 import java.math.BigInteger; import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int d[] = new int[n], s = 0, k = 0; boolean invalid = false; for (int i = 0; i &lt; n; i++) { d[i] = sc.nextInt(); if (d[i] != -1) { k++; if (d[i] &lt;= 0 || d[i] &gt;= n + 1) invalid = true; s += d[i] - 1; } } if (n == 1) { if (d[0] == 0 || d[0] == -1) System.out.println(1); else System.out.println(0); } else if (n == 2) { if ((d[0] == 1 || d[0] == -1) &amp;&amp; (d[1] == 1 || d[1] == -1)) System.out.println(1); else System.out.println(0); } else if (invalid) { System.out.println(0); } else { BigInteger fac[] = new BigInteger[n - 1]; fac[0] = BigInteger.ONE; for (int i = 1; i &lt;= n - 2; i++) fac[i] = fac[i - 1].multiply(BigInteger.valueOf(i)); BigInteger ans = BigInteger.ONE; ans = ans.multiply(fac[n - 2]).multiply(BigInteger.valueOf(n - k).pow(n - 2 - s)).divide(fac[n - 2 - s]); for (int i = 0; i &lt; n; i++) if (d[i] &gt; 1) ans = ans.divide(fac[d[i] - 1]); System.out.println(ans); } } }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>高精度</tag>
        <tag>HNOI</tag>
        <tag>Prüfer 序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2014」飞扬的小鸟 - 背包 DP]]></title>
    <url>%2Fnoip2014-bird%2F</url>
    <content type="text"><![CDATA[游戏界面是一个长为 ，高为 的二维平面，其中有 个管道（忽略管道的宽度）。 小鸟始终在游戏界面内移动。小鸟从游戏界面最左边任意整数高度位置出发，到达游戏界面最右边时，游戏完成。 小鸟每个单位时间沿横坐标方向右移的距离为 ，竖直移动的距离由玩家控制。如果点击屏幕，小鸟就会上升一定高度 ，每个单位时间可以点击多次，效果叠加；如果不点击屏幕，小鸟就会下降一定高度 。小鸟位于横坐标方向不同位置时，上升的高度 和下降的高度 可能互不相同。 小鸟高度等于 或者小鸟碰到管道时，游戏失败。小鸟高度为 时，无法再上升。 现在,请你判断是否可以完成游戏。如果可以，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。 链接 COGS 1805 CodeVS 3729 题解 动态规划，设 表示飞到横坐标为 ，纵座标为 处的最少屏幕点击次数。 考虑每一个状态是如何到达的 —— 可能是在横坐标 处点击 次屏幕，上升 个单位高度后到达；也可能是不点击屏幕，下降 个单位高度后到达。如果我们枚举 ，则状态转移方程为 显然，每次状态转移的时间为 ，总时间复杂度为 ，会超时。 考虑「点击 次」和「点击 次」之间的联系，如果最优方案中，点击了 次到达纵坐标 ，则如果点击 次，会到达纵坐标 ，此时的状态转移方程（只考虑点击）为 即，「只点击一次」和「从点击若干次到达的将要位置上再点击一次」。这是一种类似完全背包中「多装一个」的思想。 需要注意的是，使用优化后的状态转移方程计算时，不能简单地将障碍位置的答案直接置为正无穷 —— 考虑有一种情况，点击 次后会到达下方的管道的位置，而点击 次不会，而点击 次的答案需要由 次得到。解决方法是计算完一列的状态之后，将障碍区域的答案全部置为正无穷。 统计答案时，如果到达最右边一列某些位置的步数不为正无穷，则取这些中的最小值作为最小步数，否则扫描每一列，记录管道数量，直到「不可达」的一列为止。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; const int MAXN = 10000; const int MAXM = 1000; struct Pipe { bool exist; int top, bottom; } a[MAXN + 1]; int n, m, k, up[MAXN + 1], down[MAXN + 1]; template &lt;typename T&gt; bool cmin(T &amp;a, const T &amp;b) { return (a &gt; b) ? (a = b, true) : false; } int main() { scanf("%d %d %d", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; n; i++) { scanf("%d %d", &amp;up[i], &amp;down[i]); } while (k--) { int i; scanf("%d", &amp;i); scanf("%d %d", &amp;a[i].bottom, &amp;a[i].top); a[i].exist = true; } static int f[MAXN + 1][MAXM + 1]; // for (int i = 1; i &lt;= m; i++) f[0][i] = 0; f[0][0] = INT_MAX; for (int i = 1; i &lt;= n; i++) { f[i][0] = INT_MAX; for (int j = 1; j &lt; m; j++) { f[i][j] = INT_MAX; // if (a[i].exist &amp;&amp; (j &lt;= a[i].bottom || j &gt;= a[i].top)) continue; if (j &gt;= up[i - 1]) { if (f[i - 1][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j - up[i - 1]] + 1); if (f[i][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i][j - up[i - 1]] + 1); } /* if (j &lt;= m - down[i - 1]) { if (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]); } */ #ifdef DBG printf("f[%d][%d] = %d\n", i, j, f[i][j]); #endif } for (int j = 1; j &lt;= m - down[i - 1]; j++) { // if (a[i].exist &amp;&amp; (j &lt;= a[i].bottom || j &gt;= a[i].top)) continue; if (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]); } f[i][m] = INT_MAX; // if (a[i].exist) continue; for (int k = m - up[i - 1]; k &lt;= m; k++) { if (f[i - 1][k] != INT_MAX) cmin(f[i][m], f[i - 1][k] + 1); if (f[i][k] != INT_MAX) cmin(f[i][m], f[i][k] + 1); } if (a[i].exist) for (int j = 1; j &lt;= m; j++) if (j &lt;= a[i].bottom || j &gt;= a[i].top) f[i][j] = INT_MAX; } int clicks = INT_MAX; for (int i = 1; i &lt;= m; i++) cmin(clicks, f[n][i]); if (clicks != INT_MAX) { printf("1\n%d\n", clicks); } else { int pos = -1; for (int i = n - 1; i &gt;= 0; i--) { for (int j = 1; j &lt;= m; j++) { if (f[i][j] != INT_MAX) { pos = i; break; } } if (pos != -1) break; } int pipeCnt = 0; for (int i = 1; i &lt;= pos; i++) if (a[i].exist) pipeCnt++; printf("0\n%d\n", pipeCnt); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>CodeVS</tag>
        <tag>背包 DP</tag>
        <tag>COGS</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2012」借教室 - 二分 / 线段树]]></title>
    <url>%2Fnoip2012-classrooms%2F</url>
    <content type="text"><![CDATA[我们需要处理接下来 天的借教室信息，其中第 天学校有 个教室可供租借。共有 份订单，每份订单用三个正整数描述，分别为 ，表示某租借者需要从第 天到第 天租借教室（包括第 天和第 天），每天需要租借 个教室。 现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。 链接 COGS 1266 CodeVS 1217 题解 解法一 对天数建立线段树，维护区间最小值，每次租借时查询区间最小值，如果小于租借数量，则无法满足，否则对一个区间减去租借数量，继续处理下一个订单。 期望得分 100 分，实际得分 95 分。 解法二 二分天数 ，使用差分 + 前缀和检验前 天是否可以完全满足。 期望得分 100 分，实际得分 100 分。 代码 线段树，TLE #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;new&gt; const int MAXN = 1000000; const int MAXR = 1000000000; template &lt;typename T, size_t SIZE&gt; struct MemoryPool { char a[SIZE * sizeof(T)]; T *p; MemoryPool() : p((T *)a) {} T *alloc() { return p++; } }; struct SegmentTree { struct Node { Node *lchild, *rchild; int l, r; int value, min, lazy; Node(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {} void pushDown() { if (lazy) { if (lchild) lchild-&gt;value += lazy, lchild-&gt;min += lazy, lchild-&gt;lazy += lazy; if (rchild) rchild-&gt;value += lazy, rchild-&gt;min += lazy, rchild-&gt;lazy += lazy; lazy = 0; } } int queryMin(int l, int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return INT_MAX; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return min; else { pushDown(); int ans = INT_MAX; if (lchild) ans = std::min(ans, lchild-&gt;queryMin(l, r)); if (rchild) ans = std::min(ans, rchild-&gt;queryMin(l, r)); return ans; } } void update(int l, int r, int x) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) value += x, min += x, lazy += x; else { pushDown(); if (lchild) lchild-&gt;update(l, r, x); if (rchild) rchild-&gt;update(l, r, x); min = INT_MAX; if (lchild) min = std::min(min, lchild-&gt;min); if (rchild) min = std::min(min, rchild-&gt;min); } } } *root; SegmentTree(int l, int r) { root = build(l, r); } Node *build(int l, int r) { static MemoryPool&lt;Node, MAXN * 2&gt; pool; if (l &gt; r) return NULL; else if (l == r) return new (pool.alloc()) Node(l, r, NULL, NULL); else return new (pool.alloc()) Node(l, r, build(l, l + ((r - l) &gt;&gt; 1)), build(l + ((r - l) &gt;&gt; 1) + 1, r)); } int queryMin(int l, int r) { return root-&gt;queryMin(l, r); } void update(int l, int r, int x) { root-&gt;update(l, r, x); } }; int n, m; template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; char ch; while (ch = getchar(), !(ch &gt;= '0' &amp;&amp; ch &lt;= '9')); do x = x * 10 + (ch - '0'); while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9'); } int main() { read(n), read(m); SegmentTree segmentTree(1, n); for (int i = 1; i &lt;= n; i++) { int x; read(x); segmentTree.update(i, i, x); } int day = 0; for (int i = 1; i &lt;= m; i++) { int x, l, r; read(x), read(l), read(r); segmentTree.update(l, r, -x); if (segmentTree.queryMin(1, n) &lt; 0) { day = i; break; } } if (day != 0) printf("-1\n%d\n", day); else puts("0"); return 0; } 二分，AC #include &lt;cstdio&gt; const int MAXN = 1e6; int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); static int available[MAXN]; static struct Request { int l, r, cnt; } req[MAXN]; for (int i = 0; i &lt; n; i++) scanf("%d", &amp;available[i]); for (int i = 0; i &lt; m; i++) scanf("%d %d %d", &amp;req[i].cnt, &amp;req[i].l, &amp;req[i].r), req[i].l--, req[i].r--; int l = -1, r = m - 1; static int used[MAXN]; while (l &lt; r) { const int mid = l + (r - l) / 2 + 1; bool valid = true; for (int i = 0; i &lt; n; i++) used[i] = 0; for (int i = 0; i &lt;= mid; i++) { used[req[i].l] += req[i].cnt; if (req[i].r != n - 1) used[req[i].r + 1] -= req[i].cnt; } for (int i = 1; i &lt; n; i++) used[i] += used[i - 1]; for (int i = 0; i &lt; n; i++) { if (used[i] &gt; available[i]) { valid = false; break; } } #ifdef DBG printf("[%d, %d] =&gt; %d\n", l, r, mid); #endif if (valid) l = mid; else r = mid - 1; } if (l == m - 1) puts("0"); else printf("-1\n%d\n", l + 1 + 1); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>CodeVS</tag>
        <tag>COGS</tag>
        <tag>二分</tag>
        <tag>NOIP</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TJOI2015」棋盘 - 状压 DP + 矩阵乘法]]></title>
    <url>%2Ftjoi2015-chessboard%2F</url>
    <content type="text"><![CDATA[有一个 行 列的棋盘，每个棋子可以攻击到本行、上一行、下一行的一些棋子，求有多少种放棋子的方案使得任意两个棋子都不会互相攻击。 链接 BZOJ 4000 COGS 1979 题解 枚举一行内放置的所有方案，求出每种方案是否可行，并求出相邻两行放置的所有方案是否可行。 设 表示前 行，第 行放置状态为 的方案数，转移时枚举上一行的所有可行方案，累加。 使用矩阵快速幂优化，时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; const int MAXN = 1000000; const int MAXM = 6; const int MAXSTATUS = 1 &lt;&lt; 6; struct Matrix { unsigned int a[MAXSTATUS][MAXSTATUS]; Matrix(const bool unit = false) { memset(a, 0, sizeof(a)); if (unit) for (int i = 0; i &lt; MAXSTATUS; i++) a[i][i] = true; } unsigned int &amp;operator()(const int i, const int j) { return a[i][j]; } const unsigned int &amp;operator()(const int i, const int j) const { return a[i][j]; } }; Matrix operator*(const Matrix &amp;a, const Matrix &amp;b) { Matrix res(false); for (int i = 0; i &lt; MAXSTATUS; i++) for (int j = 0; j &lt; MAXSTATUS; j++) for (int k = 0; k &lt; MAXSTATUS; k++) res(i, j) += a(i, k) * b(k, j); return res; } Matrix pow(Matrix a, int n) { Matrix res(true); for (; n; n &gt;&gt;= 1, a = a * a) if (n &amp; 1) res = res * a; return res; } #ifdef DBG inline void print(const int x, const int m) { for (int i = 0; i &lt; m; i++) putchar((x &amp; (1 &lt;&lt; i)) ? '1' : '0'); // putchar('\n'); } #endif int m, w, pos; inline void apply(const bool *tpl, const int j, bool *target) { for (int k = 0; k &lt; w; k++) { if (j - pos + k &gt;= 0 &amp;&amp; j - pos + k &lt; m &amp;&amp; tpl[k]) target[j - pos + k] = true; } } int main() { freopen("tjoi2015_board.in", "r", stdin); freopen("tjoi2015_board.out", "w", stdout); int n; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;w, &amp;pos); static bool attack[3][MAXM]; for (int i = 0; i &lt; 3; i++) for (int j = 0; j &lt; w; j++) { int x; scanf("%d", &amp;x); attack[i][j] = x; } attack[1][pos] = false; static bool valid[MAXSTATUS]; for (int i = 0; i &lt; (1 &lt;&lt; m); i++) { static bool tmp[MAXM]; for (int k = 0; k &lt; m; k++) tmp[k] = false; valid[i] = true; for (int j = 0; j &lt; m; j++) if (i &amp; (1 &lt;&lt; j)) apply(attack[1], j, tmp); for (int j = 0; j &lt; m; j++) if (i &amp; (1 &lt;&lt; j) &amp;&amp; tmp[j]) { valid[i] = false; break; } #ifdef DBG printf(valid[i] ? "valid: " : "invalid: "); print(i, m); putchar('\n'); #endif } static bool near[MAXSTATUS][MAXSTATUS]; for (int i = 0; i &lt; (1 &lt;&lt; m); i++) for (int j = 0; j &lt; (1 &lt;&lt; m); j++) { if (!valid[i] || !valid[j]) { near[i][j] = false; continue; } near[i][j] = true; static bool tmpA[MAXM], tmpB[MAXM]; for (int k = 0; k &lt; m; k++) tmpA[k] = tmpB[k] = false; for (int k = 0; k &lt; m; k++) { if (!(i &amp; (1 &lt;&lt; k))) continue; apply(attack[2], k, tmpB); } for (int k = 0; k &lt; m; k++) { if (!(j &amp; (1 &lt;&lt; k))) continue; apply(attack[0], k, tmpA); } for (int k = 0; k &lt; m; k++) { if (((i &amp; (1 &lt;&lt; k)) &amp;&amp; tmpA[k]) || ((j &amp; (1 &lt;&lt; k)) &amp;&amp; tmpB[k])) { near[i][j] = false; break; } } #ifdef DBG printf(near[i][j] ? "valid: " : "invalid: "); print(i, m); putchar(' '); print(j, m); putchar('\n'); if (valid[i] &amp;&amp; valid[j]) printf("near[%d][%d] = %d\n", i, j, static_cast&lt;int&gt;(near[i][j])); #endif } #ifdef DBG static unsigned int f[MAXN + 1][MAXSTATUS]; f[0][0] = 1; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt; (1 &lt;&lt; m); j++) { if (!valid[j]) continue; for (int k = 0; k &lt; (1 &lt;&lt; m); k++) { if (!valid[k]) continue; if (near[k][j]) f[i][j] += f[i - 1][k]; } printf("f(%d, [", i); print(j, m); printf("] = %u\n", f[i][j]); } } unsigned int ansCheck = 0; for (int i = 0; i &lt; MAXSTATUS; i++) ansCheck += f[n][i]; #endif Matrix shift(false); for (int i = 0; i &lt; (1 &lt;&lt; m); i++) { if (valid[i]) { for (int j = 0; j &lt; (1 &lt;&lt; m); j++) { if (valid[j]) { if (near[j][i]) { shift(j, i) = 1; } } } } } Matrix init(false); init(0, 0) = 1; #ifndef FORCE Matrix res = pow(shift, n) * init; #else Matrix res(true); for (int i = 1; i &lt;= n; i++) { res = res * shift; #ifdef DBG for (int i = 0; i &lt; MAXSTATUS; i++) for (int j = 0; j &lt; MAXSTATUS; j++) printf("%d%c", res(i, j), j == MAXSTATUS - 1 ? '\n' : ' '); #endif } res = res * init; #endif unsigned int ans = 0; for (int i = 0; i &lt; MAXSTATUS; i++) ans += res(i, 0); printf("%u\n", ans); #ifdef DBG printf("ansCheck = %u\n", ansCheck); #endif fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>BZOJ</tag>
        <tag>状压 DP</tag>
        <tag>TJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2012」随机数生成器 - 矩阵乘法]]></title>
    <url>%2Fnoi2012-random%2F</url>
    <content type="text"><![CDATA[已知 给定 ，求 。 链接 BZOJ 2875 COGS 963 题解 用矩阵乘法计算递推。 两个数相乘结果可能溢出，需要使用类似快速幂的方法拆成二进制每次乘 。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; const long long MAXN = 1e18; const long long MAXG = 1e8; long long mod; struct Matrix { long long a[2][2]; Matrix(const bool unit = false) { memset(a, 0, sizeof(a)); if (unit) for (int i = 0; i &lt; 2; i++) a[i][i] = 1; } long long &amp;operator()(const int i, const int j) { return a[i][j]; } const long long &amp;operator()(const int i, const int j) const { return a[i][j]; } }; long long mul(long long a, long long b) { long long res = 0; for (; b; b &gt;&gt;= 1, a = (a + a) % mod) if (b &amp; 1) res = (res + a) % mod; return res; } Matrix operator*(const Matrix &amp;a, const Matrix &amp;b) { Matrix res(false); for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) (res(i, j) += mul(a(i, k), b(k, j))) %= mod; return res; } Matrix pow(Matrix a, long long n) { Matrix res(true); for (; n; n &gt;&gt;= 1, a = a * a) if (n &amp; 1) res = res * a; return res; } int main() { freopen("randoma.in", "r", stdin); freopen("randoma.out", "w", stdout); long long a, c, x, n, g; scanf("%lld %lld %lld %lld %lld %lld", &amp;mod, &amp;a, &amp;c, &amp;x, &amp;n, &amp;g); // mod = 1e9 + 7; Matrix init(false); init(0, 0) = x; init(1, 0) = c; Matrix shift(false); shift(0, 0) = a, shift(0, 1) = 1; shift(1, 0) = 0, shift(1, 1) = 1; #ifdef FORCE Matrix res = init; for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) printf("%lld%c", res(j, k), k == 2 - 1 ? '\n' : ' '); puts("----------------------"); for (int i = 0; i &lt; n; i++) { res = shift * res; for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) printf("%lld%c", res(j, k), k == 2 - 1 ? '\n' : ' '); puts("----------------------"); } #else Matrix res = pow(shift, n) * init; #endif printf("%lld\n", res(0, 0) % g); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>BZOJ</tag>
        <tag>COGS</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1706」乳牛接力跑 - 矩阵乘法]]></title>
    <url>%2Fbzoj-1706%2F</url>
    <content type="text"><![CDATA[给一个图，求从 点到 点恰好经过 步的最短路。 链接 BZOJ 1586 COGS 1470 题解 矩阵乘法可以求出恰好经过 步的路径数，将矩阵乘法中的求和改为取较小值，相乘改为相加即可求出恰好经过 步的最短路。 注意这时的单位矩阵，对角线上为 ，其它全部为正无穷。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 1000; const int MAXM = 100; const int MAXN_SMALL = 200; const int MAXK = 1000000; struct Matrix { int a[MAXN_SMALL][MAXN_SMALL]; Matrix(const bool unit = false) { for (int i = 0; i &lt; MAXN_SMALL; i++) for (int j = 0; j &lt; MAXN_SMALL; j++) a[i][j] = INT_MAX; if (unit) for (int i = 0; i &lt; MAXN_SMALL; i++) a[i][i] = 0; } int &amp;operator()(const int i, const int j) { return a[i][j]; } const int &amp;operator()(const int i, const int j) const { return a[i][j]; } }; Matrix operator*(const Matrix &amp;a, const Matrix &amp;b) { Matrix res(false); for (int i = 0; i &lt; MAXN_SMALL; i++) for (int j = 0; j &lt; MAXN_SMALL; j++) for (int k = 0; k &lt; MAXN_SMALL; k++) if (a(i, k) != INT_MAX &amp;&amp; b(k, j) != INT_MAX) res(i, j) = std::min(res(i, j), a(i, k) + b(k, j)); return res; } Matrix pow(Matrix a, int n) { Matrix res(true); for (; n; n &gt;&gt;= 1, a = a * a) if (n &amp; 1) res = res * a; return res; } int main() { freopen("relays.in", "r", stdin); freopen("relays.out", "w", stdout); int n, m, s, t, cnt; static int set[MAXM * 2]; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;s, &amp;t); static struct { int u, v, w; } E[MAXM]; for (int i = 0; i &lt; m; i++) { scanf("%d %d %d", &amp;E[i].w, &amp;E[i].u, &amp;E[i].v); set[i] = E[i].u; set[i + m] = E[i].v; } std::sort(set, set + m * 2); int *end = std::unique(set, set + m * 2); cnt = end - set; Matrix g(false); for (int i = 0; i &lt; m; i++) { E[i].u = std::lower_bound(set, end, E[i].u) - set; E[i].v = std::lower_bound(set, end, E[i].v) - set; g(E[i].u, E[i].v) = g(E[i].v, E[i].u) = E[i].w; } s = std::lower_bound(set, end, s) - set; t = std::lower_bound(set, end, t) - set; Matrix res = pow(g, n); /* Matrix res(true); for (int i = 0; i &lt; n; i++) { res = res * g; for (int i = 0; i &lt; cnt; i++) for (int j = 0; j &lt; cnt; j++) printf("%d%c", res(i, j), j == cnt - 1 ? '\n' : ' '); puts("-------------------"); } */ printf("%d\n", res(s, t)); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>BZOJ</tag>
        <tag>USACO</tag>
        <tag>COGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2004」沼泽鳄鱼 - 矩阵乘法]]></title>
    <url>%2Fzjoi2004-swamp%2F</url>
    <content type="text"><![CDATA[给一个图，有一些鳄鱼在两个、三个或四个点之间周期性移动，求从 点到 点，恰好走 步，任意时刻都不与鳄鱼同时到达同一个点的方案数。 链接 BZOJ 1898 COGS 1469 题解 如果没有鳄鱼的限制，答案就是邻接矩阵的 次方中 行 列的值。 有了鳄鱼之后，每一时刻都不能和鳄鱼停在同一个点上，所以每一次要乘的图是不同的。对于每个时间点，将鳄鱼到达点的所有出边删掉（表示，到达这个点会被鳄鱼吃掉）。 取 ，图的形态每 个单位时间循环一次。分别求出这 个矩阵和它们的积，对 的大于 的部分做快速幂，剩余部分乘上最多 个矩阵即可。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; const int MAXN = 50; const int MAXM = 20; const long long MAXK = 2e9; const int CYCLE_LCM = 12; const int MOD = 10000; struct Matrix { int a[MAXN][MAXN]; Matrix(const bool unit = false) { memset(a, 0, sizeof(a)); if (unit) for (int i = 0; i &lt; MAXN; i++) a[i][i] = 1; } int &amp;operator()(const int i, const int j) { return a[i][j]; } const int &amp;operator()(const int i, const int j) const { return a[i][j]; } }; Matrix operator*(const Matrix &amp;a, const Matrix &amp;b) { Matrix res; for (int i = 0; i &lt; MAXN; i++) for (int j = 0; j &lt; MAXN; j++) for (int k = 0; k &lt; MAXN; k++) (res(i, j) += a(i, k) * b(k, j)) %= MOD; return res; } Matrix pow(Matrix a, int n) { Matrix res(true); for (; n; n &gt;&gt;= 1, a = a * a) if (n &amp; 1) res = res * a; return res; } int main() { freopen("swamp.in", "r", stdin); freopen("swamp.out", "w", stdout); int n, m, st, ed, k; scanf("%d %d %d %d %d", &amp;n, &amp;m, &amp;st, &amp;ed, &amp;k); Matrix g; while (m--) { int u, v; scanf("%d %d", &amp;u, &amp;v); g(u, v)++; g(v, u)++; } Matrix gs[CYCLE_LCM]; for (int i = 0; i &lt; CYCLE_LCM; i++) gs[i] = g; scanf("%d", &amp;m); while (m--) { int cycle; scanf("%d", &amp;cycle); for (int i = 0; i &lt; cycle; i++) { int x; scanf("%d", &amp;x); for (int j = i; j &lt; CYCLE_LCM; j += cycle) { for (int l = 0; l &lt; n; l++) gs[j](x, l) = 0; } } } #ifdef DBG for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) printf("%d%c", g(i, j), j == n - 1 ? '\n' : ' '); puts("-------------"); for (int l = 0; l &lt; CYCLE_LCM; l++) { for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) printf("%d%c", gs[l](i, j), j == n - 1 ? '\n' : ' '); puts("-------------"); } #endif #ifndef FORCE Matrix prod(true); for (int i = 0; i &lt; CYCLE_LCM; i++) prod = prod * gs[i]; Matrix res = pow(prod, k / CYCLE_LCM); for (int i = 0; i &lt; k % CYCLE_LCM; i++) res = res * gs[i]; #else Matrix res(true); for (int i = 0; i &lt; k; i++) res = res * gs[i % CYCLE_LCM]; #endif printf("%d\n", res(st, ed)); #ifdef DBG for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) printf("%d%c", res(i, j), j == n - 1 ? '\n' : ' '); #endif fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>COGS</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2008」GT考试 - KMP + 矩阵乘法]]></title>
    <url>%2Fhnoi2008-gt%2F</url>
    <content type="text"><![CDATA[给一个长度为 的字符串 ，求长度为 且不包含 的字符串的数量。 连接 BZOJ 1009 题解 对 串进行 KMP 预处理，设状态 表示目标串的前 个字符，匹配到 串的第 个字符，的方案数。每次枚举下一个字符，刷表转移。 显然，每一阶段的结果都是与上一阶段结果呈线性的，可以使用矩阵快速幂优化，时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; const int MAXN = 1e9; const int MAXM = 20; const int MAXK = 1000; struct Matrix { int a[MAXM][MAXM]; Matrix(const bool unit = false) { memset(a, 0, sizeof(a)); if (unit) { for (int i = 0; i &lt; MAXM; i++) a[i][i] = 1; } } int &amp;operator()(const int i, const int j) { return a[i][j]; } const int &amp;operator()(const int i, const int j) const { return a[i][j]; } }; int mod; Matrix operator*(const Matrix &amp;a, const Matrix &amp;b) { Matrix res(false); for (int i = 0; i &lt; MAXM; i++) for (int j = 0; j &lt; MAXM; j++) for (int k = 0; k &lt; MAXM; k++) (res(i, j) += a(i, k) * b(k, j)) %= mod; return res; } Matrix pow(Matrix a, int n) { Matrix res(true); for (; n; n &gt;&gt;= 1, a = a * a) if (n &amp; 1) res = res * a; return res; } int main() { int n, m; char s[MAXM + 2]; scanf("%d %d %d\n%s", &amp;n, &amp;m, &amp;mod, s + 1); int fail[MAXM + 1]; fail[0] = fail[1] = 0; for (int i = 2; i &lt;= m; i++) { int k = fail[i - 1]; while (k &amp;&amp; s[k + 1] != s[i]) k = fail[k]; if (s[k + 1] == s[i]) fail[i] = k + 1; else fail[i] = 0; } // for (int i = 0; i &lt;= m; i++) printf("%d%c", fail[i], i == m ? '\n' : ' '); /* int f[50][MAXM + 1]; memset(f, 0, sizeof(f)); f[0][0] = 1; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { for (char c = '0'; c &lt;= '9'; c++) { int k = j; while (k &amp;&amp; s[k + 1] != c) k = fail[k]; if (s[k + 1] == c) k++; f[i + 1][k] += f[i][j]; } } } */ Matrix shift(false); for (int i = 0; i &lt; m; i++) { for (char c = '0'; c &lt;= '9'; c++) { int k = i; while (k &amp;&amp; s[k + 1] != c) k = fail[k]; if (s[k + 1] == c) k++; if (k &lt; m) shift(i, k)++; } } Matrix init(false); init(0, 0) = 1; Matrix res = init * pow(shift, n); int ans = 0; for (int i = 0; i &lt; m; i++) (ans += res(0, i)) %= mod; printf("%d\n", ans); // for (int i = 0; i &lt; MAXM; i++) for (int j = 0; j &lt; MAXM; j++) printf("%d%c", res(i, j), j == MAXM - 1 ? '\n' : ' '); /* for (int i = 0; i &lt;= n; i++) { for (int j = 0; j &lt;= m; j++) { printf("f[%d][%d] = %d\n", i, j, f[i][j]); } } */ return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
        <tag>矩阵乘法</tag>
        <tag>DP</tag>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>HNOI</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU 5906」Square Revolution - 后缀数组 + 并查集 + 树状数组]]></title>
    <url>%2Fhdu-5906%2F</url>
    <content type="text"><![CDATA[对于一个给定的字符串 ，有多少连续子串是 prefix-suffix-square free 的。 一个字符串被称为 square 当且仅当它可以由两个相同的串连接而成。例如，abab，aa 是 square，而 aaa，abba 不是。一个字符串是 prefix-suffix-square free 的当且仅当他的任何前缀或者后缀都不是 square。 链接 HDU 5906 题解 求出从每个位置开始、结束的最短 square，进而求出从第 个位置结束的子串，其开始位置的最小值。设从第 个位置开始的最短 square 为 ，从第 个位置结束的子串，其开始位置的最小值为 ，则答案为对于每个 ，在 内满足 的 的数量之和。 考虑如何求 square：类似「NOI2016 优秀的拆分」一题，枚举 ，枚举每个长度为 的区间，则所有长度为 的 square 都会跨越这个区间 ，从端点分别向前、后求最长公共后缀、前缀。进而可以求出若干个 square。如，从 内一点开始，均有一个长度为 的 square，此时用 更新 。 因为是从小到大枚举的 ，所以每个位置只会被赋值一次，使用并查集维护所有赋值过的点，赋值过的点合并，之后直接跳过这些区间即可。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 1e5; const int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812 struct SuffixArray { int n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1]; inline void build(const char *s, const int n) { this-&gt;n = n; static int set[MAXN], a[MAXN]; std::copy(s, s + n, set); std::sort(set, set + n); int *end = std::unique(set, set + n); for (int i = 0; i &lt; n; i++) a[i] = std::lower_bound(set, end, s[i]) - set; static int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[a[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) rk[i] = buc[a[i] - 1]; for (int t = 1; t &lt; n; t *= 2) { for (int i = 0; i &lt; n; i++) fir[i] = rk[i], sec[i] = i + t &lt; n ? rk[i + t] : -1; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[sec[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) tmp[n - buc[sec[i]]--] = i; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[fir[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i]; bool unique = true; for (int i = 0; i &lt; n; i++) { if (!i) rk[sa[i]] = 0; else if (fir[sa[i]] == fir[sa[i - 1]] &amp;&amp; sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false; else rk[sa[i]] = rk[sa[i - 1]] + 1; } if (unique) break; } for (int i = 0, k = 0; i &lt; n; i++) { if (!rk[i]) continue; int j = sa[rk[i] - 1]; if (k) k--; while (i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; a[i + k] == a[j + k]) k++; ht[rk[i]] = k; } #ifdef DBG for (int i = 0; i &lt; n; i++) printf("%d%c", sa[i], i == n - 1 ? '\n' : ' '); for (int i = 0; i &lt; n; i++) printf("%d%c", rk[i], i == n - 1 ? '\n' : ' '); for (int i = 0; i &lt; n; i++) printf("%d %s\n", ht[i], &amp;s[sa[i]]); #endif for (int i = 0; i &lt; n; i++) st[i][0] = ht[i]; for (int j = 1; (1 &lt;&lt; j) &lt; n; j++) { for (int i = 0; i &lt; n; i++) { if (i + (1 &lt;&lt; (j - 1)) &gt;= n) st[i][j] = st[i][j - 1]; else st[i][j] = std::min(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); } } for (int i = 0; i &lt;= n; i++) { int x = 0; while ((1 &lt;&lt; x) &lt;= i) x++; log[i] = x - 1; } } inline int rmq(const int l, const int r) { if (l == r) return st[l][0]; int t = log[r - l]; return std::min(st[l][t], st[r - (1 &lt;&lt; t) + 1][t]); } inline int lcp(const int i, const int j) { if (i == j) return n - i; int a = rk[i], b = rk[j]; if (a &gt; b) std::swap(a, b); return rmq(a + 1, b); } } sa1, sa2; int n, forward[MAXN], backward[MAXN]; inline int lcp(const int i, const int j) { return sa1.lcp(i, j); } inline int lcs(const int i, const int j) { return sa2.lcp(n - i - 1, n - j - 1); } inline void prepare(const int n) { /* struct SegmentTree { int l, r, mid; SegmentTree *lc, *rc; int val; SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), val(INT_MAX) {} ~SegmentTree() { if (lc) delete lc; if (rc) delete rc; } void update(const int l, const int r, const int x) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) this-&gt;val = std::min(this-&gt;val, x); else lc-&gt;update(l, r, x), rc-&gt;update(l, r, x); } int query(const int pos) { return (l == r) ? val : std::min(val, ((pos &lt;= mid) ? lc : rc)-&gt;query(pos)); } static SegmentTree *build(const int l, const int r) { if (l &gt; r) return NULL; else if (l == r) return new SegmentTree(l, r, NULL, NULL); else { const int mid = l + (r - l) / 2; return new SegmentTree(l, r, build(l, mid), build(mid + 1, r)); } } } *sForawrd = SegmentTree::build(0, n - 1), *sBackward = SegmentTree::build(0, n - 1); */ static struct UnionFindSet { int a[MAXN], n; void init(const int n) { this-&gt;n = n; for (int i = 0; i &lt; n; i++) a[i] = i; } int find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); } void merge(const int child, const int parent) { #ifdef DBG printf("merge: %d =&gt; %d\n", child, parent); #endif const int _child = find(child), _parent = find(parent); a[_child] = _parent; } void cover(const int l, const int r, const int x, int *val) { #ifdef DBG printf("cover(%d, %d, %d)\n", l, r, x); #endif for (int i = find(l); i &lt;= r; i = find(i + 1)) { val[i] = std::min(val[i], x); if (i != n - 1) merge(i, i + 1); else break; } } } sForawrd, sBackward; sForawrd.init(n); sBackward.init(n); for (int i = 0; i &lt; n; i++) forward[i] = backward[i] = INT_MAX; for (int len = 1; len &lt; n; len++) { for (int i = 0; i + len &lt; n; i += len) { const int j = i + len; const int a = std::min(lcs(i, j), len), b = std::min(lcp(i, j), len), s = a + b - 1; // const int a = lcs(i, j), b = lcp(i, j), s = a + b - 1; #ifdef DBG printf("s = %d, len = %d\n", s, len); #endif if (s &gt;= len) { #ifdef DBG printf("!FOUND! i = %d, j = %d, a = %d, b = %d, len = %d\n", i, j, a, b, len); #endif const int l = i - a + 1, r = j + b - 1; sForawrd.cover(l, l + (r - (l + len * 2 - 1)), len * 2, forward); sBackward.cover(l + len * 2 - 1, r, len * 2, backward); // sForawrd-&gt;update(l, l + (r - (l + len * 2 - 1)), len * 2); // sBackward-&gt;update(l + len * 2 - 1, r, len * 2); /* for (int i = l + len * 2 - 1; i &lt;= r; i++) { printf("[%d, %d]\n", i - len * 2 + 1, i); } */ } } } // for (int i = 0; i &lt; n; i++) forward[i] = sForawrd-&gt;query(i); // for (int i = 0; i &lt; n; i++) backward[i] = sBackward-&gt;query(i); #ifdef DBG puts("forward / backward"); for (int i = 0; i &lt; n; i++) printf("%d%c", forward[i] == INT_MAX ? 0 : forward[i], i == n - 1 ? '\n' : ' '); for (int i = 0; i &lt; n; i++) printf("%d%c", backward[i] == INT_MAX ? 0 : backward[i], i == n - 1 ? '\n' : ' '); #endif } /* struct ChairmanTree { struct SegmentTree { int l, r, mid; SegmentTree *lc, *rc; int cnt, refCnt; SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, const int cnt = 0) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), cnt(cnt), refCnt(0) {} ~SegmentTree() { if (lc &amp;&amp; lc-&gt;unRef()) delete lc; if (rc &amp;&amp; rc-&gt;unRef()) delete rc; } SegmentTree *ref() { refCnt++; return this; } bool unRef() { return !refCnt--; } int query(const int l, const int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return cnt; else return (lc ? lc-&gt;query(l, r) : 0) + (rc ? rc-&gt;query(l, r) : 0); } SegmentTree *insertSelf(const int x) { if (l == r) return this; if (x &lt;= mid) { this-&gt;lc = (new SegmentTree(l, mid, NULL, NULL, 1))-&gt;insertSelf(x); } else { this-&gt;rc = (new SegmentTree(mid + 1, r, NULL, NULL, 1))-&gt;insertSelf(x); } return this; } SegmentTree *insert(const int x) { if (x &lt;= mid) { return new SegmentTree(l, r, lc ? lc-&gt;insert(x) : (new SegmentTree(l, mid, NULL, NULL, 1))-&gt;insertSelf(x), rc ? rc-&gt;ref() : NULL, cnt + 1); } else { return new SegmentTree(l, r, lc ? lc-&gt;ref() : NULL, rc ? rc-&gt;insert(x) : (new SegmentTree(mid + 1, r, NULL, NULL, 1))-&gt;insertSelf(x), cnt + 1); } } int lcount() { return lc ? lc-&gt;cnt : 0; } } *root[MAXN + 1]; int n, l, r; void clear() { for (int i = n; i &gt;= 0; i--) { delete root[i]; } } // Build tree with array a, whose elements are limited in [l, r] void build(const int *a, const int n, const int l, const int r) { this-&gt;n = n, this-&gt;l = l, this-&gt;r = r; root[0] = new SegmentTree(0, n, NULL, NULL, 0); for (int i = 1; i &lt;= n; i++) { root[i] = root[i - 1]-&gt;insert(a[i - 1]); } } int query(const int l, const int r, const int x) { // Adjust input [0, n - 1] to [1, n] SegmentTree *vr = root[r + 1], *vl = root[l]; int ans = vr-&gt;query(this-&gt;l, x); if (vl) ans -= vl-&gt;query(this-&gt;l, x); return ans; / * while (min != max) { const int mid = mid + (max - min) / 2, t = vr-&gt;lcount() - (vl ? vl-&gt;lcount() : 0); if (t &lt; k) { k -= t, vr = vr-&gt;rc; if (vl) vl = vl-&gt;rc; } else { vr = vr-&gt;lc; if (vl) vl = vl-&gt;lc; } } return min; * / } } t; */ inline unsigned long long solve(const int *limit, const int *forward, const int n) { static struct Query { int type; int pos, val; bool operator&lt;(const Query &amp;other) const { if (pos &lt; other.pos) return true; else if (pos == other.pos &amp;&amp; !type &amp;&amp; other.type) return true; else return false; } } Q[MAXN * 3]; for (int i = 0; i &lt; n; i++) { Q[i].pos = i; Q[i].type = 0; Q[i].val = limit[i]; #ifdef DBG printf("add(pos = %d, val = %d)\n", Q[i].pos, Q[i].val); #endif } for (int i = 0; i &lt; n; i++) { Q[n + i].pos = i - 1; Q[n + i].val = i; Q[n + i].type = -1; #ifdef DBG printf("query(pos = %d, val = %d, type = %d)\n", Q[n + i].pos, Q[n + i].val, Q[n + i].type); #endif Q[n + i + n].pos = (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1); Q[n + i + n].val = i; Q[n + i + n].type = 1; #ifdef DBG printf("query(pos = %d, val = %d, type = %d)\n", Q[n + i + n].pos, Q[n + i + n].val, Q[n + i + n].type); #endif } std::sort(Q, Q + n * 3); static struct BinaryIndexedTree { int a[MAXN], n; static int lowbit(const int x) { return x &amp; -x; } void update(const int x, const int delta) { /* a[x - 1] += delta; */ for (int i = x; i &lt;= n; i += lowbit(i)) a[i - 1] += delta; } int query(const int x) { int ans = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) ans += a[i - 1]; /* for (int i = 1; i &lt;= x; i++) ans += a[i - 1]; */ return ans; } void clear(const int x) { /* a[x - 1] = 0; */ for (int i = x; i &lt;= n; i += lowbit(i)) { if (!a[i - 1]) break; a[i - 1] = 0; } } } bit; bit.n = n; unsigned long long ans = 0; for (int i = 0; i &lt; n * 3; i++) { #ifdef DBG printf("Query: %d %d %d\n", Q[i].type, Q[i].pos, Q[i].val); #endif if (Q[i].type) { int t = bit.query(Q[i].val + 1) * Q[i].type; ans += t; #ifdef DBG printf("t = %d\n", t); #endif } else bit.update(Q[i].val + 1, 1); /* #ifdef DBG printf("Query: %d %d %d\n", Q[i].l, Q[i].r, Q[i].val); #endif if (Q[i].l == -1) bit.update(Q[i].val + 1, 1); else ans += bit.query(Q[i].r + 1) - bit.query(Q[i].l); #ifdef DBG printf("ans = %d\n", ans); #endif */ } for (int i = 0; i &lt; n * 2; i++) if (!Q[i].type) bit.clear(Q[i].val + 1); return ans; } int main() { int testcase; scanf("%d", &amp;testcase); while (testcase--) { static char s[MAXN + 1]; scanf("%s", s); n = strlen(s); sa1.build(s, n); std::reverse(s, s + n); sa2.build(s, n); prepare(n); static int limit[MAXN]; for (int i = 0; i &lt; n; i++) limit[i] = backward[i] == INT_MAX ? 0 : (i - backward[i] + 2); #ifdef DBG for (int i = 0; i &lt; n; i++) printf("%d%c", limit[i], i == n - 1 ? '\n' : ' '); #endif // t.clear(); // t.build(limit, n, 0, n - 1); /* unsigned long long ans = 0; for (int i = 0; i &lt; n; i++) { ans += t.query(i, (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1), i); } */ unsigned long long ans = solve(limit, forward, n); printf("%llu\n", ans); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
        <tag>并查集</tag>
        <tag>HDU</tag>
        <tag>Bestcoder</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3796」Mushroom - 后缀数组 + AC 自动机]]></title>
    <url>%2Fbzoj-3796%2F</url>
    <content type="text"><![CDATA[给三个字符串 ，求一个长度最大的 ，满足： 是 的子串； 是 的子串； 不是 的子串； 链接 BZOJ 3796 题解 对 和 建立后缀数组，枚举 的每个后缀，该后缀与在后缀数组离它最近的 的某个后缀的最长公共前缀长度为在满足前两个条件下的最大答案。 对于条件 3，对 建立 AC 自动机，求出 在 中的每个匹配位置，设每个 位置的右边第一个匹配 的位置为 ，则在满足条件三的情况下，第 个后缀的最大答案为 。 将两个答案取较小值即可。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; const int MAXN = 100000; const int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812 const int CHARSET_SIZE = 12; const int BASE_CHAR = 'a'; struct Trie { struct Node { Node *c[CHARSET_SIZE], *fail; bool isWord; int depth; Node(const int isWord = false) : fail(NULL), isWord(isWord), depth(0) { for (int i = 0; i &lt; CHARSET_SIZE; i++) c[i] = NULL; } } *root; Trie() : root(NULL) {} void insert(const char *begin, const char *end) { Node **v = &amp;root; for (const char *p = begin; p != end; p++) { if (!*v) *v = new Node; v = &amp;(*v)-&gt;c[*p - BASE_CHAR]; } if (!*v) *v = new Node(true); else (*v)-&gt;isWord = true; } void build() { std::queue&lt;Node *&gt; q; root-&gt;fail = root; root-&gt;depth = 0; q.push(root); while (!q.empty()) { Node *v = q.front(); q.pop(); for (int i = 0; i &lt; CHARSET_SIZE; i++) { Node *&amp;c = v-&gt;c[i]; if (!c) { c = v-&gt;fail-&gt;c[i] ? v-&gt;fail-&gt;c[i] : root; continue; } c-&gt;depth = v-&gt;depth + 1; Node *u = v-&gt;fail; while (u != root &amp;&amp; !u-&gt;c[i]) u = u-&gt;fail; c-&gt;fail = v != root &amp;&amp; u-&gt;c[i] ? u-&gt;c[i] : root; q.push(c); } } } void exec(const char *begin, const char *end, bool *match) { Node *v = root; for (const char *p = begin; p != end; p++) { v = v-&gt;c[*p - BASE_CHAR]; if (v-&gt;isWord) match[p - begin - v-&gt;depth + 1] = true; } } } t; struct SuffixArray { int n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1]; template &lt;typename T&gt; void build(const T *s, const int n) { this-&gt;n = n; static int set[MAXN], a[MAXN]; std::copy(s, s + n, set); std::sort(set, set + n); int *end = std::unique(set, set + n); for (int i = 0; i &lt; n; i++) a[i] = std::lower_bound(set, end, s[i]) - set; static int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[a[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) rk[i] = buc[a[i] - 1]; for (int t = 1; t &lt; n; t *= 2) { for (int i = 0; i &lt; n; i++) fir[i] = rk[i], sec[i] = i + t &lt; n ? rk[i + t] : -1; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[sec[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) tmp[n - buc[sec[i]]--] = i; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[fir[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i]; for (int i = 0; i &lt; n; i++) { if (!i) rk[sa[i]] = 0; else if (fir[sa[i]] == fir[sa[i - 1]] &amp;&amp; sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]]; else rk[sa[i]] = rk[sa[i - 1]] + 1; } } for (int i = 0, k = 0; i &lt; n; i++) { if (!rk[i]) continue; int j = sa[rk[i] - 1]; if (k) k--; while (i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; s[i + k] == s[j + k]) k++; ht[rk[i]] = k; } #ifdef DBG printf("build: %s\n", s); for (int i = 0; i &lt; n; i++) printf("%d%c", sa[i], i == n - 1 ? '\n' : ' '); for (int i = 0; i &lt; n; i++) printf("%d%c", rk[i], i == n - 1 ? '\n' : ' '); for (int i = 0; i &lt; n; i++) printf("%d %s\n", ht[i], &amp;s[sa[i]]); #endif for (int i = 0; i &lt; n; i++) st[i][0] = ht[i]; for (int j = 1; (1 &lt;&lt; j) &lt; n; j++) { for (int i = 0; i &lt; n; i++) { if (i + (1 &lt;&lt; (j - 1)) &lt; n) st[i][j] = std::min(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); else st[i][j] = st[i][j - 1]; } } for (int i = 0; i &lt;= n; i++) { int x = 0; while ((1 &lt;&lt; x) &lt;= i) x++; log[i] = x - 1; } } int rmq(const int l, const int r) { if (l == r) return st[l][0]; else { const int t = log[r - l]; return std::min(st[l][t], st[r - (1 &lt;&lt; t) + 1][t]); } } int lcp(const int i, const int j) { if (i == j) return n - i; int a = rk[i], b = rk[j]; if (a &gt; b) std::swap(a, b); return rmq(a + 1, b); } } sa1, sa2; int main() { static char buf[MAXN]; scanf("%s", buf); const int n1 = strlen(buf); buf[n1] = ' ; scanf("%s", buf + n1 + 1); const int n2 = strlen(buf + n1 + 1); sa1.build(buf, n1 + 1 + n2); scanf("%s", buf + n1 + 1); const int n3 = strlen(buf + n1 + 1); // sa2.build(buf, n1 + 1 + n3); t.insert(buf + n1 + 1, buf + n1 + 1 + n3); t.build(); static bool match[MAXN]; t.exec(buf, buf + n1, match); static int nextMatch[MAXN]; for (int i = n1 - 1, x = INT_MAX; i &gt;= 0; i--) { if (match[i]) x = i; nextMatch[i] = x == INT_MAX ? INT_MAX : x - i + n3 - 1; } #ifdef DBG puts("KMP:"); buf[n1] = '\0'; for (int i = 0; i &lt; n1; i++) printf("%d %s\n", nextMatch[i], &amp;buf[i]); #endif static int l[MAXN], r[MAXN]; for (int i = 1, x = -1; i &lt; n1 + n2 + 1; i++) { if (sa1.sa[i] &lt; n1) l[i] = x; else if (sa1.sa[i] &gt; n1) x = i; } for (int i = n1 + n2 + 1 - 1, x = -1; i &gt;= 1; i--) { if (sa1.sa[i] &lt; n1) r[i] = x; else if (sa1.sa[i] &gt; n1) x = i; } #ifdef DBG for (int i = 1; i &lt; n1 + n2 + 1; i++) { if (sa1.sa[i] &lt; n1) printf("l[%d] = %d\n", i, l[i]); if (sa1.sa[i] &lt; n1) printf("r[%d] = %d\n", i, r[i]); } #endif int ans = 0; for (int i = 1; i &lt; n1 + n2 + 1; i++) { if (sa1.sa[i] &gt; n1) continue; int x; if (l[i] != -1) { x = sa1.lcp(sa1.sa[l[i]], sa1.sa[i]); x = std::min(x, nextMatch[sa1.sa[i]]); if (x) { ans = std::max(ans, x); #ifdef DBG printf("%d\n", x); #endif } } if (r[i] != -1) { x = sa1.lcp(sa1.sa[r[i]], sa1.sa[i]); x = std::min(x, nextMatch[sa1.sa[i]]); if (x) { ans = std::max(ans, x); #ifdef DBG printf("%d\n", x); #endif } } } printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>AC 自动机</tag>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3277」串 - 后缀数组 + 并查集 + 启发式合并]]></title>
    <url>%2Fbzoj-3277%2F</url>
    <content type="text"><![CDATA[给 个字符串，询问每个字符串有多少子串（不要求本质不同，不包括空串）是所有 个字符串中至少 个字符串的子串。 链接 BZOJ 3277 Codeforces 204E 题解 将所有串用在字符集之外的不同字符连接，对所得串建立后缀数组，考虑一个极大的两两间最长公共前缀（下文中省略） 的连通块。如果这个块内包含来自 个原串前缀，则这些后缀长度为 的前缀是满足题意的子串。 从大到小枚举 ，用并查集维护每个 的连通块，用 set 维护连通块内。每次合并相邻的连通块，统计长度为 的子串对答案的贡献。将 的子串留到下一次继续合并的时候统计。 但是会有一种情况，一个 的连通块附近没有 的连通块，则长度为 的子串不会被统计，并且长度为 的子串和长度为 的子串是相同的，一起统计即可。 对于 的情况，需要特判，输出每个字符串的子串数量。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;set&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; const int MAXN = 100000; const int MAXLEN = 100000 + MAXN; int s[MAXLEN]; int n, m, sa[MAXLEN], rk[MAXLEN], ht[MAXLEN], pos[MAXN], belong[MAXLEN]; inline void suffixArray() { static int set[MAXLEN], a[MAXLEN]; std::copy(s, s + n, set); std::sort(set, set + n); int *end = std::unique(set, set + n); for (int i = 0; i &lt; n; i++) a[i] = std::lower_bound(set, end, s[i]) - set; static int fir[MAXLEN], sec[MAXLEN], tmp[MAXLEN], _buc[MAXLEN + 1], *buc = _buc + 1; for (int i = 0; i &lt; n; i++) buc[a[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) rk[i] = buc[a[i] - 1]; for (int t = 1; t &lt; n; t *= 2) { for (int i = 0; i &lt; n; i++) fir[i] = rk[i], sec[i] = i + t &lt; n ? rk[i + t] : -1; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[sec[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) tmp[n - buc[sec[i]]--] = i; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[fir[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i]; bool unique = true; for (int i = 0; i &lt; n; i++) { if (!i) rk[sa[i]] = 0; else if (fir[sa[i]] == fir[sa[i - 1]] &amp;&amp; sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false; else rk[sa[i]] = rk[sa[i - 1]] + 1; } if (unique) break; } for (int i = 0, k = 0; i &lt; n; i++) { if (!rk[i]) continue; int j = sa[rk[i] - 1]; if (k) k--; while (i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; s[i + k] == s[j + k]) k++; ht[rk[i]] = k; } #ifdef DBG for (int i = 0; i &lt; n; i++) printf("%d%c", sa[i], i == n - 1 ? '\n' : ' '); for (int i = 0; i &lt; n; i++) printf("%d%c", rk[i], i == n - 1 ? '\n' : ' '); for (int i = 0; i &lt; n; i++) printf("%d%c", ht[i], i == n - 1 ? '\n' : ' '); #endif } struct UnionFindSet { int a[MAXLEN], l[MAXLEN], r[MAXLEN]; std::set&lt;int&gt; set[MAXLEN]; void init(const int n, const int *belong) { for (int i = 0; i &lt; n; i++) { a[i] = i; rk[i] = 1; l[i] = r[i] = i; set[i].insert(belong[i]); } } int find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); } int merge(const int x, const int y) { #ifdef DBG printf("merge(%d, %d)\n", x, y); #endif int _x = find(x), _y = find(y); if (set[_x].size() &lt; set[_y].size()) std::swap(_x, _y); a[_y] = _x; set[_x].insert(set[_y].begin(), set[_y].end()); l[_x] = std::min(l[_x], l[_y]); r[_x] = std::max(r[_x], r[_y]); return _x; } int uniqueCount(const int x) { return set[x].size(); } void getRange(const int x, int &amp;l, int &amp;r) { l = this-&gt;l[x]; r = this-&gt;r[x]; } } ufs; long long gap[MAXLEN + 1]; inline void apply(const int id, const int val = 1) { int l, r; ufs.getRange(id, l, r); gap[l] += val, gap[r + 1] -= val; #ifdef DBG for (int i = l; i &lt;= r; i++) printf("ans[%d] += %d\n", belong[i], val); #endif } int main() { int k; scanf("%d %d", &amp;m, &amp;k); int *p = s; int spliter = 233; for (int i = 0; i &lt; m; i++) { #ifdef DBG printf("%d\n", i); #endif pos[i] = p - s; static char buf[MAXLEN]; scanf("%s", buf); int len = strlen(buf); if (k == 1) { std::cout &lt;&lt; (static_cast&lt;long long&gt;(len) * (len + 1) / 2) &lt;&lt; (i == m - 1 ? '\n' : ' '); } for (int i = 0; i &lt; len; i++) *p++ = buf[i]; *p++ = spliter++; } if (k == 1) return 0; *--p = '\0'; n = p - s; suffixArray(); for (int i = 0; i &lt; n; i++) belong[i] = std::upper_bound(pos, pos + m, sa[i]) - pos - 1; ufs.init(n, belong); #ifdef DBG for (int i = 0; i &lt; n; i++) { printf("%d %d %s\n", belong[i], ht[i], &amp;s[sa[i]]); } #endif std::vector&lt;int&gt; v[MAXLEN]; int maxH = 0; for (int i = 0; i &lt; n; i++) v[ht[i]].push_back(i), maxH = std::max(maxH, ht[i]); for (int i = maxH; i &gt; 0; i--) { #ifdef DBG printf("Now processing h = %d\n", i); #endif std::vector&lt;int&gt; vec; for (std::vector&lt;int&gt;::const_iterator it = v[i].begin(); it != v[i].end(); it++) { int id = ufs.merge(*it, *it - 1); if (ufs.uniqueCount(id) &gt;= k) { // apply(id); vec.push_back(id); } } for (std::vector&lt;int&gt;::iterator it = vec.begin(); it != vec.end(); it++) *it = ufs.find(*it); std::sort(vec.begin(), vec.end()); std::vector&lt;int&gt;::const_iterator end = std::unique(vec.begin(), vec.end()); for (std::vector&lt;int&gt;::const_iterator it = vec.begin(); it != end; it++) { int l, r; ufs.getRange(*it, l, r); int x = ht[l]; if (r != n - 1) x = std::max(x, ht[r + 1]); apply(*it, i - x); } } static long long ans[MAXN]; for (int i = 1; i &lt; n; i++) gap[i] += gap[i - 1]; for (int i = 0; i &lt; n; i++) ans[belong[i]] += gap[i]; // for (int i = 0; i &lt; m; i++) printf("%lld%c", ans[i], i == m - 1 ? '\n' : ' '); for (int i = 0; i &lt; m; i++) { std::cout &lt;&lt; ans[i]; // &lt;&lt; (i == m - 1 ? '\0' : ' '); if (i != m - 1) std::cout &lt;&lt; ' '; } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>后缀数组</tag>
        <tag>Codeforces</tag>
        <tag>启发式合并</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3230」相似子串 - 后缀数组]]></title>
    <url>%2Fbzoj-3230%2F</url>
    <content type="text"><![CDATA[对于一个长度为 的字符串 ，将其本质不同的所有子串按照字典序排序。我们定义两个子串的相似程度为 的最大值，其中 、 满足：，，，。 每次询问排序后的第 个和第 个子串的相似程度。 链接 BZOJ 3230 题解 一个长度为 的串，它的本质不同的子串数量是 级别的，所以不能直接对子串排序。 考虑到每个子串都是一个后缀的前缀，对所有后缀排序，相邻两个后缀的最长公共前缀即为重复的子串。设第 个与第 个后缀的最长公共前缀为 ，则由第 个后缀的前缀构成的子串中与前 个后缀的前缀构成的子串的不同的有 个，这其中长度最小的为 ，长度最大的为该后缀本身，这些子串的字典序即为它们长度顺序。 使用后缀数组求出相邻两个后缀的最长公共前缀，求出每个后缀对子串个数的贡献，通过二分即可定位产生第 个子串的后缀，进而求出这个子串在原串中的位置。 和 使用后缀数组求最长公共前缀、后缀解决即可。 代码 #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; const int MAXN = 100000; const int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812; char s[MAXN], sRev[MAXN]; int n, log[MAXN + 1]; long long cnt[MAXN]; struct SuffixArray { int n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1]; void build(const char *s, const int n) { this-&gt;n = n; static int set[MAXN], a[MAXN]; std::copy(s, s + n, set); std::sort(set, set + n); int *end = std::unique(set, set + n); for (int i = 0; i &lt; n; i++) a[i] = std::lower_bound(set, end, s[i]) - set; static int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[a[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) rk[i] = buc[a[i] - 1]; for (int t = 1; t &lt; n; t *= 2) { for (int i = 0; i &lt; n; i++) fir[i] = rk[i], sec[i] = i + t &lt; n ? rk[i + t] : -1; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[sec[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) tmp[n - buc[sec[i]]--] = i; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[fir[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i]; bool unique = true; for (int i = 0; i &lt; n; i++) { if (!i) rk[sa[i]] = 0; else if (fir[sa[i]] == fir[sa[i - 1]] &amp;&amp; sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false; else rk[sa[i]] = rk[sa[i - 1]] + 1; } if (unique) break; } for (int i = 0, k = 0; i &lt; n; i++) { if (!rk[i]) continue; int j = sa[rk[i] - 1]; if (k) k--; while (i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; s[i + k] == s[j + k]) k++; ht[rk[i]] = k; } /* for (int i = 0; i &lt; n; i++) printf("%d%c", sa[i], i == n - 1 ? '\n' : ' '); for (int i = 0; i &lt; n; i++) printf("%d%c", rk[i], i == n - 1 ? '\n' : ' '); for (int i = 0; i &lt; n; i++) printf("%d%c", ht[i], i == n - 1 ? '\n' : ' '); for (int i = 0; i &lt; n; i++) printf("%d %s\n", ht[i], &amp;s[sa[i]]); // */ for (int i = 0; i &lt; n; i++) st[i][0] = ht[i]; for (int j = 1; (1 &lt;&lt; j) &lt; n; j++) { for (int i = 0; i &lt; n; i++) { if (i + (1 &lt;&lt; (j - 1)) &gt;= n) st[i][j] = st[i][j - 1]; else st[i][j] = std::min(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); } } } int query(const int l, const int r) { #ifdef TEST assert(l &lt;= r); #endif if (l == r) return st[l][0]; int t = log[r - l]; int res = std::min(st[l][t], st[r - (1 &lt;&lt; t) + 1][t]); #ifdef TEST int ans = n; for (int k = l; k &lt;= r; k++) ans = std::min(ans, ht[k]); assert(res == ans); #endif return res; } int lcp(const int i, const int j) { if (i == j) return n - i; int a = rk[i], b = rk[j]; if (a &gt; b) std::swap(a, b); return query(a + 1, b); } } sa, saRev; inline int lcp(const int i, const int j) { int res = sa.lcp(i, j); #ifdef TEST int ans; for (ans = 0; i + ans &lt; n &amp;&amp; j + ans &lt; n &amp;&amp; s[i + ans] == s[j + ans]; ans++); assert(res == ans); #endif return res; } inline int lcs(const int i, const int j) { int res = saRev.lcp(n - i - 1, n - j - 1); #ifdef TEST int ans; for (ans = 0; i - ans &gt;= 0 &amp;&amp; j - ans &gt;= 0 &amp;&amp; s[i - ans] == s[j - ans]; ans++); assert(res == ans); #endif return res; } inline void prepare() { for (int i = 0; i &lt;= n; i++) { int x = 0; while ((1 &lt;&lt; x) &lt;= i) x++; log[i] = x - 1; // printf("log(%d) = %d\n", i, log[i]); } sa.build(s, n); long long x = 0; for (int i = 0; i &lt; n; i++) { x += n - sa.sa[i]; if (i) x -= sa.ht[i]; cnt[i] = x; // printf("%lld\n", x); } std::copy(s, s + n, sRev); std::reverse(sRev, sRev + n); saRev.build(sRev, n); } inline bool locate(const long long k, int &amp;l, int &amp;r) { long long *p = std::upper_bound(cnt, cnt + n, k - 1); if (p == cnt + n) return false; int t = *p - k; l = sa.sa[p - cnt]; r = n - t - 1; return true; } inline void all() { std::vector&lt;std::string&gt; v; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt;= n; j++) v.push_back(std::string(&amp;s[i], &amp;s[j])); std::sort(v.begin(), v.end()); v.erase(std::unique(v.begin(), v.end()), v.end()); int i = 1; for (std::vector&lt;std::string&gt;::const_iterator it = v.begin(); it != v.end(); it++) { int l, r; locate(i++, l, r); // printf("%d %d\n", l, r); for (int j = l; j &lt;= r; j++) putchar(s[j]); putchar('\n'); printf("%s\n", it-&gt;c_str()); } } int main() { int q; scanf("%d %d\n%s", &amp;n, &amp;q, s); n = strlen(s); prepare(); // all(); /* puts("left query:"); for (int i = 0; i &lt; n; i++) for (int j = i; j &lt; n; j++) printf("lq(%d, %d) = %d\n", i, j, query(stp, i, j)); puts("right query:"); for (int i = 0; i &lt; n; i++) for (int j = i; j &lt; n; j++) printf("rq(%d, %d) = %d\n", i, j, query(sts, i, j)); */ /* for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) printf("lcp(%d, %d) = %d\n", i, j, lcp(i, j)); putchar('\n'); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) printf("lcs(%d, %d) = %d\n", i, j, lcs(i, j)); */ while (q--) { long long i, j; scanf("%lld %lld", &amp;i, &amp;j); int l1, r1, l2, r2; if (!locate(i, l1, r1) || !locate(j, l2, r2)) { puts("-1"); continue; } int lim = std::min(r1 - l1 + 1, r2 - l2 + 1); long long a = std::min(lim, lcp(l1, l2)), b = std::min(lim, lcs(r1, r2)); printf("%lld\n", a * a + b * b); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1692」队列变换 - 后缀数组 + 贪心]]></title>
    <url>%2Fbzoj-1692%2F</url>
    <content type="text"><![CDATA[对于一个字符串 ，每次从它的首部或尾部弹出一个字符，加入到 的尾部，求可以构造出的字典序最小的 。 链接 BZOJ 1692 题解 贪心，如果没有重复字符，则每次从两边选一个字典序较小的字符即可。 因为有重复字符，所以可以继续比较，直到找到某一边一个字典序较小的字符即可，这个过程使用后缀数组优化。 注意输出 80 个字符后换行。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 30000 * 2 + 1; int n, sa[MAXN], rk[MAXN]; char s[MAXN]; inline void suffixArray() { static int set[MAXN], a[MAXN]; std::copy(s, s + n, set); std::sort(set, set + n); int *end = std::unique(set, set + n); for (int i = 0; i &lt; n; i++) a[i] = std::lower_bound(set, end, s[i]) - set; static int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1; for (int i = 0; i &lt; n; i++) buc[a[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) rk[i] = buc[a[i] - 1]; for (int t = 1; t &lt; n; t *= 2) { for (int i = 0; i &lt; n; i++) fir[i] = rk[i], sec[i] = i + t &lt; n ? rk[i + t] : -1; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[sec[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) tmp[n - buc[sec[i]]--] = i; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[fir[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i]; for (int i = 0; i &lt; n; i++) { if (!i) rk[sa[i]] = 0; else if (fir[sa[i]] == fir[sa[i - 1]] &amp;&amp; sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]]; else rk[sa[i]] = rk[sa[i - 1]] + 1; } } // for (int i = 0; i &lt; n; i++) printf("%d%c", sa[i], i == n - 1 ? '\n' : ' '); // for (int i = 0; i &lt; n; i++) printf("%d%c", rk[i], i == n - 1 ? '\n' : ' '); // for (int i = 0; i &lt; n; i++) printf("%s\n", &amp;s[sa[i]]); } int main() { // scanf("%s", s); // n = strlen(s); scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) { scanf("%s", &amp;s[i]); } std::copy(s, s + n, s + n + 1); std::reverse(s + n + 1, s + n + 1 + n); s[n] = ' ; n = n * 2 + 1; s[n] = '\0'; suffixArray(); n /= 2; for (int i = 0, l = 0, r = 0; i &lt; n; i++) { if (l &lt; n &amp;&amp; rk[l] &lt; rk[n + 1 + r]) putchar(s[l++]); else putchar(s[n - 1 - r++]); if ((i + 1) % 80 == 0) putchar('\n'); } // putchar('\n'); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>后缀数组</tag>
        <tag>USACO</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2012」喵星球上的点名 - AC 自动机]]></title>
    <url>%2Fscoi2012-name%2F</url>
    <content type="text"><![CDATA[假设课堂上有 个喵星人，每个喵星人的名字由姓和名构成。喵星球上的老师会选择 个串来点名，每次读出一个串的时候，如果这个串是一个喵星人的姓或名的子串，那么这个喵星人就必须答到。 统计每次点名的时候有多少喵星人答到，以及 次点名结束后每个喵星人答到多少次。 链接 BZOJ 2754 题解 对点名串建立 AC 自动机，用姓名串暴力跑后缀链接即可。 代码 #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; const int MAXN = 20000; const int MAXM = 50000; const int MAXLEN = 100000; struct Trie { struct Node { std::map&lt;int, Node *&gt; c; Node *fail, *next; int wordCnt, ts, ans; Node(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {} } *root; Trie() : root(NULL) {} Node *insert(const int *begin, const int *end) { #ifdef DBG puts("insert: "); for (const int *p = begin; p != end; p++) printf("%d%c", *p, p == end - 1 ? '\n' : ' '); #endif Node **v = &amp;root; for (const int *p = begin; p != end; p++) { if (!*v) *v = new Node; v = &amp;(*v)-&gt;c[*p]; } if (!*v) *v = new Node(1); else /*assert((*v)-&gt;isWord == false), */(*v)-&gt;wordCnt++; return *v; } void build() { std::queue&lt;Node *&gt; q; q.push(root); root-&gt;fail = root, root-&gt;next = NULL; while (!q.empty()) { Node *v = q.front(); q.pop(); for (std::map&lt;int, Node *&gt;::iterator it = v-&gt;c.begin(); it != v-&gt;c.end(); it++) { Node *&amp;c = it-&gt;second, *u = v-&gt;fail; while (u != root &amp;&amp; u-&gt;c.find(it-&gt;first) == u-&gt;c.end()) u = u-&gt;fail; c-&gt;fail = v != root &amp;&amp; u-&gt;c.find(it-&gt;first) != u-&gt;c.end() ? u-&gt;c[it-&gt;first] : root; c-&gt;next = c-&gt;fail-&gt;wordCnt ? c-&gt;fail : c-&gt;fail-&gt;next; q.push(c); } } } int exec(const int *begin, const int *end) { #ifdef DBG puts("exec: "); for (const int *p = begin; p != end; p++) printf("%d%c", *p, p == end - 1 ? '\n' : ' '); #endif static int ts = 0; ++ts; Node *v = root; int ans = 0; static int sumAns = 0; for (const int *p = begin; p != end; p++) { while (v != root &amp;&amp; v-&gt;c.find(*p) == v-&gt;c.end()) v = v-&gt;fail; std::map&lt;int, Node *&gt;::iterator it; if ((it = v-&gt;c.find(*p)) != v-&gt;c.end()) v = it-&gt;second; // if (it != v-&gt;c.end()) v = it-&gt;second; Node *u = v-&gt;wordCnt ? v : v-&gt;next; while (u) { #ifdef DBG printf("apply(%lu)\n", u); #endif if (u-&gt;ts != ts) { u-&gt;ts = ts; u-&gt;ans++; ans += u-&gt;wordCnt; sumAns++; // printf("- %d %d\n", u-&gt;ans, ans); u = u-&gt;next; } else break; } } // printf("sumAns = %d\n", sumAns); return ans; } } t; int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); static int buf[MAXN * 2 + MAXLEN], set[MAXLEN]; int cnt = 0; for (int i = 0, tot = 0; i &lt; n; i++) { for (int j = 0; j &lt; 2; j++) { int l; scanf("%d", &amp;l); #ifdef DBG printf("--- %d ---\n", l); #endif buf[tot++] = l; for (int k = 0; k &lt; l; k++) { int x; scanf("%d", &amp;x); buf[tot++] = set[cnt++] = x; } } } std::sort(set, set + cnt); int *end = std::unique(set, set + cnt); static Trie::Node *a[MAXM]; for (int i = 0; i &lt; m; i++) { int l; scanf("%d", &amp;l); static int buf[MAXLEN]; bool invalid = false; for (int j = 0; j &lt; l; j++) { int x; scanf("%d", &amp;x); /* if (i == 1354 - 1) { printf("(%d)\n", x); } */ int *p = std::lower_bound(set, end, x); if (p == end || *p != x) { invalid = true; } buf[j] = p - set; } if (!invalid) a[i] = t.insert(buf, buf + l); else a[i] = NULL; /* if (i == 1354 - 1) { printf("1354: "); for (int i = 0; i &lt; l; i++) printf("%d%c", buf[i], i == l - 1 ? '\n' : ' '); } */ } t.build(); static int ans[MAXN]; for (int i = 0, pos = 0; i &lt; n; i++) { static int buf2[MAXLEN + 1]; int cnt = 0; for (int j = 0; j &lt; 2; j++) { if (j == 1) buf2[cnt++] = -1; int l = buf[pos++]; // printf("- "); for (int k = 0; k &lt; l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf("%d ", buf2[cnt - 1]); // putchar('\n'); } ans[i] = t.exec(buf2, buf2 + cnt); } int sum1 = 0, sum2 = 0; for (int i = 0; i &lt; m; i++) { sum1 += a[i] ? a[i]-&gt;ans : 0; // if (i == 1354 - 1) putchar('*'); printf("%d\n", a[i] ? a[i]-&gt;ans : 0); } for (int i = 0; i &lt; n; i++) { sum2 += ans[i]; printf("%d%c", ans[i], i == n - 1 ? '\n' : ' '); } // printf("%d %d\n", sum1, sum2); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>AC 自动机</tag>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2013」差异 - 后缀数组]]></title>
    <url>%2Fahoi2013-diff%2F</url>
    <content type="text"><![CDATA[一个长度为 的字符串，令 表示它从第 个字符开始的后缀，求 链接 BZOJ 3238 题解 通过打表找规律可得 剩下的一部分为 每两两间的 LCP 都被计算了一次。 它相当于 数组中每个区间的最小值。我们考虑一个数 在哪些区间里会成为最小值。 使用单调栈求出每个数 左边第一个大于等于（方便处理相等的数）它的数的位置，右边第一个大于它的数的位置，中间的所有区间内， 均为最小值。 设 左边到第一个大于等于它的数之前共有 个数（不含 和大于等于它的数），右边到第一个大于它的数之前共有 个数，则 对答案的贡献为 求和即可 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; const int MAXN = 500000; int n, sa[MAXN], rk[MAXN], ht[MAXN]; unsigned long long l[MAXN], r[MAXN]; char s[MAXN]; inline void suffixArray() { static int set[MAXN], a[MAXN]; for (int i = 0; i &lt; n; i++) set[i] = s[i]; std::sort(set, set + n); int *end = std::unique(set, set + n); for (int i = 0; i &lt; n; i++) a[i] = std::lower_bound(set, end, s[i]) - set; static int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1; for (int i = 0; i &lt; n; i++) buc[a[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) rk[i] = buc[a[i] - 1]; for (int t = 1; t &lt; n; t *= 2) { for (int i = 0; i &lt; n; i++) fir[i] = rk[i]; for (int i = 0; i &lt; n; i++) sec[i] = i + t &gt;= n ? -1 : rk[i + t]; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[sec[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) tmp[n - buc[sec[i]]--] = i; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[fir[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i]; for (int i = 0; i &lt; n; i++) { if (!i) rk[sa[i]] = 0; else if (fir[sa[i]] == fir[sa[i - 1]] &amp;&amp; sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]]; else rk[sa[i]] = rk[sa[i - 1]] + 1; } } // for (int i = 0; i &lt; n; i++) printf("%d%c", sa[i], i == n - 1 ? '\n' : ' '); // for (int i = 0; i &lt; n; i++) printf("%d%c", rk[i], i == n - 1 ? '\n' : ' '); for (int i = 0, k = 0; i &lt; n; i++) { int j = sa[rk[i] - 1]; if (k) k--; while (i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; a[i + k] == a[j + k]) k++; ht[rk[i]] = k; } // for (int i = 0; i &lt; n; i++) printf("%s\n", &amp;s[sa[i]]); // for (int i = 0; i &lt; n; i++) printf("%d%c", ht[i], i == n - 1 ? '\n' : ' '); } /* inline int lcp(const int i, const int j) { / * int a = rk[i], b = rk[j], ans = n; if (a &gt; b) std::swap(a, b); for (int i = a + 1; i &lt;= b; i++) ans = std::min(ans, ht[i]); // printf("- %d %d =&gt; %d\n", a + 1, b, ans); return ans; * / int ans = 0; while (s[i + ans] == s[j + ans] &amp;&amp; i + ans &lt; n &amp;&amp; j + ans &lt; n) ans++; return ans; } */ inline void prepare() { std::stack&lt;int&gt; s; for (int i = 1; i &lt; n; i++) { while (!s.empty() &amp;&amp; ht[s.top()] &gt; ht[i]) s.pop(); l[i] = s.empty() ? i - 1 : i - s.top() - 1; s.push(i); } while (!s.empty()) s.pop(); for (int i = n - 1; i &gt;= 1; i--) { while (!s.empty() &amp;&amp; ht[s.top()] &gt;= ht[i]) s.pop(); r[i] = s.empty() ? n - i - 1 : s.top() - i - 1; s.push(i); } } int main() { scanf("%s", s); n = strlen(s); suffixArray(); unsigned long long sumLcp = 0; /* for (int i = 1; i &lt; n; i++) for (int j = i; j &lt; n; j++) { int min = n; for (int k = i; k &lt;= j; k++) min = std::min(min, ht[k]); sumLcp += min; } */ /* for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { sumLcp += lcp(i, j); } } */ prepare(); // /* for (int i = 1; i &lt; n; i++) { // printf("%d: %d %d\n", i, l[i], r[i]); sumLcp += static_cast&lt;unsigned long long&gt;(l[i] + 2) * (r[i] + 1) * ht[i]; } // */ unsigned long long sum = 0; for (int i = 2; i &lt;= n; i++) { unsigned long long t = static_cast&lt;unsigned long long&gt;(1 + (i - 1)) * (i - 1) / 2 + static_cast&lt;unsigned long long&gt;(i) * (i - 1); // printf("- %lld\n", t); sum += t; // printf("sum = %llu\n", sum); } /* for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { // printf("- %d %d\n", n - i, n - j); sum += n - i + n - j; } } */ printf("%llu\n", sum - 2 * sumLcp); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>AHOI</tag>
        <tag>BZOJ</tag>
        <tag>单调栈</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2007」字符加密 - 后缀数组]]></title>
    <url>%2Fjsoi2007-cipher%2F</url>
    <content type="text"><![CDATA[把一个字符串 排成一圈，从每个字符开始读一圈，把每次读到的字符串排序，按顺序将每个串的最后一个字符排成一个新字符串，求新字符串。 链接 BZOJ 1031 题解 将串翻倍，建立后缀数组，得到循环意义下每个串的排序，找到每个串的最后一个字符输出即可。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 1e5 * 2; char s[MAXN]; int n, sa[MAXN], rk[MAXN], ht[MAXN]; inline void print(const int *a) { for (int i = 0; i &lt; n; i++) printf("%d%c", a[i], i == n - 1 ? '\n' : ' '); } inline void suffixArray() { static int set[MAXN], a[MAXN]; for (int i = 0; i &lt; n; i++) set[i] = s[i]; std::sort(set, set + n); int *end = std::unique(set, set + n); for (int i = 0; i &lt; n; i++) a[i] = std::lower_bound(set, end, s[i]) - set; static int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1; for (int i = 0; i &lt; n; i++) buc[a[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) rk[i] = buc[a[i] - 1]; for (int t = 1; t &lt; n; t *= 2) { for (int i = 0; i &lt; n; i++) fir[i] = rk[i], sec[i] = i + t &gt;= n ? -1 : rk[i + t]; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[sec[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; // print(fir); // print(sec); for (int i = 0; i &lt; n; i++) tmp[n - buc[sec[i]]--] = i; // print(tmp); std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[fir[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; // print(buc); for (int i = 0; i &lt; n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i]; // print(sa); for (int i = 0; i &lt; n; i++) { if (!i) rk[sa[i]] = 0; else if (fir[sa[i]] == fir[sa[i - 1]] &amp;&amp; sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]]; else rk[sa[i]] = rk[sa[i - 1]] + 1; } // print(rk); // return; } // puts("----------------"); // print(sa); // print(rk); // for (int i = 0; i &lt; n; i++) printf("%s\n", s + sa[i]); /* for (int i = 0, j, k = 0; i &lt; n; i++) { if (!rk[i]) continue; j = sa[rk[i] - 1]; if (k) k--; // k = 0; while (i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; s[i + k] == s[j + k]) k++; ht[rk[i]] = k; } */ // print(ht); } int main() { scanf("%s", s); n = strlen(s); for (int i = 0; i &lt; n; i++) s[i + n] = s[i]; n *= 2; suffixArray(); // for (int i = 0; i &lt; n; i++) printf("%d%c", sa[i] + 1, i == n - 1 ? '\n' : ' '); // for (int i = 1; i &lt; n; i++) printf("%d%c", ht[i], i == n - 1 ? '\n' : ' '); for (int i = 0; i &lt; n; i++) { if (sa[i] &lt; n / 2) { putchar(s[sa[i] + n / 2 - 1]); } } putchar('\n'); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>后缀数组</tag>
        <tag>JSOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 716E」Digit Tree - 点分治]]></title>
    <url>%2Fcf-716e%2F</url>
    <content type="text"><![CDATA[给一棵树，每一条边上有一个 内的数字，求有多少有序点对 满足，将 到 的最短路上所有边上的数字连接成一个数，这个数是 的倍数。其中 。 链接 Codeforces 716E 题解 点分治，考虑一棵子树内满足条件的点对。 记录 为从根到 节点路径上所有边上的数字按倒序连接成的数； 为对应按正序连接成的数； 为节点 的深度，等于 和 十进制位数。如 从 到 的路径组成的数可以表示为 题目要求的条件即为 因为这是一个同余式，所以 和 可以是模意义下的。 整理，得 将式子右边存入哈希表中，对于每个节点 ，对答案的贡献即为哈希表中 出现的次数。 代码 #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;map&gt; #include &lt;iostream&gt; const int MAXN = 100000; struct Node { struct Edge *e; Node *parent; int size, depth, max; bool visited, solved; long long backward, forward; } N[MAXN]; struct Edge { Node *s, *t; int w; Edge *next; Edge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t, const int w) { N[s].e = new Edge(&amp;N[s], &amp;N[t], w); N[t].e = new Edge(&amp;N[t], &amp;N[s], w); } int n, mod; long long pow10[MAXN + 1], pow10Inv[MAXN + 1]; void exgcd(const long long a, const long long b, long long &amp;g, long long &amp;x, long long &amp;y) { if (!b) g = a, x = 1, y = 0; else exgcd(b, a % b, g, y, x), y -= x * (a / b); } inline long long inv(const long long x) { long long tmp1, res, tmp2; exgcd(x, mod, tmp1, res, tmp2); return (res % mod + mod) % mod; } inline Node *center(Node *start) { std::stack&lt;Node *&gt; s; s.push(start); start-&gt;visited = false; start-&gt;parent = NULL; static Node *a[MAXN]; int cnt = 0; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { a[cnt++] = v; v-&gt;visited = true; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved &amp;&amp; e-&gt;t != v-&gt;parent) { e-&gt;t-&gt;visited = false; e-&gt;t-&gt;parent = v; s.push(e-&gt;t); } } else { v-&gt;size = 1; v-&gt;max = 0; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved &amp;&amp; e-&gt;t-&gt;parent == v) { v-&gt;size += e-&gt;t-&gt;size; v-&gt;max = std::max(v-&gt;max, e-&gt;t-&gt;size); } s.pop(); } } Node *res = NULL; for (int i = 0; i &lt; cnt; i++) { a[i]-&gt;max = std::max(a[i]-&gt;max, cnt - a[i]-&gt;size); if (!res || res-&gt;max &gt; a[i]-&gt;max) res = a[i]; } return res; } inline long long calc(Node *root, const int pre = 0) { if (pre != 0) { root-&gt;forward = root-&gt;backward = pre; root-&gt;depth = 1; } else { root-&gt;forward = root-&gt;backward = 0; root-&gt;depth = 0; } root-&gt;parent = NULL; std::queue&lt;Node *&gt; q; q.push(root); std::map&lt;long long, int&gt; map; static Node *a[MAXN]; int cnt = 0; while (!q.empty()) { Node *v = q.front(); q.pop(); map[(mod - v-&gt;forward) * pow10Inv[v-&gt;depth] % mod]++; assert((mod - v-&gt;forward) * pow10Inv[v-&gt;depth] % mod &gt;= 0); a[cnt++] = v; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved &amp;&amp; e-&gt;t != v-&gt;parent) { e-&gt;t-&gt;forward = (v-&gt;forward * 10 + e-&gt;w) % mod; e-&gt;t-&gt;backward = (e-&gt;w * pow10[v-&gt;depth] + v-&gt;backward) % mod; #ifdef DBG printf("%lld &lt;--&gt; %lld\n", e-&gt;t-&gt;forward, e-&gt;t-&gt;backward); #endif e-&gt;t-&gt;parent = v; e-&gt;t-&gt;depth = v-&gt;depth + 1; q.push(e-&gt;t); } } long long ans = 0; // pre ? 0 : -1 * 0; #ifdef FORCE for (int i = 0; i &lt; cnt; i++) { for (int j = 0; j &lt; cnt; j++) { if ((a[i]-&gt;backward * pow10[a[j]-&gt;depth] + a[j]-&gt;forward) % 3 == 0 /*&amp;&amp; !(a[i]-&gt;backward == 0 &amp;&amp; a[j]-&gt;forward == 0)*/) { ans++; #ifdef DBG printf("%lld\n", a[i]-&gt;backward * pow10[a[j]-&gt;depth] + a[j]-&gt;forward); #endif } if (a[i]-&gt;backward == 0 &amp;&amp; a[j]-&gt;forward == 0) printf("%lu %lu in %lu, %d\n", a[i] - N + 1, a[j] - N + 1, root - N + 1, pre), ans--; } } #else map[0]--; for (int i = 0; i &lt; cnt; i++) { ans += map[a[i]-&gt;backward]; #ifdef DBG printf("back = %lld, ans + %d\n", a[i]-&gt;backward, map[a[i]-&gt;backward]); #endif } #endif #ifdef DBG for (std::map&lt;long long, int&gt;::const_iterator it = map.begin(); it != map.end(); it++) printf("[%lld =&gt; %d]\n", it-&gt;first, it-&gt;second); printf("** ans = %lld\n", ans); #endif return ans; } inline long long solve() { std::queue&lt;Node *&gt; q; q.push(&amp;N[0]); long long ans = 0; while (!q.empty()) { Node *v = q.front(); q.pop(); Node *root = center(v); root-&gt;solved = true; #ifdef DBG puts("+++++++++++++++++++"); #endif ans += calc(root); for (Edge *e = root-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved) { #ifdef DBG puts("-------------------"); #endif ans -= calc(e-&gt;t, e-&gt;w); q.push(e-&gt;t); } } return ans; } int main() { scanf("%d %d", &amp;n, &amp;mod); #ifdef FORCE mod = 1e9 + 7; #endif for (int i = 0; i &lt; n - 1; i++) { int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w % mod); } pow10[0] = pow10Inv[0] = 1; for (int i = 1; i &lt;= n; i++) { pow10[i] = pow10[i - 1] * 10 % mod; pow10Inv[i] = inv(pow10[i]); } std::cout &lt;&lt; solve() &lt;&lt; std::endl; return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>点分治</tag>
        <tag>Codeforces</tag>
        <tag>乘法逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC 自动机学习笔记]]></title>
    <url>%2Facam-notes%2F</url>
    <content type="text"><![CDATA[AC 自动机是一种多模式串匹配算法，可以用来在文本串中匹配一系列模式串，其时间复杂度与串的总长度成正比。 引入 给一个 Trie 和一个文本串，求 Trie 上所有单词在文本串中的出现次数。 如果使用朴素的匹配算法，时间复杂度非常高。如果对 Trie 上每个单词使用 KMP 预处理后匹配，还是需要做 次的匹配。 失配函数 我们知道，在 KMP 算法中，如果在模式串的一个位置失配，则需要回到模式串的前面一个位置继续匹配。从位置 处失配后回到位置 ，记作 。 考虑 的条件 —— 串的前 个字符组成的前缀，是前 个字符组成前缀的后缀。理论依据是，这样可以保证每一时刻已匹配的字符尽量多，避免遗漏。 现在将问题转化为，在一棵 Trie 上，求一个节点 ，使得从根到 的路径组成的串是从根到 的路径组成串的后缀。 构造 设 父节点为 ， 的入边上的字母为 。 一个显然的结论是，如果 有字母 的出边，则该出边指向的点即为 。 例如，上图中 。 如果 没有字母 的出边，则沿着失配函数继续向上找，找到 …… 直到找到根为止，如果找不到一个符合条件的节点，则 为根。 例如，上图中 。 匹配 用于匹配字符串时，设置一个当前状态 ，它的初始值为根。每一次新加入一个字符 ，首先检查状态 有没有出边 ，如果有，则转移到出边指向的点上，否则继续检查 有无字符 的出边。如果找不到满足条件的节点，则转移到根节点上。 如果状态转移到一个单词节点上，则代表这个单词被匹配到。但有时会出现，一个节点 不是单词， 是单词。 如下图，a 和 bac 组成的 AC 自动机（一些失配边已略去）。 节点 3 可以通过失配边连向 1，如果输入 ba 则会到达节点 3，节点 1 处的单词则被忽略。为了解决这一问题，我们引入另一个指针 —— 后缀链接， 表示从节点 沿着失配边转移，能到达的第一个单词节点，如上图 。 有了后缀链接，便可以在匹配时检查每个节点的后缀链接，记录匹配单词时要遍历被匹配节点后缀链接。 后缀链接可以在失配指针之后求出 —— 如果 为单词节点，则 ，否则 。 优化 由于每次失配时需要使用失配指针，每次输入一个字符时经过的节点数不确定，时间复杂度可能会退化。 一个显然的结论是，对于一个状态，对它添加一个字符之后，转移到的状态是确定的。也就是说，我们可以预处理每一个状态可能转移到的所有状态。 对于节点 ，如果它有字符 的出边，则在加入字符 时，它可以直接转移到该出边指向的节点上。否则，应该转移到 加入对应字符时转移到的点上。我们可以用递推的方式求出这些转移方式，并且在 Trie 树上加上这些边，得到Trie 图。 模板 统计每个模式串的出现次数。 更新于 2016 年 12 月 27 日。 const int CHARSET_SIZE = 'z' - 'a' + 1; // 字符集大小 const char BASE_CHAR = 'a'; // 最小的字符 struct Trie { struct Node { Node *c[CHARSET_SIZE], *next, *fail; bool isWord; int ans; Node(bool isWord = false) : next(NULL), fail(NULL), isWord(isWord) { for (int i = 0; i &lt; CHARSET_SIZE; i++) c[i] = NULL; } void apply() { ans++; if (next) next-&gt;apply(); } } *root; Trie() : root(new Node()) {} Node *insert(const char *begin, const char *end) { // 插入过程类似 Splay Node **v = &amp;root; for (const char *p = begin; p != end; p++) { // 向下找到对应节点的位置 if (!*v) *v = new Node; v = &amp;(*v)-&gt;c[*p]; } if (!*v) *v = new Node(true); else (*v)-&gt;isWord = true; return *v; } void build() { std::queue&lt;Node *&gt; q; q.push(root); root-&gt;fail = root; // 边界 root-&gt;next = NULL; while (!q.empty()) { Node *v = q.front(); q.pop(); for (int i = 0; i &lt; CHARSET_SIZE; i++) { // 使用引用减少代码量 Node *&amp;c = v-&gt;c[i]; // 补全为 Trie 图 if (!c) { // 如果 v == root，则 v-&gt;fail == root，c 和 v-&gt;fail-&gt;c[i] 是同一个变量 c = v == root ? root : v-&gt;fail-&gt;c[i]; continue; } Node *u = v-&gt;fail; // 类似 KMP 的方法，求失配指针 // while (u != root &amp;&amp; !u-&gt;c[i]) u = u-&gt;fail; // 补全为 Trie 图，此行可省略 // 如果 v == root，则失配后一定回到根节点 c-&gt;fail = v != root &amp;&amp; u-&gt;c[i] ? u-&gt;c[i] : root; // 沿着 fail 指针能走到的第一个单词节点 c-&gt;next = c-&gt;fail-&gt;isWord ? c-&gt;fail : c-&gt;fail-&gt;next; q.push(c); } } } void exec(const char *begin, const char *end) { Node *v = root; for (const char *p = begin; p != end; p++) { // 状态转移 v = v-&gt;c[*p]; // 统计答案 if (v-&gt;isWord) v-&gt;apply(); else if (v-&gt;next) v-&gt;next-&gt;apply(); // 注意是 else if } } };]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>AC 自动机</tag>
        <tag>字符串</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2009」有趣的游戏 - AC 自动机 + 概率与期望]]></title>
    <url>%2Fjsoi2009-game2%2F</url>
    <content type="text"><![CDATA[现有 个单词，均由前 个大写字母组成。每一时刻随机产生一个字母，产生第 个字母的概率为 。 时刻后会产生一个长度为 的串。 如果某个时刻，有一个单词在这个串中出现了，则过程结束。求产生的串中出现每个单词的概率。 链接 BZOJ 1444 题解 对所有单词建立 AC 自动机，则问题转化为，在 AC 自动机上匹配产生的串，有多大概率使状态转移到每一个单词上。而每一个单词最多转移一次，问题又可以转化为，求在 AC 自动机上转移到每一个单词末尾节点上的期望次数。 考虑从一个节点转移到另一个节点的概率。设 ，节点 能在加入后转移到节点 的字母集合为 ，则从 转移到 的概率 。 设转移到 AC 自动机上非根节点 的期望次数为 ，则 对于根节点，因为它是自动机的起始状态，所以初始有 的期望次数。 列出方程组，高斯消元求解即可。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 100; const int CHARSET_SIZE = 'Z' - 'A' + 1; const int BASE_CHAR = 'A'; const double EPS = 0.005; int charsetSize, n; struct Trie { struct Node { Node *c[CHARSET_SIZE], *fail, *next; bool isWord, visited; int id; Node(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) { for (int i = 0; i &lt; charsetSize; i++) c[i] = NULL; this-&gt;id = n++; } } *root; Trie() : root(NULL) {} Node *insert(const char *begin, const char *end) { Node **v = &amp;root; for (const char *p = begin; p != end; p++) { if (!*v) *v = new Node; v = &amp;(*v)-&gt;c[*p]; } if (!*v) *v = new Node(true); else (*v)-&gt;isWord = true; return *v; } void build() { std::queue&lt;Node *&gt; q; q.push(root); root-&gt;fail = root, root-&gt;next = NULL; while (!q.empty()) { Node *v = q.front(); q.pop(); for (int i = 0; i &lt; charsetSize; i++) { Node *&amp;c = v-&gt;c[i]; if (!c) { // c = v-&gt;fail-&gt;c[i] ? v-&gt;fail-&gt;c[i] : root; c = v == root ? root : v-&gt;fail-&gt;c[i]; continue; } Node *u = v-&gt;fail; while (u != root &amp;&amp; !u-&gt;c[i]) u = u-&gt;fail; c-&gt;fail = v != root &amp;&amp; u-&gt;c[i] ? u-&gt;c[i] : root; c-&gt;next = c-&gt;fail-&gt;isWord ? c-&gt;fail : c-&gt;fail-&gt;next; q.push(c); } } } } t; double p[MAXN], matrix[MAXN + 1][MAXN + 1 + 1]; inline void buildMatrix() { for (int i = 1; i &lt; n; i++) matrix[i][i] = -1; matrix[0][0] = -1, matrix[0][n] = -1; std::queue&lt;Trie::Node *&gt; q; q.push(t.root); t.root-&gt;visited = true; while (!q.empty()) { Trie::Node *v = q.front(); q.pop(); if (v-&gt;isWord || v-&gt;next) continue; for (int i = 0; i &lt; charsetSize; i++) { // printf("%d -&gt; %d\n", v-&gt;id, v-&gt;c[i]-&gt;id); matrix[v-&gt;c[i]-&gt;id][v-&gt;id] += p[i]; if (!v-&gt;c[i]-&gt;visited) { v-&gt;c[i]-&gt;visited = true; q.push(v-&gt;c[i]); } } } } inline void gauss() { for (int i = 0; i &lt; n; i++) { if (fabs(matrix[i][i]) &lt; EPS) { for (int j = i + 1; j &lt; n; j++) if (matrix[j][i] &gt;= EPS) { std::swap(matrix[i], matrix[j]); break; } } // for (int j = i + 1; j &lt; n; j++) if (max == -1 || fabs(matrix[j][i]) &gt; fabs(matrix[max][i])) max = j; // if (max != i) std::swap(matrix[max], matrix[i]); double t = matrix[i][i]; for (int j = 0; j &lt; n + 1; j++) matrix[i][j] /= t; for (int j = 0; j &lt; n; j++) if (j != i) { double t = matrix[j][i]; for (int k = i; k &lt; n + 1; k++) matrix[j][k] -= t * matrix[i][k]; } } } bool gauss_jordan() { for (int i = 0; i &lt; n; ++i) { int idx = i; for (int j = 0; j &lt; n; ++j) if (fabs(matrix[j][i]) &gt; fabs(matrix[idx][i])) idx = j; // if (fabs(matrix[idx][i]) &lt;= eps) return false; if (idx != i) std::swap(matrix[i], matrix[idx]); // for (int j = i; j &lt;= n; ++j) std::swap(matrix[i][j], matrix[idx][j]); for (int j = 0; j &lt; n; ++j) if (i != j) { double tmp = matrix[j][i] / matrix[i][i]; for (int k = n; k &gt;= i; --k) matrix[j][k] -= matrix[i][k] * tmp; } } return true; } int main() { int m, l; scanf("%d %d %d", &amp;m, &amp;l, &amp;charsetSize); for (int i = 0; i &lt; charsetSize; i++) { double a, b; scanf("%lf %lf", &amp;a, &amp;b); p[i] = a / b; } static Trie::Node *a[MAXN]; int cnt = 0; for (int i = 0; i &lt; m; i++) { char s[MAXN + 1]; scanf("%s", s); for (int i = 0; i &lt; l; i++) { s[i] -= BASE_CHAR; if (p[s[i]] == 0) cnt++; } a[i] = t.insert(s, s + l); } /* if (cnt == m) { for (int i = 0; i &lt; m; i++) puts("0.00"); return 0; } */ t.build(); buildMatrix(); // for (int i = 0; i &lt;= n; i++) matrix[0][i] = -matrix[0][i]; gauss(); /* for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt;= n; j++) printf("%.2lf%c", matrix[i][j], j == n ? '\n' : ' '); } */ for (int i = 0; i &lt; m; i++) printf("%.2lf\n", matrix[a[i]-&gt;id][n] &lt; EPS ? 0.0f : matrix[a[i]-&gt;id][n]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>AC 自动机</tag>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>概率与期望</tag>
        <tag>JSOI</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3881」Divljak - AC 自动机 + 树上路径并]]></title>
    <url>%2Fbzoj-3881%2F</url>
    <content type="text"><![CDATA[给 个字符串 ，另有一个集合 ，初始为空。 有 次操作，每次向 中添加一个字符串 ，或询问 中有多少串能匹配 。 链接 BZOJ 3881 题解 对 建立 AC 自动机，每次加入一个串 时，将所有匹配 的单词节点计数器 ，询问时直接输出答案。 考虑到每一次能匹配一个串的单词节点数量是 级别的，需要优化。如果我们不考虑后缀链接，则匹配数量降为 ，而对于通过后缀链接转移到的点，都是这些点在 Fail 树上的祖先。 每次记录所有匹配 的首个单词节点，在 Fail 树上对这些点到根的路径求并，对路径并的每个节点计数器 。 关于求路径并，将所有节点按照 DFS 序排序，将每个点到根的路径加入到集合中，将相邻每一对点的最近公共祖先到根的路径从集合中去除即可。 体现在本题中即为将每个点到根的路径上的每一个点计数器 ，相邻每一对点的最近公共祖先到根的路径上的每一个点计数器 。转化为子树求和，用树状数组维护即可。 代码 #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;stack&gt; const int MAXN = 100000; const int MAXLEN = 2000000; const int CHARSET_SIZE = 'z' - 'a' + 1; const int BASE_CHAR = 'a'; int tot; struct Trie { struct Node { Node *c[CHARSET_SIZE], *fail, *next; int id; bool isWord, visited; Node(const bool isWord = false) : fail(NULL), next(NULL), id(tot++), isWord(isWord), visited(false) { for (int i = 0; i &lt; CHARSET_SIZE; i++) c[i] = NULL; } } *root; Trie() : root(NULL) {} Node *insert(const char *begin, const char *end) { Node **v = &amp;root; for (const char *p = begin; p != end; p++) { if (!*v) *v = new Node; v = &amp;(*v)-&gt;c[*p]; } if (!*v) *v = new Node(true); else (*v)-&gt;isWord = true; return *v; } void build() { std::queue&lt;Node *&gt; q; q.push(root); root-&gt;fail = root, root-&gt;next = NULL; while (!q.empty()) { Node *v = q.front(); q.pop(); for (int i = 0; i &lt; CHARSET_SIZE; i++) { Node *&amp;c = v-&gt;c[i]; if (!c) { c = v-&gt;fail-&gt;c[i] ? v-&gt;fail-&gt;c[i] : root; continue; } Node *u = v-&gt;fail; while (u != root &amp;&amp; !u-&gt;c[i]) u = u-&gt;fail; c-&gt;fail = v != root &amp;&amp; u-&gt;c[i] ? u-&gt;c[i] : root; c-&gt;next = c-&gt;fail-&gt;isWord ? c-&gt;fail : c-&gt;fail-&gt;next; q.push(c); } } } void exec(const char *begin, const char *end, std::vector&lt;int&gt; &amp;vec) { Node *v = root; for (const char *p = begin; p != end; p++) { v = v-&gt;c[*p]; if (v-&gt;isWord) vec.push_back(v-&gt;id); else if (v-&gt;next) vec.push_back(v-&gt;next-&gt;id); } } } t; struct Node { struct Edge *e; int l, r, depth, size; Node *p, *c, *top; bool visited; } N[MAXLEN + 1]; struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t) { #ifdef DBG printf("addEdge: %d -&gt; %d\n", s + 1, t + 1); #endif N[s].e = new Edge(&amp;N[s], &amp;N[t]); N[t].e = new Edge(&amp;N[t], &amp;N[s]); } inline void build() { std::queue&lt;Trie::Node *&gt; q; q.push(t.root); t.root-&gt;visited = true; while (!q.empty()) { Trie::Node *v = q.front(); q.pop(); if (v-&gt;fail != v) addEdge(v-&gt;id, v-&gt;fail-&gt;id); for (int i = 0; i &lt; CHARSET_SIZE; i++) { if (!v-&gt;c[i]-&gt;visited) { v-&gt;c[i]-&gt;visited = true; q.push(v-&gt;c[i]); } } } } inline void split() { std::stack&lt;Node *&gt; s; s.push(&amp;N[0]); N[0].depth = 1; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;depth) { e-&gt;t-&gt;depth = v-&gt;depth + 1; e-&gt;t-&gt;p = v; s.push(e-&gt;t); } } else { v-&gt;size = 1; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;p == v) { v-&gt;size += e-&gt;t-&gt;size; if (!v-&gt;c || v-&gt;c-&gt;size &lt; e-&gt;t-&gt;size) v-&gt;c = e-&gt;t; } s.pop(); } } for (int i = 0; i &lt; tot; i++) N[i].visited = false; s.push(&amp;N[0]); int ts = 0; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; v-&gt;top = (!v-&gt;p || v != v-&gt;p-&gt;c) ? v : v-&gt;p-&gt;top; v-&gt;l = ++ts; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;p == v &amp;&amp; e-&gt;t != v-&gt;c) { s.push(e-&gt;t); } if (v-&gt;c) s.push(v-&gt;c); } else { v-&gt;r = ts; s.pop(); } } for (int i = 0; i &lt; tot; i++) assert(N[i].l &amp;&amp; N[i].r); #ifdef DBG for (int i = 0; i &lt; tot; i++) { printf("N[%d] =&gt; [%d, %d]\n", i + 1, N[i].l, N[i].r); } #endif } inline Node *lca(Node *a, Node *b) { while (a-&gt;top != b-&gt;top) { if (a-&gt;top-&gt;depth &lt; b-&gt;top-&gt;depth) std::swap(a, b); a = a-&gt;top-&gt;p; } Node *res = a-&gt;depth &lt; b-&gt;depth ? a : b; #ifdef DBG printf("lca(%lu, %lu) = %lu\n", a - N + 1, b - N + 1, res - N + 1); #endif return res; } inline bool compare(const int a, const int b) { return N[a].l &lt; N[b].l; } struct BinaryIndexedTree { int a[MAXLEN + 1 + 1 + 1], n; void init(const int n) { this-&gt;n = n; } static int lowbit(const int x) { return x &amp; -x; } void update(const int pos, const int delta) { #ifdef DBG printf("BIT: %d add %d\n", pos, delta); #endif #ifdef FORCE a[pos] += delta; return; #endif for (int i = pos; i &lt;= n; i += lowbit(i)) a[i] += delta; } int sum(const int pos) { int res = 0; #ifdef FORCE for (int i = 1; i &lt;= pos; i++) res += a[i]; // printf("sum(%d) = %d\n", pos, res); return res; #endif for (int i = pos; i &gt; 0; i -= lowbit(i)) res += a[i]; return res; } int query(const int l, const int r) { #ifdef FORCE int res = 0; for (int i = l; i &lt;= r; i++) res += a[i]; // printf("query(%d, %d) = %d\n", l, r, res); return res; #endif return sum(r) - sum(l - 1); } } bit; inline void add(const char *begin, const char *end) { std::vector&lt;int&gt; vec; t.exec(begin, end, vec); std::sort(vec.begin(), vec.end(), compare); vec.erase(std::unique(vec.begin(), vec.end()), vec.end()); #ifdef DBG printf("%lu matched:", vec.size()); for (size_t i = 0; i &lt; vec.size(); i++) printf(" %d", vec[i] + 1); putchar('\n'); #endif for (size_t i = 0; i &lt; vec.size(); i++) { bit.update(N[vec[i]].l, 1); if (i != 0) { Node *p = lca(&amp;N[vec[i]], &amp;N[vec[i - 1]]); bit.update(p-&gt;l, -1); } } } inline int solve(const int x) { return bit.query(N[x].l, N[x].r); } int main() { int n; static char s[MAXLEN + 1]; scanf("%d", &amp;n); Trie::Node *a[MAXN]; for (int i = 0; i &lt; n; i++) { scanf("%s", s); const int len = strlen(s); for (int i = 0; i &lt; len; i++) s[i] -= BASE_CHAR; a[i] = t.insert(s, s + len); } t.build(); build(); split(); bit.init(tot); int q; scanf("%d", &amp;q); while (q--) { int cmd; scanf("%d", &amp;cmd); if (cmd == 1) { scanf("%s", s); const int len = strlen(s); #ifdef DBG printf("add(\"%s\"): ", s); #endif for (int i = 0; i &lt; len; i++) s[i] -= BASE_CHAR; add(s, s + len); } else { int x; scanf("%d", &amp;x), x--; printf("%d\n", solve(a[x]-&gt;id)); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>AC 自动机</tag>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>COCI</tag>
        <tag>树上路径并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2580」Video Game - AC 自动机]]></title>
    <url>%2Fbzoj-2580%2F</url>
    <content type="text"><![CDATA[给出 个串 ，求一个长度为 的串 ，使 匹配 （可重叠）的次数最多。 链接 BZOJ 2580 题解 设 表示已生成的 个字符组成的串在 AC 自动机上匹配的状态为第 个节点，之后再生成 个字符后的总最大匹配数量。 枚举下一个字符，如果是单词节点则对应答案为当前匹配数量 目标节点单词数量（自身单词和由后缀链接能转移到的单词），否则为当前匹配数量。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;vector&gt; const int MAXN = 15; const int MAXM = 20; const int MAXK = 1000; const int CHARSET_SIZE = 26; const int BASE_CHAR = 'A'; struct Trie { struct Node { Node *c[CHARSET_SIZE], *fail, *next; bool isWord; int wordCnt, id; Node(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) { for (int i = 0; i &lt; CHARSET_SIZE; i++) c[i] = NULL; } } *root; Trie() : root(NULL) {} void insert(const char *begin, const char *end) { Node **v = &amp;root; for (const char *p = begin; p != end; p++) { if (!*v) *v = new Node; v = &amp;(*v)-&gt;c[*p]; } if (!*v) *v = new Node(true); else (*v)-&gt;isWord = true; } void build(std::vector&lt;Node *&gt; &amp;vec) { std::queue&lt;Node *&gt; q; q.push(root); root-&gt;fail = root, root-&gt;next = NULL; while (!q.empty()) { Node *v = q.front(); v-&gt;id = vec.size(); #ifdef DBG printf("wordCnt(%d) = %d\n", v-&gt;id, v-&gt;wordCnt); #endif vec.push_back(v); q.pop(); for (int i = 0; i &lt; CHARSET_SIZE; i++) { Node *&amp;c = v-&gt;c[i]; if (!c) { c = v-&gt;fail-&gt;c[i] ? v-&gt;fail-&gt;c[i] : root; continue; } Node *u = v-&gt;fail; while (u != root &amp;&amp; !u-&gt;c[i]) u = u-&gt;fail; c-&gt;fail = v != root &amp;&amp; u-&gt;c[i] ? u-&gt;c[i] : root; c-&gt;next = c-&gt;fail-&gt;isWord ? c-&gt;fail : c-&gt;fail-&gt;next; c-&gt;wordCnt = c-&gt;isWord + (c-&gt;next ? c-&gt;next-&gt;wordCnt : 0); q.push(c); } } } } t; int main() { int n, k; scanf("%d %d", &amp;n, &amp;k); while (n--) { static char s[MAXN + 1]; scanf("%s", s); const int len = strlen(s); for (int i = 0; i &lt; len; i++) s[i] -= BASE_CHAR; t.insert(s, s + len); } std::vector&lt;Trie::Node *&gt; vec; t.build(vec); static int f[MAXN * MAXM + 1][MAXK + 1]; #ifdef DBG static char g[MAXN * MAXM + 1][MAXK + 1]; #endif // for (size_t i = 0; i &lt; vec.size(); i++) f[i][0] = vec[i]-&gt;wordCnt; for (int i = 1; i &lt;= k; i++) { for (size_t j = 0; j &lt; vec.size(); j++) { for (int k = 0; k &lt; CHARSET_SIZE; k++) { int t = f[vec[j]-&gt;c[k]-&gt;id][i - 1] + vec[j]-&gt;c[k]-&gt;wordCnt; if (t &gt;= f[j][i]) { f[j][i] = t; #ifdef DBG g[j][i] = k; #endif } } #ifdef DBG printf("f(%lu, %d) = %d\n", j, i, f[j][i]); #endif } } #ifdef DBG int last = 0; for (int i = k; i &gt;= 1; i--) { putchar(g[last][i] + 'A'); last = vec[last]-&gt;c[g[last][i]]-&gt;id; } putchar('\n'); last = 0; for (int i = k; i &gt;= 1; i--) { printf("%d%c", last, i == 1 ? '\n' : ' '); last = vec[last]-&gt;c[g[last][i]]-&gt;id; } #endif printf("%d\n", f[0][k]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>AC 自动机</tag>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3940」Censoring - AC 自动机]]></title>
    <url>%2Fbzoj-3940%2F</url>
    <content type="text"><![CDATA[给定一个串 和一些单词串，每一次在 中寻找第一次出现的单词串，并将其删除，求最终串。 链接 BZOJ 3940 题解 对单词串建立 AC 自动机，用链表维护原串，匹配到单词串时从链表中删除。 删去一个单词时，原单词的左右两边可能会连接形成一个新的单词，为了不漏掉这些新单词，必须在删掉一个单词后以在这个单词之前的状态继续匹配 —— 使用栈维护历史状态即可。 代码 #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;cstring&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;list&gt; const int MAXN = 1e5; const int CHARSET_SIZE = 'z' - 'a' + 1; const int BASE_CHAR = 'a'; struct Trie { struct Node { Node *c[CHARSET_SIZE], *fail, *next; bool isWord; int length; Node(const bool isWord = false, const int length = 0) : fail(NULL), next(NULL), isWord(isWord), length(length) { for (int i = 0; i &lt; CHARSET_SIZE; i++) c[i] = NULL; } } *root; Trie() : root(NULL) {} void insert(const char *begin, const char *end) { Node **v = &amp;root; for (const char *p = begin; p != end; p++) { if (!*v) *v = new Node(); v = &amp;(*v)-&gt;c[*p]; } if (!*v) *v = new Node(true, end - begin); else (*v)-&gt;isWord = true, (*v)-&gt;length = end - begin; } void build() { std::queue&lt;Node *&gt; q; q.push(root); root-&gt;fail = root, root-&gt;next = NULL; while (!q.empty()) { Node *v = q.front(); q.pop(); for (int i = 0; i &lt; CHARSET_SIZE; i++) { Node *&amp;c = v-&gt;c[i]; if (!c) { c = v == root ? root : v-&gt;fail-&gt;c[i]; continue; } Node *u = v-&gt;fail; while (u != root &amp;&amp; !u-&gt;c[i]) u = u-&gt;fail; c-&gt;fail = v != root &amp;&amp; u-&gt;c[i] ? u-&gt;c[i] : root; c-&gt;next = c-&gt;fail-&gt;isWord ? c-&gt;fail : c-&gt;fail-&gt;next; q.push(c); } } } void exec(std::list&lt;char&gt; &amp;list) { Node *v = root; std::stack&lt;Node *&gt; history; for (std::list&lt;char&gt;::iterator it = list.begin(); it != list.end(); ) { history.push(v); // while (v != root &amp;&amp; !v-&gt;c[*it]) v = v-&gt;fail, assert(false); if (v-&gt;c[*it]) v = v-&gt;c[*it]; if (!v-&gt;isWord &amp;&amp; v-&gt;next) v = v-&gt;next; if (v-&gt;isWord) { for (int i = 1; i &lt; v-&gt;length; i++) it--; for (int i = 0; i &lt; v-&gt;length; i++) it = list.erase(it); for (int i = 1; i &lt; v-&gt;length; i++) history.pop(); v = history.top(); history.pop(); } else it++; } } } t; int main() { static char s[MAXN + 1]; scanf("%s", s); std::list&lt;char&gt; list; for (const char *p = s; *p; p++) list.push_back(*p - BASE_CHAR); int n; scanf("%d", &amp;n); while (n--) { scanf("%s", s); const int len = strlen(s); for (int i = 0; i &lt; len; i++) s[i] -= BASE_CHAR; t.insert(s, s + len); } t.build(); t.exec(list); for (std::list&lt;char&gt;::const_iterator it = list.begin(); it != list.end(); it++) putchar(*it + BASE_CHAR); putchar('\n'); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>AC 自动机</tag>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>USACO</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BeiJing2011」矩阵模板 - AC 自动机]]></title>
    <url>%2Fbzoj-2462%2F</url>
    <content type="text"><![CDATA[给定一个 行 列的 01 矩阵，以及 个 行 列的 01 矩阵，你需要求出这 个矩阵哪些在原矩阵中出现过。 链接 BZOJ 2462 题解 对模式矩阵的每一行建立 AC 自动机，匹配目标矩阵的每一行。如果目标矩阵的第 行在第 个字符处完成了对模式矩阵的第 行的匹配，则对以 为左上角的子矩阵有 的贡献（表示这个位置的矩阵有一行被匹配了）。 统计答案时，如果某个位置的值 ，则该模式矩阵可以匹配。 代码 #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;queue&gt; #include &lt;utility&gt; const int MAXN = 1000; const int CHARSET_SIZE = '1' - '0' + 1; const int BASE_CHAR = '0'; struct Trie { struct Node { Node *c[CHARSET_SIZE], *fail, *next; bool isWord; int id; Node(const bool isWord = false, const int id = -1) : fail(NULL), next(NULL), isWord(isWord), id(id) { for (int i = 0; i &lt; CHARSET_SIZE; i++) c[i] = NULL; } void apply(std::vector&lt; std::pair&lt;int, int&gt; &gt; &amp;vec, const int pos) { assert(isWord); vec.push_back(std::make_pair(pos, id)); if (next) next-&gt;apply(vec, pos); } } *root; Trie() : root(NULL) {} template &lt;typename T&gt; void insert(const T *begin, const T *end, const int id) { Node **v = &amp;root; for (const T *p = begin; p != end; p++) { if (!*v) *v = new Node(); v = &amp;(*v)-&gt;c[*p]; } if (!*v) *v = new Node(true, id); else (*v)-&gt;id = id, (*v)-&gt;isWord = true; } void build() { std::queue&lt;Node *&gt; q; q.push(root); root-&gt;fail = root; root-&gt;next = NULL; while (!q.empty()) { Node *v = q.front(); q.pop(); for (int i = 0; i &lt; CHARSET_SIZE; i++) { Node *&amp;c = v-&gt;c[i]; if (!c) continue; Node *u = v-&gt;fail; while (u != root &amp;&amp; !u-&gt;c[i]) u = u-&gt;fail; c-&gt;fail = v != root &amp;&amp; u-&gt;c[i] ? u-&gt;c[i] : root; c-&gt;next = c-&gt;fail-&gt;isWord ? c-&gt;fail : c-&gt;fail-&gt;next; q.push(c); } } } void exec(const bool *begin, const bool *end, std::vector&lt; std::pair&lt;int, int&gt; &gt; &amp;vec) { Node *v = root; for (const bool *p = begin; p != end; p++) { while (v != root &amp;&amp; !v-&gt;c[*p]) v = v-&gt;fail; v = v-&gt;c[*p] ? v-&gt;c[*p] : root; if (v-&gt;isWord) v-&gt;apply(vec, p - begin); else if (v-&gt;next) v-&gt;next-&gt;apply(vec, p - begin); } } void clear() { root = NULL; } } t; int main() { int n, m, a, b; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;a, &amp;b); static bool matrix[MAXN][MAXN]; for (int i = 0; i &lt; n; i++) { static char s[MAXN + 1]; scanf("%s", s); for (int j = 0; j &lt; m; j++) matrix[i][j] = s[j] - BASE_CHAR; } int q; scanf("%d", &amp;q); while (q--) { t.clear(); for (int i = 0; i &lt; a; i++) { static char s[MAXN + 1]; scanf("%s", s); for (int j = 0; j &lt; b; j++) s[j] -= BASE_CHAR; t.insert(s, s + b, i); } t.build(); static int matchCnt[MAXN][MAXN]; for (int i = 0; i &lt; n; i++) { std::vector&lt; std::pair&lt;int, int&gt; &gt; vec; t.exec(matrix[i], matrix[i] + m, vec); for (std::vector&lt; std::pair&lt;int, int&gt; &gt;::const_iterator it = vec.begin(); it != vec.end(); it++) { // printf("%d matched %d\n", i, *it); if (i - it-&gt;second &gt;= 0) matchCnt[i - it-&gt;second][it-&gt;first - b + 1]++; } } bool flag = false; for (int i = 0; i &lt; n; i++) { // printf("match(%d) = %d\n", i, matchCnt[i]); for (int j = 0; j &lt; m; j++) { if (matchCnt[i][j] &gt;= b) flag = true; matchCnt[i][j] = 0; } } puts(flag ? "1" : "0"); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>AC 自动机</tag>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POI2000」病毒 - AC 自动机 + 拓扑排序]]></title>
    <url>%2Fpoi2000-wir%2F</url>
    <content type="text"><![CDATA[二进制病毒审查委员会最近发现了如下的规律：某些确定的二进制串是病毒的代码。如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。 链接 BZOJ 2938 题解 为病毒代码建立 AC 自动机，如果一个节点是单词节点，或者它可以通过后缀链接转移到单词节点，则这个节点是无效的。 按照 AC 自动机建图，对于每个节点，向在之后添加 和 所到达的点连边。如果图中包含一个由有效节点组成的环，且 AC 自动机根节点对应节点可以到达这个环，则答案为真。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; const int CHARSET_SIZE = '1' - '0' + 1; const int BASE_CHAR = '0'; const int MAXN = 30000; int n; struct Trie { struct Node { Node *c[CHARSET_SIZE], *fail, *next; bool isWord, visited; int id; Node(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord), visited(false) { this-&gt;id = n++; for (int i = 0; i &lt; CHARSET_SIZE; i++) c[i] = NULL; } } *root; Trie() : root(NULL) {} void insert(const char *begin, const char *end) { Node **v = &amp;root; for (const char *p = begin; p != end; p++) { if (!*v) *v = new Node(); v = &amp;(*v)-&gt;c[*p]; } if (!*v) *v = new Node(true); else (*v)-&gt;isWord = true; } void build() { std::queue&lt;Node *&gt; q; q.push(root); root-&gt;fail = root, root-&gt;next = NULL; while (!q.empty()) { Node *v = q.front(); q.pop(); for (int i = 0; i &lt; CHARSET_SIZE; i++) { Node *&amp;c = v-&gt;c[i]; if (!c) continue; Node *u = v-&gt;fail; while (u != root &amp;&amp; !u-&gt;c[i]) u = u-&gt;fail; c-&gt;fail = v != root &amp;&amp; u-&gt;c[i] ? u-&gt;c[i] : root; c-&gt;next = c-&gt;fail-&gt;isWord ? c-&gt;fail : c-&gt;fail-&gt;next; q.push(c); } } } } t; struct Node { struct Edge *e; int inDegree; bool invalid, flag, visited; } N[MAXN]; struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t) { // printf("Edge(%d, %d)\n", s, t); N[s].e = new Edge(&amp;N[s], &amp;N[t]); N[t].inDegree++; } inline void build() { std::queue&lt;Trie::Node *&gt; q; q.push(t.root); t.root-&gt;visited = true; while (!q.empty()) { Trie::Node *v = q.front(); q.pop(); if (v-&gt;isWord || v-&gt;next) N[v-&gt;id].invalid = true; for (int i = 0; i &lt; CHARSET_SIZE; i++) { Trie::Node *u = v; while (u != t.root &amp;&amp; !u-&gt;c[i]) u = u-&gt;fail; if (u-&gt;c[i]) { if (!v-&gt;isWord &amp;&amp; !v-&gt;next &amp;&amp; !u-&gt;c[i]-&gt;isWord) addEdge(v-&gt;id, u-&gt;c[i]-&gt;id); } else { if (!v-&gt;isWord &amp;&amp; !v-&gt;next) addEdge(v-&gt;id, t.root-&gt;id); } if (!v-&gt;c[i]) continue; v-&gt;c[i]-&gt;visited = true; q.push(v-&gt;c[i]); } } } inline bool solve() { std::queue&lt;Node *&gt; q; int cnt = 0; for (int i = 0; i &lt; n; i++) if (!N[i].inDegree &amp;&amp; !N[i].invalid) { q.push(&amp;N[i]); cnt++; } while (!q.empty()) { Node *v = q.front(); q.pop(); cnt--; v-&gt;flag = true; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;t-&gt;invalid) continue; if (!--e-&gt;t-&gt;inDegree) { q.push(e-&gt;t); } } } if (!cnt) return false; q.push(&amp;N[0]); N[0].visited = true; while (!q.empty()) { Node *v = q.front(); q.pop(); if (!v-&gt;flag) return true; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;visited &amp;&amp; !e-&gt;t-&gt;invalid) e-&gt;t-&gt;visited = true, q.push(e-&gt;t); } return false; } int main() { int n; scanf("%d", &amp;n); static char s[MAXN + 1]; while (n--) { scanf("%s", s); const int len = strlen(s); for (int i = 0; i &lt; len; i++) s[i] -= BASE_CHAR; t.insert(s, s + len); } t.build(); build(); puts(solve() ? "TAK" : "NIE"); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>AC 自动机</tag>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>拓扑排序</tag>
        <tag>POI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2004」L语言 - Trie]]></title>
    <url>%2Fhnoi2004-language%2F</url>
    <content type="text"><![CDATA[我们称一段文章 在某个字典 下是可以被理解的，是指如果文章 可以被分成若干部分，且每一个部分都是字典 中的单词。 给定一个字典 ，你的程序需要判断若干段文章在字典 下是否能够被理解。并给出其在字典 下能够被理解的最长前缀的位置。 链接 BZOJ 1212 题解 设 表示文章的前 个字符是否可被理解，如果 为真，则对于每一个长度为 单词，若它能从 位置开始完全匹配，则 为真。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; const int MAXN = 1024 * 1024; const int CHARSET_SIZE = 'z' - 'a' + 1; const int BASE_CHAT = 'a'; struct Trie { struct Node { Node *c[CHARSET_SIZE]; //, *fail, *next; bool isWord; Node(const bool isWord) : /* fail(NULL), next(NULL), */ isWord(isWord) { for (int i = 0; i &lt; CHARSET_SIZE; i++) c[i] = NULL; } } *root; Trie() : root(NULL) {} void insert(const char *begin, const char *end) { Node **v = &amp;root; for (const char *p = begin; p != end; p++) { if (!*v) *v = new Node(false); v = &amp;(*v)-&gt;c[*p]; } if (!*v) *v = new Node(true); else (*v)-&gt;isWord = true; } /* void build() { std::queue&lt;Node *&gt; q; q.push(root); root-&gt;fail = root, root-&gt;next = NULL; while (!q.empty()) { Node *v = q.front(); q.pop(); for (int i = 0; i &lt; CHARSET_SIZE; i++) { Node *&amp;c = v-&gt;c[i]; if (!c) continue; Node *u = v-&gt;fail; while (u != root &amp;&amp; !u-&gt;c[i]) u = u-&gt;fail; c-&gt;fail = v != root &amp;&amp; u-&gt;c[i] ? u-&gt;c[i] : root; c-&gt;next = c-&gt;fail-&gt;isWord ? c-&gt;fail : c-&gt;fail-&gt;next; q.push(c); } } } */ } t; int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); static char s[MAXN + 1]; while (n--) { scanf("%s", s); const int len = strlen(s); for (int i = 0; i &lt; len; i++) s[i] -= 'a'; t.insert(s, s + len); } // t.build(); while (m--) { scanf("%s", s); const int len = strlen(s); static bool _f[MAXN + 1], *f = _f + 1; for (int i = 0; i &lt; len; i++) s[i] -= 'a', f[i] = false; int ans = -1; f[-1] = true; for (int i = 0; i &lt; len; i++) { if (!f[i - 1]) continue; Trie::Node *v = t.root; for (int j = i; j &lt; len; j++) { // while (v != t.root &amp;&amp; !v-&gt;c[s[j]]) v = v-&gt;fail; if (!v-&gt;c[s[j]]) break; v = v-&gt;c[s[j]]; if (v-&gt;isWord) f[j] = true, ans = std::max(ans, j); } } printf("%d\n", ans + 1); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>HNOI</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2011」阿狸的打字机 - AC 自动机]]></title>
    <url>%2Fnoi2011-type%2F</url>
    <content type="text"><![CDATA[打字机上只有 个按键，分别印有 个小写英文字母和 B、P 两个字母。 经阿狸研究发现，这个打字机是这样工作的： 输入小写字母，打字机的一个凹槽中会加入这个字母（这个字母加在凹槽的最后）。 按一下印有 B 的按键，打字机凹槽中最后一个字母会消失。 按一下印有 P 的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。 我们把纸上打印出来的字符串从 开始顺序编号，一直到 。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数 （其中 ），打字机会显示第 个打印的字符串在第 个打印的字符串中出现了多少次。 链接 BZOJ 2434 题解 使用 Trie 储存操作序列，问题转化为，在 Trie 上求一个单词在另一个单词中的出现次数。 建立 AC 自动机，可以发现如果 中出现了 ，那么 到根路径上的某个节点的 fail 指针（直接或间接地）指向 。问题转化为，在 AC 自动机上求 到根的路径上有多少节点可以经过 fail 指针转移到 。 将 fail 指针反向，形成一棵树，称为 Fail 树。在 Fail 树上，子节点可以在 AC 自动机上经过 fail 指针转移到父节点上。问题转化，AC 自动机中在 到根路径上的节点，有多少个在 Fail 树上对应节点在 的子树中。 考虑这样一种暴力 —— 在 AC 自动机上从根走到 ，对于经过的每一个节点，将它在 Fail 树上对应节点的权值置为 ，之后枚举要对 查询的所有 ，每一次的答案即为 在 Fail 树上子树中所有节点的权值和。 对于子树权值和，我们可以用 DFS 序 + 树状数组维护。根据按照操作序列重新遍历 AC 自动机，进入每个节点时，它在 Fail 树上对应节点的权值置为 ，退出时置为 ，每次走到一个单词节点时，处理由该节点作为 的所有询问。 代码 #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;algorithm&gt; const int MAXN = 1e5; const int CHARSET_SIZE = 'z' - 'a' + 1; const int BASE_CHAR = 'a'; struct Trie { struct Node { Node *c[CHARSET_SIZE], *fail, *next, *p; int id; bool isWord; struct Query { Node *x; int *ans; Query(Node *x, int *ans) : x(x), ans(ans) {} }; std::vector&lt;Query&gt; q; Node(Node *p, bool isWord, const int id) : fail(NULL), next(NULL), p(p), id(id), isWord(isWord) { for (int i = 0; i &lt; CHARSET_SIZE; i++) c[i] = NULL; } } *root; Trie() : root(NULL) {} int init(const char *s, std::vector&lt;Node *&gt; &amp;vec) { int cnt = 0; Node *v = root = new Node(NULL, false, cnt++); for (const char *p = s; *p; p++) { assert(*p == 'P' || *p == 'B' || (*p &gt;= 'a' &amp;&amp; *p &lt;= 'z')); if (*p == 'P') v-&gt;isWord = true, vec.push_back(v); else if (*p == 'B') v = v-&gt;p; else { if (!v-&gt;c[*p - BASE_CHAR]) v-&gt;c[*p - BASE_CHAR] = new Node(v, false, cnt++); v = v-&gt;c[*p - BASE_CHAR]; } } return cnt; } void build() { std::queue&lt;Node *&gt; q; root-&gt;fail = root, root-&gt;next = NULL; q.push(root); while (!q.empty()) { Node *v = q.front(); q.pop(); assert(v-&gt;q.size() &lt; MAXN); for (int i = 0; i &lt; CHARSET_SIZE; i++) { Node *&amp;c = v-&gt;c[i]; if (!c) continue; Node *u = v-&gt;fail; while (u != root &amp;&amp; !u-&gt;c[i]) u = u-&gt;fail; c-&gt;fail = v != root &amp;&amp; u-&gt;c[i] ? u-&gt;c[i] : root; c-&gt;next = c-&gt;fail-&gt;isWord ? c-&gt;fail : c-&gt;fail-&gt;next; q.push(c); assert(v-&gt;q.size() &lt; MAXN); assert(c-&gt;q.size() &lt; MAXN); } } } } t; struct Node { Node *p, *c, *next; int l, r; bool v; } N[MAXN]; int n; inline void addEdge(const int p, const int c) { // printf("addEdge(%d, %d)\n", p, c); N[c].next = N[p].c; N[p].c = &amp;N[c]; N[c].p = &amp;N[p]; } inline void buildFailTree() { std::queue&lt;Trie::Node *&gt; q; q.push(t.root); while (!q.empty()) { Trie::Node *v = q.front(); q.pop(); for (int i = 0; i &lt; CHARSET_SIZE; i++) { Trie::Node *&amp;c = v-&gt;c[i]; if (!c) continue; addEdge(c-&gt;fail-&gt;id, c-&gt;id); q.push(c); } } } inline void dfs() { std::stack&lt;Node *&gt; s; s.push(&amp;N[0]); int ts = 0; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;v) { v-&gt;v = true; v-&gt;l = ++ts; for (Node *c = v-&gt;c; c; c = c-&gt;next) s.push(c); } else { v-&gt;r = ts; s.pop(); } } } struct BinaryIndexedTree { int a[MAXN + 1], n; void init(const int n) { this-&gt;n = n; } static int lowbit(const int x) { return x &amp; -x; } void update(const int pos, const int delta) { for (int i = pos; i &lt;= n; i += lowbit(i)) a[i] += delta; } int query(const int pos) { int ans = 0; for (int i = pos; i &gt; 0; i -= lowbit(i)) ans += a[i]; return ans; } } bit; char op[MAXN + 1]; inline void solve() { bit.init(n); Trie::Node *y = t.root; for (const char *p = op; *p; p++) { if (*p == 'P') { for (std::vector&lt;Trie::Node::Query&gt;::iterator it = y-&gt;q.begin(); it != y-&gt;q.end(); it++) { *it-&gt;ans = bit.query(N[it-&gt;x-&gt;id].r) - bit.query(N[it-&gt;x-&gt;id].l - 1); } } else if (*p == 'B') { bit.update(N[y-&gt;id].l, -1); y = y-&gt;p; } else { y = y-&gt;c[*p - BASE_CHAR]; bit.update(N[y-&gt;id].l, 1); } } } int main() { scanf("%s", op); std::vector&lt;Trie::Node *&gt; vec; n = t.init(op, vec); t.build(); buildFailTree(); dfs(); int m; static int ans[MAXN]; scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) { int x, y; scanf("%d %d", &amp;x, &amp;y), x--, y--; vec[y]-&gt;q.push_back(Trie::Node::Query(vec[x], &amp;ans[i])); } solve(); for (int i = 0; i &lt; m; i++) printf("%d\n", ans[i]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>AC 自动机</tag>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2007」文本生成器 - AC 自动机]]></title>
    <url>%2Fjsoi2007-generator%2F</url>
    <content type="text"><![CDATA[「文本生成器」可以随机生成一些文章 ―― 总是生成一篇长度固定且完全随机的文章 —— 也就是说，生成的文章中每个字节都是完全随机的。 如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章 包含单词 ，当且仅当单词 是文章 的子串）。 求生成的所有文本中可读文本的数量。 链接 BZOJ 1030 题解 首先，考虑只有一个单词的情况，这个单词出现了，当且仅当之前连续若干个位置匹配了单词的前面若干个字符，并且当前字符是单词的最后一个字符。 我们可以设计 DP 状态 —— 还要生成 个字符，在这之前生成的最后若干个字符匹配了单词中的前 个字符，最终生成串不包含单词串方案数。枚举第一个字符，尝试继续匹配，如果不能匹配则跳转到 KMP 的失配位置。 对于多个单词的情况，只需要将 KMP 改为 AC 自动机即可，「匹配了单词中的前 个字符」改为「当前状态为 AC 自动机的节点 」。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;vector&gt; const int MAXN = 60; const int MAXM = 100; const int CHARSET_SIZE = 'Z' - 'A' + 1; const char BASE_CHAR = 'A'; const int MOD = 10007; struct Trie { struct Node { int id; Node *c[CHARSET_SIZE], *fail, *next; bool isWord; Node(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) { for (int i = 0; i &lt; CHARSET_SIZE; i++) c[i] = NULL; } } *root; Trie() : root(NULL) {} void insert(const char *begin, const char *end) { Node **v = &amp;root; for (const char *p = begin; p != end; p++) { if (!*v) *v = new Node(false); v = &amp;(*v)-&gt;c[*p]; } if (!*v) *v = new Node(true); else (*v)-&gt;isWord = true; } void build() { std::queue&lt;Node *&gt; q; q.push(root); root-&gt;fail = root, root-&gt;next = NULL; while (!q.empty()) { Node *v = q.front(); q.pop(); for (int i = 0; i &lt; CHARSET_SIZE; i++) { Node *&amp;c = v-&gt;c[i]; if (!c) continue; Node *u = v-&gt;fail; while (u != root &amp;&amp; !u-&gt;c[i]) u = u-&gt;fail; c-&gt;fail = v != root &amp;&amp; u-&gt;c[i] ? u-&gt;c[i] : root; c-&gt;next = c-&gt;fail-&gt;isWord ? c-&gt;fail : c-&gt;fail-&gt;next; q.push(c); } } } bool next(Node *v, const char ch, Node *&amp;next) { while (v != root &amp;&amp; !v-&gt;c[ch]) v = v-&gt;fail; next = v-&gt;c[ch] ? v-&gt;c[ch] : root; if (!v-&gt;c[ch]) return false; else if (v-&gt;c[ch]-&gt;isWord) return true; else if (v-&gt;c[ch]-&gt;next) return true; else return false; } void getNodeList(std::vector&lt;Node *&gt; &amp;vec) { std::queue&lt;Node *&gt; q; q.push(root); while (!q.empty()) { Node *v = q.front(); q.pop(); vec.push_back(v); for (int i = 0; i &lt; CHARSET_SIZE; i++) if (v-&gt;c[i]) q.push(v-&gt;c[i]); } } } t; inline int pow(int x, int n) { int ans = 1; for (; n; n &gt;&gt;= 1, x = x * x % MOD) if (n &amp; 1) ans = ans * x % MOD; return ans; } int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); while (n--) { char s[MAXM + 1]; scanf("%s", s); int len = strlen(s); for (int i = 0; i &lt; len; i++) s[i] -= BASE_CHAR; t.insert(s, s + len); } t.build(); std::vector&lt;Trie::Node *&gt; vec; t.getNodeList(vec); // std::tr1::unordered_map&lt;Trie::Node *, int&gt; f[MAXM + 1]; static int f[MAXM + 1][MAXM * MAXN + 1]; // for (size_t i = 0; i &lt; vec.size(); i++) for (int j = 0; j &lt; CHARSET_SIZE; j++) if (!vec[i]-&gt;c[j] || !vec[i]-&gt;c[j]-&gt;isWord) f[1][vec[i]]++; for (size_t i = 0; i &lt; vec.size(); i++) vec[i]-&gt;id = i, f[0][i] = 1; for (int i = 1; i &lt;= m; i++) { for (size_t j = 0; j &lt; vec.size(); j++) { for (int k = 0; k &lt; CHARSET_SIZE; k++) { Trie::Node *next; if (!t.next(vec[j], k, next)) { (f[i][j] += f[i - 1][next-&gt;id]) %= MOD; // if (k &lt;= 5) printf("(%d, %lu) =&gt; %d (%d)\n", i, j, k, f[i - 1][next]); } } } } /* for (int i = 1; i &lt;= m; i++) { for (size_t j = 0; j &lt; vec.size(); j++) printf("f(%d, %lu) = %d\n", i, j, f[i][vec[j]]); putchar('\n'); } // */ // printf("%d\n", f[m][t.root]); printf("%d\n", ((pow(CHARSET_SIZE, m) - f[m][t.root-&gt;id]) % MOD + MOD) % MOD); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>AC 自动机</tag>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>JSOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TJOI2013」单词 - AC 自动机]]></title>
    <url>%2Ftjoi2013-word%2F</url>
    <content type="text"><![CDATA[某人读论文，一篇论文是由许多单词组成。但他发现一个单词会在论文中出现很多次，现在想知道每个单词分别在论文中出现多少次。 链接 BZOJ 3172 题解 AC 自动机可以用来多模式串匹配。对所有的单词建 AC 自动机，在所有单词中间加一个非字母字符隔开组成论文。在 AC 自动机中匹配论文串，记录每个串的匹配次数即可。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; const int MAXN = 1e6 + 200; const int CHARSET_SIZE = 'z' - '`' + 1; const char BASE_CHAR = '`'; struct Trie { struct Node { Node *c[CHARSET_SIZE], *next, *fail; bool isWord; #ifdef DBG char ch; #endif int ans; Node(const bool isWord = false) : next(NULL), fail(NULL), isWord(isWord) { for (int i = 0; i &lt; CHARSET_SIZE; i++) c[i] = NULL; } void apply() { ans++; if (next) next-&gt;apply(); } } *root; Trie() : root(new Node()) {} Node *insert(const char *begin, const char *end) { Node **v = &amp;root; for (const char *p = begin; p != end; p++) { if (!*v) *v = new Node; v = &amp;(*v)-&gt;c[*p]; } if (!*v) *v = new Node(true); else (*v)-&gt;isWord = true; #ifdef DBG v = &amp;root; for (const char *p = begin; p != end; p++) { v = &amp;(*v)-&gt;c[*p]; (*v)-&gt;ch = *p + 'a'; } #endif return *v; } void build() { std::queue&lt;Node *&gt; q; q.push(root); root-&gt;fail = root; root-&gt;next = NULL; while (!q.empty()) { Node *v = q.front(); q.pop(); for (int i = 0; i &lt; CHARSET_SIZE; i++) { Node *&amp;c = v-&gt;c[i]; if (!c) continue; Node *u = v-&gt;fail; while (u != root &amp;&amp; !u-&gt;c[i]) u = u-&gt;fail; c-&gt;fail = v != root &amp;&amp; u-&gt;c[i] ? u-&gt;c[i] : root; c-&gt;next = c-&gt;fail-&gt;isWord ? c-&gt;fail : c-&gt;fail-&gt;next; q.push(c); } } } void exec(const char *begin, const char *end) { Node *v = root; for (const char *p = begin; p != end; p++) { while (v != root &amp;&amp; !v-&gt;c[*p]) v = v-&gt;fail; v = v-&gt;c[*p] ? v-&gt;c[*p] : root; if (v-&gt;isWord) v-&gt;apply(); else if (v-&gt;next) v-&gt;next-&gt;apply(); } } } t; int main() { int n; scanf("%d", &amp;n); static char s[MAXN + 1]; char *p = s; static Trie::Node *node[MAXN]; for (int i = 0; i &lt; n; i++) { static char s[MAXN + 1]; scanf("%s", s); int len = strlen(s); for (int i = 0; i &lt; len; i++) s[i] -= BASE_CHAR, *p++ = s[i]; *p++ = 0; node[i] = t.insert(s, s + len); } *--p = 0; // for (char *c = s; c != p; c++) putchar(*c + BASE_CHAR); t.build(); t.exec(s, p); for (int i = 0; i &lt; n; i++) printf("%d\n", node[i]-&gt;ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>AC 自动机</tag>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>TJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tarjan 割点学习笔记]]></title>
    <url>%2Ftarjan-cut-notes%2F</url>
    <content type="text"><![CDATA[在一个无向图中，如果删掉点 后图的连通块数量增加，则称点 为图的割点。 定义 表示进入节点 时的时间。 表示由节点 开始搜索所能到达的点中，在搜索树上是 的祖先且 最小的节点的 。 算法描述 类似于 Tarjan 求强连通分量的算法。 从起点开始 DFS； 进入一个节点时，初始化它的 和 均为当前时间戳； 枚举当前点 的所有邻接点； 如果某个邻接点 已被访问过，则更新 ； 如果某个邻接点 未被访问过，则对 进行 DFS，并在回溯后更新 ； 对于一个搜索树上的非根节点 ，如果存在子节点 ，满足 ，则 为割点； 对于根节点，如果它有两个或更多的子节点，则它为割点。 解释 对于根节点，如果它有两个或更多的子节点，则它为割点。 显然，根是两棵子树上节点的唯一连通方式。 对于一个搜索树上的非根节点 ，如果存在子节点 ，满足 ，则 为割点； 的意义是， 向上无法到达 的父节点。 模板 递归（CodeVS 5524）： 更新于 2016 年 12 月 29 日。 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 20000; struct Node { struct Edge *firstEdge; Node *fa; int dfn, low; bool vis, isCut; } N[MAXN + 1]; struct Edge { Node *from, *to; Edge *next; Edge(Node *from, Node *to) : from(from), to(to), next(from-&gt;firstEdge) {} }; inline void addEdge(int s, int t) { N[s].firstEdge = new Edge(&amp;N[s], &amp;N[t]); N[t].firstEdge = new Edge(&amp;N[t], &amp;N[s]); } inline int tarjan(Node *v) { static int ts = 0; v-&gt;dfn = v-&gt;low = ++ts; v-&gt;vis = true; int res = 0, childCnt = 0; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (!e-&gt;to-&gt;vis) { e-&gt;to-&gt;fa = v; res += tarjan(e-&gt;to); v-&gt;low = std::min(v-&gt;low, e-&gt;to-&gt;low); if (v-&gt;fa) { // 某个子节点能到达的最高点不高于 v if (e-&gt;to-&gt;low &gt;= v-&gt;dfn) v-&gt;isCut = true; } else { // 不是搜索树的根 // 有两个以上的子树 if (++childCnt == 2) v-&gt;isCut = true; } } else { // 无向图 DFS 树没有横叉边，所有非树边均为返祖边 v-&gt;low = std::min(v-&gt;low, e-&gt;to-&gt;dfn); } } if (v-&gt;isCut) res++; return res; } int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); while (m--) { int u, v; scanf("%d %d", &amp;u, &amp;v); addEdge(u, v); } int ans = 0; for (int i = 1; i &lt;= n; i++) { if (!N[i].vis) ans += tarjan(&amp;N[i]); } printf("%d\n", ans); for (int i = 1; i &lt;= n; i++) { for (Edge *&amp;e = N[i].firstEdge, *next; e; next = e-&gt;next, delete e, e = next); N[i].vis = N[i].isCut = false; N[i].dfn = N[i].low = 0; N[i].fa = NULL; } return 0; } 非递归： struct Node { struct Edge *e, *c; Node *p; int dfn, low; bool v, pushed, flag; } N[MAXN]; struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t) { N[s].e = new Edge(&amp;N[s], &amp;N[t]); N[t].e = new Edge(&amp;N[t], &amp;N[s]); } int n; inline int tarjan() { int ts = 0, cnt = 0; for (int i = 0; i &lt; n; i++) { if (N[i].v) continue; std::stack&lt;Node *&gt; s; s.push(&amp;N[i]); N[i].pushed = true; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;v) { v-&gt;v = true; v-&gt;c = v-&gt;e; v-&gt;low = v-&gt;dfn = ++ts; } if (v-&gt;c) { Edge *&amp;e = v-&gt;c; if (e-&gt;t-&gt;v) v-&gt;low = std::min(v-&gt;low, e-&gt;t-&gt;dfn); else if (!e-&gt;t-&gt;pushed) e-&gt;t-&gt;pushed = true, s.push(e-&gt;t), e-&gt;t-&gt;p = v; e = e-&gt;next; } else { if (v != &amp;N[i]) for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;low &gt;= v-&gt;dfn &amp;&amp; e-&gt;t-&gt;p == v) { v-&gt;flag = true; break; } if (v-&gt;flag) cnt++; if (v-&gt;p) v-&gt;p-&gt;low = std::min(v-&gt;p-&gt;low, v-&gt;low); s.pop(); } } int cnt = 0; for (Edge *e = N[i].e; e; e = e-&gt;next) if (e-&gt;t-&gt;p == &amp;N[i]) cnt++; N[i].flag = cnt &gt;= 2; } return cnt; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>Tarjan</tag>
        <tag>图论</tag>
        <tag>割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2016」网格 - 图连通性]]></title>
    <url>%2Fnoi2016-grid%2F</url>
    <content type="text"><![CDATA[在一个 的网格上，有 个障碍，其余均为空地。求至少需要将多少空地转化为障碍，可以使得存在两个空地在四连通意义下不在同一连通块中。 链接 BZOJ 4651 UOJ #220 题解 显然，如果有解，则答案最大为 。我们只需要依次判断答案是否为无解、、、 即可。 判断无解 无解有两种情况： 没有空地； 只有两块在四连通意义下相邻的空地。 对于第一种情况，只需要判断 即可，第二种情况，因为 和 不大（），可以标记所有障碍格子，取出两块空地格子的坐标，判断 即可。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>Tarjan</tag>
        <tag>图论</tag>
        <tag>割点</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POI2008」BLO - 割点]]></title>
    <url>%2Fpoi2008-blo%2F</url>
    <content type="text"><![CDATA[Byteotia 城市有 个 towns， 条双向 roads。每条 road 连接两个不同的 towns，没有重复的 road。所有 towns 连通。 求当把每个点封锁时，会有多少有序点对 不连通。 链接 BZOJ 1123 题解 如果一个点不是割点，则答案是 。 如果一个点是割点，则将它去掉后，剩下的所有连通块两两之间不连通，对于两个连通块，它们对答案的贡献是它们的大小之和。 DFS 时维护 DFS 树上每棵子树的大小，对于每个割点 ，删掉它后，所有满足 的子节点 的子树均为一个对答案有贡献的连通块。另外，树上除 的整棵子树的其它部分也是一个连通块。 设每个连通块的大小分别为 ，，则答案贡献为： 代码 #include &lt;cstdio&gt; #include &lt;stack&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; const int MAXN = 100000; struct Node { struct Edge *e, *c; Node *p; int dfn, low, size; long long ans; bool flag, pushed, v; } N[MAXN]; struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t) { N[s].e = new Edge(&amp;N[s], &amp;N[t]); N[t].e = new Edge(&amp;N[t], &amp;N[s]); } int n; inline long long calc(const std::vector&lt;long long&gt; &amp;vec) { long long s = 0, ans = 0; for (size_t i = 0; i &lt; vec.size(); i++) s += vec[i]; for (size_t i = 0; i &lt; vec.size(); i++) ans += (s - vec[i]) * vec[i]; return ans; } inline void tarjan() { int ts = 0; for (int i = 0; i &lt; n; i++) { if (N[i].v) continue; std::stack&lt;Node *&gt; s; N[i].pushed = true; s.push(&amp;N[i]); while (!s.empty()) { Node *v = s.top(); if (!v-&gt;v) { v-&gt;v = true; v-&gt;dfn = v-&gt;low = ++ts; v-&gt;c = v-&gt;e; v-&gt;size = 1; } if (v-&gt;c) { Edge *&amp;e = v-&gt;c; if (e-&gt;t-&gt;v) v-&gt;low = std::min(v-&gt;low, e-&gt;t-&gt;dfn); else if (!e-&gt;t-&gt;pushed) e-&gt;t-&gt;pushed = true, e-&gt;t-&gt;p = v, s.push(e-&gt;t); e = e-&gt;next; } else { std::vector&lt;long long&gt; vec; if (v != &amp;N[i]) { for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;t-&gt;p != v) continue; if (e-&gt;t-&gt;low &gt;= v-&gt;dfn) { v-&gt;flag = true; vec.push_back(e-&gt;t-&gt;size); } v-&gt;size += e-&gt;t-&gt;size; } int t = n - 1; for (size_t i = 0; i &lt; vec.size(); i++) t -= vec[i]; vec.push_back(t); if (v-&gt;flag) v-&gt;ans = calc(vec); // if (v-&gt;flag) printf("tarjan(): found %lu\n", v - N + 1); } if (v-&gt;p) v-&gt;p-&gt;low = std::min(v-&gt;p-&gt;low, v-&gt;low); s.pop(); } } std::vector&lt;long long&gt; vec; for (Edge *e = N[i].e; e; e = e-&gt;next) if (e-&gt;t-&gt;p == &amp;N[i]) vec.push_back(e-&gt;t-&gt;size); if (vec.size() &gt;= 2) N[i].ans = calc(vec), N[i].flag = true; // if (N[i].flag) printf("tarjan(): found %d\n", i + 1); } } int main() { int m; scanf("%d %d", &amp;n, &amp;m); while (m--) { int u, v; scanf("%d %d", &amp;u, &amp;v), u--, v--; addEdge(u, v); } tarjan(); for (int i = 0; i &lt; n; i++) printf("%lld\n", N[i].ans + (n - 1) * 2); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>Tarjan</tag>
        <tag>图论</tag>
        <tag>割点</tag>
        <tag>POI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2012」矿场搭建 - 割点]]></title>
    <url>%2Fhnoi2012-mine%2F</url>
    <content type="text"><![CDATA[煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。 请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。 链接 BZOJ 2730 题解 考虑删掉所有割点，图被分成若干个连通块，如果一个连通块与两个以上的割点连通，则不需要单独建设出口，否则需要单独建设一个出口。 如果图没有割点，需要任意找两个点建设出口。 代码 #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;tr1/unordered_set&gt; const int MAXN = 100000; struct Node { struct Edge *e, *c; Node *p; int dfn, low; bool v, pushed, flag; } N[MAXN]; struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t) { N[s].e = new Edge(&amp;N[s], &amp;N[t]); N[t].e = new Edge(&amp;N[t], &amp;N[s]); } int n; inline int tarjan() { int ts = 0, cnt = 0; for (int i = 0; i &lt; n; i++) { if (N[i].v) continue; std::stack&lt;Node *&gt; s; s.push(&amp;N[i]); N[i].pushed = true; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;v) { v-&gt;v = true; v-&gt;c = v-&gt;e; v-&gt;low = v-&gt;dfn = ++ts; } if (v-&gt;c) { Edge *&amp;e = v-&gt;c; if (e-&gt;t-&gt;v) v-&gt;low = std::min(v-&gt;low, e-&gt;t-&gt;dfn); else if (!e-&gt;t-&gt;pushed) e-&gt;t-&gt;pushed = true, s.push(e-&gt;t), e-&gt;t-&gt;p = v; e = e-&gt;next; } else { if (v != &amp;N[i]) for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;low &gt;= v-&gt;dfn &amp;&amp; e-&gt;t-&gt;p == v) { v-&gt;flag = true; break; } // if (v-&gt;flag) printf("!!!: %lu\n", v - N + 1); if (v-&gt;flag) cnt++; if (v-&gt;p) v-&gt;p-&gt;low = std::min(v-&gt;p-&gt;low, v-&gt;low); s.pop(); } } int cnt = 0; for (Edge *e = N[i].e; e; e = e-&gt;next) if (e-&gt;t-&gt;p == &amp;N[i]) cnt++; N[i].flag = cnt &gt;= 2; } return cnt; } inline void solve(int &amp;min, long long &amp;cnt) { min = 0, cnt = 1; for (int i = 0; i &lt; n; i++) N[i].v = false; for (int i = 0; i &lt; n; i++) { if (N[i].v || N[i].flag) continue; std::queue&lt;Node *&gt; q; q.push(&amp;N[i]); N[i].v = true; std::tr1::unordered_set&lt;unsigned long&gt; s; int size = 0; while (!q.empty()) { Node *v = q.front(); q.pop(); size++; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;t-&gt;flag) s.insert(e-&gt;t - N); else if (!e-&gt;t-&gt;v) q.push(e-&gt;t), e-&gt;t-&gt;v = true; } } if (s.size() == 1) min++, cnt *= size; } if (!min) min = 2, cnt = n * (n - 1) / 2; } int main() { for (int i = 1, m; ~scanf("%d", &amp;m) &amp;&amp; m; i++) { n = 0; while (m--) { int u, v; scanf("%d %d", &amp;u, &amp;v); n = std::max(n, std::max(u, v)); u--, v--; addEdge(u, v); } tarjan(); int min; long long cnt; solve(min, cnt); printf("Case %d: %d %lld\n", i, min, cnt); for (int i = 0; i &lt; n; i++) { N[i].v = N[i].pushed = N[i].flag = false; N[i].dfn = N[i].low = 0; N[i].p = NULL; Edge *next; for (Edge *&amp;e = N[i].e; e; next = e-&gt;next, delete e, e = next); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>Tarjan</tag>
        <tag>HNOI</tag>
        <tag>图论</tag>
        <tag>割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2016」优秀的拆分 - Hash]]></title>
    <url>%2Fnoi2016-excellent%2F</url>
    <content type="text"><![CDATA[如果一个字符串可以被拆分为 AABB 的形式，其中 和 是任意非空字符串，则我们称该字符串的这种拆分是优秀的。 例如，对于字符串 aabaabaa，如果令 ，我们就找到了这个字符串拆分成 AABB 的一种方式。 一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。比如我们令 ，也可以用 AABB 表示出上述字符串；但是，字符串 abaabaa 就没有优秀的拆分。 现在给出一个长度为 的字符串 ，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。 题解 点我去看题解 代码 Hash T 飞了 …… #pragma GCC optimize("O3") #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;cassert&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; typedef unsigned __int128 hash1_t; const int MAXN = 30000; const hash1_t BASE1 = 233; // const hash2_t BASE2 = 233; // const hash3_t BASE3 = 53; char s[MAXN]; int n; long long forward[MAXN + 1], backward[MAXN + 1]; hash1_t hash1[MAXN], base1[MAXN + 1]; // hash2_t hash2[MAXN], base2[MAXN + 1]; // hash3_t hash3[MAXN], base3[MAXN + 1]; inline __attribute__((always_inline)) bool compare(const int a, const int b, const int len) { return hash1[b + len - 1] - hash1[b - 1] * base1[len] == hash1[a + len - 1] - hash1[a - 1] * base1[len]; // &amp;&amp; hash2[b + len - 1] - hash2[b - 1] * base2[len] == hash2[a + len - 1] - hash2[a - 1] * base2[len] // &amp;&amp; hash3[b + len - 1] - hash3[b - 1] * base3[len] == hash3[a + len - 1] - hash3[a - 1] * base3[len]; // register long long h1 = ((hash[b + len - 1] - hash[b - 1] * base[len] % MOD) % MOD + MOD) % MOD; // register long long h2 = ((hash[a + len - 1] - hash[a - 1] * base[len] % MOD) % MOD + MOD) % MOD; // register hash_t h1 = hash[b + len - 1] - hash[b - 1] * base[len]; // register hash_t h2 = hash[a + len - 1] - hash[a - 1] * base[len]; // const bool res = h1 == h2; // assert(res == (memcmp(&amp;s[a], &amp;s[b], len) == 0)); // return h1 == h2; // return memcmp(&amp;s[a], &amp;s[b], len) == 0; } inline __attribute__((always_inline)) int lcp(register int a, register int b) { if (a &gt; b) std::swap(a, b); if (a &lt; 0 || b &gt;= n) return 0; register int l = 0, r = n - b; while (l != r) { const register int m = l + (r - l) / 2 + 1; if (compare(a, b, m)) { l = m; } else r = m - 1; } return l; } inline __attribute__((always_inline)) int lcs(register int a, register int b) { if (a &gt; b) std::swap(a, b); if (a &lt; 0 || b &gt;= n) return 0; register int l = 0, r = a + 1; while (l != r) { const register int m = l + (r - l) / 2 + 1; if (compare(a - m + 1, b - m + 1, m)) { l = m; } else r = m - 1; } return l; } int main() { // base1[0] = base2[0] = base3[0] = 1; base1[0] = 1; // for (int i = 1; i &lt;= MAXN; i++) base[i] = base[i - 1] * BASE % MOD; for (register int i = 1; i &lt;= MAXN; i++) { base1[i] = base1[i - 1] * BASE1; // base2[i] = base2[i - 1] * BASE2; // base3[i] = base3[i - 1] * BASE3; } int t; scanf("%d", &amp;t); while (t--) { scanf("%s", s); n = strlen(s); for (register int i = 0; i &lt; n; i++) s[i] -= 'a' - 1; // hash1[0] = hash2[0] = hash3[0] = s[0]; hash1[0] = s[0]; // for (int i = 1; i &lt; n; i++) hash[i] = (hash[i - 1] * BASE + s[i]) % MOD; for (register int i = 1; i &lt; n; i++) { hash1[i] = (hash1[i - 1] * BASE1 + s[i]); // hash2[i] = (hash2[i - 1] * BASE2 + s[i]); // hash3[i] = (hash3[i - 1] * BASE3 + s[i]); } for (register int k = 1; k &lt;= n / 2; k++) { // printf("k = %d\n", k); for (register int i = 0; i &lt; n; i += k) { const register int a = std::min(lcs(i, i + k), k) - 1, b = std::min(lcp(i, i + k), k); // printf("lcs(%d, %d) - 1 = %d, lcp(%d, %d) = %d\n", i, i + k, a, i, i + k, b); if (a + b &gt;= k) { register int l, r; l = i + k + k - a - 1, r = l + (a + b - k); // l = std::max(i + k + k - a, i + k), r = std::min(l + (a + b - k), i + k + k - 1); // printf("[%d, %d]\n", l, r); // for (int i = l; i &lt;= r; i++) backward[i]++; backward[l]++, backward[r + 1]--; r = r - 2 * k + 1, l = l - 2 * k + 1; // for (int i = l; i &lt;= r; i++) forward[i]++; forward[l]++, forward[r + 1]--; } } } for (register int i = 1; i &lt; n; i++) forward[i] += forward[i - 1], backward[i] += backward[i - 1]; register long long ans = 0; for (register int i = 1; i &lt; n; i++) ans += backward[i - 1] * forward[i]; for (register int i = 0; i &lt; n; i++) { hash1[i] = 0; // hash2[i] = 0; // hash3[i] = 0; backward[i] = forward[i] = 0; } forward[n] = backward[n] = 0; printf("%lld\n", ans); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>Hash</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2016」区间 - 线段树]]></title>
    <url>%2Fnoi2016-interval%2F</url>
    <content type="text"><![CDATA[在数轴上有 个闭区间 。现在要从中选出 个区间，使得这 个区间共同包含至少一个位置。换句话说，就是使得存在一个 ，使得对于每一个被选中的区间 ，都有 。 对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。区间 的长度定义为 ，即等于它的右端点的值减去左端点的值。 求所有合法方案中最小的花费。 链接 BZOJ 4653 题解 将所有区间按照长度排序，按长度从小到大枚举每个区间，在线段树上对其标记，如果线段树上已有一点被 个区间覆盖，则从小到大删除区间，每次更新答案。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 500000; const int MAXM = 200000; struct SegmentTree { int l, r; SegmentTree *lc, *rc; int val, tag; SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), val(0) {} void cover(const int delta) { val += delta; tag += delta; } void pushDown() { if (tag) { lc-&gt;cover(tag); rc-&gt;cover(tag); tag = 0; } } void update(const int l, const int r, const int delta) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) cover(delta); else { pushDown(); lc-&gt;update(l, r, delta); rc-&gt;update(l, r, delta); val = std::max(lc-&gt;val, rc-&gt;val); } } int query(const int l, const int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return val; else { pushDown(); return std::max(lc-&gt;query(l, r), rc-&gt;query(l, r)); } } static SegmentTree *build(const int l, const int r) { if (l &gt; r) return NULL; else if (l == r) return new SegmentTree(l, r, NULL, NULL); else { const int mid = l + (r - l) / 2; return new SegmentTree(l, r, build(l, mid), build(mid + 1, r)); } } } *segment; struct Interval { int l, r, len; bool operator&lt;(const Interval &amp;other) const { return len &lt; other.len; } } a[MAXN]; int n, m; int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf("%d %d", &amp;a[i].l, &amp;a[i].r), a[i].len = a[i].r - a[i].l; static int set[MAXN * 2]; int cnt = 0, max = 0; for (int i = 0; i &lt; n; i++) set[cnt++] = a[i].l, set[cnt++] = a[i].r; std::sort(set, set + n * 2); int *end = std::unique(set, set + n * 2); for (int i = 0; i &lt; n; i++) a[i].l = std::lower_bound(set, end, a[i].l) - set, a[i].r = std::lower_bound(set, end, a[i].r) - set, max = std::max(max, a[i].r); std::sort(a, a + n); segment = SegmentTree::build(0, max); int ans = INT_MAX; for (Interval *l = a, *r = a; r != a + n; r++) { segment-&gt;update(r-&gt;l, r-&gt;r, 1); while (l &lt;= r &amp;&amp; segment-&gt;query(0, max) &gt;= m) { ans = std::min(ans, r-&gt;len - l-&gt;len); segment-&gt;update(l-&gt;l, l-&gt;r, -1); l++; } } if (ans == INT_MAX) puts("-1"); else printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>BZOJ</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2013」森林 - LCA + 主席树 + 启发式合并]]></title>
    <url>%2Fsdoi2013-rforest%2F</url>
    <content type="text"><![CDATA[森林中有 个点， 条边，每个点有点权，执行 次操作： 查询两点间点权的第 小； 连接两个点，保证图在操作后仍然为森林。 链接 BZOJ 3123 题解 对于第 小的询问，可以使用类似树上前缀和求两点距离的方法，使用主席树。将主席树的序列前缀和改为树上前缀和即可。 对于合并操作，每次将较小树合并到较大树上（使用并查集维护每棵树的大小），可以证明总复杂度为 。 代码 #pragma GCC optimize("O3") #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #define inline inline __attribute__((always_inline)) const int MAXN = 80000; const int MAXN_LOG = 17; struct UnionFindSet { int a[MAXN], s[MAXN]; inline void init(const int n) { for (register int i = 0; i &lt; n; i++) a[i] = i, s[i] = 1; } int find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); } inline int getSize(const int x) { return s[find(x)]; } inline void merge(const int x, const int y) { const register int p = find(x), q = find(y); a[p] = q; s[q] += s[p]; } } ufs; struct SegmentTree { int l, r; SegmentTree *lc, *rc; int cnt, refCnt; inline SegmentTree(const int l, const int r, SegmentTree *lc = NULL, SegmentTree *rc = NULL, const int cnt = 0) : l(l), r(r), lc(lc), rc(rc), cnt(cnt), refCnt(1) {} inline static SegmentTree *newNode(); inline static void deleteNode(SegmentTree *v); ~SegmentTree() { if (r - l &lt; 600) return; if (lc &amp;&amp; lc-&gt;unref()) deleteNode(lc); if (rc &amp;&amp; rc-&gt;unref()) deleteNode(rc); } inline SegmentTree *buildChild(const int x) { register int mid = l + (r - l) / 2; if (x &lt;= mid) return new (newNode()) SegmentTree(l, mid, NULL, NULL, 0); else return new (newNode()) SegmentTree(mid + 1, r, NULL, NULL, 0); } SegmentTree *insertSelf(const int x) { cnt++; register int mid = l + (r - l) / 2; if (x == l &amp;&amp; x == r) return this; else if (x &lt;= mid) return (lc = buildChild(x))-&gt;insertSelf(x), this; else return (rc = buildChild(x))-&gt;insertSelf(x), this; } SegmentTree *insert(const int x) { register int mid = l + (r - l) / 2; if (x == l &amp;&amp; x == r) return new (newNode()) SegmentTree(l, r, NULL, NULL, cnt + 1); else if (x &lt;= mid) return new (newNode()) SegmentTree(l, r, lc ? lc-&gt;insert(x) : buildChild(x)-&gt;insertSelf(x), rc ? rc-&gt;ref() : NULL, cnt + 1); else return new (newNode()) SegmentTree(l, r, lc ? lc-&gt;ref() : NULL, rc ? rc-&gt;insert(x) : buildChild(x)-&gt;insertSelf(x), cnt + 1); } inline SegmentTree *ref() { refCnt++; return this; } inline bool unref() { return !--refCnt; } int query(const int l, const int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return cnt; else return lc-&gt;query(l, r) + rc-&gt;query(l, r); } inline int rank() { return lc ? lc-&gt;cnt : 0; } } *segRoot; template &lt;typename T, size_t SIZE&gt; struct MemoryPool { char buf[sizeof(T) * SIZE], *p; T *recycle[SIZE], **pr; inline MemoryPool() : p(buf), pr(recycle) {} inline T *alloc() { if (p == buf + sizeof(T) * SIZE) { if (pr &lt;= recycle) throw std::bad_alloc(); else return *--pr; } else { register char *res = p; p += sizeof(T); return reinterpret_cast&lt;T *&gt;(res); } } inline void free(T *p) { *pr++ = p; } }; MemoryPool&lt;SegmentTree, MAXN * MAXN_LOG * 10&gt; pool; inline SegmentTree *SegmentTree::newNode() { return pool.alloc(); } inline void SegmentTree::deleteNode(SegmentTree *p) { p-&gt;~SegmentTree(); pool.free(p); } struct Node { struct Edge *e; Node *p; int w, ts, d; bool v; SegmentTree *seg; Node *f[MAXN_LOG + 1]; } N[MAXN]; struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {}; }; inline void addEdge(const int u, const int v) { N[u].e = new Edge(&amp;N[u], &amp;N[v]); N[v].e = new Edge(&amp;N[v], &amp;N[u]); } int n, ts, logn = 0; inline void bfs(Node *start, const bool init = true) { ++ts; std::queue&lt;Node *&gt; q; start-&gt;ts = ts; if (init) { start-&gt;p = start-&gt;f[0] = start; start-&gt;seg = segRoot-&gt;insert(start-&gt;w); start-&gt;d = 0; } q.push(start); while (!q.empty()) { Node *v = q.front(); q.pop(); for (register int j = 1; j &lt;= logn; j++) { v-&gt;f[j] = v-&gt;f[j - 1]-&gt;f[j - 1]; } for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;ts != ts &amp;&amp; (init || e-&gt;t != start-&gt;p)) { e-&gt;t-&gt;ts = ts; e-&gt;t-&gt;p = e-&gt;t-&gt;f[0] = v; if (e-&gt;t-&gt;seg) SegmentTree::deleteNode(e-&gt;t-&gt;seg); e-&gt;t-&gt;seg = v-&gt;seg-&gt;insert(e-&gt;t-&gt;w); e-&gt;t-&gt;d = v-&gt;d + 1; q.push(e-&gt;t); } } } inline void bfs() { for (register int i = 0; i &lt; n; i++) if (N[i].ts == 0) bfs(&amp;N[i]); } inline void link(int u, int v) { const register int su = ufs.getSize(u), sv = ufs.getSize(v); if (su &gt; sv) std::swap(u, v); addEdge(u, v); N[u].p = N[u].f[0] = &amp;N[v]; SegmentTree::deleteNode(N[u].seg); N[u].seg = N[v].seg-&gt;insert(N[u].w); N[u].d = N[v].d + 1; bfs(&amp;N[u], false); ufs.merge(u, v); } inline Node *lca(Node *u, Node *v) { if (u-&gt;d &lt; v-&gt;d) std::swap(u, v); if (u-&gt;d != v-&gt;d) { for (register int i = logn; i &gt;= 0; i--) if (u-&gt;f[i]-&gt;d &gt;= v-&gt;d) u = u-&gt;f[i]; } if (u != v) { for (register int i = logn; i &gt;= 0; i--) if (u-&gt;f[i] != v-&gt;f[i]) u = u-&gt;f[i], v = v-&gt;f[i]; return u-&gt;p; } return u; } inline int query(Node *u, Node *v, int k) { Node *p = lca(u, v); register int min = 0, max = n - 1; SegmentTree *sa = u-&gt;seg, *sb = v-&gt;seg, *sc = p-&gt;seg, *sd = p-&gt;p != p ? p-&gt;p-&gt;seg : segRoot; while (min != max) { const register int mid = min + (max - min) / 2; register int t = 0; if (sa) t += sa-&gt;rank(); if (sb) t += sb-&gt;rank(); if (sc) t -= sc-&gt;rank(); if (sd) t -= sd-&gt;rank(); if (k &lt;= t) { if (sa) sa = sa-&gt;lc; if (sb) sb = sb-&gt;lc; if (sc) sc = sc-&gt;lc; if (sd) sd = sd-&gt;lc; max = mid; } else { if (sa) sa = sa-&gt;rc; if (sb) sb = sb-&gt;rc; if (sc) sc = sc-&gt;rc; if (sd) sd = sd-&gt;rc; k -= t, min = mid + 1; } } return min; } int main() { int tc; scanf("%d", &amp;tc); int m, t; scanf("%d %d %d", &amp;n, &amp;m, &amp;t); ufs.init(n); for (; (1 &lt;&lt; (logn + 1)) &lt;= n; logn++); for (register int i = 0; i &lt; n; i++) scanf("%d", &amp;N[i].w); static int set[MAXN]; for (register int i = 0; i &lt; n; i++) set[i] = N[i].w; std::sort(set, set + n); register int *end = std::unique(set, set + n); for (register int i = 0; i &lt; n; i++) N[i].w = std::lower_bound(set, end, N[i].w) - set; segRoot = new SegmentTree(0, n - 1); while (m--) { int u, v; scanf("%d %d", &amp;u, &amp;v), u--, v--; addEdge(u, v); } bfs(); register int lastAns = 0; while (t--) { char cmd[2]; int u, v; scanf("%s %d %d", cmd, &amp;u, &amp;v), u ^= lastAns, v ^= lastAns, u--, v--; if (cmd[0] == 'Q') { int k; scanf("%d", &amp;k); k ^= lastAns; printf("%d\n", lastAns = set[query(&amp;N[u], &amp;N[v], k)]); } else { link(u, v); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>最近公共祖先</tag>
        <tag>主席树</tag>
        <tag>启发式合并</tag>
        <tag>并查集</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2007」最大半连通子图 - 强连通分量]]></title>
    <url>%2Fzjoi2007-semi%2F</url>
    <content type="text"><![CDATA[一个有向图 称为半连通的（Semi-Connected），如果满足： ，满足 或 ，即对于图中任意两点 ，，存在一条 到 的有向路径或者从 到 的有向路径。 若 满足 ， 是 中所有跟 有关的边，则称 是 的一个导出子图。 若 是 的导出子图，且 半连通，则称 为 的半连通子图。 若 是 所有半连通子图中包含节点数最多的，则称 是 的最大半连通子图。 给定一个有向图 ，请求出 的最大半连通子图拥有的节点数 ，以及不同的最大半连通子图的数目 。由于 可能比较大，仅要求输出 对 的余数。 链接 BZOJ 1093 题解 显然，一个强连通分量中的点是半连通的，一条链上的所有点是半连通的。 将原图的强连通分量缩为点，问题转化为求 DAG 上最长路，拓扑排序后 DP 即可。 对于方案统计，求出从起点到每一个点的最长路 后，对于每条边 ，如果 （ 表示点 所对应原图的强连通分量大小），则这条边在一条或多条最长路中，对所有在最长路上的边构成的图求路径数即可。 注意重边需要特判。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;tr1/unordered_set&gt; const int MAXN = 100000; const int MAXM = 1000000; const int MAXX = 100000000; struct Node { struct Edge *e, *c; struct SCC *s; Node *p; bool inStack, pushed, visited; int dfn, low, d, sum; } N[MAXN]; struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {} }; struct SCC { Node v; int size, inDegree, in, len, sum; } S[MAXN]; inline void addEdge(const int s, const int t) { N[s].e = new Edge(&amp;N[s], &amp;N[t]); } int n, x; inline int tarjan() { int cnt = 0, ts = 0; for (int i = 0; i &lt; n; i++) { if (N[i].visited) continue; std::stack&lt;Node *&gt; s, t; s.push(&amp;N[i]); N[i].pushed = true; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; v-&gt;c = v-&gt;e; t.push(v); v-&gt;inStack = true; v-&gt;dfn = v-&gt;low = ++ts; } if (v-&gt;c) { Edge *&amp;e = v-&gt;c; if (e-&gt;t-&gt;inStack) v-&gt;low = std::min(v-&gt;low, e-&gt;t-&gt;dfn); else if (!e-&gt;t-&gt;pushed) e-&gt;t-&gt;pushed = true, e-&gt;t-&gt;p = v, s.push(e-&gt;t); e = e-&gt;next; } else { s.pop(); if (v-&gt;dfn == v-&gt;low) { SCC *scc = &amp;S[cnt++]; scc-&gt;v.s = scc; Node *u; do { u = t.top(); t.pop(); u-&gt;inStack = false; u-&gt;s = scc; scc-&gt;size++; } while (u != v); } if (v-&gt;p) v-&gt;p-&gt;low = std::min(v-&gt;p-&gt;low, v-&gt;low); } } } return cnt; } inline void contract() { std::tr1::unordered_set&lt;unsigned long long&gt; s; for (int i = 0; i &lt; n; i++) { for (Edge *e = N[i].e; e; e = e-&gt;next) { unsigned long long x = (static_cast&lt;unsigned long long&gt;(e-&gt;s-&gt;s - S) &lt;&lt; 32) | static_cast&lt;unsigned long long&gt;(e-&gt;t-&gt;s - S); if (e-&gt;s-&gt;s != e-&gt;t-&gt;s &amp;&amp; !s.count(x)) { s.insert(x); // printf("[%ld, %ld]\n", e-&gt;s-&gt;s - S + 1, e-&gt;t-&gt;s - S + 1); e-&gt;s-&gt;s-&gt;v.e = new Edge(&amp;e-&gt;s-&gt;s-&gt;v, &amp;e-&gt;t-&gt;s-&gt;v); e-&gt;t-&gt;s-&gt;inDegree++; } } } } inline int dp(const int cnt) { std::queue&lt;Node *&gt; q; for (int i = 0; i &lt; cnt; i++) { // printf("size[%d] = %d\n", i, S[i].size); if (S[i].inDegree == 0) q.push(&amp;S[i].v); S[i].v.d = S[i].size; S[i].in = S[i].inDegree; } while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) { e-&gt;t-&gt;d = std::max(e-&gt;t-&gt;d, v-&gt;d + e-&gt;t-&gt;s-&gt;size); if (!--e-&gt;t-&gt;s-&gt;in) { q.push(e-&gt;t); } } } int ans = 0; for (int i = 0; i &lt; cnt; i++) if (!S[i].v.e) ans = std::max(ans, S[i].v.d); return ans; } inline int dpSum(const int cnt, const int d) { std::queue&lt;Node *&gt; q; for (int i = 0; i &lt; cnt; i++) { if (S[i].inDegree == 0) { q.push(&amp;S[i].v); S[i].v.sum = 1; } S[i].in = S[i].inDegree; } while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;t-&gt;d == v-&gt;d + e-&gt;t-&gt;s-&gt;size) (e-&gt;t-&gt;sum += v-&gt;sum) %= x; if (!--e-&gt;t-&gt;s-&gt;in) { q.push(e-&gt;t); } } } int ans = 0; for (int i = 0; i &lt; cnt; i++) if (S[i].v.d == d) (ans += S[i].v.sum) %= x; return ans; } int main() { int m; scanf("%d %d %d", &amp;n, &amp;m, &amp;x); while (m--) { int u, v; scanf("%d %d", &amp;u, &amp;v), u--, v--; addEdge(u, v); } int cnt = tarjan(); contract(); int d = dp(cnt); printf("%d\n", d); printf("%d\n", dpSum(cnt, d)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>缩点</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3280」小 R 的烦恼 - 费用流]]></title>
    <url>%2Fbzoj-3280%2F</url>
    <content type="text"><![CDATA[程设老师最近要进行一项邪恶的实验，这个实验一共持续 天，第 天需要 个研究生来给他搬砖。研究生毕竟也是人，所以雇佣研究生是需要钱的，机智的程设老师已经联系好了 所大学，第 所大学共有 个研究生，同时雇佣这所大学的一个研究生需要 元钱。 一天下来给他搬砖的所有研究生都会进入濒死状态。濒死状态的研究生，毫无疑问，就不能再进行工作了。但是机智的老师早早联系好了 家医院，第 家医院医治一个濒死的研究生需要 天，并且需要 元钱。 链接 BZOJ 3280 题解 建立费用流模型。 为每一天建两个点，一个表示这一天开始时可用的研究生，另一个表示这一天结束时濒死的研究生。两点之间连一条边，流量上下界均为这一天所需的研究生数量 ，费用为零。 显然，第一天雇佣所有的研究生，每一天未使用的研究生留到下一天，和在每一天分别雇佣研究生是等价的。从源点向第一天可用研究生的点连 条边，容量为 ，费用为一个 。 从第 天表示濒死的研究生的点向第 天表示可用研究生的点连一条边，表示医治一些研究生，容量为正无穷，费用为 。 对上下界的处理：从源点到表示每天濒死研究生的点连一条边，容量为 ，从表示每天可用研究生的点向汇点连一条边，容量为 ，最终流量为 则有解。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 50; const int MAXM = 50; const int MAXK = 50; struct Node { struct Edge *e, *in; bool q; int d, f; } N[MAXN * 2 + 2]; struct Edge { Node *s, *t; int f, c, w; Edge *next, *r; Edge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t, const int c, const int w) { N[s].e = new Edge(&amp;N[s], &amp;N[t], c, w); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0, -w); (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } inline void edmondskarp(const int s, const int t, const int n, int &amp;flow, int &amp;cost) { flow = cost = 0; while (1) { for (int i = 0; i &lt; n; i++) { N[i].in = NULL; N[i].q = false; N[i].d = INT_MAX; N[i].f = 0; } std::queue&lt;Node *&gt; q; q.push(&amp;N[s]); N[s].d = 0, N[s].f = INT_MAX; while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;q = false; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;f &lt; e-&gt;c &amp;&amp; e-&gt;t-&gt;d &gt; v-&gt;d + e-&gt;w) { e-&gt;t-&gt;d = v-&gt;d + e-&gt;w; e-&gt;t-&gt;f = std::min(v-&gt;f, e-&gt;c - e-&gt;f); e-&gt;t-&gt;in = e; if (!e-&gt;t-&gt;q) { e-&gt;t-&gt;q = true; q.push(e-&gt;t); } } } if (N[t].d == INT_MAX) return; for (Edge *e = N[t].in; e; e = e-&gt;s-&gt;in) { e-&gt;f += N[t].f; e-&gt;r-&gt;f -= N[t].f; } flow += N[t].f; cost += N[t].f * N[t].d; } } inline void clear(const int n) { for (int i = 0; i &lt; n; i++) { Edge *next; for (Edge *&amp;e = N[i].e; e; next = e-&gt;next, delete e, e = next); } } int main() { int t; scanf("%d", &amp;t); for (int i = 1; i &lt;= t; i++) { int n, m, k; scanf("%d %d %d", &amp;n, &amp;m, &amp;k); const int s = 0, t = n * 2 + 1; int sum = 0; for (int i = 1; i &lt;= n; i++) { int x; scanf("%d", &amp;x); addEdge(i, t, x, 0); addEdge(s, i + n, x, 0); sum += x; if (i != n) addEdge(i, i + 1, INT_MAX, 0); } for (int i = 1; i &lt;= m; i++) { int a, b; scanf("%d %d", &amp;a, &amp;b); addEdge(s, 1, a, b); } for (int i = 1; i &lt;= k; i++) { int a, b; scanf("%d %d", &amp;a, &amp;b), a++; for (int j = 1; j &lt;= n - a; j++) addEdge(j + n, j + a, INT_MAX, b); } int flow, cost; edmondskarp(s, t, n * 2 + 2, flow, cost); printf("Case %d: ", i); if (flow == sum) printf("%d\n", cost); else puts("impossible"); clear(n * 2 + 2); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>Edmonds-Karp</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2007」蜥蜴 - 网络流]]></title>
    <url>%2Fscoi2007-lizard%2F</url>
    <content type="text"><![CDATA[在一个 行 列的网格地图中有一些高度不同的石柱，一些石柱上站着一些蜥蜴，你的任务是让尽量多的蜥蜴逃到边界外。 每行每列中相邻石柱的距离为 ，蜥蜴的跳跃距离是 ，即蜥蜴可以跳到平面曼哈顿距离不超过 的任何一个石柱上。 石柱都不稳定，每次当蜥蜴跳跃时，所离开的石柱高度减 （如果仍然落在地图内部，则到达的石柱高度不变），如果该石柱原来高度为 ，则蜥蜴离开后消失。以后其他蜥蜴不能落脚。 任何时刻不能有两只蜥蜴在同一个石柱上。 链接 BZOJ 1066 题解 网络流，从每个点向所有与其曼哈顿距离在 以内的点连双向边，对每个点设置流量限制为石柱高度，蜥蜴数量减去最大流即为答案。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 20; const int MAXD = 4; struct Node; struct Edge; struct Node { Edge *e, *c; int l; } N[MAXN * MAXN * 2 + 2]; struct Edge { Node *s, *t; int f, c; Edge *next, *r; Edge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s-&gt;e) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;l &amp;&amp; e-&gt;f &lt; e-&gt;c) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } return false; } int findPath(Node *s, Node *t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) if (e-&gt;t-&gt;l == s-&gt;l + 1 &amp;&amp; e-&gt;f &lt; e-&gt;c) { int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c - e-&gt;f)); if (f) { e-&gt;f += f, e-&gt;r-&gt;f -= f; return f; } } return 0; } int operator()(const int s, const int t, const int n) { int res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += f; } return res; } } dinic; inline void addEdge(const int s, const int t, const int c) { // printf("addEdge(%d, %d, %d)\n", s, t, c); N[s].e = new Edge(&amp;N[s], &amp;N[t], c); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0); (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } int n, m; inline int id(const int i, const int j, const int l) { return l * n * m + i * m + j + 1; } int main() { int d; scanf("%d %d %d", &amp;n, &amp;m, &amp;d); /* printf("%d -&gt; %d\n", id(2, 2, 1), id(2, 2, 0)); printf("%d -&gt; %d\n", id(2, 2, 0), id(2, 2, 2)); printf("%d -&gt; %d\n", id(2, 2, 2), id(2, 1, 1)); printf("%d -&gt; %d\n", id(2, 1, 1), id(3, 1, 0)); printf("%d -&gt; %d\n", id(3, 1, 0), id(3, 1, 2)); printf("%d -&gt; %d\n", id(3, 1, 2), id(3, 0, 1)); */ /* for (int h = 0; h &lt;= d; h++) for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) printf("%d\n", id(i, j, h)); printf("t = %d\n", n * m * (d + 1) + 1); return 0; */ const int s = 0, t = n * m * 2 + 1; for (int i = 0; i &lt; n; i++) { static char buf[MAXN + 1]; scanf("%s", buf); for (int j = 0; j &lt; m; j++) { addEdge(id(i, j, 0), id(i, j, 1), buf[j] - '0'); } } int cnt = 0; for (int i = 0; i &lt; n; i++) { static char buf[MAXN + 1]; scanf("%s", buf); for (int j = 0; j &lt; m; j++) { if (buf[j] == 'L') addEdge(s, id(i, j, 0), 1), cnt++; } } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { for (int k = 0; k &lt; n; k++) { for (int l = 0; l &lt; m; l++) { if (abs(i - k) + abs(j - l) &lt;= d) { addEdge(id(i, j, 1), id(k, l, 0), INT_MAX); addEdge(id(k, l, 1), id(i, j, 0), INT_MAX); } } } if (i &lt; d || i &gt; n - d - 1 || j &lt; d || j &gt; m - d - 1) addEdge(id(i, j, 1), t, INT_MAX); } } int ans = dinic(s, t, n * m * 2 + 2); printf("%d\n", cnt - ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2014」旅行 - 树链剖分]]></title>
    <url>%2Fsdoi2014-journey%2F</url>
    <content type="text"><![CDATA[给一棵树，每个点有其初始颜色和权值，每次修改一个点的颜色或权值，查询路径上颜色与起点相同点权值的和或最大值。 链接 BZOJ 3531 题解 树链剖分，对每种颜色单独建立线段树，线段树动态开点、删点，时间复杂度与空间复杂度均为 级别。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; const int MAXN = 1e5; const int MAXQ = 1e5; const int MAXC = 1e5; struct SegmentTree { int l, r, mid; SegmentTree *lc, *rc; int max, sum; SegmentTree(const int l, const int r) : l(l), r(r), mid(l + (r - l) / 2), lc(NULL), rc(NULL), max(0), sum(0) {} void update(const int pos, const int val) { if (l != r) { SegmentTree *&amp;c = pos &lt;= mid ? lc : rc; if (!c) c = (pos &lt;= mid) ? new SegmentTree(l, mid) : new SegmentTree(mid + 1, r); c-&gt;update(pos, val); if (val == 0 &amp;&amp; !c-&gt;lc &amp;&amp; !c-&gt;rc) delete c, c = NULL; max = sum = 0; if (lc) max = std::max(max, lc-&gt;max), sum += lc-&gt;sum; if (rc) max = std::max(max, rc-&gt;max), sum += rc-&gt;sum; } else sum = max = val; } int querySum(const int l, const int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return sum; else return (lc ? lc-&gt;querySum(l, r) : 0) + (rc ? rc-&gt;querySum(l, r) : 0); } int queryMax(const int l, const int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return max; else return std::max(lc ? lc-&gt;queryMax(l, r) : 0, rc ? rc-&gt;queryMax(l, r) : 0); } } *seg[MAXC]; struct Node; struct Edge; struct Node { Edge *e; int d, s, i; bool f; Node *p, *c, *t; } N[MAXN]; struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t) { N[s].e = new Edge(&amp;N[s], &amp;N[t]); N[t].e = new Edge(&amp;N[t], &amp;N[s]); } int n, q, f[MAXN], v[MAXN]; inline void cut() { std::stack&lt;Node *&gt; s; s.push(&amp;N[0]); N[0].d = 1; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;f) { v-&gt;f = true; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;d) { e-&gt;t-&gt;d = v-&gt;d + 1; e-&gt;t-&gt;p = v; s.push(e-&gt;t); } } else { v-&gt;s = 1; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;p == v) { v-&gt;s += e-&gt;t-&gt;s; if (!v-&gt;c || v-&gt;c-&gt;s &lt; e-&gt;t-&gt;s) v-&gt;c = e-&gt;t; } s.pop(); } } s.push(&amp;N[0]); int i = 0; while (!s.empty()) { Node *v = s.top(); if (v-&gt;f) { v-&gt;f = false; v-&gt;i = i++; if (!v-&gt;p || v != v-&gt;p-&gt;c) v-&gt;t = v; else v-&gt;t = v-&gt;p-&gt;t; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;p == v &amp;&amp; e-&gt;t != v-&gt;c) s.push(e-&gt;t); if (v-&gt;c) s.push(v-&gt;c); } else s.pop(); } } inline int querySum(const int u, const int v, SegmentTree *seg) { Node *a = &amp;N[u], *b = &amp;N[v]; int ans = 0; while (a-&gt;t != b-&gt;t) { if (a-&gt;t-&gt;d &lt; b-&gt;t-&gt;d) std::swap(a, b); ans += seg-&gt;querySum(a-&gt;t-&gt;i, a-&gt;i); a = a-&gt;t-&gt;p; } if (a-&gt;d &gt; b-&gt;d) std::swap(a, b); return ans + seg-&gt;querySum(a-&gt;i, b-&gt;i); } inline int queryMax(const int u, const int v, SegmentTree *seg) { Node *a = &amp;N[u], *b = &amp;N[v]; int ans = 0; while (a-&gt;t != b-&gt;t) { if (a-&gt;t-&gt;d &lt; b-&gt;t-&gt;d) std::swap(a, b); ans = std::max(ans, seg-&gt;queryMax(a-&gt;t-&gt;i, a-&gt;i)); a = a-&gt;t-&gt;p; } if (a-&gt;d &gt; b-&gt;d) std::swap(a, b); return std::max(ans, seg-&gt;queryMax(a-&gt;i, b-&gt;i)); } int main() { scanf("%d %d", &amp;n, &amp;q); for (int i = 0; i &lt; MAXC; i++) seg[i] = new SegmentTree(0, n - 1); for (int i = 0; i &lt; n; i++) { scanf("%d %d", &amp;v[i], &amp;f[i]); f[i]--; // printf("seg[%d]-&gt;update(%d, %d)\n", f[i], i, v[i]); // seg[f[i]]-&gt;update(i, v[i]); } for (int i = 0; i &lt; n - 1; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v), u--, v--; addEdge(u, v); } cut(); for (int i = 0; i &lt; n; i++) seg[f[i]]-&gt;update(N[i].i, v[i]); while (q-- ) { char s[3]; int a, b; scanf("%s %d %d", s, &amp;a, &amp;b); if (s[1] == 'C') { a--, b--; seg[f[a]]-&gt;update(N[a].i, 0); seg[b]-&gt;update(N[a].i, v[a]); f[a] = b; } else if (s[1] == 'W') { a--; seg[f[a]]-&gt;update(N[a].i, b); v[a] = b; } else if (s[1] == 'S') { a--, b--; printf("%d\n", querySum(a, b, seg[f[a]])); } else if (s[1] == 'M') { a--, b--; printf("%d\n", queryMax(a, b, seg[f[a]])); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
        <tag>BZOJ</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2008」校门外的区间 - 线段树]]></title>
    <url>%2Fsdoi2008-interval%2F</url>
    <content type="text"><![CDATA[受校门外的树这道经典问题的启发，A 君根据基本的离散数学的知识，抽象出 种运算维护集合 （初始为空）并最终输出 。现在，请你完成这道校门外的树之难度增强版 —— 校门外的区间。 种运算如下： ； 链接 BZOJ 3226 题解 比较容易想到，用线段树维护区间。因为区间端点均为整数，所以对于开区间 ，可以转化为闭区间 ，再两端点同时 ，得到 。 对于每种操作： 对 区间置 ； 对非 区间置 ； 对 区间置 ； 反转整个序列，并将非 区间置 ； 反转 区间。 这两种标记是可以合并的：置 和置 可以替换任何标记，反转叠加在置 上变成置 ，叠加在置 上变成置 ，反转互相叠加可以抵销。 查询时，从根到叶子找到第一个置 或置 ，并记录路径上反转标记的数量。 代码 #include &lt;cstdio&gt; const int MAXN = 65535; const int MAXM = 70000; struct SegmentTree { int l, r, mid; SegmentTree *lc, *rc; enum TagType { Zero, One, Reverse, None } tag; bool val; SegmentTree(const int l, const int r, const int mid, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(mid), lc(lc), rc(rc), tag(None), val(false) {} void setTag(const TagType t) { if (t == Reverse) { if (l == r) val ^= 1; else { if (tag == Reverse) tag = None; else if (tag == Zero) tag = One; else if (tag == One) tag = Zero; else tag = Reverse; } } else { if (l == r) val = t == One; else tag = t; } } void pushDown() { if (tag != None) { lc-&gt;setTag(tag); rc-&gt;setTag(tag); tag = None; } } void update(const int l, const int r, const TagType t) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) setTag(t); else { pushDown(); lc-&gt;update(l, r, t); rc-&gt;update(l, r, t); } } bool query(const int pos) { SegmentTree *v = this; bool rev = false; while (!(v-&gt;l == v-&gt;r || v-&gt;tag == Zero || v-&gt;tag == One)) { if (v-&gt;tag == Reverse) rev ^= 1; v = (pos &lt;= v-&gt;mid) ? v-&gt;lc : v-&gt;rc; } if (v-&gt;tag == Zero) v-&gt;val = false; else if (v-&gt;tag == One) v-&gt;val = true; return rev ? v-&gt;val ^ 1 : v-&gt;val; } static SegmentTree *build(const int l, const int r) { if (l &gt; r) return NULL; else if (l == r) return new SegmentTree(l, r, l, NULL, NULL); else { const int mid = l + (r - l) / 2; return new SegmentTree(l, r, mid, build(l, mid), build(mid + 1, r)); } } /* static bool a[MAXN * 2 + 1]; static void update(const int l, const int r, const TagType t) { if (l &gt; r) return; for (int i = l; i &lt;= r; i++) { if (t == Zero) a[i] = false; else if (t == One) a[i] = true; else if (t == Reverse) a[i] ^= 1; } } static bool query(const int pos) { return a[pos]; } static SegmentTree *build(const int l, const int r) { return NULL; } */ } *segment; // bool SegmentTree::a[MAXN * 2 + 1]; inline void parse(char *s, int &amp;l, int &amp;r) { char ch; bool fl = false; ch = *s++; if (ch == '(') fl = true; l = 0; while ((ch = *s++) != ',') l = l * 10 + ch - '0'; l *= 2; if (fl) l++; r = 0; while ((ch = *s++), (ch &gt;= '0' &amp;&amp; ch &lt;= '9')) r = r * 10 + ch - '0'; r *= 2; if (ch == ')') r--; } inline void print() { int l = -1; bool flag = false; for (int i = 0; i &lt;= MAXN * 2; i++) { bool val = segment-&gt;query(i); if (l == -1 &amp;&amp; val) { l = i; } else if (l != -1 &amp;&amp; !val) { printf("%c%d,%d%c ", l % 2 == 0 ? '[' : '(', l / 2, (i - 1 + 1) / 2, (i - 1) % 2 == 0 ? ']' : ')'); flag = true; l = -1; } } if (l != -1) printf("%c%d,%d%c ", l % 2 == 0 ? '[' : '(', l / 2, MAXN, ']'), flag = true; if (!flag) printf("empty set"); putchar('\n'); } int main() { segment = SegmentTree::build(0, MAXN * 2); char cmd[2], s[100]; while (~scanf("%s %s", cmd, s)) { int l, r; parse(s, l, r); // printf("read: [%d, %d]\n", l, r); if (cmd[0] == 'U') { segment-&gt;update(l, r, SegmentTree::One); } else if (cmd[0] == 'I') { segment-&gt;update(0, l - 1, SegmentTree::Zero); segment-&gt;update(r + 1, MAXN * 2, SegmentTree::Zero); } else if (cmd[0] == 'D') { segment-&gt;update(l, r, SegmentTree::Zero); } else if (cmd[0] == 'C') { segment-&gt;update(0, MAXN * 2, SegmentTree::Reverse); segment-&gt;update(0, l - 1, SegmentTree::Zero); segment-&gt;update(r + 1, MAXN * 2, SegmentTree::Zero); } else if (cmd[0] == 'S') { segment-&gt;update(l, r, SegmentTree::Reverse); } // print(); } print(); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>BZOJ</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在时光的交叉路口 —— 写在 NOI2016 之后]]></title>
    <url>%2Fat-the-cross-of-time%2F</url>
    <content type="text"><![CDATA[.post .post-content .aplayer { margin-top: 20px; } var ap = new APlayer({ element: document.getElementById('aplayer'), narrow: false, autoplay: false, preload: 'metadata', showlrc: 3, mutex: true, theme: '#615754', music: { title: '夢追人', author: 'KOKIA', url: 'https://cdn.menci.xyz/menci-oi-blog/music/mzr/mzr.ogg', pic: 'https://cdn.menci.xyz/menci-oi-blog/music/mzr/mzr.jpg', lrc: 'https://cdn.menci.xyz/menci-oi-blog/music/mzr/mzr.lrc' } }); 高一结束了，作为 OIer 的生活过去一半了，NOI 也是一个多月之前的事了，在这期间一直想着，想要写些什么。一拖再拖，终于拖到了开学前的最后一夜。 NOI 的成绩不怎么好，但相比几位比我优秀，但没有发挥好的伙伴来说，我或许已经足够幸运了。自己作为一个弱者，在不考虑随机条件的影响下，取得这等名次，也是理所当然的吧。 最后的两天，和一位考砸的朋友聊了两个晚上，心里也颇有些感触，当然，这都不能说明什么。比赛都会有竞争，而竞争，就一定会分出强弱。强者是理所应当的胜者，而弱者呢？ 或者说，弱者存在的意义是什么？想想 OIer 们 —— 从入学时的全省几千人，到初赛几百人通过，到联赛几十人拿到省一。百余人参加省选，一轮、二轮，然后十几个人组成省队。最后，全国的这些人中，五十多人拿到金牌 —— 也有上百人空手而归。 如果这样想，竞赛就像一只筛子，每一次选拔，都会筛下一部分人，留下那些更强的，运气更好的，去等待下一次过筛。 事实上就是这样 —— 竞赛确是残酷的，就像极限运动，你很难想象，每一次正式比赛都有可能是你的最后一场，你必须时刻做好告别的心里准备 —— 一场重要比赛的失误足够让你永远失去资格。有时候，你必须承认，那些更强的人，更有理由获得最终的胜利。 一次一次的，最终留下的便是最强的 —— 不至于万里挑一，但这种悬殊已经足够让真正的强者去展现自己。而弱者存在的意义，只是一个陪衬罢了。 这并不是说弱者是完全失败的，更没有否定弱者的价值 —— 奥林匹克精神中便有「重在参与」，虽然每个人心中都有一个金牌梦，但能梦想成真的，每年只有那五十多个 —— 相对于「我一定要拿金牌」这种励志向的话语，你必须有另外的事支撑着你去努力，哪怕最终只能成为一个「陪衬者」。 就像那位第二个到达南极的探险家，一个伟大的悲剧。 当然，这也不是在否定自己成为「强者」、「胜者」的希望，尽管「金牌」看上去很遥远（实际上确实是的），但在你在成绩单上看见一个整天和你谈笑风生的伙伴卡线拿了金牌，你是不是也会感觉到，有些事，似乎从来没有离自己这么近？ 或者说，我们还不够强。 很多 OIer 都常说自己弱，排除谦虚的成分，这就是我们和那些强者的差距。我们知道，只有明白自己弱，才可以尝试去变强，并且，我们在努力。我们不能保证自己最终能走到哪里，但也不会说自己永远无法到达他们的层次。 想到这里，对接下来那段路，还有什么可害怕的呢？ 最后，祝贺各位拿到金牌的同学；祝高三退役的同学们高考顺利；同时，希望我们，我们几个人，能成为下一届省队中的佼佼者。 眼下便是高二的新学期，文化课不可放弃，而 OI 更加重要，在这样一个交叉路口处，希望自己能找到一个平衡罢。晚安。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「NOI2014」魔法森林 - LCT]]></title>
    <url>%2Fnoi2014-forest%2F</url>
    <content type="text"><![CDATA[魔法森林是一个 个节点 条边的无向图，节点标号为 ，边标号为 。初始时小 E 同学在号节点 ，隐士在节点 。 无向图中的每一条边 包含两个权值 与 。若身上携带的 A 型守护精灵个数不少于 ，且 B 型守护精灵个数不少于 ，这条边上的妖怪就发起攻击。 小 E 想要知道，要能够成功拜访到隐士，最少需要携带守护精灵的总个数。 链接 BZOJ 3669 UOJ #3 题解 将边按照 排序，以 作为边权，加入到 LCT 中（每条边拆成一个点和两条边，分别与两个端点相连）。每当出现环时，删除环上 最大的边。每次判断 到 是否连通，更新答案。 注意自环。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;cassert&gt; #include &lt;algorithm&gt; const int MAXN = 50000; const int MAXM = 100000; struct LinkCutTree { struct Node { Node *c[2], *p, *pp, *max; int w; bool rev; Node() : p(NULL), pp(NULL), max(this), w(0) {} int relation() { return this == p-&gt;c[0] ? 0 : 1; } void maintain() { max = this; if (c[0] &amp;&amp; c[0]-&gt;max-&gt;w &gt; max-&gt;w) max = c[0]-&gt;max; if (c[1] &amp;&amp; c[1]-&gt;max-&gt;w &gt; max-&gt;w) max = c[1]-&gt;max; } void pushDown() { if (rev) { std::swap(c[0], c[1]); if (c[0]) c[0]-&gt;rev ^= 1; if (c[1]) c[1]-&gt;rev ^= 1; rev = false; } } void rotate() { std::swap(pp, p-&gt;pp); int r = relation(); Node *o = p; p = o-&gt;p; if (o-&gt;p) o-&gt;p-&gt;c[o-&gt;relation()] = this; o-&gt;c[r] = c[r ^ 1]; if (c[r ^ 1]) c[r ^ 1]-&gt;p = o; c[r ^ 1] = o; o-&gt;p = this; o-&gt;maintain(), maintain(); } void splay() { while (p) { if (p-&gt;p) p-&gt;p-&gt;pushDown(); p-&gt;pushDown(), pushDown(); if (!p-&gt;p) rotate(); else if (p-&gt;relation() == relation()) p-&gt;rotate(), rotate(); else rotate(), rotate(); } pushDown(); } void expose() { splay(); if (c[1]) { std::swap(c[1]-&gt;p, c[1]-&gt;pp); c[1] = NULL; maintain(); } } bool splice() { splay(); if (!pp) return false; pp-&gt;expose(); pp-&gt;c[1] = this; pp-&gt;maintain(); std::swap(p, pp); return true; } void access() { expose(); while (splice()); } void evert() { access(); splay(); rev ^= 1; } } N[MAXN], E[MAXM], *a[MAXM][2]; void link(Node *u, Node *v) { // printf("Linking %ld as %ld's parent.\n", u - N + 1, v - N + 1); v-&gt;evert(); u-&gt;expose(); v-&gt;pp = u; } void link(const int u, const int v, const int i, const int w) { E[i].w = w; a[i][0] = &amp;N[u]; a[i][1] = &amp;N[v]; link(&amp;N[u], &amp;E[i]); link(&amp;E[i], &amp;N[v]); } void cut(Node *u, Node *v) { v-&gt;evert(); v-&gt;expose(); u-&gt;splay(); u-&gt;pp = NULL; } void cut(const int i) { cut(a[i][0], &amp;E[i]); cut(&amp;E[i], a[i][1]); } Node *find(const int u) { Node *v = &amp;N[u]; v-&gt;access(); v-&gt;splay(); if (!v-&gt;c[0]) { // printf("find(%d) = %ld\n", u + 1, v - N + 1); return v; } while (v-&gt;c[0]) v = v-&gt;c[0]; // printf("find(%d) = %ld\n", u + 1, v - N + 1); return v; } bool test(const int u, const int v) { return find(u) == find(v); } int queryMax(const int u, const int v) { N[u].evert(); N[v].access(); N[v].splay(); assert(N[v].max &gt;= E); return N[v].max - E; } } lct; struct Edge { int u, v, a, b; bool operator&lt;(const Edge &amp;other) const { return a &lt; other.a; } } E[MAXM]; int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) scanf("%d %d %d %d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].a, &amp;E[i].b), E[i].u--, E[i].v--; std::sort(E, E + m); int ans = INT_MAX; for (int i = 0; i &lt; m; i++) { Edge &amp;e = E[i]; if (e.u == e.v) continue; if (lct.test(e.u, e.v)) { // printf("[%d, %d, %d, %d] will lead to a circle!\n", e.u + 1, e.v + 1, e.a, e.b); int max = lct.queryMax(e.u, e.v); // printf("max = %d\n", max); if (E[max].b &gt; e.b) { lct.cut(max); lct.link(e.u, e.v, i, e.b); } } else { // printf("Connecting [%d, %d, %d, %d] ...\n", e.u + 1, e.v + 1, e.a, e.b); lct.link(e.u, e.v, i, e.b); } if (lct.test(0, n - 1)) ans = std::min(ans, e.a + E[lct.queryMax(0, n - 1)].b); } printf("%d\n", ans == INT_MAX ? -1 : ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>BZOJ</tag>
        <tag>Link-Cut Tree</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2014」动物园 - KMP]]></title>
    <url>%2Fnoi2014-zoo%2F</url>
    <content type="text"><![CDATA[对于字符串 的前 个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作 ，求 链接 BZOJ 3670 UOJ #5 题解 考虑简化问题，去除「该后缀与该前缀不重叠」的限制后，问题变成了一个简单的 DP —— 。 考虑限制条件 —— 我们需要对 数组设置同样的限制条件，并设其为 。然后对于带限制的 （设为 ），发现 并不成立，观察后可发现 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; const int MAXT = 5; const int MAXN = 1000000; const unsigned long long MOD = 1000000007; int n, next[MAXN + 1], next2[MAXN + 1], num[MAXN + 1], num2[MAXN + 1]; char s[MAXN + 1]; inline unsigned long long kmp() { next[0] = next[1] = num[0] = num[1] = 0; for (int i = 2, t = 0, k = 0; i &lt;= n; i++) { while (t &amp;&amp; s[t] != s[i - 1]) t = next[t]; while ((k &amp;&amp; s[k] != s[i - 1]) || k &gt;= i / 2) k = next[k]; if (s[k] == s[i - 1]) num2[i] = num[++k] + 1; else num2[i] = 0; if (s[t] == s[i - 1]) next[i] = ++t, num[i] = num[t] + 1; else next[i] = num[i] = 0; } // for (int i = 1; i &lt;= n; i++) printf("%d%c", f[i], i == n ? '\n' : ' '); // for (int i = 1; i &lt;= n; i++) printf("%d%c", num[i], i == n ? '\n' : ' '); // for (int i = 1; i &lt;= n; i++) printf("%d%c", num2[i], i == n ? '\n' : ' '); unsigned long long ans = 1; for (int i = 1; i &lt;= n; i++) (ans *= (num2[i] + 1)) %= MOD; return ans; } int main() { int t = 1; scanf("%d", &amp;t); while (t--) { scanf("%s", s); n = strlen(s); printf("%llu\n", kmp()); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>KMP</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4145」The Prices - 状压 DP]]></title>
    <url>%2Fbzoj-4145%2F</url>
    <content type="text"><![CDATA[你要购买 种物品各一件，一共有 家商店，你到第 家商店的路费为 ，在第 家商店购买第 种物品的费用为 ，求最小总费用。 链接 BZOJ 4145 题解 将所有的物品压进一个二进制集合中，用 表示已经尝试了前 个商店，已购买物品集合为 的最小总费用。 使用类似背包的方式枚举每个物品转移即可。 代码 #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;queue&gt; #include &lt;utility&gt; const int maxn = 100; const int maxm = 16; const int maxstatus = 1 &lt;&lt; 16; int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); static int c[maxn][maxm], d[maxn]; for (int i = 0; i &lt; n; i++) { scanf("%d", &amp;d[i]); for (int j = 0; j &lt; m; j++) scanf("%d", &amp;c[i][j]); } static int f[maxn][maxstatus]; for (int j = 0; j &lt; (1 &lt;&lt; m); j++) { f[0][j] = d[0]; for (int k = 0; k &lt; m; k++) { if (j &amp; (1 &lt;&lt; k)) f[0][j] += c[0][k]; } } f[0][0] = 0; for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; (1 &lt;&lt; m); j++) f[i][j] = f[i - 1][j] + d[i]; for (int j = 0; j &lt; (1 &lt;&lt; m); j++) { for (int k = 0; k &lt; m; k++) { if (j &amp; (1 &lt;&lt; k)) f[i][j] = std::min(f[i][j], f[i][j ^ (1 &lt;&lt; k)] + c[i][k]); } } for (int j = 0; j &lt; (1 &lt;&lt; m); j++) f[i][j] = std::min(f[i][j], f[i - 1][j]); // , printf("f[%d][%d] = %d\n", i, j, f[i][j]); } printf("%d\n", f[n - 1][(1 &lt;&lt; m) - 1]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>状压 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4247」挂饰 - 背包 DP]]></title>
    <url>%2Fbzoj-4247%2F</url>
    <content type="text"><![CDATA[JOI 君有 个装在手机上的挂饰，编号为 。JOI君可以将其中的一些装在手机上。 一些挂饰附有可以挂其他挂件的挂钩。每个挂件要么直接挂在手机上，要么挂在其他挂件的挂钩上。直接挂在手机上的挂件最多有 个。此外，每个挂件有一个安装时会获得的喜悦值，用一个整数（可以为负）来表示。 JOI 君想要最大化所有挂饰的喜悦值之和。注意不必要将所有的挂钩都挂上挂饰，而且一个都不挂也是可以的。 链接 BZOJ 4247 题解 允许背包容量为负，做一次背包，答案取背包容量为 到 时结果的最大值。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 2000; int main() { int n; scanf("%d", &amp;n); static struct Array { int a[MAXN * 2 + 1]; int &amp;operator[](const int i) { return a[i + MAXN]; } } f[MAXN + 1]; for (int i = -n; i &lt; 0; i++) f[0][i] = INT_MIN; for (int i = 1; i &lt;= n; i++) { int x, v; scanf("%d %d", &amp;x, &amp;v); const int w = 1 - x; for (int j = -n; j &lt;= n; j++) { if (j - w &gt;= -n &amp;&amp; j - w &lt;= n &amp;&amp; f[i - 1][j - w] != INT_MIN) f[i][j] = std::max(f[i - 1][j], f[i - 1][j - w] + v); else if (j - w &gt; n) f[i][j] = std::max(f[i - 1][j], f[i - 1][n] + v); else f[i][j] = f[i - 1][j]; // printf("f[%d][%d] = %d\n", i, j, f[i][j]); } } int ans = 0; for (int i = -n; i &lt;= 1; i++) ans = std::max(ans, f[n][i]); printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>背包 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HEOI2013」Eden 的新背包问题 - 背包 DP]]></title>
    <url>%2Fheoi2013-bag%2F</url>
    <content type="text"><![CDATA[有 个玩偶，每个玩偶有对应的价值、价钱，每个玩偶都可以被买有限次，在携带的价钱 固定的情况下，如何选择买哪些玩偶以及每个玩偶买多少个，才能使得选择的玩偶总价钱不超过 ，且价值和最大。 多次询问，每次询问都将给出新的总价钱，并且会去掉某个玩偶（即这个玩偶不能被选择），再问此时的多重背包的答案。 链接 BZOJ 3163 题解 用 表示第 件及其之前物品装进容量为 的背包中的最大收益；用 表示第 件及其之后物品装进容量为 的背包中的最大收益； 对于无法选择 物品，背包容量为 ，答案为 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;utility&gt; const int MAXN = 1000; const int MAXM = 1000; const int MAXLOGN = 10; const int MAXQ = 300000; int main() { int n; static int w[MAXN], v[MAXN], cnt[MAXN]; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%d %d %d", &amp;w[i], &amp;v[i], &amp;cnt[i]); static std::pair&lt;int, int&gt; r[MAXN]; static int W[MAXN * MAXLOGN], V[MAXN * MAXLOGN]; int N = 0; for (int i = 0; i &lt; n; i++) { r[i].first = N + 1; for (int j = 1; j &lt;= cnt[i]; cnt[i] -= j, j *= 2) { // for (int j = 1; cnt[i]; cnt[i]--) { N++; W[N] = w[i] * j; V[N] = v[i] * j; } if (cnt[i]) { N++; W[N] = w[i] * cnt[i]; V[N] = v[i] * cnt[i]; } r[i].second = N; } static int f[MAXN * MAXLOGN + 1][MAXM + 1], g[MAXN * MAXLOGN + 2][MAXM + 1]; // for (int i = 0; i &lt;= N; i++) f[i][0] = 1; // for (int i = 1; i &lt;= N + 1; i++) g[i][0] = 1; for (int i = 1; i &lt;= N; i++) { for (int j = 0; j &lt;= MAXM; j++) { if (j &lt; W[i]) f[i][j] = f[i - 1][j]; else f[i][j] = std::max(f[i - 1][j], f[i - 1][j - W[i]] + V[i]); } } for (int i = N; i &gt;= 1; i--) { for (int j = 0; j &lt;= MAXM; j++) { if (j &lt; W[i]) g[i][j] = g[i + 1][j]; else g[i][j] = std::max(g[i + 1][j], g[i + 1][j - W[i]] + V[i]); } } int q; scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++) { int id, m; scanf("%d %d", &amp;id, &amp;m); int ans = 0, a = r[id].first - 1, b = r[id].second + 1; for (int j = 0; j &lt;= m; j++) ans = std::max(ans, f[a][j] + g[b][m - j]); printf("%d\n", ans); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>背包 DP</tag>
        <tag>HEOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2008」魔兽地图 - 背包 DP]]></title>
    <url>%2Fjsoi2008-dotr%2F</url>
    <content type="text"><![CDATA[游戏中，一些装备有价格，可以无限购买；另一些装备需要其它装备合成，这些装备有合成次数限制。每个装备都有膜法值，求 个金币最多能得到多少膜法值的装备。 链接 BZOJ 1017 题解 对于每个装备， 表示先获取 个用于合成其它装备，一共最多用 个金币，的最大收益。 对于需要合成的装备，用 表示前 棵子树用 个金币的最大收益。用类似背包的方法转移。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;climits&gt; #include &lt;queue&gt; const int MAXN = 51; const int MAXM = 2000; const int MAXK = 100; struct Node; struct Edge; struct Node { Edge *e; int cnt, cost, val, ind; bool basic; // , visited; int f[MAXK + 1][MAXM + 1]; } N[MAXN], *seq[MAXN]; struct Edge { Node *s, *t; int w; Edge *next; Edge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t, const int w) { // printf("E(%d, %d, %d)\n", s, t, w); N[t].ind++; N[s].e = new Edge(&amp;N[s], &amp;N[t], w); } int n, m, ans; inline void bfs() { int pos = n; for (int i = 0; i &lt; n; i++) { if (N[i].ind) continue; // printf("%d\n", i); std::queue&lt;Node *&gt; q; q.push(&amp;N[i]); // N[i].visited = true; while (!q.empty()) { for (Edge *e = (seq[--pos] = q.front())-&gt;e; e; e = e-&gt;next) q.push(e-&gt;t); // , e-&gt;t-&gt;visited = true; q.pop(); } } } inline void dp1() { for (int i = 0; i &lt; n; i++) { Node *&amp;v = seq[i]; if (!v-&gt;basic) { v-&gt;cnt = INT_MAX; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { v-&gt;cnt = std::min(v-&gt;cnt, e-&gt;t-&gt;cnt / e-&gt;w); v-&gt;cost += e-&gt;t-&gt;cost * e-&gt;w; } v-&gt;cnt = std::min(v-&gt;cnt, m / v-&gt;cost); } } } inline void dp2() { for (int i = 0; i &lt; n; i++) { Node *&amp;v = seq[i]; int (&amp;f)[MAXK + 1][MAXM + 1] = v-&gt;f; static int g[MAXN + 1][MAXM + 1]; if (v-&gt;basic) { for (int i = 0; i &lt;= v-&gt;cnt; i++) { for (int j = v-&gt;cost * i; j &lt;= m; j++) { f[i][j] = std::max(f[i][j], std::min(v-&gt;cnt - i, (j - v-&gt;cost * i) / v-&gt;cost) * v-&gt;val); } } } else { for (int i = 0; i &lt;= v-&gt;cnt; i++) { // memset(g, 0, sizeof(g)); for (int i = 0; i &lt;= MAXN; i++) for (int j = 0; j &lt;= MAXM; j++) g[i][j] = i == 0 ? 0 : INT_MIN; // if (!v-&gt;e) { /* for (int j = 0; j &lt;= i; j++) { for (int k = v-&gt;cost * i; k &lt;= m; k++) { f[j][k] = std::max(f[j][k], v-&gt;val * (i - j)); } } */ // } else { // for (int j = v-&gt;cost * i; j &lt;= m; j++) g[j] = v-&gt;val * i; int id = 0; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { id++; for (int j = m; j &gt;= 0; j--) { for (int k = i * e-&gt;w * e-&gt;t-&gt;cost; k &lt;= j; k++) { g[id][j] = std::max(g[id][j], g[id - 1][j - k] + e-&gt;t-&gt;f[e-&gt;w * i][k]); // if (j - k * e-&gt;t-&gt;cost &gt;= v-&gt;cost * i) g[i][j] = std::max(g[i][j], g[i][j - k * e-&gt;t-&gt;cost]); } } // printf("g[%d][%d] = %d\n", i, j, g[i][j]); } for (int j = 0; j &lt;= i; j++) { for (int k = v-&gt;cost * i; k &lt;= m; k++) { f[j][k] = std::max(f[j][k], g[id][k] + (i - j) * v-&gt;val); ans = std::max(ans, f[j][k]); } } } } } } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) { scanf("%d", &amp;N[i].val); char s[2]; scanf("%s", s); if (s[0] == 'B') { scanf("%d %d", &amp;N[i].cost, &amp;N[i].cnt); N[i].basic = true; } else { int t; scanf("%d", &amp;t); while (t--) { int u, w; scanf("%d %d", &amp;u, &amp;w), u--; addEdge(i, u, w); } } } bfs(); dp1(); dp2(); printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>背包 DP</tag>
        <tag>JSOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2009」粉刷匠 - 背包 DP]]></title>
    <url>%2Fscoi2009-paint%2F</url>
    <content type="text"><![CDATA[windy 有 条木板需要被粉刷。每条木板被分为 个格子。每个格子要被刷成红色或蓝色。windy 每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。每个格子最多只能被粉刷一次。如果 windy 只能粉刷 次，他最多能正确粉刷多少格子？ 一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。 链接 BZOJ 1296 题解 对于每一行，用 表示前 个格子刷 次的最大正确数量。枚举最后一次刷的区间，刷较多的颜色。 用 表示第 行刷 次的最大正确数量。最后用背包求解即可。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 50; const int MAXM = 50; const int MAXT = 2500; int main() { int n, m, t; scanf("%d %d %d", &amp;n, &amp;m, &amp;t); static int w[MAXN][MAXM + 1], f[MAXM + 1][MAXM + 1]; for (int i = 0; i &lt; n; i++) { memset(f, 0, sizeof(f)); static char s[MAXM + 1]; scanf("%s", s); for (int j = 1; j &lt;= m; j++) { for (int k = 1; k &lt;= j; k++) { int cnt[2] = { 0, 0 }; for (int l = j - 1; l &gt;= k - 1; l--) { cnt[s[l] - '0']++; f[j][k] = std::max(f[j][k], f[l][k - 1] + std::max(cnt[0], cnt[1])); w[i][k] = std::max(w[i][k], f[j][k]); } // printf("f[%d][%d][%d] = %d\n", i, j, k, f[j][k]); } } // for (int j = 1; j &lt;= m; j++) printf("w[%d][%d] = %d\n", i, j, w[i][j]); } static int g[MAXT + 1]; for (int i = 0; i &lt; n; i++) { for (int j = t; j &gt;= 0; j--) { for (int k = 1; k &lt;= m; k++) { if (k &lt;= j) g[j] = std::max(g[j], g[j - k] + w[i][k]); } } } printf("%d\n", g[t]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>背包 DP</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1334」Elect - 背包 DP]]></title>
    <url>%2Fbzoj-1334%2F</url>
    <content type="text"><![CDATA[个政党要组成一个联合内阁，每个党都有自己的席位数。现在希望你找出一种方案，你选中的党的席位数要大于总数的一半，并且联合内阁的席位数越多越好。对于一个联合内阁，如果某个政党退出后，其它党的席位仍大于总数的一半，则这个政党被称为是多余的，这是不允许的。 链接 BZOJ 1334 题解 一个显然的结论是，只要当席位最少的党是多余的，这个方案就一定不合法。 使用类似背包的方法，设 表示联合内阁席位数为 时，席位最少的党的席位数的最大值。 完成 DP 后扫描整个数组，满足 的最大的 即为答案。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 300; const int MAXM = 100000; int main() { int n; scanf("%d", &amp;n); static int a[MAXN + 1]; int m = 0; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), m += a[i]; static int f[MAXM + 1]; f[0] = INT_MAX; for (int i = 1; i &lt;= n; i++) { for (int j = m; j &gt;= a[i]; j--) { f[j] = std::max(f[j], std::min(f[j - a[i]], a[i])); } } int ans = 0; for (int i = m; i &gt;= 0; i--) { if (i - f[i] &lt;= m / 2) { ans = i; break; } } printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>背包 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2010」合唱队 - 区间 DP]]></title>
    <url>%2Fhnoi2010-chorus%2F</url>
    <content type="text"><![CDATA[合唱队的排队方式为： 第一个人直接插入空的队形中； 对于第二个人开始的每一个人，如果他比上一个人高，则站到最右边，否则站到最左边。 求对于某一个排好的序列，可以被多少种初始序列构建出，答案对任意数取模。 链接 BZOJ 1996 题解 显然，某一个人是站在前面还是后面，只与上一个人有关。对于一个区间，考虑最后一个站进去的人，一定是最左边或者最右边的，并且这个人站在哪里，受到子区间两端的人的影响。 假设区间 中最后一个人 站在最右边，即 比 的最后一个人要高。即，区间 中，站在两边的比 矮的人都有可能是最后一个站进去的。 设 表示 内，按照 的方式确定最后一个人是否可放在最左边或最右边，的方案总数。 代码 #include &lt;cstdio&gt; const int MAXN = 1000; const int MOD = 19650827; const int DP_L = 0; const int DP_R = 1; const int DP_LR = 2; int n, a[MAXN]; inline int dp(const int l, const int r, const int flag) { static int mem[MAXN][MAXN][3]; static bool calced[MAXN][MAXN][3]; int &amp;ans = mem[l][r][flag]; if (calced[l][r][flag]) return ans; calced[l][r][flag] = true; if (r - l + 1 == 2) { if (a[l] &gt; a[r]) return ans = 0; else if (flag == DP_LR) return ans = 2; else return ans = 1; } if (flag != DP_L) { const int L = l, R = r - 1; if (a[r] &gt; a[L] &amp;&amp; a[r] &gt; a[R]) ans += dp(L, R, DP_LR); else if (a[r] &gt; a[L]) ans += dp(L, R, DP_L); else if (a[r] &gt; a[R]) ans += dp(L, R, DP_R); } if (flag != DP_R) { const int L = l + 1, R = r; if (a[l] &lt; a[L] &amp;&amp; a[l] &lt; a[R]) ans += dp(L, R, DP_LR); else if (a[l] &lt; a[L]) ans += dp(L, R, DP_L); else if (a[l] &lt; a[R]) ans += dp(L, R, DP_R); } return ans %= MOD; } int main() { scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); printf("%d\n", dp(0, n - 1, DP_LR)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>HNOI</tag>
        <tag>区间 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2003」字符串折叠 - 区间 DP]]></title>
    <url>%2Fscoi2003-fold%2F</url>
    <content type="text"><![CDATA[折叠的定义如下： 一个字符串可以看成它自身的折叠。 是 个 连接在一起的串的折叠。 如果 是 的折叠， 是 的折叠，则 是 的折叠。 给一个字符串，求它的最短折叠。 链接 BZOJ 1090 题解 设 为 区间内字符串的最短折叠。 四种转移： 自身的长度 ； 枚举左边前缀的长度，将前缀向右匹配，将第一个失配点右边作为一个子区间处理； 枚举右边后缀的长度，将后缀向左匹配，将第一个失配点左边作为一个子区间处理； 枚举断点，将区间分成两个处理。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 100; int n; char s[MAXN + 1]; inline int numberLength(int x) { int res = 0; do res++; while (x /= 10); return res; } inline int dp(const int l, const int r) { static int mem[MAXN][MAXN]; static bool calced[MAXN][MAXN]; int &amp;ans = mem[l][r]; if (calced[l][r]) return ans; calced[l][r] = true; if (l == r) return ans = 1; else if (l &gt; r) return ans = 0; ans = r - l + 1; for (int i = 1; i &lt;= r - l + 1; i++) { int base = dp(l, l + i - 1); int pos = l + i, cnt = 1; while (pos + i - 1 &lt;= r &amp;&amp; strncmp(s + l, s + pos, i) == 0) pos += i, cnt++; ans = std::min(ans, dp(pos, r) + numberLength(cnt) + 2 + base); } for (int i = 1; i &lt;= r - l + 1; i++) { int base = dp(r - i + 1, r); int pos = r - i - i + 1, cnt = 1; while (pos &gt;= l &amp;&amp; strncmp(s + r - i + 1, s + pos, i) == 0) pos -= i, cnt++; ans = std::min(ans, dp(l, pos + i - 1) + numberLength(cnt) + 2 + base); } for (int i = 1; i &lt;= r - l + 1 - 1; i++) { ans = std::min(ans, dp(l, i) + dp(i + 1, r)); } // printf("dp(%d, %d) = %d\n", l, r, ans); return ans; } int main() { scanf("%s", s); n = strlen(s); printf("%d\n", dp(0, n - 1)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>区间 DP</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2008」玩具取名 - 区间 DP]]></title>
    <url>%2Fhaoi2008-name%2F</url>
    <content type="text"><![CDATA[某人有一套玩具，并想法给玩具命名。首先他选择 WING 四个字母中的任意一个字母作为玩具的基本名字。然后他会根据自己的喜好，将名字中任意一个字母用 WING 中任意两个字母代替，使得自己的名字能够扩充得很长。 现在，他想请你猜猜某一个很长的名字，最初可能是由哪几个字母变形过来的。 链接 BZOJ 1055 题解 用四个二进制位表示一个名字可能由哪些字母变形而来。设 表示 这段区间能由哪些字母变形而来。枚举断点，并枚举左右区间可能由哪些字母变形而来，推出整个区间的答案。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; const int MAXN = 200; const int K = 4; int n, a[MAXN]; bool map[K][K][K]; inline int id(const char ch) { switch (ch) { case 'W': return 0; case 'I': return 1; case 'N': return 2; case 'G': return 3; default: return -1; } } inline char letter(const int x) { return ("WING")[x]; } inline void setMap(const int x, const int n) { for (int i = 0; i &lt; n; i++) { char s[3]; scanf("%s", s); map[id(s[0])][id(s[1])][x] = true; } } inline int dp(const int l, const int r) { static int mem[MAXN][MAXN]; int &amp;ans = mem[l][r]; static bool calced[MAXN][MAXN]; if (calced[l][r]) return ans; calced[l][r] = true; if (l == r) return ans = 1 &lt;&lt; a[l]; for (int i = l; i &lt; r; i++) { const int a = dp(l, i), b = dp(i + 1, r); for (int i = 0; i &lt; K; i++) if (a &amp; (1 &lt;&lt; i)) for (int j = 0; j &lt; K; j++) if (b &amp; (1 &lt;&lt; j)) { for (int k = 0; k &lt; K; k++) if (map[i][j][k]) ans |= 1 &lt;&lt; k; } } // printf("dp(%d, %d) = %d\n", l, r, ans); return ans; } int main() { int cnt[K]; for (int i = 0; i &lt; K; i++) scanf("%d", &amp;cnt[i]); for (int i = 0; i &lt; K; i++) setMap(i, cnt[i]); static char s[MAXN + 1]; scanf("%s", s); n = strlen(s); for (int i = 0; i &lt; n; i++) a[i] = id(s[i]); int res = dp(0, n - 1); bool flag = false; for (int i = 0; i &lt; K; i++) if (res &amp; (1 &lt;&lt; i)) putchar(letter(i)), flag = true; if (flag) putchar('\n'); else puts("The name is wrong!"); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>HAOI</tag>
        <tag>区间 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2015」寿司晚宴 - 状压 DP]]></title>
    <url>%2Fnoi2015-dinner%2F</url>
    <content type="text"><![CDATA[给定 ~ 这 个数，让两个人分别选出一些数，使得对于第一个人选择的任意一个数 和第二个人选择的任意一个数 ，有 ，求方案数。 链接 BZOJ 4197 UOJ #129 题解 因为题目要求的条件不互质就是指没有相同的质因子，一个显然的思路是求出这些数的所有质因子，用 （、 为二进制集合）表示第一个人选择的质因子集合为 、第二个人为 的方案数。 但是这些数的质因子太多，无法进行状压，如果我们不考虑每个数 的（最多一个的）大于 的质因子，则质因子只有 个 —— ，将这些质因子状压。 考虑另一个质因子的影响，设它为 ，则如果一个人选了一个含有质因子 的数，另一个人不能选取任何含有质因子 的数。 将所有数按照 分组，对于每一组，以二进制集合的方式储存其所有数的其它质因子，设第 个数为 。一组数中，最多由某一个人选若干个。 设 表示不选当前组的情况下，第一个人所选集合为 ，第二个人所选集合为 的方案总数。 对于每一个集合，设 表示组内前 个数，全部由第 个人来选，第一个人所选集合为 ，第二个人所选集合为 的方案总数。 转移时，枚举组内每个数 ，分别以 和 更新 和 。 注意到枚举 和 时，所枚举到的 或 均为 或 的字集，体现在十进制意义下，即 、。这启发我们可以像背包一样，滚动掉第一维 ，从大到小枚举 和 ，同时刷表更新 和 。 最后一个问题，对于每个没有大于 的因子的数 ，将这些数每个单独分一组即可。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;utility&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; const int MAXN = 500; const int MAXK = 8; const int MAXSTAT = 1 &lt;&lt; 8; const int PRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19 }; int main() { int n, p; scanf("%d %d", &amp;n, &amp;p); std::vector&lt; std::vector&lt;int&gt; &gt; v; std::vector&lt; std::pair&lt;int, int&gt; &gt; tmp; for (int i = 2; i &lt;= n; i++) { int x = i, t = 0; for (int j = 0; j &lt; 8; j++) { if (x % PRIMES[j] == 0) { while (x % PRIMES[j] == 0) x /= PRIMES[j]; t |= 1 &lt;&lt; j; } } tmp.push_back(std::make_pair(x, t)); } std::sort(tmp.begin(), tmp.end()); for (std::vector&lt; std::pair&lt;int, int&gt; &gt;::const_iterator it = tmp.begin(); it != tmp.end(); it++) { if (it == tmp.begin() || it-&gt;first == 1 || it-&gt;first != (it - 1)-&gt;first) { v.resize(v.size() + 1); } v.back().push_back(it-&gt;second); } static int f[MAXSTAT][MAXSTAT], g[2][MAXSTAT][MAXSTAT]; f[0][0] = 1; for (std::vector&lt; std::vector&lt;int&gt; &gt;::const_iterator it = v.begin(); it != v.end(); it++) { memcpy(g[0], f, sizeof(f)); memcpy(g[1], f, sizeof(f)); // puts("new"); for (std::vector&lt;int&gt;::const_iterator it2 = it-&gt;begin(); it2 != it-&gt;end(); it2++) { // printf("%d\n", *it2); for (int a = MAXSTAT - 1; a &gt;= 0; a--) { for (int b = MAXSTAT - 1; b &gt;= 0; b--) { // printf("%d %d\n", a, b); if (!(b &amp; *it2)) /* printf("[0] += %d\n", g[0][a][b]), */ (g[0][a | (*it2)][b] += g[0][a][b]) %= p; if (!(a &amp; *it2)) /* printf("[1] += %d\n", g[1][a][b]), */ (g[1][a][b | (*it2)] += g[1][a][b]) %= p; // printf("%d\n", *it2); // printf("%d %d\n", g[0][a][b], g[1][a][b]); } } } for (int a = MAXSTAT - 1; a &gt;= 0; a--) { for (int b = MAXSTAT - 1; b &gt;= 0; b--) { f[a][b] = ((g[0][a][b] + g[1][a][b] - f[a][b]) % p + p) % p; } } } int ans = 0; for (int a = MAXSTAT - 1; a &gt;= 0; a--) { for (int b = MAXSTAT - 1; b &gt;= 0; b--) { if (!(a &amp; b)) (ans += f[a][b]) %= p; } } printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>背包 DP</tag>
        <tag>状压 DP</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2015」荷马史诗 - 哈夫曼树]]></title>
    <url>%2Fnoi2015-epic%2F</url>
    <content type="text"><![CDATA[有 种不同的单词，从 到 进行编号。其中第 种单词出现的总次数为 。要用 进制串 来替换第 种单词，满足对于任意的 ，都有： 不是 的前缀。 替换以后得到的新的长度最小为多少； 在确保总长度最小的情况下，最长的 的最短长度是多少？ 链接 BZOJ 4198 UOJ #130 题解 考虑当 时，其最优化条件相当于哈夫曼树，即：将所有单词作为一棵树放在集合中，每次取出两个最小的合并起来，放回集合，直到集合中只剩下一个元素。 显然， 时，将「两个最小的」换成「 个」即可。 考虑第二个条件，使最长的 最短。在哈夫曼树算法中 的长度体现在一个节点被合并的次数上，只需要将每一个节点被合并的次数作为第二关键字即可。 最后一个问题，如果每次取出 个，加入 个，最后不够 个怎么办。考虑到每次减少了 个，需要将 个减掉 —— 只需加入一些空节点（）使 即可。 代码 #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;utility&gt; const int MAXN = 100000; const int MAXK = 9; int main() { int n, k; scanf("%d %d", &amp;n, &amp;k); std::priority_queue&lt; std::pair&lt;long long, int&gt;, std::vector&lt; std::pair&lt;long long, int&gt; &gt;, std::greater&lt; std::pair&lt;long long, int&gt; &gt; &gt; q; for (int i = 0; i &lt; n; i++) { long long x; scanf("%lld", &amp;x); q.push(std::make_pair(x, 0)); } while ((q.size() - 1) % (k - 1) != 0) q.push(std::make_pair(0, 0)); long long ans = 0; while (q.size() &gt; 1) { std::pair&lt;long long, int&gt; newNode; for (int i = 0; i &lt; k; i++) { std::pair&lt;long long, int&gt; p = q.top(); q.pop(); ans += p.first; newNode.first += p.first; newNode.second = std::max(newNode.second, p.second); } newNode.second++; q.push(newNode); } std::pair&lt;long long, int&gt; p = q.top(); printf("%lld\n%d\n", ans, p.second); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>BZOJ</tag>
        <tag>NOI</tag>
        <tag>堆</tag>
        <tag>哈夫曼树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2015」小园丁与老司机 - DP + 上下界网络流]]></title>
    <url>%2Fnoi2015-farm%2F</url>
    <content type="text"><![CDATA[在坐标系的第一象限内有 个点。 从原点开始，每次向左、右、上、左上 、右上 任意一个方向走到第一个未到过的点，重复这个过程，求最多能经过多少点； 求 (1) 中的一个最优方案； 对于 (1) 中的所有最优方案，其所有上、左上 、右上 的边组成了一个 DAG，求该 DAG 的可重叠最小路径覆盖。 链接 BZOJ 4200 UOJ #132 题解 第一问 我们可以发现，对于两个点 和 ，如果 ，则它们在同一行，如果 或 ，说明它们在同一对角线上。 记录每一行、每一主对角线、每一副对角线上的点，并进行排序，处理行之间的转移时，可以直接由这些方向上前一个点转移而来。 显而易见的两个结论： 除最后一行外，同一行的若干次移动完成后，一定继续移动到上面的某一行上； 每一行内，任意两个点都可以通过左右移动到达。 这为我们提供了一个计算顺序 —— 对于每一行，先计算出每个点向上移动的最多步数，再计算同一行以每个点开始到另一个点最多移动的步数，取最大值。 但是，这样做时间复杂度太高，需要优化。考虑到对于同一行的两个点 、（ 在 左侧），从 到达 的最优方案为：先从 经过若干个点移动到一行中的最左端点，然后移动到 右边最近的点，继续向右移动到 。 打出从 到达 的最多步数表可以发现，当 增大 时，到所有 的步数，只有两个会改变： 1 2 3 4 5 5 0 1 2 3 4 4 0 3 0 2 0 1 0 使用线段树维护当前点到 的步数加 向上走的最大步数，可以在 的时间内求出每个点的结果。 算上排序，第一问的总时间复杂度为 。 第二问 要求出一种方案，我们可以在第一问的转移中记录每个状态的前驱。不同行间的转移可以直接找到前驱，同一行内的转移需要找到行内的目标点后，模拟出走到行首（行尾）后走回目标点的过程。 一个细节是如何判断应该向上走还是走同一行。如果上一次走了同一行到达当前点，那么这一次一定向上走，否则可能会死循环。 第三问 要求出所有方案中可能的上、左上、右上的边。 从源点的一行开始向上考虑。对于每一行，枚举所有从下面转移过来的点，在与第一问相同的线段树上为所有最大值的点打标记，枚举完一整行后，取出所有被打标记的点，并以这些点开始向上继续考虑。枚举三个方向，对于可以取得最大值的方向，在网络上连一条流量下界为 ，上界为 的边，并对这些方向上的目标点打上标记。 最终，网络的最小可行流为第三问答案。 代码 #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;climits&gt; #include &lt;cassert&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;utility&gt; #include &lt;algorithm&gt; #include &lt;tr1/unordered_map&gt; #include &lt;tr1/functional&gt; const int MAXN = 50000 + 1; struct Node; struct Edge; struct Node { Edge *e, *c; int l, in; } N[MAXN + 2 + 2]; struct Edge { Node *s, *t; int f, c; Edge *next, *r; Edge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s-&gt;e) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, const int n) { for (int i = 0; i &lt; n; i++) N[i].c = N[i].e, N[i].l = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;l &amp;&amp; e-&gt;f &lt; e-&gt;c) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } return false; } int findPath(Node *s, Node *t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) if (e-&gt;t-&gt;l == s-&gt;l + 1 &amp;&amp; e-&gt;f &lt; e-&gt;c) { int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c - e-&gt;f)); if (f) { e-&gt;f += f; e-&gt;r-&gt;f -= f; return f; } } return 0; } int operator()(const int s, const int t, const int n) { int res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += f; } #ifdef DBG printf("dinic(%d, %d, %d) = %d\n", s, t, n, res); #endif return res; } } dinic; inline Edge *addEdge(const int s, const int t, const int c) { #ifdef DBG printf("E(%d, %d, %d)\n", s, t, c); #endif N[s].e = new Edge(&amp;N[s], &amp;N[t], c); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0); return (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } inline void addEdge(const int s, const int t, const int l, const int r) { N[s].in -= l; N[t].in += l; addEdge(s, t, r - l); } inline int minFlow(const int s, const int t, const int n) { const int S = n, T = n + 1; int full = 0; for (int i = 0; i &lt; n; i++) { if (N[i].in &gt; 0) addEdge(S, i, N[i].in), full += N[i].in; else if (N[i].in &lt; 0) addEdge(i, T, -N[i].in); } Edge *e = addEdge(t, s, INT_MAX); assert(dinic(S, T, n + 2) == full); int f = e-&gt;f; e-&gt;c = e-&gt;r-&gt;c = 0; for (e = N[s].e; e; e = e-&gt;next) e-&gt;c = e-&gt;r-&gt;c = 0; for (e = N[t].e; e; e = e-&gt;next) e-&gt;c = e-&gt;r-&gt;c = 0; return f - dinic(t, s, n); } struct DPValue; struct Point; struct DPValue { Point *prec; int x; DPValue(Point *prec = NULL, const int x = 0) : prec(prec), x(x) {} DPValue extend(Point &amp;p, const int delta) { return DPValue(&amp;p, x + delta); } operator int() const { return x; } }; struct Point { int id, x, y, lineIndex; std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt;::iterator itX, itDiagonal1, itDiagonal2; DPValue dpUp, dpInline; bool flagUp, flagInline; std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &amp;getVectorY() const; std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &amp;getVectorX() const; std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &amp;getVectorDiagonal1() const; std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &amp;getVectorDiagonal2() const; }; bool compareByY(const Point &amp;a, const Point &amp;b) { return a.y &gt; b.y; } bool compareByX(const Point &amp;a, const Point &amp;b) { return a.x &gt; b.x; } bool compareByDiagonal1(const Point &amp;a, const Point &amp;b) { return a.x &gt; b.x; } bool compareByDiagonal2(const Point &amp;a, const Point &amp;b) { return a.x &lt; b.x; } int n, lineCnt; Point a[MAXN]; std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; lines[MAXN]; std::tr1::unordered_map&lt; int, std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &gt; mapX, mapDiagonal1, mapDiagonal2; std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &amp;Point::getVectorY() const { return lines[lineIndex]; } std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &amp;Point::getVectorX() const { return mapX[x]; } std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &amp;Point::getVectorDiagonal1() const { return mapDiagonal1[x + y]; } std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &amp;Point::getVectorDiagonal2() const { return mapDiagonal2[x - y]; } inline void dpUp(const int lineIndex) { std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &amp;v = lines[lineIndex]; for (std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt;::iterator it = v.begin(); it != v.end(); it++) { Point &amp;p = it-&gt;get(); // p.dpUp = DPValue(NULL, 1); if (p.itX != p.getVectorX().begin()) { p.dpUp = std::max(p.dpUp, (p.itX - 1)-&gt;get().dpInline.extend((p.itX - 1)-&gt;get(), 1)); } if (p.itDiagonal1 != p.getVectorDiagonal1().begin()) { p.dpUp = std::max(p.dpUp, (p.itDiagonal1 - 1)-&gt;get().dpInline.extend((p.itDiagonal1 - 1)-&gt;get(), 1)); } if (p.itDiagonal2 != p.getVectorDiagonal2().begin()) { p.dpUp = std::max(p.dpUp, (p.itDiagonal2 - 1)-&gt;get().dpInline.extend((p.itDiagonal2 - 1)-&gt;get(), 1)); } } } inline void dpInline(const int lineIndex) { struct SegmentTree { int l, r, m; SegmentTree *lc, *rc; DPValue val; SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc) {} ~SegmentTree() { if (lc) delete lc; if (rc) delete rc; } void update(const int pos, const DPValue &amp;val) { if (l == r) this-&gt;val = val; else (pos &lt;= m ? lc : rc)-&gt;update(pos, val), this-&gt;val = std::max(lc-&gt;val, rc-&gt;val); } DPValue query() { return val; } static SegmentTree *build(const int l, const int r) { if (l &gt; r) return NULL; else if (l == r) return new SegmentTree(l, r, NULL, NULL); else { int m = l + (r - l) / 2; return new SegmentTree(l, r, build(l, m), build(m + 1, r)); } } } *segment; std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &amp;v = lines[lineIndex]; segment = SegmentTree::build(0, v.size() - 1); for (size_t i = 0; i &lt; v.size(); i++) { segment-&gt;update(i, v[i].get().dpUp.extend(v[i].get(), i)); } for (size_t i = 0; i &lt; v.size(); i++) { v[i].get().dpInline = segment-&gt;query(); if (i &lt; v.size() - 1) { segment-&gt;update(i, v[i].get().dpUp.extend(v[i].get(), v.size() - i - 1)); segment-&gt;update(i + 1, v[i + 1].get().dpUp.extend(v[i + 1].get(), 0)); } } delete segment; } inline void dp() { for (int i = 0; i &lt; n; i++) { if (i != 0) dpUp(i); dpInline(i); } } inline void getInlinePath(std::vector&lt;Point *&gt; &amp;v, Point *s, Point *t) { std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &amp;line = s-&gt;getVectorY(); std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt;::iterator a = std::lower_bound(line.begin(), line.end(), *s, &amp;compareByX), b = std::lower_bound(line.begin(), line.end(), *t, &amp;compareByX); assert(&amp;a-&gt;get() == s); assert(&amp;b-&gt;get() == t); #ifdef DBG printf("getInlinePath(%d(%d, %d), %d(%d, %d))\n", s-&gt;id, s-&gt;x, s-&gt;y, t-&gt;id, t-&gt;x, t-&gt;y); #endif if (a &lt; b) { for (std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt;::iterator it = a - 1; it &gt;= line.begin(); it--) { #ifdef DBG printf("to %d(%d, %d)\n", it-&gt;get().id, it-&gt;get().x, it-&gt;get().y); #endif v.push_back(&amp;it-&gt;get()); } #ifdef DBG puts("reverse!"); #endif for (std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt;::iterator it = a + 1; it &lt;= b; it++) { #ifdef DBG printf("to %d(%d, %d)\n", it-&gt;get().id, it-&gt;get().x, it-&gt;get().y); #endif v.push_back(&amp;it-&gt;get()); } } else { for (std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt;::iterator it = a + 1; it != line.end(); it++) { #ifdef DBG printf("to %d(%d, %d)\n", it-&gt;get().id, it-&gt;get().x, it-&gt;get().y); #endif v.push_back(&amp;it-&gt;get()); } #ifdef DBG puts("reverse!"); #endif for (std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt;::iterator it = a - 1; it &gt;= b; it--) { #ifdef DBG printf("to %d(%d, %d)\n", it-&gt;get().id, it-&gt;get().x, it-&gt;get().y); #endif v.push_back(&amp;it-&gt;get()); } } } inline void getPath(std::vector&lt;Point *&gt; &amp;v) { Point *p = &amp;a[n - 1]; bool flag = false; while (p-&gt;dpUp.x || (!flag &amp;&amp; p-&gt;dpInline.x &amp;&amp; p-&gt;dpInline.prec != p)) { if (flag || p-&gt;dpInline.prec == p || p-&gt;dpInline.x &lt;= p-&gt;dpUp.x) { #ifdef DBG printf("%d(%d, %d) -&gt; %d(%d, %d)\n", p-&gt;id, p-&gt;x, p-&gt;y, p-&gt;dpUp.prec-&gt;id, p-&gt;dpUp.prec-&gt;x, p-&gt;dpUp.prec-&gt;y); #endif p = p-&gt;dpUp.prec; v.push_back(p); flag = false; } else { getInlinePath(v, p, p-&gt;dpInline.prec); p = p-&gt;dpInline.prec; flag = true; } } } inline void getEdges(std::vector&lt; std::pair&lt;Point *, Point *&gt; &gt; &amp;E) { struct SegmentTree { int l, r, m; SegmentTree *lc, *rc; DPValue val; bool flag; SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc), flag(false) {} ~SegmentTree() { if (flag) pushDown(); if (lc) delete lc; if (rc) delete rc; } void pushDown() { if (flag) { if (lc || rc) { if (val.x == lc-&gt;val.x) lc-&gt;flag = true; if (val.x == rc-&gt;val.x) rc-&gt;flag = true; } else { val.prec-&gt;flagInline = true; } flag = false; } } void update(const int pos, const DPValue &amp;val) { pushDown(); if (l == r) this-&gt;val = val; else (pos &lt;= m ? lc : rc)-&gt;update(pos, val), this-&gt;val = std::max(lc-&gt;val, rc-&gt;val); } DPValue query() { return val; } void mark() { flag = true; } static SegmentTree *build(const int l, const int r) { if (l &gt; r) return NULL; else if (l == r) return new SegmentTree(l, r, NULL, NULL); else { int m = l + (r - l) / 2; return new SegmentTree(l, r, build(l, m), build(m + 1, r)); } } } *segment; a[n - 1].flagUp = true; for (int i = lineCnt - 1; i &gt;= 0; i--) { std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &amp;v = lines[i]; segment = SegmentTree::build(0, v.size() - 1); for (size_t j = 0; j &lt; v.size(); j++) { segment-&gt;update(j, v[j].get().dpUp.extend(v[j].get(), j)); } for (size_t j = 0; j &lt; v.size(); j++) { if (v[j].get().flagUp) { segment-&gt;mark(); } if (j &lt; v.size() - 1) { segment-&gt;update(j, v[j].get().dpUp.extend(v[j].get(), v.size() - j - 1)); segment-&gt;update(j + 1, v[j + 1].get().dpUp.extend(v[j + 1].get(), 0)); } } delete segment; for (size_t j = 0; j &lt; v.size(); j++) { if (v[j].get().flagInline) { Point &amp;p = v[j].get(); // p.dpUp = DPValue(NULL, 1); if (p.itX != p.getVectorX().begin() &amp;&amp; p.dpUp.x == (p.itX - 1)-&gt;get().dpInline.x + 1) { (p.itX - 1)-&gt;get().flagUp = true; #ifdef DBG printf("(%d, %d) flagUp (%d, %d)\n", p.x, p.y, (p.itX - 1)-&gt;get().x, (p.itX - 1)-&gt;get().y); #endif E.push_back(std::make_pair(&amp;p, &amp;(p.itX - 1)-&gt;get())); } if (p.itDiagonal1 != p.getVectorDiagonal1().begin() &amp;&amp; p.dpUp.x == (p.itDiagonal1 - 1)-&gt;get().dpInline.x + 1) { (p.itDiagonal1 - 1)-&gt;get().flagUp = true; #ifdef DBG printf("(%d, %d) flagUp (%d, %d)\n", p.x, p.y, (p.itDiagonal1 - 1)-&gt;get().x, (p.itDiagonal1 - 1)-&gt;get().y); #endif E.push_back(std::make_pair(&amp;p, &amp;(p.itDiagonal1 - 1)-&gt;get())); } if (p.itDiagonal2 != p.getVectorDiagonal2().begin() &amp;&amp; p.dpUp.x == (p.itDiagonal2 - 1)-&gt;get().dpInline.x + 1) { (p.itDiagonal2 - 1)-&gt;get().flagUp = true; #ifdef DBG printf("(%d, %d) flagUp (%d, %d)\n", p.x, p.y, (p.itDiagonal2 - 1)-&gt;get().x, (p.itDiagonal2 - 1)-&gt;get().y); #endif E.push_back(std::make_pair(&amp;p, &amp;(p.itDiagonal2 - 1)-&gt;get())); } } } } } inline void sort() { for (int i = 0; i &lt; lineCnt; i++) { std::sort(lines[i].begin(), lines[i].end(), &amp;compareByX); } for (std::tr1::unordered_map&lt; int, std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &gt;::iterator it = mapX.begin(); it != mapX.end(); it++) { std::sort(it-&gt;second.begin(), it-&gt;second.end(), &amp;compareByY); for (std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt;::iterator it2 = it-&gt;second.begin(); it2 != it-&gt;second.end(); it2++) { Point &amp;p = *it2; p.itX = it2; } } for (std::tr1::unordered_map&lt; int, std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &gt;::iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) { std::sort(it-&gt;second.begin(), it-&gt;second.end(), &amp;compareByDiagonal2); for (std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt;::iterator it2 = it-&gt;second.begin(); it2 != it-&gt;second.end(); it2++) { Point &amp;p = *it2; p.itDiagonal1 = it2; } } for (std::tr1::unordered_map&lt; int, std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &gt;::iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) { std::sort(it-&gt;second.begin(), it-&gt;second.end(), &amp;compareByDiagonal1); for (std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt;::iterator it2 = it-&gt;second.begin(); it2 != it-&gt;second.end(); it2++) { Point &amp;p = *it2; p.itDiagonal2 = it2; } } } #ifdef DBG inline void debugPrint() { for (int i = 0; i &lt; lineCnt; i++) { printf("lines[%d] = { ", i); for (std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt;::const_iterator it = lines[i].begin(); it != lines[i].end(); it++) { const Point &amp;p = *it; printf("(%d, %d)%s", p.x, p.y, it + 1 == lines[i].end() ? " }\n" : ", "); } } putchar('\n'); for (std::tr1::unordered_map&lt; int, std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &gt;::const_iterator it = mapX.begin(); it != mapX.end(); it++) { printf("x[%d] = { ", it-&gt;first); for (std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt;::const_iterator it2 = it-&gt;second.begin(); it2 != it-&gt;second.end(); it2++) { const Point &amp;p = *it2; printf("(%d, %d)%s", p.x, p.y, it2 + 1 == it-&gt;second.end() ? " }\n" : ", "); } } putchar('\n'); for (std::tr1::unordered_map&lt; int, std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &gt;::const_iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) { printf("diagonal1[%d] = { ", it-&gt;first); for (std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt;::const_iterator it2 = it-&gt;second.begin(); it2 != it-&gt;second.end(); it2++) { const Point &amp;p = *it2; printf("(%d, %d)%s", p.x, p.y, it2 + 1 == it-&gt;second.end() ? " }\n" : ", "); } } putchar('\n'); for (std::tr1::unordered_map&lt; int, std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt; &gt;::const_iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) { printf("diagonal2[%d] = { ", it-&gt;first); for (std::vector&lt; std::tr1::reference_wrapper&lt;Point&gt; &gt;::const_iterator it2 = it-&gt;second.begin(); it2 != it-&gt;second.end(); it2++) { const Point &amp;p = *it2; printf("(%d, %d)%s", p.x, p.y, it2 + 1 == it-&gt;second.end() ? " }\n" : ", "); } } putchar('\n'); for (int i = 0; i &lt; n; i++) { printf("(%d, %d): ", a[i].x, a[i].y); if (a[i].dpUp.prec) printf("dpUp[%d] = { (%d, %d), %d }, ", i, a[i].dpUp.prec-&gt;x, a[i].dpUp.prec-&gt;y, a[i].dpUp.x); else printf("dpUp[%d] = { nullptr, %d }, ", i, a[i].dpUp.x); if (a[i].dpInline.prec) printf("dpInline[%d] = { (%d, %d), %d }\n", i, a[i].dpInline.prec-&gt;x, a[i].dpInline.prec-&gt;y, a[i].dpInline.x); else printf("dpInline[%d] = { nullptr, %d }\n", i, a[i].dpInline.x); } } #endif int main() { scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) { scanf("%d %d", &amp;a[i].x, &amp;a[i].y); a[i].id = i; } a[n].x = 0, a[n].y = 0, a[n].id = n, n++; std::sort(a, a + n, &amp;compareByY); for (int i = 0, last; i &lt; n; i++) { Point &amp;p = a[i]; if (!i || p.y != a[last].y) ++lineCnt; lines[lineCnt - 1].push_back(std::tr1::reference_wrapper&lt;Point&gt;(p)); p.lineIndex = lineCnt - 1; mapX[p.x].push_back(std::tr1::reference_wrapper&lt;Point&gt;(p)); mapDiagonal1[p.x + p.y].push_back(std::tr1::reference_wrapper&lt;Point&gt;(p)); mapDiagonal2[p.x - p.y].push_back(std::tr1::reference_wrapper&lt;Point&gt;(p)); last = i; } sort(); #ifdef DBG debugPrint(); #endif dp(); int cnt = a[n - 1].dpInline.x; printf("%d\n", cnt); std::vector&lt;Point *&gt; v; getPath(v); #ifdef DBG for (size_t i = 0; i &lt; v.size(); i++) printf("%d: (%d, %d)\n", v[i]-&gt;id + 1, v[i]-&gt;x, v[i]-&gt;y); #else for (size_t i = 0; i &lt; v.size(); i++) printf("%d%c", v[i]-&gt;id + 1, i == v.size() - 1 ? '\n' : ' '); #endif std::vector&lt; std::pair&lt;Point *, Point *&gt; &gt; E; getEdges(E); const int s = 0, t = n + 1; for (int i = 1; i &lt;= n; i++) addEdge(s, i, INT_MAX), addEdge(i, t, INT_MAX); for (std::vector&lt; std::pair&lt;Point *, Point *&gt; &gt;::const_iterator it = E.begin(); it != E.end(); it++) { addEdge(it-&gt;first-&gt;id + 1, it-&gt;second-&gt;id + 1, 1, INT_MAX); } printf("%d\n", minFlow(s, t, n + 2)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>上下界网络流</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2015」品酒大会 - 后缀数组 + 并查集]]></title>
    <url>%2Fnoi2015-savour%2F</url>
    <content type="text"><![CDATA[给定字符串 和序列 ，对于 ，求： 满足 的无序二元组 数量； 上述二元组 使 取得的最大值。 链接 BZOJ 4199 UOJ #130 题解 使用后缀数组求出排名相邻后缀的 LCP，打出表，可以发现如果连续的一段后缀的相邻 LCP 长度都 ，那么这其中任意两个后缀都是第一问的一组解。进而得出，一个大小为 的块对答案的贡献为 。 对于第二问，每个块内两个 值最大（或最小，因为有负数）的对应 值乘积对答案有贡献。 使用带权并查集维护每个块的大小、最大值、次大值、最小值、次小值。 考虑到 较大时答案较小，且 减小时答案可累加。从大到小枚举 ，每次判断当前后缀可否和前一个或后一个后缀所在块合并（可以合并的条件是对应的后缀的 值大于等于当前后缀），并统计答案。注意，连续两次被前后合并同一个块可能导致答案被统计多次。 两问都需要 long long。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;cassert&gt; #include &lt;vector&gt; #include &lt;stack&gt; #include &lt;utility&gt; #include &lt;algorithm&gt; #include &lt;functional&gt; const int MAXN = 300000; char s[MAXN + 1]; int a[MAXN], A[MAXN], n, rk[MAXN], sa[MAXN], ht[MAXN]; inline void suffixArray() { static int set[MAXN], a[MAXN]; for (int i = 0; i &lt; n; i++) set[i] = s[i]; std::sort(set, set + n); int *end = std::unique(set, set + n); for (int i = 0; i &lt; n; i++) a[i] = std::lower_bound(set, end, s[i]) - set; static int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1; for (int i = 0; i &lt; n; i++) buc[a[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) rk[i] = buc[a[i] - 1]; for (int t = 1; t &lt; n; t *= 2) { for (int i = 0; i &lt; n; i++) fir[i] = rk[i]; for (int i = 0; i &lt; n; i++) sec[i] = i + t &gt;= n ? -1 : fir[i + t]; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[sec[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) tmp[n - buc[sec[i]]--] = i; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[fir[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int j = 0, i; j &lt; n; j++) i = tmp[j], sa[--buc[fir[i]]] = i; for (int j = 0, i, last = -1; j &lt; n; j++) { i = sa[j]; if (last == -1) rk[i] = 0; else if (fir[i] == fir[last] &amp;&amp; sec[i] == sec[last]) rk[i] = rk[last]; else rk[i] = rk[last] + 1; last = i; } } for (int i = 0, k = 0; i &lt; n; i++) { if (rk[i] == 0) k = 0; else { if (k &gt; 0) k--; int j = sa[rk[i] - 1]; while (i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; a[i + k] == a[j + k]) k++; } ht[rk[i]] = k; } // for (int i = 0; i &lt; n; i++) printf("%d%c", ht[i], i == n - 1 ? '\n' : ' '); #ifdef DBG for (int i = 0; i &lt; n; i++) printf("%3d %2d %s\n", ::a[sa[i]], ht[i], &amp;s[sa[i]]); puts("----------------"); #endif } struct UnionFindSet { int f[MAXN], size[MAXN]; int max[MAXN], max2[MAXN], min[MAXN], min2[MAXN]; #ifdef DBG bool invalid[MAXN]; int top[MAXN], bottom[MAXN]; #endif void init() { for (int i = 1; i &lt; n; i++) { i[f] = i; i[size] = 1; if (A[i] &gt; A[i - 1]) i[max] = i[min2] = i, i[min] = i[max2] = i - 1; else i[max] = i[min2] = i - 1, i[min] = i[max2] = i; #ifdef DBG i[top] = i[bottom] = i; i[invalid] = false; #endif } } template &lt;typename T&gt; void updateMinMax(int &amp;m, int &amp;m2, const int x, T compare) { if (compare(A[x], A[m])) m2 = m, m = x; else if (x != m &amp;&amp; compare(A[x], A[m2])) m2 = x; } void addTo(const int a, const int b) { #ifdef DBG a[invalid] = true; b[top] = std::min(b[top], a[top]); b[bottom] = std::max(b[bottom], a[bottom]); #endif b[size] = a[size] + b[size]; a[size] = 0; updateMinMax(b[max], b[max2], a[max], std::greater&lt;int&gt;()); updateMinMax(b[max], b[max2], a[max2], std::greater&lt;int&gt;()); updateMinMax(b[max], b[max2], a[min], std::greater&lt;int&gt;()); updateMinMax(b[max], b[max2], a[min2], std::greater&lt;int&gt;()); updateMinMax(b[min], b[min2], a[min], std::less&lt;int&gt;()); updateMinMax(b[min], b[min2], a[min2], std::less&lt;int&gt;()); updateMinMax(b[min], b[min2], a[max], std::less&lt;int&gt;()); updateMinMax(b[min], b[min2], a[max2], std::less&lt;int&gt;()); } int find(const int x, int *size = NULL, int *max = NULL, int *max2 = NULL, int *min = NULL, int *min2 = NULL) { int res = x; while (res[f] != res) res = res[f]; for (int i = x, tmp; i != res; ) { tmp = i[f]; addTo(i, res); i[f] = res; i = tmp; } if (size) *size = this-&gt;size[res]; if (max) *max = A[this-&gt;max[res]]; if (max2) *max2 = A[this-&gt;max2[res]]; if (min) *min = A[this-&gt;min[res]]; if (min2) *min2 = A[this-&gt;min2[res]]; return res; } bool test(const int a, const int b) { return find(a) == find(b); } void merge(const int a, const int b) { // printf("merge(%d, %d)\n", a, b); int x = find(a), y = find(b); // printf("-- merge(%d, %d)\n", x, y); assert(x != y); addTo(x, y); x[f] = y; } #ifdef DBG void print() { for (int i = 1; i &lt; n; i++) find(i); for (int i = 1; i &lt; n; i++) { if (invalid[i]) continue; printf("[%d]: ", i); if (f[i] == i) printf("root, "); else printf("f = %d, ", f[i]); printf("[%d, %d], size = %d, max = [%d] -&gt; %d, max2 = [%d] -&gt; %d, min = [%d] -&gt; %d, min2 = [%d] -&gt; %d\n", top[i], bottom[i], size[i], max[i], max[i][sa][::a], max2[i], max2[i][sa][::a], min[i], min[i][sa][::a], min2[i], min2[i][sa][::a]); } } #endif } ufs; inline long long calcCnt(const int x) { int size; ufs.find(x, &amp;size); long long cnt = static_cast&lt;long long&gt;(size) * (size + 1) / 2; // printf("cnt(%d) = %d\n", x, cnt); return cnt; } inline long long calcMax(const int x) { int max, max2, min, min2; ufs.find(x, NULL, &amp;max, &amp;max2, &amp;min, &amp;min2); return std::max(static_cast&lt;long long&gt;(max) * max2, static_cast&lt;long long&gt;(min) * min2); } int main() { scanf("%d\n%s", &amp;n, s); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); suffixArray(); for (int i = 0; i &lt; n; i++) A[i] = a[sa[i]]; ufs.init(); std::vector&lt;int&gt; v[MAXN]; for (int i = 1; i &lt; n; i++) v[ht[i]].push_back(i); long long cnt = 0, max = LLONG_MIN; std::stack&lt; std::pair&lt;long long, long long&gt; &gt; stack; for (int i = n - 1; i &gt;= 0; i--) { for (std::vector&lt;int&gt;::const_iterator it = v[i].begin(); it != v[i].end(); it++) { // printf("ht[%d] = %d\n", *it, ht[*it]); if (!(it != v[i].end() - 1 &amp;&amp; ufs.test(*(it + 1), *it + 1))) { if (*it != n - 1) { if (ht[*it + 1] &gt;= ht[*it] &amp;&amp; !ufs.test(*it + 1, *it)) { // puts("------- + 1"); cnt -= calcCnt(*it + 1); ufs.merge(*it, *it + 1); } } } if (*it != 1 &amp;&amp; ht[*it - 1] &gt;= ht[*it] &amp;&amp; !ufs.test(*it - 1, *it)) { // puts("------- - 1"); cnt -= calcCnt(*it - 1); ufs.merge(*it, *it - 1); } // puts("+++++++"); cnt += calcCnt(*it); max = std::max(max, calcMax(*it)); #ifdef DBG printf("calcMax(%d) = %lld\n", *it, calcMax(*it)); #endif } #ifdef DBG printf("%lld %lld\n", cnt, max == LLONG_MIN ? 0 : max); if (cnt != 0) ufs.print(); #else stack.push(std::make_pair(cnt, max == LLONG_MIN ? 0 : max)); #endif } #ifndef DBG while (!stack.empty()) { printf("%lld %lld\n", stack.top().first, stack.top().second); stack.pop(); } #endif return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>后缀数组</tag>
        <tag>并查集</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2438」杀人游戏 - 强连通分量]]></title>
    <url>%2Fbzoj-2438%2F</url>
    <content type="text"><![CDATA[一位杀手潜入假装成平民。警察希望能在 个人里面，查出谁是杀手。警察能够对每一个人进行查证，假如查证的对象是平民，他会告诉警察，他认识的人，谁是杀手，谁是平民。假如查证的对象是杀手，杀手将会把警察干掉。 现在警察掌握了每一个人认识谁。每一个人都有可能是杀手，可看作他们是杀手的概率是相同的。 根据最优的情况，保证警察自身安全并知道谁是杀手的概率最大是多少？ 链接 BZOJ 2438 题解 如果一些人在一个强连通分量中，那么这些人中只需要查证一个人。 缩点后，统计有多少入度为零的点，查证这些点一定不会漏掉。 考虑这样一种特殊情况：只有一个人，这个人一定是杀手，即不需要查证任何人。 更普遍的，每一个入度为零一个人的单点（必须是一个人不能是一群人），对于其连接的所有点，这些点的入度如果都不为 ，则这个人可以不需要查证。查证其它所有人后，他认识的人也都被查证过，只剩他一个人不需要查证即知道身份。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; const int MAXN = 100000; struct Node; struct Edge; struct SCC; struct Node { Edge *e, *in, *c; bool visited, pushed, inStack; int dfn, low, inDegree; SCC *scc; } N[MAXN]; struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {} }; struct SCC { Node v; int s; } S[MAXN]; inline void addEdge(const int s, const int t) { N[s].e = new Edge(&amp;N[s], &amp;N[t]); } int n, m; inline int tarjan() { int time = 0, cnt = 0; for (int i = 0; i &lt; n; i++) { if (N[i].visited) continue; std::stack&lt;Node *&gt; s, t; s.push(&amp;N[i]); N[i].pushed = true; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; v-&gt;c = v-&gt;e; v-&gt;dfn = v-&gt;low = time++; v-&gt;inStack = true; t.push(v); } if (v-&gt;c) { if (v-&gt;c-&gt;t-&gt;inStack) v-&gt;low = std::min(v-&gt;low, v-&gt;c-&gt;t-&gt;dfn); else if (v-&gt;c-&gt;t-&gt;pushed == false) s.push(v-&gt;c-&gt;t), v-&gt;c-&gt;t-&gt;pushed = true, v-&gt;c-&gt;t-&gt;in = v-&gt;c; v-&gt;c = v-&gt;c-&gt;next; } else { if (v-&gt;dfn == v-&gt;low) { Node *u; SCC *scc = &amp;S[cnt++]; do { u = t.top(); t.pop(); u-&gt;inStack = false; u-&gt;scc = scc; u-&gt;scc-&gt;s++; } while (u != v); } if (v-&gt;in) v-&gt;in-&gt;s-&gt;low = std::min(v-&gt;in-&gt;s-&gt;low, v-&gt;low); s.pop(); } } } return cnt; } inline void contract() { for (int i = 0; i &lt; n; i++) { for (Edge *e = N[i].e; e; e = e-&gt;next) { if (e-&gt;s-&gt;scc != e-&gt;t-&gt;scc) { e-&gt;s-&gt;scc-&gt;v.e = new Edge(&amp;e-&gt;s-&gt;scc-&gt;v, &amp;e-&gt;t-&gt;scc-&gt;v); e-&gt;t-&gt;scc-&gt;v.inDegree++; } } } } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) { int s, t; scanf("%d %d", &amp;s, &amp;t), s--, t--; addEdge(s, t); } int cnt = tarjan(); contract(); int k = 0; for (int i = 0; i &lt; cnt; i++) { if (S[i].v.inDegree == 0) k++; } for (int i = 0; i &lt; cnt; i++) { if (S[i].v.inDegree == 0 &amp;&amp; S[i].s == 1) { bool flag = false; for (Edge *e = S[i].v.e; e; e = e-&gt;next) { if (e-&gt;t-&gt;inDegree &lt;= 1) { flag = true; break; } } if (!flag) { k--; break; } } } printf("%.6lf\n", static_cast&lt;double&gt;(n - k) / n); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2716」天使玩偶 - CDQ]]></title>
    <url>%2Fbzoj-2716%2F</url>
    <content type="text"><![CDATA[维护一个平面，支持以下两种操作： 加入点 ； 查询麦哈顿距离与点 最小的点。 链接 BZOJ 2716 题解 任意两个点 、 的麦哈顿距离为 。 当 在 左下方时，其麦哈顿距离为： 问题转化为数据结构维护 的最大值，很明显这是一个三维偏序问题，可以使用 CDQ 分治解决，将传统的 CDQ 分治中的累加改为取较小值即可。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 500000; const int MAXM = 500000; const int MAXX = 1000000; struct Triple { int id, x, y, *ans; Triple() {} Triple(const int x, const int y, int *ans = NULL) : x(x), y(y), ans(ans) { static int i = 0; id = i++; } } a[MAXN + MAXM]; bool operator&lt;(const Triple &amp;a, const Triple &amp;b) { return a.id &lt; b.id; } int maxX, maxY; struct BinaryIndexedTree { int a[MAXX + 2]; static int lowbit(const int x) { return x &amp; -x; } int query(const int x) const { int ans = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) ans = std::max(ans, a[i - 1]); return ans; } void update(const int x, const int v) { for (int i = x; i &lt;= maxY; i += lowbit(i)) a[i - 1] = std::max(a[i - 1], v); } void clear(const int x) { for (int i = x; i &lt;= maxY; i += lowbit(i)) { if (a[i - 1]) a[i - 1] = 0; else break; } } } bit; inline void cdq(Triple *l, Triple *r) { if (l == r) return; Triple *mid = l + (r - l) / 2; cdq(l, mid); cdq(mid + 1, r); static Triple tmp[MAXN + MAXM]; for (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q &lt;= tmp + (r - l); q++) { if ((p1 &lt;= mid &amp;&amp; p1-&gt;x &lt;= p2-&gt;x) || p2 &gt; r) { *q = *p1++; if (!q-&gt;ans) bit.update(q-&gt;y, q-&gt;x + q-&gt;y); } else { *q = *p2++; if (q-&gt;ans) { int res = bit.query(q-&gt;y); if (res) *q-&gt;ans = std::min(*q-&gt;ans, q-&gt;x + q-&gt;y - res); } } } for (Triple *q = tmp, *p = l; p &lt;= r; p++, q++) { *p = *q; bit.clear(p-&gt;y); } } int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); int cnt = 0; for (int i = 0; i &lt; n; i++) { int x, y; scanf("%d %d\n", &amp;x, &amp;y), x += 2, y += 2; a[cnt++] = Triple(x, y); maxX = std::max(maxX, x); maxY = std::max(maxY, y); } static int ans[MAXM]; int qCnt = 0; for (int j = 0; j &lt; m; j++) { int t, x, y; scanf("%d %d %d", &amp;t, &amp;x, &amp;y), x += 2, y += 2; if (t == 1) { a[cnt++] = Triple(x, y); } else { a[cnt++] = Triple(x, y, &amp;ans[qCnt++]); } maxX = std::max(maxX, x); maxY = std::max(maxY, y); } for (int i = 0; i &lt; qCnt; i++) ans[i] = INT_MAX; cdq(a, a + cnt - 1); for (int i = 0; i &lt; cnt; i++) a[i].x = maxX - a[i].x + 1; std::sort(a, a + cnt); cdq(a, a + cnt - 1); for (int i = 0; i &lt; cnt; i++) a[i].y = maxY - a[i].y + 1; std::sort(a, a + cnt); cdq(a, a + cnt - 1); for (int i = 0; i &lt; cnt; i++) a[i].x = maxX - a[i].x + 1; std::sort(a, a + cnt); cdq(a, a + cnt - 1); for (int i = 0; i &lt; qCnt; i++) printf("%d\n", ans[i]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>BZOJ</tag>
        <tag>CDQ</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SHOI2007」园丁的烦恼 - CDQ]]></title>
    <url>%2Fshoi2007-tree%2F</url>
    <content type="text"><![CDATA[每一棵树可以用一个整数坐标来表示，每次询问你某一个矩阵内有多少树。 链接 BZOJ 1935 题解 同 BZOJ 1176。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 500000; const int MAXM = 500000; const int MAXX = 10000000; struct Triple { int x, y, *ans, k; Triple() {} Triple(const int x, const int y, int *ans, const int k) : x(x), y(y), ans(ans), k(k) {} } a[MAXN + MAXM * 4]; int max = 0; struct BinaryIndexedTree { int a[MAXX + 2]; static int lowbit(const int x) { return x &amp; -x; } int query(const int x) const { int ans = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) ans += a[i - 1]; // printf("sum[1, %d] = %d\n", x, ans); return ans; } void update(const int x, const int delta) { // printf("a[%d] += %d\n", x, delta); for (int i = x; i &lt;= max; i += lowbit(i)) a[i - 1] += delta; } void clear(const int x) { // printf("a[%d] = 0\n", x); for (int i = x; i &lt;= max; i += lowbit(i)) { if (a[i - 1]) a[i - 1] = 0; else break; } } } bit; void cdq(Triple *l, Triple *r) { if (l == r) return; Triple *mid = l + (r - l) / 2; cdq(l, mid); cdq(mid + 1, r); static Triple tmp[MAXN + MAXM * 4]; for (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q &lt;= tmp + (r - l); q++) { if ((p1 &lt;= mid &amp;&amp; p1-&gt;x &lt;= p2-&gt;x) || p2 &gt; r) { *q = *p1++; if (!q-&gt;ans) bit.update(q-&gt;y, 1); } else { *q = *p2++; // printf("ans += %d\n", bit.query(q-&gt;y) * q-&gt;k); if (q-&gt;ans) *q-&gt;ans += bit.query(q-&gt;y) * q-&gt;k; } } for (Triple *q = tmp, *p = l; p &lt;= r; q++, p++) { *p = *q; bit.clear(p-&gt;y); } } int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) { scanf("%d %d", &amp;a[i].x, &amp;a[i].y), a[i].x += 2, a[i].y += 2; max = std::max(max, a[i].y); } static int ans[MAXM]; int cnt = n; for (int i = 0; i &lt; m; i++) { int x1, y1, x2, y2; scanf("%d %d %d %d", &amp;x1, &amp;y1, &amp;x2, &amp;y2), x1 += 2, y1 += 2, x2 += 2, y2 += 2; int *p = &amp;ans[i]; a[cnt++] = Triple(x2, y2, p, 1); a[cnt++] = Triple(x1 - 1, y1 - 1, p, 1); a[cnt++] = Triple(x1 - 1, y2, p, -1); a[cnt++] = Triple(x2, y1 - 1, p, -1); max = std::max(max, y1); max = std::max(max, y2); } // for (int i = 0; i &lt; cnt; i++) { // if (a[i].ans) printf("Query [%d, %d] for ans[%ld]\n", a[i].x, a[i].y, a[i].ans - ans); // else printf("Update [%d, %d] = 1\n", a[i].x, a[i].y); // } cdq(a, a + cnt - 1); for (int i = 0; i &lt; m; i++) printf("%d\n", ans[i]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>BZOJ</tag>
        <tag>CDQ</tag>
        <tag>分治</tag>
        <tag>SHOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2009」狼和羊的故事 - 最小割]]></title>
    <url>%2Fzjoi2009-ws%2F</url>
    <content type="text"><![CDATA[Orez 的羊狼圈可以看作一个 个矩阵格子，这个矩阵的边缘已经装上了篱笆。他决定在羊狼圈中再加入一些篱笆，还是要将羊狼分开来养。通过仔细观察，Orez 发现狼和羊都有属于自己领地，Orez 想要添加篱笆的尽可能的短。篱笆不能改变狼羊的所属领地，篱笆必须修筑完整，也就是说必须修建在单位格子的边界上并且不能只修建一部分。 链接 BZOJ 1412 题解 从源点向狼的领地连边，容量正无穷，从羊的领地向汇点连边，容量正无穷；相邻格子连无向边。最小割即为答案。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 100; struct Node; struct Edge; struct Node { Edge *e, *c; int l; } N[MAXN * MAXN + 2]; struct Edge { Node *t; int c; Edge *next, *r; Edge(Node *s, Node *t, const int c) : t(t), c(c), next(s-&gt;e) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;l &amp;&amp; e-&gt;c) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } return false; } int findPath(Node *s, Node *t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) if (e-&gt;t-&gt;l == s-&gt;l + 1 &amp;&amp; e-&gt;c) { int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c)); if (f) { e-&gt;c -= f, e-&gt;r-&gt;c += f; return f; } } return 0; } int operator()(const int s, const int t, const int n) { int res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += f; } return res; } } dinic; inline void addEdge(const int s, const int t, const int c) { N[s].e = new Edge(&amp;N[s], &amp;N[t], c); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0); (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } int n, m; inline int id(const int i, const int j) { return (i - 1) * m + j; } int main() { scanf("%d %d", &amp;n, &amp;m); const int s = 0, t = n * m + 1; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { int x; scanf("%d", &amp;x); if (x == 1) addEdge(s, id(i, j), INT_MAX); else if (x == 2) addEdge(id(i, j), t, INT_MAX); if (i != 1) addEdge(id(i - 1, j), id(i, j), 1); if (i != n) addEdge(id(i + 1, j), id(i, j), 1); if (j != 1) addEdge(id(i, j - 1), id(i, j), 1); if (j != m) addEdge(id(i, j + 1), id(i, j), 1); } } const int maxFlow = dinic(s, t, n * m + 2); printf("%d\n", maxFlow); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>最小割</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2132」圈地计划 - 最小割]]></title>
    <url>%2Fbzoj-2132%2F</url>
    <content type="text"><![CDATA[对于第 行第 列的区域，建造商业区将得到 收益，建造工业区将得到 收益。另外不同的区域连在一起可以得到额外的收益，即如果区域 相邻（相邻是指两个格子有公共边）有 块（显然 不超过 ）类型不同于 的区域，则这块区域能增加 收益。求最大收益。 链接 BZOJ 2132 题解 黑白染色，从源点到所有 点连边，容量为 ，从源点到所有 点连边，容量为 ；从所有 点到汇点连边，容量为 ，从所有 点向汇点连边，容量为 。 对于相邻的点，之间连一条容量为 的无向边。 考虑相邻的两个点，如果都割源点方向的边或都割汇点方向的边，则不需要割中间的边；如果一个割源点方向的边，另一个割汇点方向的边，则需要同时割掉中间的边，此时两个点对应区域建造相同。 所有可能获得的收益减去最小割即为答案。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 100; struct Node; struct Edge; struct Node { Edge *e, *c; int l; } N[MAXN * MAXN + 2]; struct Edge { Node *t; int c; Edge *next, *r; Edge(Node *s, Node *t, const int c) : t(t), c(c), next(s-&gt;e) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;l &amp;&amp; e-&gt;c) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } return false; } int findPath(Node *s, Node *t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) if (e-&gt;t-&gt;l == s-&gt;l + 1 &amp;&amp; e-&gt;c) { int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c)); if (f) { e-&gt;c -= f, e-&gt;r-&gt;c += f; return f; } } return 0; } int operator()(const int s, const int t, const int n) { int res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += f; } return res; } } dinic; inline void addEdge(const int s, const int t, const int c, const int rc = 0) { N[s].e = new Edge(&amp;N[s], &amp;N[t], c); N[t].e = new Edge(&amp;N[t], &amp;N[s], rc); (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } int n, m; inline int id(const int i, const int j) { return (i - 1) * m + j; } int main() { scanf("%d %d", &amp;n, &amp;m); int sum = 0; const int s = 0, t = n * m + 1; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { int x; scanf("%d", &amp;x); sum += x; if ((i + j) % 2 == 0) addEdge(s, id(i, j), x); else addEdge(id(i, j), t, x); } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { int x; scanf("%d", &amp;x); sum += x; if ((i + j) % 2 != 0) addEdge(s, id(i, j), x); else addEdge(id(i, j), t, x); } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { int x; scanf("%d", &amp;x); if (i != 1) addEdge(id(i - 1, j), id(i, j), x, x), sum += x; if (i != n) addEdge(id(i + 1, j), id(i, j), x, x), sum += x; if (j != 1) addEdge(id(i, j - 1), id(i, j), x, x), sum += x; if (j != m) addEdge(id(i, j + 1), id(i, j), x, x), sum += x; } } const int maxFlow = dinic(s, t, n * m + 2); printf("%d\n", sum - maxFlow); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POI2005」Kos-Dicing - 二分答案 + 网络流]]></title>
    <url>%2Fpoi2005-kos%2F</url>
    <content type="text"><![CDATA[Dicing 是一个两人玩的游戏，人们专门成立了这个游戏的一个俱乐部，俱乐部的人时常在一起玩这个游戏然后评选出玩得最好的人。有一个人想知道比赛以后赢的最多的那个家伙最少会赢多少场。 链接 BZOJ 1532 题解 二分答案 ，从源点向每个人连边容量为 ，从每个人向他参加的比赛连边容量为 ，每个比赛向汇点连边容量为 ，若最大流为 则可行。 每一条单位为 的增广路表示一个人赢了一场比赛。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; const int MAXN = 10000; const int MAXM = 10000; struct Node; struct Edge; struct Node { Edge *e, *c; int l; } N[MAXN + MAXM + 2]; struct Edge { Node *t; int f, c; Edge *next, *r; Edge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s-&gt;e) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;l &amp;&amp; e-&gt;c &gt; e-&gt;f) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } return false; } int findPath(Node *s, Node *t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) if (e-&gt;t-&gt;l == s-&gt;l + 1 &amp;&amp; e-&gt;c &gt; e-&gt;f) { int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c - e-&gt;f)); if (f) { e-&gt;f += f, e-&gt;r-&gt;f -= f; return f; } } return 0; } int operator()(const int s, const int t, const int n) { int res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += f; } // printf("dinic() = %d\n", res); return res; } } dinic; inline Edge *addEdge(const int s, const int t, const int c) { N[s].e = new Edge(&amp;N[s], &amp;N[t], c); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0); return (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } int n, m; Edge *E[MAXN]; inline void reset(const int c) { for (int i = 0; i &lt; n + m + 2; i++) { if (i &lt; n) E[i]-&gt;c = c; for (Edge *e = N[i].e; e; e = e-&gt;next) e-&gt;f = 0; } } inline int solve(const int s, const int t, const int n) { int l = 0, r = m; while (l &lt; r) { // printf("[%d, %d]\n", l, r); int mid = l + (r - l) / 2; reset(mid); if (dinic(s, t, n) &lt; m) l = mid + 1; else r = mid; } return l; } int main() { scanf("%d %d", &amp;n, &amp;m); const int s = 0, t = n + m + 1; for (int i = 1; i &lt;= n; i++) E[i - 1] = addEdge(s, i, 0); for (int i = 1; i &lt;= m; i++) { int a, b; scanf("%d %d", &amp;a, &amp;b); addEdge(a, n + i, 1); addEdge(b, n + i, 1); addEdge(n + i, t, 1); } printf("%d\n", solve(s, t, n + m + 2)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>二分答案</tag>
        <tag>POI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POI2006」Szk-Schools - 费用流]]></title>
    <url>%2Fpoi2006-szk%2F</url>
    <content type="text"><![CDATA[有一个长度为 的序列 ，每个数都在 之间，要求把这些数变成一个 的排列： 可以被改成 之间的数； 改变为 的花费为 。 求是否可行及最小花费。 链接 BZOJ 1520 题解 对于第 个旧数字，向 中的每个新数字连一条边，容量为 ，费用为花费。 源点向每个旧数字连边，容量为 ；每个新数字向汇点连边，容量为 。 若最大流不为 则无解，否则最小费用即为答案。 代码 #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 200; struct Node; struct Edge; struct Node { Edge *e, *in; int d, f; bool q; } N[MAXN * 2 + 2]; struct Edge { Node *s, *t; int f, c, w; Edge *next, *r; Edge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s-&gt;e) {} }; inline void edmondskarp(const int s, const int t, const int n, int &amp;f, int &amp;c) { f = c = 0; while (true) { for (int i = 0; i &lt; n; i++) { N[i].q = false; N[i].f = 0; N[i].d = INT_MAX; N[i].in = NULL; } std::queue&lt;Node *&gt; q; q.push(&amp;N[s]); N[s].f = INT_MAX, N[s].d = 0; while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;q = false; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;f &lt; e-&gt;c &amp;&amp; e-&gt;t-&gt;d &gt; v-&gt;d + e-&gt;w) { e-&gt;t-&gt;d = v-&gt;d + e-&gt;w; e-&gt;t-&gt;f = std::min(v-&gt;f, e-&gt;c - e-&gt;f); e-&gt;t-&gt;in = e; if (!e-&gt;t-&gt;q) { e-&gt;t-&gt;q = true; q.push(e-&gt;t); } } } if (N[t].d == INT_MAX) return; for (Edge *e = N[t].in; e; e = e-&gt;s-&gt;in) { e-&gt;f += N[t].f; e-&gt;r-&gt;f -= N[t].f; } f += N[t].f; c += N[t].f * N[t].d; } } inline void addEdge(const int s, const int t, const int c, const int w) { N[s].e = new Edge(&amp;N[s], &amp;N[t], c, w); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0, -w); (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } int main() { int n; scanf("%d", &amp;n); const int s = 0, t = n * 2 + 1; for (int i = 1; i &lt;= n; i++) { int m, l, r, k; scanf("%d %d %d %d", &amp;m, &amp;l, &amp;r, &amp;k); addEdge(s, i, 1, 0); addEdge(i + n, t, 1, 0); for (int j = l; j &lt;= r; j++) { addEdge(i, n + j, 1, k * abs(j - m)); } } int f, c; edmondskarp(s, t, n * 2 + 2, f, c); if (f != n) puts("NIE"); else printf("%d\n", c); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>Edmonds-Karp</tag>
        <tag>费用流</tag>
        <tag>POI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1585」Earthquake Damage 2 - 最小割]]></title>
    <url>%2Fbzoj-1585%2F</url>
    <content type="text"><![CDATA[农场里有 个牧场，有 条无向道路连接着他们，第 条道路连接着两个牧场 和 ，注意可能有很多条道路连接着相同的 和 ，并且 有可能和 相等。Farmer John 在 号牧场里。某些牧场被损坏， 条道路没有一条损坏。有 头奶牛，第 头奶牛报告一个整数 ，代表第 个牧场没有损毁，但不能够从第 个牧场经过一些没有损坏的牧场到达 号牧场。现在 Farmer John 想知道，最少有多少损坏的牧场。 链接 BZOJ 1585 题解 将点拆成两个，之间容量为 。从源点连向每个 ，从 点连向汇点，求出最小割即为答案。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 3000; const int MAXM = 20000; struct Node; struct Edge; struct Node { Edge *e, *c; int l; } N[MAXN * 2 + 2]; struct Edge { Node *t; int c; Edge *next, *r; Edge(Node *s, Node *t, const int c) : t(t), c(c), next(s-&gt;e) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;l &amp;&amp; e-&gt;c) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } return false; } int findPath(Node *s, Node *t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) if (e-&gt;t-&gt;l == s-&gt;l + 1 &amp;&amp; e-&gt;c) { int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c)); if (f) { e-&gt;c -= f, e-&gt;r-&gt;c += f; return f; } } return 0; } int operator()(const int s, const int t, const int n) { int res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += f; } return res; } } dinic; inline void addEdge(const int s, const int t, const int c) { N[s].e = new Edge(&amp;N[s], &amp;N[t], c); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0); (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } int main() { int n, m, k; scanf("%d %d %d", &amp;n, &amp;m, &amp;k); const int s = 0, t = n + n + 1; for (int i = 1; i &lt;= n; i++) addEdge(i, i + n, 1); for (int i = 0; i &lt; m; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v); addEdge(u + n, v, INT_MAX); addEdge(v + n, u, INT_MAX); } for (int i = 0; i &lt; k; i++) { int u; scanf("%d", &amp;u); addEdge(s, u + n, INT_MAX); } addEdge(1, t, INT_MAX); int maxFlow = dinic(s, t, n + n + 2); printf("%d\n", maxFlow); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>最小割</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CEOI2008」Order - 最小割]]></title>
    <url>%2Fceoi2008-order%2F</url>
    <content type="text"><![CDATA[有 个工作， 种机器，每种机器你可以租或者买过来。每个工作（可以不做）包括若干道工序，每道工序需要某种机器来完成，你可以通过购买或租用机器来完成。求最大利润。 链接 BZOJ 1391 题解 为每个工作和机器建点，增加源和汇。 从源点向每个工作连边，容量为利润；从每个工作向它需要的机器连边，容量为租用费用；从每个机器向汇点连边，容量为购买费用。 割源点连向工作的边表示不做工作，割中间的边表示租用一台机器，割机器到汇点的边表示购买机器。 所有工作利润的总和减去最小割即为答案。 代码 不知道哪里写错了，一直 MLE …… #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; // #include &lt;queue&gt; // #include &lt;vector&gt; const int MAXN = 1200; const int MAXM = 1200; struct Node; struct Edge; struct Node { Edge *e, *c; int l; } N[MAXN + MAXM + 2]; struct Edge { Node *t; int c; Edge *next, *r; Edge(Node *s, Node *t, const int c) : t(t), c(c), next(s-&gt;e) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; // std::queue&lt;Node *&gt; q; // q.push(s); static Node *q[MAXN + MAXM + 2]; Node **l = q, **r = q - 1; *++r = s; s-&gt;l = 1; while (l &lt;= r /* !q.empty() */) { Node *v = *l++ /* q.front() */; // q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;l &amp;&amp; e-&gt;c) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else *++r = e-&gt;t; // q.push(e-&gt;t); } } return false; } int findPath(Node *s, Node *t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) if (e-&gt;t-&gt;l == s-&gt;l + 1 &amp;&amp; e-&gt;c) { int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c)); if (f) { e-&gt;c -= f, e-&gt;r-&gt;c += f; return f; } } return 0; } int operator()(const int s, const int t, const int n) { int res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += f; } return res; } } dinic; inline void addEdge(const int s, const int t, const int c) { N[s].e = new Edge(&amp;N[s], &amp;N[t], c); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0); (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } int main() { int n, m, sum = 0; scanf("%d %d", &amp;n, &amp;m); const int s = 0, t = n + m + 1; for (int i = 1; i &lt;= n; i++) { int w, k; scanf("%d %d", &amp;w, &amp;k); sum += w; addEdge(s, i, w); for (int j = 0; j &lt; k; j++) { int x, c; scanf("%d %d", &amp;x, &amp;c); addEdge(i, n + x, c); } } for (int i = 1; i &lt;= m; i++) { int x; scanf("%d", &amp;x); addEdge(n + i, t, x); } /* static int w[MAXN]; static std::vector&lt; std::pair&lt;int, int&gt; &gt; used[MAXN]; static std::vector&lt;int&gt; borrow[MAXM]; static std::pair&lt;int, int&gt; buy[MAXM]; int id = n + 1, sum = 0; for (int i = 1; i &lt;= n; i++) { int k; scanf("%d %d", &amp;w[i - 1], &amp;k); sum += w[i - 1]; for (int j = 0; j &lt; k; j++) { int x, c; scanf("%d %d", &amp;x, &amp;c); int t = id++; used[i - 1].push_back(std::make_pair(t, c)); borrow[x - 1].push_back(t); } } for (int i = 0; i &lt; m; i++) { scanf("%d", &amp;buy[i].second); buy[i].first = id++; } const int s = 0, t = id++; for (int i = 1; i &lt;= n; i++) { addEdge(s, i, w[i - 1]); for (std::vector&lt; std::pair&lt;int, int&gt; &gt;::const_iterator it = used[i - 1].begin(); it != used[i - 1].end(); it++) { addEdge(i, it-&gt;first, it-&gt;second); } } for (int i = 0; i &lt; m; i++) { for (std::vector&lt;int&gt;::const_iterator it = borrow[i].begin(); it != borrow[i].end(); it++) { addEdge(*it, buy[i].first, INT_MAX); } addEdge(buy[i].first, t, buy[i].second); } */ int maxFlow = dinic(s, t, n + m + 2); printf("%d\n", sum - maxFlow); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1711」Dining - 网络流]]></title>
    <url>%2Fbzoj-1711%2F</url>
    <content type="text"><![CDATA[每一头牛只喜欢吃一些食品和饮料而别的一概不吃。农夫做了 （）种食品并准备了 （）种饮料。（）头牛都以决定了是否愿意吃某种食物和喝某种饮料。 农夫想给每一头牛一种食品和一种饮料，使得尽可能多的牛得到喜欢的食物和饮料。 每一件食物和饮料只能由一头牛来用。 链接 BZOJ 1711 题解 将一头牛拆成两个点 和 ，从每个食品向能吃它的牛的 点连一条边，从每头牛的 点向它能喝的饮料连一条边。 源点向每个食品连边，每个饮料向汇点连边。 边权均为 ，最大流即为答案。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; const int MAXN = 100; const int MAXM = 100; struct Node; struct Edge; struct Node { Edge *e, *c; int l; } N[MAXN * 2 + MAXM * 2 + 2]; struct Edge { Node *s, *t; int f, c; Edge *next, *r; Edge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s-&gt;e) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;l &amp;&amp; e-&gt;f &lt; e-&gt;c) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } return false; } int findPath(Node *s, Node *t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) if (e-&gt;t-&gt;l == s-&gt;l + 1 &amp;&amp; e-&gt;f &lt; e-&gt;c) { int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c - e-&gt;f)); if (f) { e-&gt;f += f, e-&gt;r-&gt;f -= f; return f; } } return 0; } int operator()(const int s, const int t, const int n) { int res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += f; } return res; } } dinic; inline void addEdge(const int s, const int t, const int c) { N[s].e = new Edge(&amp;N[s], &amp;N[t], c); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0); (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } int s, t; int main() { int n, m1, m2; scanf("%d %d %d", &amp;n, &amp;m1, &amp;m2); const int s = 0, t = n * 2 + m1 + m2 + 1; for (int i = 1; i &lt;= n; i++) addEdge(i, i + n, 1); for (int i = n + n + 1; i &lt;= n + n + m1; i++) addEdge(s, i, 1); for (int i = n + n + m1 + 1; i &lt;= n + n + m1 + m2; i++) addEdge(i, t, 1); for (int i = 1; i &lt;= n; i++) { int k1, k2; scanf("%d %d", &amp;k1, &amp;k2); for (int j = 0; j &lt; k1; j++) { int x; scanf("%d", &amp;x); addEdge(n + n + x, i, 1); } for (int j = 0; j &lt; k2; j++) { int x; scanf("%d", &amp;x); addEdge(i + n, n + n + m1 + x, 1); } } int maxFlow = dinic(s, t, n * 2 + m1 + m2 + 2); printf("%d\n", maxFlow); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2009」晨跑 - 费用流]]></title>
    <url>%2Fsdoi2009-run%2F</url>
    <content type="text"><![CDATA[现在给出一张地图，地图中包含 个十字路口和 条街道，Elaxia 只能从一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。Elaxia 每天从寝室出发跑到学校，保证寝室编号为 ，学校编号为 。Elaxia 的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路口。 他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天数尽量长。 链接 BZOJ 1877 题解 将每个点拆成两个点，中间设置 的流量限制，求出最小费用最大流，费用为路程，流量为天数。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; const int MAXN = 200; const int MAXM = 20000; struct Node; struct Edge; struct Node { Edge *e, *in; int f, d; bool q; } N[MAXN * 2 + 2]; struct Edge { Node *s, *t; int f, c, w; Edge *next, *r; Edge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t, const int c, const int w) { N[s].e = new Edge(&amp;N[s], &amp;N[t], c, w); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0, -w); (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } inline void edmondskarp(const int s, const int t, const int n, int &amp;f, int &amp;c) { f = c = 0; while (true) { // printf("%d %d\n", f, c); for (int i = 0; i &lt; n; i++) { N[i].in = NULL; N[i].f = 0; N[i].d = INT_MAX; N[i].q = false; } std::queue&lt;Node *&gt; q; q.push(&amp;N[s]); N[s].f = INT_MAX, N[s].d = 0; while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;q = false; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;d &gt; v-&gt;d + e-&gt;w &amp;&amp; e-&gt;f &lt; e-&gt;c) { e-&gt;t-&gt;d = v-&gt;d + e-&gt;w; e-&gt;t-&gt;f = std::min(v-&gt;f, e-&gt;c - e-&gt;f); e-&gt;t-&gt;in = e; if (!e-&gt;t-&gt;q) { e-&gt;t-&gt;q = true; q.push(e-&gt;t); } } } if (N[t].d == INT_MAX) return; for (Edge *e = N[t].in; e; e = e-&gt;s-&gt;in) { // printf("[%ld, %ld]\n", e-&gt;s - N, e-&gt;t - N); e-&gt;f += N[t].f; e-&gt;r-&gt;f -= N[t].f; } f += N[t].f; c += N[t].f * N[t].d; } } int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) addEdge(i, i + n, 1, 0); const int s = 0, t = n * 2 + 1; for (int i = 0; i &lt; m; i++) { int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); addEdge(u + n, v, 1, w); } addEdge(s, 1 + n, INT_MAX, 0); addEdge(n, t, INT_MAX, 0); int f, c; edmondskarp(s, t, n * 2 + 2, f, c); printf("%d %d\n", f, c); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>Edmonds-Karp</tag>
        <tag>费用流</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3894」文理分科 - 最大权闭合图]]></title>
    <url>%2Fbzoj-3894%2F</url>
    <content type="text"><![CDATA[小 P 所在的班级要进行文理分科。他的班级可以用一个 的矩阵进行描述，每个格子代表一个同学的座位。每位同学必须从文科和理科中选择一科。同学们在选择科目的时候会获得一个满意值。满意值按如下的方式得到： 如果第 行第 列的同学选择了文科，则他将获得 的满意值，如果选择理科，将获得 的满意值。 如果第 行第 列的同学选择了文科，并且他相邻（两个格子相邻当且仅当它们拥有一条相同的边）的同学全部选择了文科，则他会更开心，所以会增加 的满意值。 如果第 行第 列的同学选择了理科，并且他相邻的同学全部选择了理科，则增加 的满意值。 小 P 想知道，大家应该如何选择，才能使所有人的满意值之和最大。请告诉他这个最大值。 链接 BZOJ 2127 题解 先考虑每个人都选择文科，然后考虑一个人改选理科带来的影响。 建立最大权闭合图模型：为每个人建 个点，分别表示 TA 自己改选理科（权值为 ）、TA 和 TA 相邻的人有任意一个选择理科（失去文科的收益加成）、TA 和 TA 相邻的人全部选择理科（获得理科的收益加成）。 对于每一个人，从TA 和 TA 相邻所有人的第一个点向 TA 的第二个点连边，从 TA 的第三个点向 TA 和 TA 相邻所有人的第一个点连边。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; const int MAXN = 100; struct Node; struct Edge; struct Node { Edge *e, *c; int l; } N[MAXN * MAXN * 3 + 2]; struct Edge { Node *s, *t; int f, c; Edge *next, *r; Edge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s-&gt;e) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;l &amp;&amp; e-&gt;f &lt; e-&gt;c) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } return false; } int findPath(Node *s, Node *t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) if (e-&gt;t-&gt;l == s-&gt;l + 1 &amp;&amp; e-&gt;f &lt; e-&gt;c) { int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c - e-&gt;f)); if (f) { e-&gt;f += f, e-&gt;r-&gt;f -= f; return f; } } return 0; } int operator()(const int s, const int t, const int n) { int res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += f; } return res; } } dinic; inline void addEdge(const int s, const int t, const int c) { N[s].e = new Edge(&amp;N[s], &amp;N[t], c); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0); (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } int s, t; int main() { int n, m, sum = 0; scanf("%d %d", &amp;n, &amp;m); static int a[MAXN][MAXN], b[MAXN][MAXN], A[MAXN][MAXN], B[MAXN][MAXN], id[MAXN][MAXN][3]; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) scanf("%d", &amp;a[i][j]), sum += a[i][j]; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) scanf("%d", &amp;b[i][j]); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) scanf("%d", &amp;A[i][j]), sum += A[i][j]; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) scanf("%d", &amp;B[i][j]); int x = 1; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) for (int k = 0; k &lt; 3; k++) id[i][j][k] = x++; const int s = 0, t = n * m * 3 + 1; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { int x = b[i][j] - a[i][j]; if (x &gt; 0) addEdge(s, id[i][j][0], x), sum += x; else addEdge(id[i][j][0], t, -x); addEdge(id[i][j][1], t, A[i][j]); addEdge(s, id[i][j][2], B[i][j]), sum += B[i][j]; addEdge(id[i][j][0], id[i][j][1], INT_MAX); addEdge(id[i][j][2], id[i][j][0], INT_MAX); if (i != 0) { addEdge(id[i][j][0], id[i - 1][j][1], INT_MAX); addEdge(id[i - 1][j][2], id[i][j][0], INT_MAX); } if (i != n - 1) { addEdge(id[i][j][0], id[i + 1][j][1], INT_MAX); addEdge(id[i + 1][j][2], id[i][j][0], INT_MAX); } if (j != 0) { addEdge(id[i][j][0], id[i][j - 1][1], INT_MAX); addEdge(id[i][j - 1][2], id[i][j][0], INT_MAX); } if (j != m - 1) { addEdge(id[i][j][0], id[i][j + 1][1], INT_MAX); addEdge(id[i][j + 1][2], id[i][j][0], INT_MAX); } } } int maxFlow = dinic(s, t, n * m * 3 + 2); printf("%d\n", sum - maxFlow); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>最大权闭合图</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2127」happiness - 最大权闭合图]]></title>
    <url>%2Fbzoj-2127%2F</url>
    <content type="text"><![CDATA[高一一班的座位表是个 的矩阵，经过一个学期的相处，每个同学和前后左右相邻的同学互相成为了好朋友。这学期要分文理科了，每个同学对于选择文科与理科有着自己的喜悦值，而一对好朋友如果能同时选文科或者理科，那么他们又将收获一些喜悦值。如何分配可以使得全班的喜悦值总和最大？ 链接 BZOJ 2127 题解 先考虑每个人都选择文科，然后考虑一个人改选理科带来的影响。 建立最大权闭合图模型：为每个人建点，权值为理科收益减去文科收益。为每一对之间建两个点，一个点表示两个人中任意一个人选理，则文科收益加成取消，另一个点表示两个人都选理，则获得理科收益加成。从每一对的第一个点向两个人连边，每个人向每一对的第二个点连边。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; const int MAXN = 100; struct Node; struct Edge; struct Node { Edge *e, *c; int l; } N[MAXN * MAXN + MAXN * (MAXN - 1) * 4 + 2]; struct Edge { Node *s, *t; int f, c; Edge *next, *r; Edge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s-&gt;e) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;l &amp;&amp; e-&gt;f &lt; e-&gt;c) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } return false; } int findPath(Node *s, Node *t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) if (e-&gt;t-&gt;l == s-&gt;l + 1 &amp;&amp; e-&gt;f &lt; e-&gt;c) { int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c - e-&gt;f)); if (f) { e-&gt;f += f, e-&gt;r-&gt;f -= f; return f; } } return 0; } int operator()(const int s, const int t, const int n) { int res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += f; } return res; } } dinic; inline void addEdge(const int s, const int t, const int c) { N[s].e = new Edge(&amp;N[s], &amp;N[t], c); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0); (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } int s, t; int main() { int n, m, sum = 0; scanf("%d %d", &amp;n, &amp;m); static int a[MAXN][MAXN], b[MAXN][MAXN], aDown[MAXN - 1][MAXN], bDown[MAXN - 1][MAXN], aRight[MAXN][MAXN - 1], bRight[MAXN][MAXN - 1], vID[MAXN][MAXN], eID[MAXN][MAXN][2][2]; const int DOWN = 0, RIGHT = 1; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) scanf("%d", &amp;a[i][j]), sum += a[i][j]; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) scanf("%d", &amp;b[i][j]); for (int i = 0; i &lt; n - 1; i++) for (int j = 0; j &lt; m; j++) scanf("%d", &amp;aDown[i][j]), sum += aDown[i][j]; for (int i = 0; i &lt; n - 1; i++) for (int j = 0; j &lt; m; j++) scanf("%d", &amp;bDown[i][j]); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m - 1; j++) scanf("%d", &amp;aRight[i][j]), sum += aRight[i][j]; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m - 1; j++) scanf("%d", &amp;bRight[i][j]); int id = 1; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) vID[i][j] = id++; // printf("eID starts from %d\n", id); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (i != n - 1) eID[i][j][DOWN][0] = id++, eID[i][j][DOWN][1] = id++; if (j != m - 1) eID[i][j][RIGHT][0] = id++, eID[i][j][RIGHT][1] = id++; } } const int s = 0, t = n * m + (n * (m - 1) + m * (n - 1)) * 2 + 1; // printf("%d %d\n", id, t); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { int x = b[i][j] - a[i][j]; if (x &gt; 0) addEdge(s, vID[i][j], x), sum += x; else addEdge(vID[i][j], t, -x); if (i != n - 1) { addEdge(eID[i][j][DOWN][0], t, aDown[i][j]); addEdge(s, eID[i][j][DOWN][1], bDown[i][j]), sum += bDown[i][j]; addEdge(vID[i][j], eID[i][j][DOWN][0], INT_MAX); addEdge(vID[i + 1][j], eID[i][j][DOWN][0], INT_MAX); addEdge(eID[i][j][DOWN][1], vID[i][j], INT_MAX); addEdge(eID[i][j][DOWN][1], vID[i + 1][j], INT_MAX); } if (j != m - 1) { addEdge(eID[i][j][RIGHT][0], t, aRight[i][j]); addEdge(s, eID[i][j][RIGHT][1], bRight[i][j]), sum += bRight[i][j]; addEdge(vID[i][j], eID[i][j][RIGHT][0], INT_MAX); addEdge(vID[i][j + 1], eID[i][j][RIGHT][0], INT_MAX); addEdge(eID[i][j][RIGHT][1], vID[i][j], INT_MAX); addEdge(eID[i][j][RIGHT][1], vID[i][j + 1], INT_MAX); } } } int maxFlow = dinic(s, t, n * m + (n * (m - 1) + m * (n - 1)) * 2 + 2); printf("%d\n", sum - maxFlow); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>最大权闭合图</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3438」小 M 的作物 - 最大权闭合图]]></title>
    <url>%2Fbzoj-3438%2F</url>
    <content type="text"><![CDATA[小 M 有耕地 和 ，有 中作物的种子，第i种作物种植在 中种植可以获得 的收益，在 中种植可以获得 的收益。 共有 种作物组合，第 个组合中的作物共同种在 中可以获得 的额外收益，共同总在 中可以获得 的额外收益。 求最大收益。 链接 BZOJ 3438 题解 首先考虑将所有作物种植在 中，收益为 。 考虑选择一些作物改为种在 中，任意一个作物种在 中后，包含该作物的组合 的 将失去。如果一个组合中所有作物都种在 中，则该组合 的 将被获得。 建立最大权闭合图模型。每个作物的点权为 ，每个组合拆为两个点，一个点表示损失掉的 ，另一个点表示得到的 。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; const int MAXN = 1000; const int MAXM = 1000; struct Node; struct Edge; struct Node { Edge *e, *c; int l; } N[MAXN + MAXM * 2 + 2]; struct Edge { Node *s, *t; int f, c; Edge *next, *r; Edge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s-&gt;e) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;l &amp;&amp; e-&gt;f &lt; e-&gt;c) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } return false; } int findPath(Node *s, Node *t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) if (e-&gt;t-&gt;l == s-&gt;l + 1 &amp;&amp; e-&gt;f &lt; e-&gt;c) { int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c - e-&gt;f)); if (f) { e-&gt;f += f, e-&gt;r-&gt;f -= f; return f; } } return 0; } int operator()(const int s, const int t, const int n) { int res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += f; } return res; } } dinic; inline void addEdge(const int s, const int t, const int c) { // printf("[%d, %d] = %d\n", s, t, c); N[s].e = new Edge(&amp;N[s], &amp;N[t], c); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0); (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } int s, t; int main() { int n; scanf("%d", &amp;n); int sum = 0; static int a[MAXN], b[MAXN]; for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]), sum += a[i]; for (int i = 0; i &lt; n; i++) scanf("%d", &amp;b[i]); int m; scanf("%d", &amp;m); const int s = 0, t = n + m * 2 + 1; for (int i = 1; i &lt;= n; i++) { int w = b[i - 1] - a[i - 1]; if (w &gt; 0) addEdge(s, i, w), sum += w; else addEdge(i, t, -w); } for (int i = n + 1; i &lt;= n + m; i++) { int k, c1, c2; scanf("%d %d %d", &amp;k, &amp;c1, &amp;c2); addEdge(i, t, c1); addEdge(s, i + m, c2); sum += c1 + c2; for (int j = 0; j &lt; k; j++) { int x; scanf("%d", &amp;x); addEdge(x, i, INT_MAX); addEdge(i + m, x, INT_MAX); } } int maxFlow = dinic(s, t, n + m * 2 + 2); printf("%d\n", sum - maxFlow); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>最大权闭合图</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SHOI2007」善意的投票 - 最小割]]></title>
    <url>%2Fshoi2007-vote%2F</url>
    <content type="text"><![CDATA[幼儿园里有 个小朋友打算通过投票来决定睡不睡午觉。他们也可以投和自己本来意愿相反的票。我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数。每位小朋友应该怎样投票，才能使冲突数最小？ 链接 BZOJ 1934 题解 从源点向每个意愿反对的人连边，从每个意愿赞成的人向汇点连边，「好朋友」之间连单向边，容量均为 。最小割即为答案。 对于一条增广路 ， 意愿反对， 意愿赞成。如果割掉中间 的边，表示 和 分别按照自己的意愿投票，两个人之间冲突，代价 。如果割掉 或 ，表示 或 不按照自己的意愿，自身发生冲突，代价 。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; const int MAXN = 300; const int MAXM = MAXN * (MAXN - 1) / 2; struct Node; struct Edge; struct Node { Edge *e, *c; int l; } N[MAXN + 2]; struct Edge { Node *s, *t; int f, c; Edge *next, *r; Edge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s-&gt;e) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;l &amp;&amp; e-&gt;f &lt; e-&gt;c) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } return false; } int findPath(Node *s, Node *t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *e = s-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;l == s-&gt;l + 1 &amp;&amp; e-&gt;f &lt; e-&gt;c) { int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c - e-&gt;f)); if (f) { e-&gt;f += f, e-&gt;r-&gt;f -= f; return f; } } return 0; } int operator()(const int s, const int t, const int n) { int res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += f; } return res; } } dinic; inline void addEdge(const int s, const int t, const int c, const int rc = 0) { // printf("[%d, %d, %d, %d]\n", s, t, c, rc); N[s].e = new Edge(&amp;N[s], &amp;N[t], c); N[t].e = new Edge(&amp;N[t], &amp;N[s], rc); (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); const int s = 0, t = n + 1; for (int i = 1; i &lt;= n; i++) { int x; scanf("%d", &amp;x); if (x == 0) { addEdge(s, i, 1); } else { addEdge(i, t, 1); } } for (int i = 0; i &lt; m; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v); addEdge(u, v, 1, 1); } int maxFlow = dinic(s, t, n + 2); printf("%d\n", maxFlow); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>最小割</tag>
        <tag>SHOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2010」网络扩容 - 网络流 + 费用流]]></title>
    <url>%2Fzjoi2010-network%2F</url>
    <content type="text"><![CDATA[给定一张有向图，每条边都有一个容量 和一个扩容费用 。这里扩容费用是指将容量扩大 所需的费用，求 在不扩容的情况下， 到 的最大流； 将 到 的最大流增加 所需的最小扩容费用。 链接 BZOJ 1834 题解 第一问直接跑网络流。 第二问，考虑扩容的实质是增加一条连接原来两个点的边，并且这条边费用为 。 将每一条边对应新增的边加入到残量网络中，限制流量为 跑最小费用流即可。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 1000; const int MAXM = 5000; const int MAXK = 10; struct Node; struct Edge; struct Node { Edge *e, *c, *in; int l, d, f; bool q; } N[MAXN + 1]; struct Edge { Node *s, *t; int f, c, w; Edge *next, *r; Edge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s-&gt;e) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;l &amp;&amp; e-&gt;f &lt; e-&gt;c) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } return false; } int findPath(Node *s, Node *t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) if (e-&gt;t-&gt;l == s-&gt;l + 1 &amp;&amp; e-&gt;f &lt; e-&gt;c) { int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c - e-&gt;f)); if (f) { e-&gt;f += f, e-&gt;r-&gt;f -= f; return f; } } return 0; } int operator()(const int s, const int t, const int n) { int res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += f; } return res; } } dinic; inline void edmondskarp(const int s, const int t, const int n, int &amp;f, int &amp;c) { f = c = 0; while (true) { for (int i = 0; i &lt; n; i++) { N[i].f = 0; N[i].d = INT_MAX; N[i].q = false; N[i].in = NULL; } std::queue&lt;Node *&gt; q; q.push(&amp;N[s]); N[s].d = 0, N[s].f = INT_MAX; while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;q = false; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;f &lt; e-&gt;c &amp;&amp; e-&gt;t-&gt;d &gt; v-&gt;d + e-&gt;w) { e-&gt;t-&gt;d = v-&gt;d + e-&gt;w; e-&gt;t-&gt;in = e; e-&gt;t-&gt;f = std::min(v-&gt;f, e-&gt;c - e-&gt;f); if (!e-&gt;t-&gt;q) { e-&gt;t-&gt;q = true; q.push(e-&gt;t); } } } if (N[t].d == INT_MAX) return; for (Edge *e = N[t].in; e; e = e-&gt;s-&gt;in) { e-&gt;f += N[t].f; e-&gt;r-&gt;f -= N[t].f; } f += N[t].f; c += N[t].f * N[t].d; } } inline void addEdge(const int s, const int t, const int c, const int w = 0) { N[s].e = new Edge(&amp;N[s], &amp;N[t], c, w); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0, -w); (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } int main() { int n, m, k; static struct Edge { int s, t, c, w; } E[MAXM]; scanf("%d %d %d", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; m; i++) { Edge &amp;e = E[i]; scanf("%d %d %d %d", &amp;e.s, &amp;e.t, &amp;e.c, &amp;e.w); addEdge(e.s, e.t, e.c, 0); } int maxFlow = dinic(1, n, n + 1); for (int i = 0; i &lt; m; i++) { Edge &amp;e = E[i]; addEdge(e.s, e.t, INT_MAX, e.w); } addEdge(0, 1, k, 0); int flow, cost; edmondskarp(0, n, n + 1, flow, cost); printf("%d %d\n", maxFlow, cost); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>Edmonds-Karp</tag>
        <tag>费用流</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CQOI2011」动态逆序对 - CDQ]]></title>
    <url>%2Fcqoi2011-inverse%2F</url>
    <content type="text"><![CDATA[对于序列 ，它的逆序对数定义为满足 ，且 的数对 的个数。给 到 的一个排列，按照某种顺序依次删除 个元素，你的任务是在每次删除一个元素之前统计整个序列的逆序对数。 链接 BZOJ 3295 题解 离线将删除转换为添加，并在开始将未被删除的元素加入。 考虑加入一个元素时，增加的逆序对数量 —— 等于在它左边比它大的元素数量加在它右边比它小的元素数量。 对于前一半，将每个数 改为 ，则转化为在它左边比它小的数量，经典的三维（时间、位置、大小）偏序问题，使用 CDQ 分治解决。 对于后一半，将每个数的位置 改为 ，则同样转化为在它左边比它小的数量，同理用 CDQ 分治解决即可。 求出每次对答案的贡献后做前缀和即可。 代码 #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;algorithm&gt; const int MAXN = 100000; const int MAXM = 50000; struct Triple { int id, pos, num; unsigned int *ans; Triple(const int pos, const int num, unsigned int *ans) : pos(pos), num(num), ans(ans) { static int id = 0; this-&gt;id = id++; } Triple() {} bool operator&lt;(const Triple &amp;other) const { return id &lt; other.id; } } a[MAXN]; int n, m; struct BinaryIndexedTree { unsigned int a[MAXN]; static int lowbit(const int x) { return x &amp; -x; } unsigned int query(const int x) { unsigned int ans = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) ans += a[i - 1]; return ans; } void update(const int x, const int delta) { for (int i = x; i &lt;= n; i += lowbit(i)) a[i - 1] += delta; } void clear(const int x) { for (int i = x; i &lt;= n; i += lowbit(i)) { if (a[i - 1]) a[i - 1] = 0; else break; } } } bit; inline void cdq(Triple *l, Triple *r) { /* for (Triple *a = l; a &lt;= r; a++) { if (a-&gt;ans) { for (Triple *b = l; b &lt; a; b++) { if (b-&gt;pos &lt; a-&gt;pos &amp;&amp; b-&gt;num &lt; a-&gt;num) (*a-&gt;ans)++; } } } return; */ if (l == r) return; Triple *m = l + (r - l) / 2; cdq(l, m); cdq(m + 1, r); static Triple tmp[MAXN]; for (Triple *q = tmp, *p1 = l, *p2 = m + 1; q &lt;= tmp + (r - l); q++) { if ((p1 &lt;= m &amp;&amp; p1-&gt;pos &lt;= p2-&gt;pos) || p2 &gt; r) { *q = *p1++; bit.update(q-&gt;num, 1); } else { *q = *p2++; if (q-&gt;ans) *q-&gt;ans += bit.query(q-&gt;num); } } for (Triple *q = tmp, *p = l; p &lt;= r; q++, p++) { bit.clear(q-&gt;num); *p = *q; assert(p-&gt;num != 0); } } /* inline void print() { for (int i = 0; i &lt; n; i++) { printf("[%d, %d, %d]%s", a[i].id, a[i].pos, a[i].num, i == n - 1 ? "\n" : ", "); } } */ int main() { scanf("%d %d", &amp;n, &amp;m); static int num[MAXN], pos[MAXN], del[MAXM]; for (int i = 0; i &lt; n; i++) scanf("%d", &amp;num[i]), pos[num[i] - 1] = i + 1; static bool deleted[MAXN]; for (int i = 0; i &lt; m; i++) { int x; scanf("%d", &amp;x); del[i] = pos[x - 1]; deleted[del[i] - 1] = true; } static unsigned int ans[MAXN]; int cnt = 0; for (int i = 1; i &lt;= n; i++) if (!deleted[i - 1]) { a[cnt] = Triple(i, num[i - 1], &amp;ans[n - cnt - 1]); // , printf("ans[%d]\n", n - cnt - 1); cnt++; } // const int invalidCnt = cnt; for (int i = m - 1; i &gt;= 0; i--) { a[cnt++] = Triple(del[i], num[del[i] - 1], &amp;ans[i]); // , printf("ans[%d]\n", i); } for (int i = 0; i &lt; cnt; i++) { a[i].pos = n - a[i].pos + 1; } // print(); cdq(a, a + n - 1); std::sort(a, a + cnt); for (int i = 0; i &lt; cnt; i++) { a[i].pos = n - a[i].pos + 1; a[i].num = n - a[i].num + 1; } // print(); cdq(a, a + n - 1); for (int i = n - 2; i &gt;= 0; i--) ans[i] += ans[i + 1]; for (int i = 0; i &lt; m; i++) printf("%u\n", ans[i]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>BZOJ</tag>
        <tag>CDQ</tag>
        <tag>分治</tag>
        <tag>CQOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1176」Mokia - CDQ]]></title>
    <url>%2Fbzoj-1176%2F</url>
    <content type="text"><![CDATA[维护一个 （）的矩阵，初始值均为 。每次操作可以增加某格子的权值，或询问某子矩阵的总权值。 修改操作数 ，询问数 。 链接 BZOJ 1176 题解 设 表示左上角 右下角 的矩形数字总和，则 问题转化为三维（时间、、）偏序问题，时间是有序的，对 进行分治，用树状数组维护 即可。 代码 #include &lt;cstdio&gt; const int MAXN = 2000000 + 1; const int MAXQ = 10000; const int MAXM = 160000 + MAXQ * 4; struct Triple { int id, x, y, d, delta, *ans; Triple() {} Triple(const int x, const int y, const int d, int *ans) : x(x), y(y), d(d), delta(0), ans(ans) { setID(); } Triple(const int x, const int y, const int delta) : x(x), y(y), d(0), delta(delta), ans(NULL) { setID(); } void setID() { static int id = 0; this-&gt;id = id++; } bool isQuery() const { return d != 0; } } a[MAXM]; int s, n, m, cnt, ans[MAXQ]; struct BinaryIndexedTree { int a[MAXN]; static int lowbit(const int x) { return x &amp; -x; } int query(const int x) const { int ans = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) ans += a[i - 1]; return ans; } void update(const int x, const int delta) { for (int i = x; i &lt;= n; i += lowbit(i)) a[i - 1] += delta; } void clear(const int x) { for (int i = x; i &lt;= n; i += lowbit(i)) { if (a[i - 1]) a[i - 1] = 0; else break; } } } bit; inline void cdq(Triple *l, Triple *r) { if (l == r) return; Triple *mid = l + (r - l) / 2; cdq(l, mid); cdq(mid + 1, r); static Triple tmp[MAXM]; for (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p &lt;= tmp + (r - l); p++) { if ((p1-&gt;x &lt;= p2-&gt;x &amp;&amp; p1 &lt;= mid) || p2 &gt; r) { *p = *p1++; if (!p-&gt;isQuery()) bit.update(p-&gt;y, p-&gt;delta); } else { *p = *p2++; if (p-&gt;isQuery()) *p-&gt;ans += bit.query(p-&gt;y) * p-&gt;d; } } for (Triple *p = tmp, *q = l; q &lt;= r; p++, q++) { if (q &lt;= mid &amp;&amp; !q-&gt;isQuery()) bit.clear(q-&gt;y); *q = *p; } } int main() { scanf("%d %d", &amp;s, &amp;n), n++; int qcnt = 0; while (true) { int t; scanf("%d", &amp;t); if (t == 3) break; else if (t == 2) { int x1, y1, x2, y2; scanf("%d %d %d %d", &amp;x1, &amp;y1, &amp;x2, &amp;y2), x1++, y1++, x2++, y2++; int *p = &amp;ans[qcnt++]; *p = (y2 - y1 + 1) * (x2 - x1 + 1) * s; a[cnt++] = Triple(x2, y2, 1, p); a[cnt++] = Triple(x1 - 1, y2, -1, p); a[cnt++] = Triple(x2, y1 - 1, -1, p); a[cnt++] = Triple(x1 - 1, y1 - 1, 1, p); } else if (t == 1) { int x, y, delta; scanf("%d %d %d", &amp;x, &amp;y, &amp;delta), x++, y++; a[cnt++] = Triple(x, y, delta); } } /* for (int i = 0; i &lt; cnt; i++) { printf("Triple(x = %d, y = %d, d = %d, delta = %d)\n", a[i].x, a[i].y, a[i].d, a[i].delta); } */ cdq(a, a + cnt - 1); for (int i = 0; i &lt; qcnt; i++) printf("%d\n", ans[i]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>BZOJ</tag>
        <tag>CDQ</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2010」地精部落 - DP]]></title>
    <url>%2Fsdoi2010-goblin%2F</url>
    <content type="text"><![CDATA[我们称一个排列是合法的，当且仅当每一个数都满足这个数比它相邻的数都要大或都要小。 求长度为 的合法排列数量。 链接 BZOJ 1925 题解 题目相当于要求 ~ 的合法排列数。 设 表示 ~ 的排列，第一个数为 （），且第二个数比第一个数小的方案数。 考虑第二个数，当第二个数小于 时，其方案数为第一个数为 时的方案数，即 。 当第二个数等于 时，从第二个数开始，是一个 ~ 的排列，这个排列的第二个数比第一个数大。如果将每个数 变成 ，那么就变成原有的第二个数比第一个数小的情况了。即 。 所以转移方程为 。 答案为 ，因为要考虑第二个数大于第一个数的方案数所以乘 。 代码 不使用滚动数组，内存 30M+ 是可以过的。 #include &lt;cstdio&gt; const int MAXN = 4200; int n, p; int _f[MAXN * (MAXN + 1) / 2]; int *f[MAXN + 1]; inline void init() { int *curr = _f; for (int i = 0; i &lt; n; i++) { f[i] = curr; curr += i + 1; } // printf("%ld %d\n", curr - _f, n * (n + 1) / 2); } int main() { scanf("%d %d", &amp;n, &amp;p); init(); f[1][1] = 1; for (int i = 2; i &lt; n; i++) { for (int j = 1; j &lt;= i; j++) { f[i][j] = (f[i][j - 1] + f[i - 1][i - j]) % p; // printf("f[%d][%d] = %d\n", i, j, f[i][j]); } } int ans = 0; for (int i = 0; i &lt; n; i++) ans = (ans + f[n - 1][i]) % p; printf("%d\n", ans * 2 % p); return 0; } 使用滚动数组之后，时间也快不少。 #include &lt;cstdio&gt; const int MAXN = 4200; int n, p; int main() { scanf("%d %d", &amp;n, &amp;p); static int f[2][MAXN]; f[1 % 2][1] = 1; for (int i = 2; i &lt; n; i++) { for (int j = 1; j &lt;= i; j++) { f[i % 2][j] = (f[i % 2][j - 1] + f[(i - 1) % 2][i - j]) % p; } } int ans = 0; for (int i = 0; i &lt; n; i++) ans = (ans + f[(n - 1) % 2][i]) % p; printf("%d\n", ans * 2 % p); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3262」陌上花开 - CDQ]]></title>
    <url>%2Fbzoj-3262%2F</url>
    <content type="text"><![CDATA[定义一个序列，序列中每个元素都是一个三元组 。 若 ，则称 比 优。 定义 的等级为有多少 满足 比 更优。 求每个等级的元素数量。 链接 BZOJ 3262 题解 经典的三维偏序问题，使用 CDQ 分治解决。 首先，将第一维排序，进行 CDQ 分治。分治时保证前一半元素的 始终小于等于后一半，并且两半分别按照 升序。 分治完两半之后，将两半按照 归并，并同时对 维护树状数组，动态查询有多少点的 小于等于当前点。树状数组保证了 的大小关系，归并保证了 的大小关系，排序保证了 的大小关系，CDQ 保证了对一个元素有贡献的所有元素都被考虑的到。 每一次分治完成后需要清空树状数组。 注意可能有多个重复的元素，此时只需记录一个元素出现的次数即可。一个元素会对它本身的答案有贡献，在分治到最后一层时对其赋值即可。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 100000; const int MAXK = 200000; struct Triple { int a, b, c, cnt, ans; } a[MAXN], A[MAXN]; bool operator&lt;(const Triple &amp;a, const Triple &amp;b) { return a.a &lt; b.a || (a.a == b.a &amp;&amp; a.b &lt; b.b) || (a.a == b.a &amp;&amp; a.b == b.b &amp;&amp; a.c &lt; b.c); } int n, k; struct BinaryIndexedTree { int a[MAXK]; static int lowbit(const int x) { return x &amp; -x; } int query(const int x) { int ans = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) ans += a[i - 1]; return ans; } void update(const int x, const int delta) { for (int i = x; i &lt;= k; i += lowbit(i)) a[i - 1] += delta; } void clean(const int x) { for (int i = x; i &lt;= k; i += lowbit(i)) { if (a[i - 1]) a[i - 1] = 0; else break; } } } bit; inline void cdq(Triple *l, Triple *r) { if (l == r) { l-&gt;ans += l-&gt;cnt - 1; return; } Triple *mid = l + (r - l) / 2; cdq(l, mid); cdq(mid + 1, r); static Triple tmp[MAXN]; for (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p &lt;= tmp + (r - l); p++) { if ((p1-&gt;b &lt;= p2-&gt;b &amp;&amp; p1 &lt;= mid) || p2 &gt; r) { *p = *p1++; bit.update(p-&gt;c, p-&gt;cnt); } else { *p = *p2++; p-&gt;ans += bit.query(p-&gt;c); } } for (Triple *p = tmp, *q = l; q &lt;= r; p++, q++) { bit.clean(p-&gt;c); *q = *p; } /* printf("cdq(%ld, %ld): ", l - A + 1, r - A + 1); for (Triple *p = l; p &lt;= r; p++) { printf("(%d, %d, %d)%s", p-&gt;a, p-&gt;b, p-&gt;c, p == r ? "\n" : ", "); } */ } template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; while (ch = getchar(), !(ch &gt;= '0' &amp;&amp; ch &lt;= '9')); do x = x * 10 + (ch - '0'); while (ch = getchar(), (ch &gt;= '0' &amp;&amp; ch &lt;= '9')); } template &lt;typename T&gt; inline void write(T &amp;x) { static char s[20]; int cnt = 0; do s[cnt++] = x % 10; while (x /= 10); while (cnt--) putchar(s[cnt] + '0'); putchar('\n'); } int main() { read(n), read(k); for (int i = 0; i &lt; n; i++) read(a[i].a), read(a[i].b), read(a[i].c), a[i].cnt = 1; // scanf("%d %d", &amp;n, &amp;k); // for (int i = 0; i &lt; n; i++) scanf("%d %d %d", &amp;a[i].a, &amp;a[i].b, &amp;a[i].c), a[i].cnt = 1; std::sort(a, a + n); int cnt = 0; for (int i = 0; i &lt; n; i++) { if (i == 0 || !(a[i].a == a[i - 1].a &amp;&amp; a[i].b == a[i - 1].b &amp;&amp; a[i].c == a[i - 1].c)) A[cnt++] = a[i]; else A[cnt - 1].cnt++; } cdq(A, A + cnt - 1); static int ans[MAXN]; for (int i = 0; i &lt; cnt; i++) ans[A[i].ans] += A[i].cnt; for (int i = 0; i &lt; n; i++) write(ans[i]); // for (int i = 0; i &lt; n; i++) printf("%d\n", ans[i]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>BZOJ</tag>
        <tag>CDQ</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3196」二逼平衡树 - 树套树]]></title>
    <url>%2Fbzoj-3196%2F</url>
    <content type="text"><![CDATA[您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作： 查询 在区间内的排名； 查询区间内排名为 的值； 修改某一位值上的数值； 查询 在区间内的前驱（前驱定义为小于 ，且最大的数）； 查询 在区间内的后继（后继定义为大于 ，且最小的数）。 链接 BZOJ 3196 题解 对于没有区间限制的查询，我们可以使用平衡树维护，有了区间的限制，可以在外层套上一层线段树。 对序列建立线段树，在每个线段树节点中建立平衡树。考虑到序列中的每个数最多会出现在线段树上的 个节点中，总空间复杂度为 。可以在 的时间内完成建树。 排名 在该区间对应在线段树上的 个节点中的平衡树上查询该数的排名，累加得到区间内公有多少数比该数小即可； 根据排名选择 枚举答案，并查询所枚举的答案的排名，显然这里的答案是单调的，可以使用二分。 二分 ，如果 的排名大于 ，则它不可能成为答案，但这时我们可以将右边界置为 ；反之它可以被置为左边界。最终二分区间内只剩下两个数时，判断较大的数是否合法即可。 对数据进行离散化可以加速二分。 修改 转化为一次删除一次插入即可。 前驱（后继） 在该区间对应在线段树上的 个节点中的平衡树上查询该数前驱（后继），取最大（小）值即可。 总时间复杂度为 ，但 Splay 常数巨大，在 BZOJ 可以卡着时限通过。 另一种方法是将内层的平衡树换为带垃圾回收的动态开点的权值线段树，空间复杂度为 ，需要 512M 内存。 正解分块，时间复杂度为 ，我没写。 代码 线段树套 Splay，RP 不好的时候会 TLE。 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;cassert&gt; #include &lt;algorithm&gt; const int MAXN = 50000; const int MAXM = 50000; int n, m, a[MAXN]; struct Splay { enum Relation { L = 0, R = 1 }; struct Node { Node *c[2], *p, **r; int size, cnt, val; Node(Node *p, const int val, Node **r) : p(p), r(r), size(1), cnt(1), val(val) { c[L] = c[R] = NULL; } ~Node() { if (c[L]) delete c[L]; if (c[R]) delete c[R]; } void maintain() { size = cnt; if (c[L]) size += c[L]-&gt;size; if (c[R]) size += c[R]-&gt;size; } Relation relatain() const { return this == p-&gt;c[L] ? L : R; } void rotate() { Relation x = relatain(); Node *o = p; p = o-&gt;p; if (o-&gt;p) o-&gt;p-&gt;c[o-&gt;relatain()] = this; o-&gt;c[x] = c[x ^ 1]; if (c[x ^ 1]) c[x ^ 1]-&gt;p = o; c[x ^ 1] = o; o-&gt;p = this; o-&gt;maintain(), maintain(); if (!p) *r = this; } Node *splay(Node *targetParent = NULL) { while (p != targetParent) { if (p-&gt;p == targetParent) rotate(); else if (p-&gt;relatain() == relatain()) p-&gt;rotate(), rotate(); else rotate(), rotate(); } return this; } Node *prec() { splay(); Node *v = c[L]; while (v-&gt;c[R]) v = v-&gt;c[R]; return v-&gt;splay(); } Node *succ() { splay(); Node *v = c[R]; while (v-&gt;c[L]) v = v-&gt;c[L]; return v-&gt;splay(); } int left() const { return c[L] ? c[L]-&gt;size : 0; } #ifdef DBG void validate() { int size = 0; if (c[L]) c[L]-&gt;validate(), assert(this-&gt;val &gt; c[L]-&gt;val), size += c[L]-&gt;size; if (c[R]) c[R]-&gt;validate(), assert(this-&gt;val &lt; c[R]-&gt;val), size += c[R]-&gt;size; assert(this-&gt;size == size + cnt); } void print(const int depth = 0); #endif } *r; #ifdef DBG int id; #endif Splay(const int *a, const int n) : r(NULL) { insert(INT_MAX), insert(INT_MIN); #ifdef DBG static int time = 0; time++; id = time; printf("build(%d): ", id); for (int i = 0; i &lt; n; i++) printf("%d%c", a[i], i == n - 1 ? '\n' : ' '); #endif for (int i = 0; i &lt; n; i++) insert(a[i]); } ~Splay() { delete r; } Node *find(const int x) { Node *v = r; while (v &amp;&amp; x != v-&gt;val) { if (x &lt; v-&gt;val) v = v-&gt;c[L]; else v = v-&gt;c[R]; } return v ? v-&gt;splay() : NULL; } Node *insert(const int x) { Node *v = find(x); if (v) { v-&gt;cnt++, v-&gt;size++; return v; } Node **target = &amp;r, *p = NULL; while (*target) { p = *target; p-&gt;size++; if (x&lt; p-&gt;val) target = &amp;p-&gt;c[L]; else target = &amp;p-&gt;c[R]; } return (*target = new Node(p, x, &amp;r))-&gt;splay(); } int rank(const int x) { Node *v = find(x); int res; if (v) res = v-&gt;left(); else { v = insert(x); res = v-&gt;left(); erase(v); } #ifdef DBG printf("rank(%d) in (%d) = %d\n", x, id, res); #endif return res; } Node *select(const int k) { int x = k + 1; Node *v = r; while (!(x &gt;= v-&gt;left() + 1 &amp;&amp; x &lt;= v-&gt;left() + v-&gt;cnt)) { if (x &lt; v-&gt;left() + 1) v = v-&gt;c[L]; else x -= v-&gt;left() + v-&gt;cnt, v = v-&gt;c[R]; } return v-&gt;splay(); } void erase(Node *v) { if (v-&gt;cnt != 1) { v-&gt;cnt--, v-&gt;size--; return; } Node *prec = v-&gt;prec(), *succ = v-&gt;succ(); prec-&gt;splay(); succ-&gt;splay(prec); delete succ-&gt;c[L]; succ-&gt;c[L] = NULL; succ-&gt;maintain(), prec-&gt;maintain(); } void erase(const int x) { Node *v = find(x); erase(v); } int prec(const int x) { Node *v = find(x); if (v) return v-&gt;prec()-&gt;val; else { v = insert(x); int res = v-&gt;prec()-&gt;val; erase(v); return res; } } int succ(const int x) { Node *v = find(x); if (v) return v-&gt;succ()-&gt;val; else { v = insert(x); int res = v-&gt;succ()-&gt;val; erase(v); return res; } } #ifdef DBG void validate() { r-&gt;validate(); } #endif }; #ifdef DBG void Splay::Node::print(const int depth) { if (c[L]) c[L]-&gt;print(depth + 1); for (int i = 0; i &lt; depth; i++) putchar(' '), putchar(' '); printf("%d\n", val); if (c[R]) c[R]-&gt;print(depth + 1); } #endif int map[MAXM + MAXN], max; struct SegmentTree { SegmentTree *lc, *rc; int l, r; Splay s; SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) { #ifdef DBG printf(" [%d, %d]\n", l, r); validate(); #endif } ~SegmentTree() { if (lc) delete lc; if (rc) delete rc; } static SegmentTree *build(const int l, const int r, int *a) { if (l &gt; r) return NULL; else if (l == r) return new SegmentTree(l, r, NULL, NULL, a); else { int m = l + (r - l) / 2; return new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a); } } void update(const int pos, const int old, const int curr) { if (pos &gt; this-&gt;r || pos &lt; this-&gt;l); else if (pos &gt;= this-&gt;l &amp;&amp; pos &lt;= this-&gt;r) { s.erase(old); s.insert(curr); if (pos != this-&gt;l || pos != this-&gt;r) lc-&gt;update(pos, old, curr), rc-&gt;update(pos, old, curr); } } int rank(const int l, const int r, const int k) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 1; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return s.rank(k); else return (lc-&gt;rank(l, r, k) - 1) + (rc-&gt;rank(l, r, k) - 1) + 1; } int prec(const int l, const int r, const int k) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return INT_MIN; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return s.prec(k); else return std::max(lc-&gt;prec(l, r, k), rc-&gt;prec(l, r, k)); } int succ(const int l, const int r, const int k) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return INT_MAX; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return s.succ(k); else return std::min(lc-&gt;succ(l, r, k), rc-&gt;succ(l, r, k)); } int select(const int l, const int r, const int k) { int L = 0, R = max; while (L + 1 &lt; R) { int m = L + (R - L) / 2; if (rank(l, r, m) &gt; k) R = m; else L = m; } if (rank(l, r, R) == k) return R; else return L; } #ifdef DBG void validate() { assert(s.r-&gt;size == r - l + 1 + 2); s.validate(); if (lc) lc-&gt;validate(); if (rc) rc-&gt;validate(); } #endif } *segment; struct Query { int opt, l, r, pos, k; } Q[MAXM]; int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); int cnt = 0; for (int i = 0; i &lt; m; i++) { Query &amp;q = Q[i]; scanf("%d", &amp;q.opt); if (q.opt == 3) { scanf("%d %d", &amp;q.pos, &amp;q.k); } else { scanf("%d %d %d", &amp;q.l, &amp;q.r, &amp;q.k); } if (q.opt != 2) { map[cnt++] = q.k; } } for (int i = 0; i &lt; n; i++) map[cnt++] = a[i]; std::sort(map, map + cnt); int *end = std::unique(map, map + cnt); for (int i = 0; i &lt; n; i++) a[i] = std::lower_bound(map, end, a[i]) - map; for (int i = 0; i &lt; m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map; max = end - map - 1; segment = SegmentTree::build(1, n, a); for (int i = 0; i &lt; m; i++) { Query &amp;q = Q[i]; if (q.opt == 1) { printf("%d\n", segment-&gt;rank(q.l, q.r, q.k)); } else if (q.opt == 2) { printf("%d\n", map[segment-&gt;select(q.l, q.r, q.k)]); } else if (q.opt == 3) { segment-&gt;update(q.pos, a[q.pos - 1], q.k); a[q.pos - 1] = q.k; } else if (q.opt == 4) { printf("%d\n", map[segment-&gt;prec(q.l, q.r, q.k)]); } else if (q.opt == 5) { printf("%d\n", map[segment-&gt;succ(q.l, q.r, q.k)]); } #ifdef DBG segment-&gt;validate(); #endif } return 0; } 线段树套带垃圾回收的动态开点的权值线段树，MLE。 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;cassert&gt; #include &lt;algorithm&gt; const int MAXN = 50000; const int MAXM = 50000; int n, m, a[MAXN]; int map[MAXM + MAXN], max; struct WeightSegmentTree { int l, r, mid; WeightSegmentTree *lc, *rc; int min, max, cnt; WeightSegmentTree(const int l, const int r) : l(l), r(r), mid(l + (r - l) / 2), lc(NULL), rc(NULL), min(INT_MAX), max(INT_MIN), cnt(0) {} WeightSegmentTree(const int *a, const int n) : l(0), r(::max - 1), mid((max - 1) / 2), lc(NULL), rc(NULL), min(INT_MAX), max(INT_MIN), cnt(0) { for (int i = 0; i &lt; n; i++) insert(a[i]); } ~WeightSegmentTree() { if (lc) delete lc; if (rc) delete rc; } void maintain() { min = INT_MAX; if (lc) min = std::min(min, lc-&gt;min); if (rc) min = std::min(min, rc-&gt;min); max = INT_MIN; if (lc) max = std::max(max, lc-&gt;max); if (rc) max = std::max(max, rc-&gt;max); cnt = 0; if (lc) cnt += lc-&gt;cnt; if (rc) cnt += rc-&gt;cnt; } void insert(const int x) { if (x &gt; r || x &lt; l); else if (x == l &amp;&amp; x == r) { if (!cnt++) min = max = x; } else { if (x &lt;= mid) { if (!lc) lc = new WeightSegmentTree(l, mid); lc-&gt;insert(x); } else { if (!rc) rc = new WeightSegmentTree(mid + 1, r); rc-&gt;insert(x); } maintain(); } } void erase(const int x) { if (x &gt; r || x &lt; l); else if (x == l &amp;&amp; x == r) { if (!--cnt) min = INT_MAX, max = INT_MIN; } else { if (x &lt;= mid) lc-&gt;erase(x); else rc-&gt;erase(x); maintain(); if (x &lt;= mid &amp;&amp; lc-&gt;cnt == 0) delete lc, lc = NULL; else if (x &gt; mid &amp;&amp; rc-&gt;cnt == 0) delete rc, rc = NULL; } } int prec(const int x) { return queryMax(0, x - 1); } int succ(const int x) { return queryMin(x + 1, ::max); } int rank(const int x) { return queryCnt(0, x - 1) + 1; } int select(const int k) { int x = k; WeightSegmentTree *v = this; while (v-&gt;l != v-&gt;r) { if (!v-&gt;lc) v = v-&gt;rc; else if (x &lt;= v-&gt;lc-&gt;cnt) v = v-&gt;lc; else x -= v-&gt;lc-&gt;cnt, v = v-&gt;rc; } return v-&gt;mid; } int queryMin(const int l, const int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return INT_MAX; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return min; else { int res = INT_MAX; if (lc) res = lc-&gt;queryMin(l, r); if (res == INT_MAX &amp;&amp; rc) return rc-&gt;queryMin(l, r); return res; } } int queryMax(const int l, const int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return INT_MIN; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return max; else { int res = INT_MIN; if (rc) res = rc-&gt;queryMax(l, r); if (res == INT_MIN &amp;&amp; lc) return lc-&gt;queryMax(l, r); return res; } } int queryCnt(const int l, const int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return cnt; else { int res = 0; if (lc) res += lc-&gt;queryCnt(l, r); if (rc) res += rc-&gt;queryCnt(l, r); return res; } } }; struct SegmentTree { SegmentTree *lc, *rc; int l, r; WeightSegmentTree s; SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) { #ifdef DBG printf(" [%d, %d]\n", l, r); validate(); #endif } ~SegmentTree() { if (lc) delete lc; if (rc) delete rc; } static SegmentTree *build(const int l, const int r, int *a) { if (l &gt; r) return NULL; else if (l == r) return new SegmentTree(l, r, NULL, NULL, a); else { int m = l + (r - l) / 2; return new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a); } } void update(const int pos, const int old, const int curr) { if (pos &gt; this-&gt;r || pos &lt; this-&gt;l); else if (pos &gt;= this-&gt;l &amp;&amp; pos &lt;= this-&gt;r) { s.erase(old); s.insert(curr); if (pos != this-&gt;l || pos != this-&gt;r) lc-&gt;update(pos, old, curr), rc-&gt;update(pos, old, curr); } } int rank(const int l, const int r, const int k) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 1; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return s.rank(k); else return (lc-&gt;rank(l, r, k) - 1) + (rc-&gt;rank(l, r, k) - 1) + 1; } int prec(const int l, const int r, const int k) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return INT_MIN; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return s.prec(k); else return std::max(lc-&gt;prec(l, r, k), rc-&gt;prec(l, r, k)); } int succ(const int l, const int r, const int k) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return INT_MAX; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return s.succ(k); else return std::min(lc-&gt;succ(l, r, k), rc-&gt;succ(l, r, k)); } int select(const int l, const int r, const int k) { int L = 0, R = max; while (L + 1 &lt; R) { int m = L + (R - L) / 2; if (rank(l, r, m) &gt; k) R = m; else L = m; } if (rank(l, r, R) == k) return R; else return L; } #ifdef DBG void validate() { assert(s.r-&gt;size == r - l + 1 + 2); s.validate(); if (lc) lc-&gt;validate(); if (rc) rc-&gt;validate(); } #endif } *segment; struct Query { int opt, l, r, pos, k; } Q[MAXM]; int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); int cnt = 0; for (int i = 0; i &lt; m; i++) { Query &amp;q = Q[i]; scanf("%d", &amp;q.opt); if (q.opt == 3) { scanf("%d %d", &amp;q.pos, &amp;q.k); } else { scanf("%d %d %d", &amp;q.l, &amp;q.r, &amp;q.k); } if (q.opt != 2) { map[cnt++] = q.k; } } for (int i = 0; i &lt; n; i++) map[cnt++] = a[i]; std::sort(map, map + cnt); int *end = std::unique(map, map + cnt); for (int i = 0; i &lt; n; i++) a[i] = std::lower_bound(map, end, a[i]) - map; for (int i = 0; i &lt; m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map; max = end - map - 1; segment = SegmentTree::build(1, n, a); for (int i = 0; i &lt; m; i++) { Query &amp;q = Q[i]; if (q.opt == 1) { printf("%d\n", segment-&gt;rank(q.l, q.r, q.k)); } else if (q.opt == 2) { printf("%d\n", map[segment-&gt;select(q.l, q.r, q.k)]); } else if (q.opt == 3) { segment-&gt;update(q.pos, a[q.pos - 1], q.k); a[q.pos - 1] = q.k; } else if (q.opt == 4) { printf("%d\n", map[segment-&gt;prec(q.l, q.r, q.k)]); } else if (q.opt == 5) { printf("%d\n", map[segment-&gt;succ(q.l, q.r, q.k)]); } #ifdef DBG segment-&gt;validate(); #endif } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>BZOJ</tag>
        <tag>Splay</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2456」mode - 乱搞]]></title>
    <url>%2Fbzoj-2456%2F</url>
    <content type="text"><![CDATA[给你一个 个数的数列，其中某个数出现了超过 次即众数，请你找出那个数。 链接 BZOJ 2456 题解 的数据， 内存是存不下的，考虑空间复杂度为 的做法。 如果众数出现了超过 次，那么任意删除序列中的两个不同的数，众数的出现次数仍然超过一半。不停地进行下去，最终剩下的一个数即为众数。 实现时，记录一个「当前的数」和它的「出现次数」，删除一次则出现次数减一，出现次数为 时用读入的数更新当前的数。 代码 #include &lt;cstdio&gt; const int MAXN = 500000; int main() { int n; scanf("%d", &amp;n); int ans = -1, cnt = 0; for (int i = 0; i &lt; n; i++) { int x; scanf("%d", &amp;x); if (cnt == 0) { ans = x; cnt = 1; } else { if (ans == x) { cnt++; } else { cnt--; } } } printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从傅里叶变换到数论变换]]></title>
    <url>%2Ffft-to-ntt%2F</url>
    <content type="text"><![CDATA[FFT 可以用来计算多项式乘法，但复数的运算会产生浮点误差。对于只有整数参与的多项式运算，有时，使用数论变换（Number-Theoretic Transform）会是更好的选择。 原根 FFT 中，我们使用单位复根 。我们需要单位复根的以下性质。 互不相同，保证点值表示的合法； ，用于分治； ，用于分治； 当 时，，用于逆变换。 在数论中，考虑一个质数 （其中 为 的幂）。定义其原根 为使得 互不相同的数。 性质一 令 ，由于 互不相同，满足性质一。 性质二 由 可知 （），故 ，满足性质二。 性质三 根据费马小定理得 又因为 ，所以 ，而根据性质一可得 ，即 。可推出 ，满足性质三。 性质四 当 时 由性质三中的推论可知，，故 ，性质四成立。 求原根 求一个质数的原根，可以使用枚举法 —— 枚举 ，检验 是否为 的原根。 对于一个数 ，最小的满足 的正整数 一定是 的约数。 证明：假设最小的 不是 的约数，找到 满足 ，由费马小定理可知 ，与假设矛盾。 检验时，只需要枚举 的所有约数 ，检验 即可。 inline long long pow(const long long x, const long long n, const long long p) { long long ans = 1; for (long long num = x, tmp = n; tmp; tmp &gt;&gt;= 1, num = num * num % p) if (tmp &amp; 1) ans = ans * num % p; return ans; } inline long long root(const long long p) { for (int i = 2; i &lt;= p; i++) { int x = p - 1; bool flag = false; for (int k = 2; k * k &lt;= p - 1; k++) if (x % k == 0) { if (pow(i, (p - 1) / k, p) == 1) { flag = true; break; } while (x % k == 0) x /= k; } if (!flag &amp;&amp; (x == 1 || pow(i, (p - 1) / x, p) != 1)) { return i; } } throw; } 模板 把原有的复数运算改为模意义下的运算即可。 注意 要改为 。 inline long long pow(const long long x, const long long n, const long long p) { long long ans = 1; for (long long num = x, tmp = n; tmp; tmp &gt;&gt;= 1, num = num * num % p) if (tmp &amp; 1) ans = ans * num % p; return ans; } inline long long root(const long long p) { for (int i = 2; i &lt;= p; i++) { int x = p - 1; bool flag = false; for (int k = 2; k * k &lt;= p - 1; k++) if (x % k == 0) { if (pow(i, (p - 1) / k, p) == 1) { flag = true; break; } while (x % k == 0) x /= k; } if (!flag &amp;&amp; (x == 1 || pow(i, (p - 1) / x, p) != 1)) { return i; } } throw; } inline void exgcd(const long long a, const long long b, long long &amp;g, long long &amp;x, long long &amp;y) { if (!b) g = a, x = 1, y = 0; else exgcd(b, a % b, g, y, x), y -= x * (a / b); } inline long long inv(const long long a, const long long p) { long long g, x, y; exgcd(a, p, g, x, y); return (x + p) % p; } struct NumberTheoreticTransform { long long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED]; void init(const int n) { long long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD); for (int i = 0; i &lt; n; i++) { assert(i &lt; MAXM_EXTENDED); omega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD; omegaInverse[i] = inv(omega[i], MOD); } } void transform(long long *a, const int n, const long long *omega) { int k = 0; while ((1 &lt;&lt; k) != n) k++; for (int i = 0; i &lt; n; i++) { int t = 0; for (int j = 0; j &lt; k; j++) if (i &amp; (1 &lt;&lt; j)) t |= (1 &lt;&lt; (k - j - 1)); if (t &gt; i) std::swap(a[i], a[t]); } for (int l = 2; l &lt;= n; l *= 2) { int m = l / 2; for (long long *p = a; p != a + n; p += l) { for (int i = 0; i &lt; m; i++) { long long t = omega[n / l * i] * p[i + m] % MOD; p[i + m] = (p[i] - t + MOD) % MOD; (p[i] += t) %= MOD; } } } } void dft(long long *a, const int n) { transform(a, n, omega); } void idft(long long *a, const int n) { transform(a, n, omegaInverse); long long x = inv(n, MOD); for (int i = 0; i &lt; n; i++) a[i] = a[i] * x % MOD; } } ntt;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>数论</tag>
        <tag>多项式</tag>
        <tag>原根</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点分治学习笔记]]></title>
    <url>%2Ftree-divide-notes%2F</url>
    <content type="text"><![CDATA[点分治是用来解决树上路径问题的一种方法。 在解决树上路径问题时，我们可以选取一点为根，将树转化为有根树，然后考虑经过根的所有路径（有时将两条从根出发的路径连接为一条）。统计完这些路径的答案后，将根节点标记为删除，对剩下的若干棵树进行同样的操作。 如图，我们可以先考虑经过节点 的路径，之后将节点 标记为删除，此时可以认为考虑过的路径均已被删除。继续对其它子树做相同处理即可。 每次确认一个根节点后，共有 条需要考虑的路径（ 为当前子树大小）。上图中将 删除后，剩下左侧的子树较大，和原树大小相当，继续处理这棵子树时仍然需要与前一过程相当的时间。 最严重的情况，当整棵树是一条链时，每次需要考虑的路径数量是 级别的，如果每条路径需要常数时间进行统计，则总时间复杂度为 。而对于形态随机的树，则远远小于这个级别。 如果我们选择 作为这棵树的根节点，情况会好很多 —— 删除 后剩余的最大一棵子树的大小比删除 时要小。这说明「科学地」选择点作为根节点可以有效的降低复杂度。 重心 我们定义一棵树的重心为以该点为根时最大子树最小的点。 性质：以重心为根，任意一棵子树的大小都不超过整棵树大小的一半。 证明：从树上任取一点，以它为根，如果最大的一棵子树大小不超过整棵树大小的一半，则它为重心。否则选择最大子树的根节点，继续这个过程，最终会得到一个点，它满足重心的性质，从这个点向任何方向走，最多有一个点同样满足重心的性质。 注意不会出现来回走，两个点都不满足性质的情况。假设有，则删掉这两个点后，剩下的两棵树的大小都至少为 ，整棵树至少有 个点，不成立。 求重心可以用一次 DFS 完成 —— 任选一个点为根做 DFS，记录每个节点的大小 ，记录最大子节点子树的大小 。因为要同时考虑某个点的祖先（以这个点为根时这些点为它的一棵子树），所以使 最小的 即为重心。 如果在点分治时每次使用重心为根，则最大的子树大小不会超过原树的二分之一，考虑到处理较小子树的代价原小于最大子树，若每个节点需要常数时间，根据主定理有 如图，蓝色点为第一次选取的重心，删除蓝色点后，剩余几棵子树的重心为红色点，再向下一层的重心为黄色点，最后剩下一个白色点 模板 已处理过的根将被置为 solved，任何时候不要经过这些点，这保证了复杂度分析中的 是当前子树的大小，而不是整棵树的大小。 struct Node { struct Edge *firstEdge; // solved 表示该节点是否已被解决 // 在点分治中，标记 solved 的节点被认为不存在 // // vis 表示在当前 DFS / BFS 中是否访问过 bool solved, vis; // size 表示子树大小（和树剖中相同） // max 表示最大子节点大小 int size, max; Node *fa; // 父节点 } N[MAXN + 1]; // 找以 start 为根的子树的重心 // 非递归 DFS inline Node *center(Node *start) { std::stack&lt;Node *&gt; s; s.push(start); start-&gt;vis = false; start-&gt;fa = NULL; static Node *a[MAXN + 1]; // 储存所有 DFS 到的节点 int cnt = 0; while (!s.empty()) { Node *v = s.top(); // 如果是第一次出栈，则不将 v 从栈中删除 // 将所有子节点入栈 if (!v-&gt;vis) { a[++cnt] = v; // 记录节点 v-&gt;vis = true; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { // 判断不走回父节点，不走到已经 solved 的节点 if (e-&gt;to != v-&gt;fa &amp;&amp; !e-&gt;to-&gt;solved) { e-&gt;to-&gt;fa = v; e-&gt;to-&gt;vis = false; // 子节点入栈 s.push(e-&gt;to); } } } else { // 第二次出栈，表示回溯到 v v-&gt;size = 1; v-&gt;max = 0; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;to-&gt;fa == v) { // 维护 size 和 max v-&gt;size += e-&gt;to-&gt;size; v-&gt;max = std::max(v-&gt;max, e-&gt;to-&gt;size); } } // 将 v 从栈中删除 s.pop(); } } // 统计重心 Node *res = NULL; for (int i = 1; i &lt;= cnt; i++) { // v-&gt;max 表示在整棵子树中，删掉 v 后剩余的最大子树 // 如果把 v 作为根，则原有的除 v 的子树以外的部分会成为 v 的一棵子树 // 这部分的大小为 总节点数量 - v-&gt;size // 因为是以 start 作为根进行的 BFS，总节点数量即为 start-&gt;size a[i]-&gt;max = std::max(a[i]-&gt;max, start-&gt;size - a[i]-&gt;size); // 更新答案 if (!res || res-&gt;max &gt; a[i]-&gt;max) res = a[i]; } return res; } // 主求解过程 inline int solve() { std::stack&lt;Node *&gt; s; s.push(&amp;N[1]); int ans = 0; // 答案 while (!s.empty()) { // 这里的 DFS 不需要回溯，所以每次出栈即可 Node *v = s.top(); s.pop(); // 求重心 Node *root = center(v); // 为防止后续的 BFS、DFS 走回根，先将根置为 solved root-&gt;solved = true; ans += calc(root); } return ans; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「IOI2011」Race - 点分治]]></title>
    <url>%2Fioi2011-race%2F</url>
    <content type="text"><![CDATA[给一棵树，每条边有权。求一条简单路径，权值和等于 ，且边的数量最小。 链接 BZOJ 2599 题解 点分治，考虑经过根的路径中权值和等于 的路径。 遍历整棵树，记录到达每一个点时的经过的边数 和边权和 。 设 表示当前根的之前几棵子树中从根到某个节点边权和为 的路径经过的最少边数。 枚举当前子树的所有节点，用 更新答案。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;cassert&gt; // #include "rand.h" #include &lt;queue&gt; #include &lt;stack&gt; const int MAXN = 200000; const int MAXK = 1000000; struct Node; struct Edge; struct Node { Edge *e; int dist, depth, size, max; bool visited, solved; Node *parent; } N[MAXN]; struct Edge { Node *s, *t; int w; Edge *next; Edge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t, const int w) { N[s].e = new Edge(&amp;N[s], &amp;N[t], w); N[t].e = new Edge(&amp;N[t], &amp;N[s], w); } int n, k; int f[MAXK + 1]; inline Node *center(Node *start) { std::stack&lt;Node *&gt; s; s.push(start); start-&gt;parent = NULL; start-&gt;visited = false; static Node *a[MAXN]; int cnt = 0; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; a[cnt++] = v; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved &amp;&amp; e-&gt;t != v-&gt;parent) { e-&gt;t-&gt;parent = v; e-&gt;t-&gt;visited = false; s.push(e-&gt;t); } } else { v-&gt;size = 1; v-&gt;max = 0; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved &amp;&amp; e-&gt;t-&gt;parent == v) { v-&gt;size += e-&gt;t-&gt;size; v-&gt;max = std::max(v-&gt;max, e-&gt;t-&gt;size); } s.pop(); } } // return a[rand(0, cnt - 1)]; Node *res = NULL; for (int i = 0; i &lt; cnt; i++) { // printf("%d %d\n", cnt, start-&gt;size); assert(cnt == start-&gt;size); a[i]-&gt;max = std::max(a[i]-&gt;max, cnt - a[i]-&gt;size); if (!res || res-&gt;max &gt; a[i]-&gt;max) res = a[i]; } // printf("root(%ld) = %ld\n", start - N + 1, res - N + 1); return res; } inline int calc(Node *root) { static int A[MAXN]; int tot = 0, res = INT_MAX; for (Edge *e = root-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved) { std::queue&lt;Node *&gt; q; q.push(e-&gt;t); e-&gt;t-&gt;parent = root; e-&gt;t-&gt;dist = e-&gt;w; e-&gt;t-&gt;depth = 1; static Node *a[MAXN]; int cnt = 0; while (!q.empty()) { Node *v = q.front(); q.pop(); if (v-&gt;dist &gt; k) continue; A[tot++] = v-&gt;dist; a[cnt++] = v; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved &amp;&amp; e-&gt;t != v-&gt;parent) { e-&gt;t-&gt;parent = v; e-&gt;t-&gt;dist = v-&gt;dist + e-&gt;w; e-&gt;t-&gt;depth = v-&gt;depth + 1; q.push(e-&gt;t); } } for (int i = 0; i &lt; cnt; i++) { // assert(k - a[i]-&gt;dist &gt;= 0 &amp;&amp; k - a[i]-&gt;dist &lt;= k); if (f[k - a[i]-&gt;dist] != INT_MAX) res = std::min(res, f[k - a[i]-&gt;dist] + a[i]-&gt;depth); } for (int i = 0; i &lt; cnt; i++) { f[a[i]-&gt;dist] = std::min(f[a[i]-&gt;dist], a[i]-&gt;depth); } } for (int i = 0; i &lt; tot; i++) { // assert(A[i] &gt;= 0 &amp;&amp; A[i] &lt;= k); f[A[i]] = INT_MAX; } // printf("calc(%ld) = %d\n", root - N + 1, res); return res; } inline int solve() { std::stack&lt;Node *&gt; s; s.push(&amp;N[0]); int ans = INT_MAX; while (!s.empty()) { Node *v = s.top(); s.pop(); Node *root = center(v); root-&gt;solved = true; ans = std::min(ans, calc(root)); for (Edge *e = root-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved) { s.push(e-&gt;t); } } return ans; } int main() { scanf("%d %d", &amp;n, &amp;k); // assert(n &lt;= MAXN); // assert(k &lt;= MAXK); for (int i = 0; i &lt; n - 1; i++) { int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); } for (int i = 1; i &lt;= k; i++) f[i] = INT_MAX; int ans = solve(); printf("%d\n", ans == INT_MAX ? -1 : ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>BZOJ</tag>
        <tag>点分治</tag>
        <tag>IOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3365」Distance Statistics - 点分治]]></title>
    <url>%2Fbzoj-3365%2F</url>
    <content type="text"><![CDATA[约翰提供一个整数 （），希望你输出有多少对农场之间的距离是不超过 的。 链接 BZOJ 3365 题解 和 BZOJ 1468 一样。 代码 #include &lt;algorithm&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;vector&gt; const int MAXN = 40000; struct Node; struct Edge; struct Node { Edge *e; bool solved, visited; int size, dist, max; Node *parent; } N[MAXN]; struct Edge { Node *s, *t; int w; Edge *next; Edge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t, const int w) { N[s].e = new Edge(&amp;N[s], &amp;N[t], w); N[t].e = new Edge(&amp;N[t], &amp;N[s], w); } int n, k; // int cnt_root, cnt_calc; inline Node *center(Node *start) { std::stack&lt;Node *&gt; s; s.push(start); start-&gt;visited = false; start-&gt;parent = NULL; static Node *a[MAXN]; int cnt = 0; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { a[cnt++] = v; v-&gt;visited = true; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t != v-&gt;parent &amp;&amp; !e-&gt;t-&gt;solved) { e-&gt;t-&gt;parent = v; e-&gt;t-&gt;visited = false; s.push(e-&gt;t); } } else { v-&gt;size = 1; v-&gt;max = 0; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved &amp;&amp; e-&gt;t-&gt;parent == v) { v-&gt;size += e-&gt;t-&gt;size; v-&gt;max = std::max(v-&gt;max, e-&gt;t-&gt;size); } s.pop(); } } // printf("start-&gt;size - cnt = %d\n", start-&gt;size - cnt); Node *res = NULL; for (int i = 0; i &lt; cnt; i++) { a[i]-&gt;max = std::max(a[i]-&gt;max, start-&gt;size - a[i]-&gt;max); if (!res || res-&gt;max &gt; a[i]-&gt;max) res = a[i]; } // printf("root(%ld) = %ld\n", start - N + 1, res - N + 1); // cnt_root++; return res; } inline int calc(Node *root, const int dist = 0) { static int a[MAXN]; int cnt = 0; std::queue&lt;Node *&gt; q; q.push(root); root-&gt;dist = dist; root-&gt;parent = NULL; while (!q.empty()) { Node *v = q.front(); q.pop(); a[cnt++] = v-&gt;dist; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved &amp;&amp; e-&gt;t != v-&gt;parent) { e-&gt;t-&gt;parent = v; e-&gt;t-&gt;dist = v-&gt;dist + e-&gt;w; q.push(e-&gt;t); } } int res = 0; std::sort(a, a + cnt); for (int i = 0, j = cnt - 1; i &lt; j; i++) { while (i &lt; j &amp;&amp; a[i] + a[j] &gt; k) j--; res += j - i; } // cnt_calc++; return res; } inline int solve() { std::stack&lt;Node *&gt; s; s.push(&amp;N[0]); int ans = 0; while (!s.empty()) { Node *v = s.top(); s.pop(); // printf("work(%ld)\n", v - N + 1); Node *root = center(v); root-&gt;solved = true; ans += calc(root); for (Edge *e = root-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved) { ans -= calc(e-&gt;t, e-&gt;w); s.push(e-&gt;t); } } return ans; } int main() { int m; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n - 1; i++) { int u, v, w; char s[2]; scanf("%d %d %d %s", &amp;u, &amp;v, &amp;w, s), u--, v--; addEdge(u, v, w); } scanf("%d", &amp;k); int ans = solve(); printf("%d\n", ans); // printf("cnt_root = %d, cnt_calc = %d\n", cnt_root, cnt_calc); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>BZOJ</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3697」采药人的路径 - 点分治]]></title>
    <url>%2Fbzoj-3697%2F</url>
    <content type="text"><![CDATA[采药人的药田是一个树状结构，每条路径上都种植着同种药材。 采药人每种药材进行了分类。大致分为两类，一种是阴性的，一种是阳性的。 采药人每天都要进行采药活动。他走的一定是两种药材数目相等的路径。他希望他选出的路径中有一个可以作为休息站的节点（不包括起点和终点），满足起点到休息站和休息站到终点的路径也是两种药材数目相等的。他想知道他一共可以选择多少种不同的路径。 链接 BZOJ 3697 题解 点分治，考虑经过根的路径中合法的路径数量。 将边权为 改为 ，对树遍历时记录路径上的前缀和。 对根的所有子树做 DFS 遍历，设 表示当前子树前缀和为 且 在路径上仅出现过一次的路径数， 表示当前子树前缀和为 且 在路径上出现过至少两次的路径数。 如果一个前缀和 在一棵子树内出现过两次，那么在根的另一棵子树选一条前缀和为 的路径与其相接，即可组成一条合法的路径 —— 休息站可以被选择在前一条路径上另一个前缀和为 的点上。 对树进行 DFS 遍历时，记录 表示当前路径前缀和为 的节点数量，根据情况将当前节点累加在 或 中。 记录 、 为之前的所有子树中对应的路径数量，每次更新答案，统计不以根节点为休息站的路径数量 令 的初始值为 ，表示根节点单独组成一条路径，统计以根节点为休息站的的路径数量 代码 #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;climits&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;algorithm&gt; const int MAXN = 100003; struct Node; struct Edge; struct Node { Edge *e; int size, max, dist; bool solved, visited; Node *parent; } N[MAXN]; struct Edge { Node *s, *t; int w; Edge *next; Edge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t, const int w) { N[s].e = new Edge(&amp;N[s], &amp;N[t], w); N[t].e = new Edge(&amp;N[t], &amp;N[s], w); } int n; template &lt;typename T, int L, int R&gt; struct Array { T a[R - L + 1]; T &amp;operator[](const int pos) { return a[pos - L]; } const T &amp;operator[](const int pos) const { return a[pos - L]; } }; Array&lt;long long [2], -(MAXN - 1), MAXN - 1&gt; f, g; inline Node *center(Node *start) { std::stack&lt;Node *&gt; s; s.push(start); start-&gt;visited = false; start-&gt;parent = NULL; static Node *a[MAXN]; int cnt = 0; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { a[cnt++] = v; v-&gt;visited = true; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t != v-&gt;parent &amp;&amp; !e-&gt;t-&gt;solved) { e-&gt;t-&gt;visited = false; e-&gt;t-&gt;parent = v; s.push(e-&gt;t); } } else { v-&gt;size = 1; v-&gt;max = 0; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved &amp;&amp; e-&gt;t-&gt;parent == v) { v-&gt;size += e-&gt;t-&gt;size; v-&gt;max = std::max(v-&gt;max, e-&gt;t-&gt;size); } s.pop(); } } Node *res = NULL; for (int i = 0; i &lt; cnt; i++) { a[i]-&gt;max = std::max(a[i]-&gt;max, start-&gt;size - a[i]-&gt;max); if (!res || res-&gt;max &gt; a[i]-&gt;max) res = a[i]; } return res; } inline void dfs(Node *start, const int dist, int &amp;max) { std::stack&lt;Node *&gt; s; s.push(start); start-&gt;parent = NULL; start-&gt;dist = dist; start-&gt;visited = false; static int _cnt[MAXN * 2 - 1], *cnt = _cnt + MAXN - 1; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { f[v-&gt;dist][!cnt[v-&gt;dist] ? 0 : 1]++; cnt[v-&gt;dist]++; max = std::max(max, v-&gt;dist); max = std::max(max, abs(v-&gt;dist)); v-&gt;visited = true; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved &amp;&amp; e-&gt;t != v-&gt;parent) { e-&gt;t-&gt;parent = v; e-&gt;t-&gt;dist = v-&gt;dist + e-&gt;w; e-&gt;t-&gt;visited = false; s.push(e-&gt;t); } } else { cnt[v-&gt;dist]--; s.pop(); } } } /* inline void print(const int max) { for (int i = -max; i &lt;= max; i++) { printf("f[%d][0] = %lld, f[%d][1] = %lld\n", i, f[i][0], i, f[i][1]); printf("g[%d][0] = %lld, g[%d][1] = %lld\n", i, g[i][0], i, g[i][1]); } putchar('\n'); } */ inline long long calc(Node *root) { long long res = 0; int max = 0; g[0][0] = 1; for (Edge *e = root-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved) { int curr = 0; dfs(e-&gt;t, e-&gt;w, curr); // print(max); res += (g[0][0] - 1) * f[0][0]; for (int i = -curr; i &lt;= curr; i++) { // printf("res += %lld\n", (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0])); res += (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]); } for (int i = -curr; i &lt;= curr; i++) { g[i][0] += f[i][0]; g[i][1] += f[i][1]; f[i][0] = f[i][1] = 0; } max = std::max(max, curr); } for (int i = -max; i &lt;= max; i++) { g[i][0] = g[i][1] = 0; } // printf("calc(%ld) = %lld\n", root - N + 1, res); return res; } inline long long solve() { std::stack&lt;Node *&gt; s; s.push(&amp;N[0]); long long ans = 0; while (!s.empty()) { Node *v = s.top(); s.pop(); Node *root = center(v); root-&gt;solved = true; ans += calc(root); for (Edge *e = root-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved) { s.push(e-&gt;t); } } return ans; } int main() { scanf("%d", &amp;n); for (int i = 0; i &lt; n - 1; i++) { int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w), u--, v--; if (w == 0) w = -1; addEdge(u, v, w); } long long ans = solve(); printf("%lld\n", ans); // printf("counter: %lld\n", counter); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>BZOJ</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2152」聪聪可可 - 点分治]]></title>
    <url>%2Fbzoj-2152%2F</url>
    <content type="text"><![CDATA[求在一棵 个点的带权树上随机选择两个有序点（可以相同），两点距离为 的倍数的概率。 链接 BZOJ 2152 题解 点分治，每次分治计算从根出发的长度 的值为 的路径数量为 。 点对有序，考虑两条路径可以连接，因此 是答案的一部分。 考虑 对答案的贡献，每条路径可以单独算，也可以与另一条连接，注意到每条路径可以与其连接的路径条数是一个等差数列，因此该部分答案为 ，点对有序，再乘以 ，加上单独算的答案，为 。 因此，统计 即可。 最终答案需要处以 （总方案数），之后约分即可。 代码 #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;algorithm&gt; const int MAXN = 20000; struct Node; struct Edge; struct Node { Edge *e; int size, dist, max; bool solved, visited; Node *parent; } N[MAXN]; struct Edge { Node *s, *t; int w; Edge *next; Edge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t, const int w) { N[s].e = new Edge(&amp;N[s], &amp;N[t], w); N[t].e = new Edge(&amp;N[t], &amp;N[s], w); } int n; inline Node *center(Node *start) { std::stack&lt;Node *&gt; s; s.push(start); start-&gt;visited = false; start-&gt;parent = NULL; static Node *a[MAXN]; int cnt = 0; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; a[cnt++] = v; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved &amp;&amp; e-&gt;t != v-&gt;parent) { e-&gt;t-&gt;visited = false; e-&gt;t-&gt;parent = v; s.push(e-&gt;t); } } else { v-&gt;size = 1; v-&gt;max = 0; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved &amp;&amp; e-&gt;t-&gt;parent == v) { v-&gt;size += e-&gt;t-&gt;size; v-&gt;max = std::max(v-&gt;max, e-&gt;t-&gt;size); } s.pop(); } } Node *res = NULL; for (int i = 0; i &lt; cnt; i++) { a[i]-&gt;max = std::max(start-&gt;size - a[i]-&gt;max, a[i]-&gt;max); if (!res || res-&gt;max &gt; a[i]-&gt;max) res = a[i]; } return res; } inline int calc(Node *root, const int dist = 0) { std::queue&lt;Node *&gt; q; q.push(root); root-&gt;parent = NULL; root-&gt;dist = dist; int a[3] = { 0, 0, 0 }, cnt = 0; while (!q.empty()) { Node *v = q.front(); q.pop(); cnt++; a[v-&gt;dist %= 3]++; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved &amp;&amp; e-&gt;t != v-&gt;parent) { e-&gt;t-&gt;parent = v; e-&gt;t-&gt;dist = v-&gt;dist + e-&gt;w; q.push(e-&gt;t); } } return a[0] * a[0] + a[1] * a[2] * 2; } inline int solve() { std::stack&lt;Node *&gt; s; s.push(&amp;N[0]); int res = 0; while (!s.empty()) { Node *v = s.top(); s.pop(); Node *root = center(v); res += calc(root); root-&gt;solved = true; for (Edge *e = root-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved) { res -= calc(e-&gt;t, e-&gt;w); s.push(e-&gt;t); } } return res; } int main() { scanf("%d", &amp;n); for (int i = 0; i &lt; n - 1; i++) { int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w), u--, v--, w %= 3; addEdge(u, v, w); } int cnt = solve(), sum = n * n, g = std::__gcd(cnt, sum); printf("%d/%d\n", cnt / g, sum / g); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>BZOJ</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1468」Tree - 点分治]]></title>
    <url>%2Fbzoj-1468%2F</url>
    <content type="text"><![CDATA[给你一棵 Tree，以及这棵 Tree 上边的距离。问有多少对点它们两者间的距离小于等于 。 链接 BZOJ 1468 题解 点分治，考虑「经过根且两端在不同子树的路径」中满足条件的路径数目（如果两端在同一子树内，则距离不是最短）。 遍历整棵树，得到所有点到根的距离，排序后得到一个递增序列。问题转化为序列中找两个元素加起来小于等于 的方案数。 显然，对于给定的数 ，满足 的数 是连续的一段。我们只要从小到大枚举 ，并维护 指向的位置，每次 增加时减小 ，直到 ，此时 的数都满足条件，对答案的贡献即为 。 这样求出来的路径会包含两端在同一子树的路径，我们需要再减去每棵子树的「经过根的路径」的答案数。实现时相当于对每棵子树做一遍上述过程，但计算距离时计算的还是相对于当前根的距离。 时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;vector&gt; const int MAXN = 40000; struct Node; struct Edge; struct Node { Edge *e; bool solved, visited; int size, dist, max; Node *parent; } N[MAXN]; struct Edge { Node *s, *t; int w; Edge *next; Edge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t, const int w) { N[s].e = new Edge(&amp;N[s], &amp;N[t], w); N[t].e = new Edge(&amp;N[t], &amp;N[s], w); } int n, k; // int cnt_root, cnt_calc; inline Node *center(Node *start) { std::stack&lt;Node *&gt; s; s.push(start); start-&gt;visited = false; start-&gt;parent = NULL; static Node *a[MAXN]; int cnt = 0; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { a[cnt++] = v; v-&gt;visited = true; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t != v-&gt;parent &amp;&amp; !e-&gt;t-&gt;solved) { e-&gt;t-&gt;parent = v; e-&gt;t-&gt;visited = false; s.push(e-&gt;t); } } else { v-&gt;size = 1; v-&gt;max = 0; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved &amp;&amp; e-&gt;t-&gt;parent == v) { v-&gt;size += e-&gt;t-&gt;size; v-&gt;max = std::max(v-&gt;max, e-&gt;t-&gt;size); } s.pop(); } } Node *res = NULL; for (int i = 0; i &lt; cnt; i++) { a[i]-&gt;max = std::max(a[i]-&gt;max, start-&gt;size - a[i]-&gt;max); if (!res || res-&gt;max &gt; a[i]-&gt;max) res = a[i]; } // printf("root(%ld) = %ld\n", start - N + 1, res - N + 1); // cnt_root++; return res; } inline int calc(Node *root, const int dist = 0) { static int a[MAXN]; int cnt = 0; std::queue&lt;Node *&gt; q; q.push(root); root-&gt;dist = dist; root-&gt;parent = NULL; while (!q.empty()) { Node *v = q.front(); q.pop(); a[cnt++] = v-&gt;dist; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved &amp;&amp; e-&gt;t != v-&gt;parent) { e-&gt;t-&gt;parent = v; e-&gt;t-&gt;dist = v-&gt;dist + e-&gt;w; q.push(e-&gt;t); } } int res = 0; std::sort(a, a + cnt); for (int i = 0, j = cnt - 1; i &lt; j; i++) { while (i &lt; j &amp;&amp; a[i] + a[j] &gt; k) j--; res += j - i; } // cnt_calc++; return res; } inline int solve() { std::stack&lt;Node *&gt; s; s.push(&amp;N[0]); int ans = 0; while (!s.empty()) { Node *v = s.top(); s.pop(); // printf("work(%ld)\n", v - N + 1); Node *root = center(v); root-&gt;solved = true; ans += calc(root); for (Edge *e = root-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;solved) { ans -= calc(e-&gt;t, e-&gt;w); s.push(e-&gt;t); } } return ans; } int main() { scanf("%d", &amp;n); for (int i = 0; i &lt; n - 1; i++) { int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w), u--, v--; addEdge(u, v, w); } scanf("%d", &amp;k); printf("%d\n", solve()); // printf("cnt_root = %d, cnt_calc = %d\n", cnt_root, cnt_calc); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>BZOJ</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2011」计算器 - 快速幂 + EXGCD + BSGS]]></title>
    <url>%2Fsdoi2011-calc%2F</url>
    <content type="text"><![CDATA[你被要求设计一个计算器完成以下三项任务： 给定 、、，计算 的值； 给定 、、，计算满足 的最小非负整数 ； 给定 、、，计算满足 的最小非负整数 。 链接 BZOJ 2242 题解 第一种，快速幂。 第二种，当 且 时无解。 否则当 时答案为 。 其它情况，考虑 在模 意义下的乘法逆元 EXGCD 求解逆元即可。 第三种，BSGS 求解离散对数。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;tr1/unordered_map&gt; template &lt;typename T&gt; inline T pow(const T a, const T n, const T p) { T ans = 1; for (T x = a, tmp = n; tmp; tmp &gt;&gt;= 1, x = x * x % p) if (tmp &amp; 1) ans = ans * x % p; return ans; } template &lt;typename T&gt; inline void exgcd(const T a, const T b, T &amp;g, T &amp;x, T &amp;y) { if (!b) g = a, x = 1, y = 0; else exgcd(b, a % b, g, y, x), y -= x * (a / b); } template &lt;typename T&gt; inline T inv(const T x, const T p) { T g, r, y; exgcd(x, p, g, r, y); return (r % p + p) % p; } template &lt;typename T&gt; inline T bsgs(const T a, const T b, const T p) { if (a == 0) { return b == 0 ? 1 : -1; } std::tr1::unordered_map&lt;T, T&gt; map; T m = ceil(sqrt(static_cast&lt;double&gt;(p))), t = 1; for (int i = 0; i &lt; m; i++) { if (!map.count(t)) map[t] = i; t = t * a % p; } T r = b, k = inv(t, p) % p; for (int i = 0; i &lt; m; i++) { if (map.count(r)) return map[r] + i * m; r = r * k % p; } return -1; } int main() { int t, k; scanf("%d %d", &amp;t, &amp;k); while (t--) { long long a, b, p; scanf("%lld %lld %lld", &amp;a, &amp;b, &amp;p); if (k == 1) { printf("%lld\n", pow(a, b, p)); } else if (k == 2) { if (a &gt; p &amp;&amp; a % p == 0) puts("Orz, I cannot find x!"); else { long long t = inv(a, p); printf("%lld\n", b * t % p); } } else if (k == 3) { long long ans = bsgs(a % p, b % p, p); if (ans == -1) puts("Orz, I cannot find x!"); else printf("%lld\n", ans); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>BSGS</tag>
        <tag>EXGCD</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离散对数与 BSGS]]></title>
    <url>%2Fbsgs-notes%2F</url>
    <content type="text"><![CDATA[对于给定的 、、 存在一个 ，使得 则称 为 在模 意义下以 为底的离散对数。 性质 离散对数有类似于一般的对数的性质 BSGS 求解离散对数问题常用的算法是 BSGS（Baby-Step Giant-Step）。 我们需要求解的方程为（ 为质数） 令 。 根据费马小定理，有 ，故若方程有解，则必然存在一个 。 设 ，其中 。 方程可化为 我们只需要找到一组 、 使得最后一个式子成立即可。 枚举 ，递推出左边 的所有取值，并将其按照 的映射关系插入到哈希表中。 之后，求出 的乘法逆元，即 。枚举 ，递推出所有的 ，每得到一个值后，从哈希表中查找该值，如果存在，取出其对应的 ， 即为一个解。 时间复杂度为 。 模板 inline void exgcd(long long a, long long b, long long &amp;g, long long &amp;x, long long &amp;y) { if (!b) g = a, x = 1, y = 0; else exgcd(b, a % b, g, y, x), y -= x * (a / b); } inline long long inv(long long x, long long p) { long long g, r, y; exgcd(x, p, g, r, y); return (r % p + p) % p; } inline long long bsgs(long long a, long long b, long long p) { if (a == 0) return b == 0 ? 1 : -1; std::map&lt;long long, long long&gt; map; long long m = ceil(sqrt(p)), t = 1; for (int i = 0; i &lt; m; i++) { if (!map.count(t)) map[t] = i; t = t * a % p; } long long k = inv(t, p), w = b; for (int i = 0; i &lt; m; i++) { if (map.count(w)) return i * m + map[w]; w = w * k % p; } return -1; } EXBSGS 用 BSGS 求解离散对数需要 为质数，因为算法中用到了 的乘法逆元。实际上，只要 成立即可。 考虑方程 将它写成二元不定方程的形式 令 ，若 ，则有 即 此时 ，可以求出 的乘法逆元，乘到右边去 至此，问题转化为规模更小的子问题，继续如上过程直到 时调用 BSGS 求解即可。若过程中出现 则无解，若 则答案为 （加上之前所有减去的 ）。 模板 inline long long exbsgs(long long a, long long b, long long p) { long long t, c = 0; while ((t = std::__gcd(a, p)) != 1) { if (b == 1) return c; if (b % t != 0) return -1; p /= t; b = b / t * inv(a / t, p) % p; c++; } long long r = bsgs(a, b, p); if (r == -1) return -1; else return r + c; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>BSGS</tag>
        <tag>离散对数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2015」序列统计 - 生成函数 + NTT]]></title>
    <url>%2Fsdoi2015-sequence%2F</url>
    <content type="text"><![CDATA[小 C 有一个集合 ，里面的元素都是小于 的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为 的数列，数列中的每个数都属于集合 。 小 C 用这个生成器生成了许多这样的数列。但是小 C 有一个问题需要你的帮助：给定整数 ，求所有可以生成出的，且满足数列中所有数的乘积 的值等于 的不同的数列的有多少个。小 C 认为，两个数列 和 不同，当且仅当至少存在一个整数 ，满足 。另外，小 C 认为这个问题的答案可能很大，因此他只需要你帮助他求出答案 的值就可以了。 链接 BZOJ 3992 题解 首先，题目中要求乘起来为 的方案数，我们可以对 和 取关于 的原根的离散对数，转化为 加起来为 的方案数。 小于 的非负整数，除去 ，共有 个，这些数 的离散对数的取值范围为 。因为根据费马小定理，有 。 定义生成函数 对于集合中的每个数 ，令 ，否则 。 快速幂求出 的第 项即为答案。相乘时使用 NTT。 注意取离散对数后要求的是加起来 为 ，所以每次乘法后需要将所有次数 为 的项系数加到 次项上。 时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;algorithm&gt; const int MAXM = 8000; const int MAXM_EXTENDED = 16384; const long long MOD = 1004535809; inline long long pow(const long long x, const long long n, const long long p) { long long ans = 1; for (long long num = x, tmp = n; tmp; tmp &gt;&gt;= 1, num = num * num % p) if (tmp &amp; 1) ans = ans * num % p; return ans; } inline long long root(const long long p) { for (int i = 2; i &lt;= p; i++) { int x = p - 1; bool flag = false; for (int k = 2; k * k &lt;= p - 1; k++) if (x % k == 0) { if (pow(i, (p - 1) / k, p) == 1) { flag = true; break; } while (x % k == 0) x /= k; } if (!flag &amp;&amp; (x == 1 || pow(i, (p - 1) / x, p) != 1)) { // printf("root(%lld) = %d\n", p, i); return i; } } throw; } inline void exgcd(const long long a, const long long b, long long &amp;g, long long &amp;x, long long &amp;y) { if (!b) g = a, x = 1, y = 0; else exgcd(b, a % b, g, y, x), y -= x * (a / b); } inline long long inv(const long long a, const long long p) { long long g, x, y; exgcd(a, p, g, x, y); return (x + p) % p; } int m; long long log[MAXM]; inline void prepare() { long long t = 1, r = root(m); for (int i = 0; i &lt; m - 1; i++) { log[t] = i; // printf("log(%lld) = %d\n", t, i); t = t * r % m; } } struct NumberTheoreticTransform { long long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED]; void init(const int n) { long long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD); for (int i = 0; i &lt; n; i++) { assert(i &lt; MAXM_EXTENDED); omega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD; omegaInverse[i] = inv(omega[i], MOD); // printf("omega[%d] = %lld\n", i, omega[i]); } } void transform(long long *a, const int n, const long long *omega) { int k = 0; while ((1 &lt;&lt; k) != n) k++; for (int i = 0; i &lt; n; i++) { assert(i &lt; MAXM_EXTENDED); int t = 0; for (int j = 0; j &lt; k; j++) if (i &amp; (1 &lt;&lt; j)) t |= (1 &lt;&lt; (k - j - 1)); if (t &gt; i) std::swap(a[i], a[t]); assert(t &lt; MAXM_EXTENDED); } for (int l = 2; l &lt;= n; l *= 2) { int m = l / 2; for (long long *p = a; p != a + n; p += l) { for (int i = 0; i &lt; m; i++) { assert(n / l * i &lt; MAXM_EXTENDED); assert(p - a + i &lt; MAXM_EXTENDED); long long t = omega[n / l * i] * p[i + m] % MOD; // printf("use omega = %lld\n", omega[n / l * i]); p[i + m] = (p[i] - t + MOD) % MOD; (p[i] += t) %= MOD; } } } } void dft(long long *a, const int n) { transform(a, n, omega); } void idft(long long *a, const int n) { transform(a, n, omegaInverse); long long x = inv(n, MOD); for (int i = 0; i &lt; n; i++) a[i] = a[i] * x % MOD; } void operator()(long long *a, long long *b, const int n) { assert(n &lt;= MAXM_EXTENDED); /* putchar('{'); for (int i = 0; i &lt; n; i++) printf(" %lld%c", a[i], (i == n - 1) ? ' ' : ','); putchar('}'); printf(" * "); putchar('{'); for (int i = 0; i &lt; n; i++) printf(" %lld%c", b[i], (i == n - 1) ? ' ' : ','); putchar('}'); putchar('\n'); */ dft(a, n); /* printf("After NTT: {"); for (int i = 0; i &lt; n; i++) printf(" %lld%c", a[i], (i == n - 1) ? ' ' : ','); putchar('}'); putchar('\n'); */ if (a != b) dft(b, n); /* printf("After NTT: {"); for (int i = 0; i &lt; n; i++) printf(" %lld%c", b[i], (i == n - 1) ? ' ' : ','); putchar('}'); putchar('\n'); */ for (int i = 0; i &lt; n; i++) a[i] = a[i] * b[i] % MOD; idft(a, n); if (a != b) idft(b, n); } } ntt; inline void pow(const long long *a, const int m, const int n, long long *res) { int size = 1; while (size &lt; m + m) size *= 2; ntt.init(size); // printf("size = %d, m = %d\n", size, m); static long long buf[MAXM_EXTENDED], bufDft[MAXM_EXTENDED]; std::copy(a, a + m, buf); std::copy(a, a + m, res); int tmp = n - 1; /* for (int i = 0; i &lt; tmp; i++) { ntt(res, buf, size); for (int i = m; i &lt; size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0; } return; */ assert(size &lt;= MAXM_EXTENDED); while (tmp) { if (tmp &amp; 1) { ntt.dft(res, size); std::copy(buf, buf + size, bufDft); ntt.dft(bufDft, size); for (int i = 0; i &lt; size; i++) (res[i] *= bufDft[i]) %= MOD; ntt.idft(res, size); for (int i = m; i &lt; size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0; } tmp &gt;&gt;= 1; ntt.dft(buf, size); for (int i = 0; i &lt; size; i++) (buf[i] *= buf[i]) %= MOD; ntt.idft(buf, size); for (int i = m; i &lt; size; i++) (buf[i % m] += buf[i]) %= MOD, buf[i] = 0; } } int main() { long long n; int x, s; static long long a[MAXM]; scanf("%lld %d %d %d", &amp;n, &amp;m, &amp;x, &amp;s); for (int i = 0; i &lt; s; i++) scanf("%lld", &amp;a[i]); prepare(); static long long f[MAXM_EXTENDED]; for (int i = 0; i &lt; s; i++) { if (a[i] == 0) continue; f[log[a[i] % m]]++; } static long long res[MAXM_EXTENDED]; pow(f, m - 1, n, res); assert(log[x] &lt; MAXM_EXTENDED); long long ans = res[log[x]]; printf("%lld\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>FFT</tag>
        <tag>原根</tag>
        <tag>SDOI</tag>
        <tag>NTT</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2014」力 - FFT]]></title>
    <url>%2Fzjoi2014-force%2F</url>
    <content type="text"><![CDATA[已知 求数列 。 链接 BZOJ 3527 题解 由题意得 设 考虑前一半，它等价于 考虑这样两个函数 上式化为 为~多项式乘法~卷积的形式，可以用 FFT 加速计算。 同理，对于后一半，有 与 BZOJ 2194 一题相似，将 翻转后计算即可。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;complex&gt; #include &lt;algorithm&gt; const int MAXN = 100000; const int MAXN_EXTENDED = 262144; const long double PI = acos(-1); struct FastFourierTransform { std::complex&lt;long double&gt; omega[MAXN_EXTENDED], omegaInverse[MAXN_EXTENDED]; void init(const int n) { for (int i = 0; i &lt; n; i++) { omega[i] = std::complex&lt;long double&gt;(cosl(2 * PI / n * i), sinl(2 * PI / n * i)); omegaInverse[i] = std::conj(omega[i]); } } void transform(std::complex&lt;long double&gt; *a, const int n, const std::complex&lt;long double&gt; *omega) { int k = 0; while ((1 &lt;&lt; k) != n) k++; for (int i = 0; i &lt; n; i++) { int t = 0; for (int j = 0; j &lt; k; j++) if (i &amp; (1 &lt;&lt; j)) t |= (1 &lt;&lt; (k - j - 1)); if (t &gt; i) std::swap(a[t], a[i]); } for (int l = 2; l &lt;= n; l *= 2) { const int m = l / 2; for (std::complex&lt;long double&gt; *p = a; p != a + n; p += l) { for (int i = 0; i &lt; m; i++) { const std::complex&lt;long double&gt; t = omega[n / l * i] * p[i + m]; p[i + m] = p[i] - t; p[i] += t; } } } } void dft(std::complex&lt;long double&gt; *a, const int n) { transform(a, n, omega); } void idft(std::complex&lt;long double&gt; *a, const int n) { transform(a, n, omegaInverse); for (int i = 0; i &lt; n; i++) a[i] /= n; } void multiply(std::complex&lt;long double&gt; *a, std::complex&lt;long double&gt; *b, const int n) { int size = 1; while (size &lt; n * 2) size *= 2; /* static std::complex&lt;long double&gt; c[MAXN_EXTENDED]; for (int i = 0; i &lt; n; i++) c[i] = 0; for (int j = 0; j &lt; n; j++) { for (int i = 0; i &lt;= j; i++) { c[j] += a[i] * b[j - i]; } } std::copy(c, c + n, a); return; */ init(size); dft(a, size); dft(b, size); for (int i = 0; i &lt; size; i++) a[i] *= b[i]; idft(a, size); } } fft; int n; long double q[MAXN + 1]; inline void calc(const long double *q, long double *E) { static std::complex&lt;long double&gt; f[MAXN_EXTENDED], g[MAXN_EXTENDED]; std::fill(f, f + MAXN_EXTENDED, 0); std::fill(g, g + MAXN_EXTENDED, 0); std::copy(q, q + n + 1, f); f[0] = g[0] = std::complex&lt;long double&gt;(0, 0); for (int i = 1; i &lt;= n; i++) { g[i] = std::complex&lt;long double&gt;(1.0 / pow(i, 2), 0); } fft.multiply(f, g, n + 1); for (int i = 1; i &lt;= n; i++) E[i] = f[i].real(); /* for (int i = 0; i &lt; (n + 1) * 2; i++) printf("* %lf\n", static_cast&lt;double&gt;(f[i].real())); putchar('\n'); return; static std::complex&lt;long double&gt; r[MAXN_EXTENDED]; for (int j = 0; j &lt;= n; j++) { r[j] = 0; for (int i = 0; i &lt;= j; i++) { r[j] += f[i] * g[j - i]; } } for (int i = 0; i &lt;= n; i++) printf("* %lf\n", static_cast&lt;double&gt;(r[i].real())); putchar('\n'); for (int i = 1; i &lt;= n; i++) E[i] = r[i].real(); */ } int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) { double x; scanf("%lf", &amp;x); q[i] = x; } static long double E1[MAXN + 1], E2[MAXN + 1]; calc(q, E1); std::reverse(q + 1, q + n + 1); calc(q, E2); for (int i = 1; i &lt;= n; i++) printf("%.3lf\n", static_cast&lt;double&gt;(E1[i] - E2[n - i + 1])); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>FFT</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2194」快速傅立叶之二 - FFT]]></title>
    <url>%2Fbzoj-2194%2F</url>
    <content type="text"><![CDATA[给定两个长度为 的序列 、，求长度为 的序列 ，满足 。 链接 BZOJ 2194 题解 将 反转得到 ，则有 调整求和指标，使 从 开始枚举 现在表达式已经类似多项式乘法的形式了，考虑这样一个多项式乘法 令 ，则上式化为 考虑将 翻转为 至此，原式已被化为多项式乘法的形式，只需将 和 作为多项式系数，求出 （只需前 项），翻转后即为 。 总时间复杂度为 FFT 的时间复杂度，。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;complex&gt; const int MAXN = 131072 * 2; const double PI = acos(-1); struct FastFourierTransform { std::complex&lt;double&gt; omega[MAXN], omegaInverse[MAXN]; void init(const int n) { for (int i = 0; i &lt; n; i++) { omega[i] = std::complex&lt;double&gt;(cos(2 * PI / n * i), sin(2 * PI / n * i)); omegaInverse[i] = std::conj(omega[i]); } } void transform(std::complex&lt;double&gt; *a, const int n, const std::complex&lt;double&gt; *omega) { int k = 0; while ((1 &lt;&lt; k) != n) k++; for (int i = 0; i &lt; n; i++) { int t = 0; for (int j = 0; j &lt; k; j++) if (i &amp; (1 &lt;&lt; (k - j - 1))) t |= (1 &lt;&lt; j); if (t &gt; i) std::swap(a[i], a[t]); } for (int l = 2; l &lt;= n; l *= 2) { const int m = l / 2; for (std::complex&lt;double&gt; *p = a; p != a + n; p += l) { for (int i = 0; i &lt; m; i++) { const std::complex&lt;double&gt; t = omega[n / l * i] * p[i + m]; p[i + m] = p[i] - t; p[i] += t; } } } } void dft(std::complex&lt;double&gt; *a, const int n) { transform(a, n, omega); } void idft(std::complex&lt;double&gt; *a, const int n) { transform(a, n, omegaInverse); for (int i = 0; i &lt; n; i++) a[i] /= n; } void operator()(const int *a, const int n1, const int *b, const int n2, int *c) { for (int k = 0; k &lt; n1 + n2; k++) { for (int i = 0; i &lt;= k; i++) { c[k] += a[i] * b[k - i]; } } return; static std::complex&lt;double&gt; ca[MAXN], cb[MAXN]; int n = 1; while (n &lt; (n1 + n2)) n *= 2; for (int i = 0; i &lt; n; i++) ca[i] = std::complex&lt;double&gt;(i &lt; n1 ? a[i] : 0, 0); for (int i = 0; i &lt; n; i++) cb[i] = std::complex&lt;double&gt;(i &lt; n2 ? b[i] : 0, 0); init(n); dft(ca, n); dft(cb, n); for (int i = 0; i &lt; n; i++) ca[i] *= cb[i]; idft(ca, n); for (int i = 0; i &lt; n; i++) c[i] = static_cast&lt;int&gt;(floor(ca[i].real() + 0.5)); } } fft; inline void force(const int *a, const int *b, int *c, const int n) { /* for (int k = 0; k &lt; n; k++) { for (int i = k; i &lt; n; i++) { c[k] += a[n - i - 1] * b[i - k]; } } return; */ for (int k = 0; k &lt; n; k++) { for (int i = 0; i &lt; n - k; i++) { c[k] += a[n - k - 1 - i] * b[i]; } } } int main() { int n; scanf("%d", &amp;n); static int a[MAXN], b[MAXN], c[MAXN]; for (int i = 0; i &lt; n; i++) scanf("%d %d", &amp;a[n - i - 1], &amp;b[i]); // force(a, b, c, n); fft(a, n, b, n, c); for (int i = 0; i &lt; n; i++) printf("%d\n", c[n - i - 1]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFT 学习笔记]]></title>
    <url>%2Ffft-notes%2F</url>
    <content type="text"><![CDATA[快速傅里叶变换（Fast Fourier Transform，FFT）是一种可在 时间内完成的离散傅里叶变换（Discrete Fourier transform，DFT）算法，在 OI 中的主要应用之一是加速多项式乘法的计算。 定义 多项式 系数表示与点值表示 多项式的系数表示，设 表示一个 次多项式，所有项的系数组成的 维向量 唯一确定了这个多项式。 多项式的点值表示，将一组互不相同的 个 带入多项式，得到的 个值。设它们组成的 维向量分别为 、。 求值与插值 定理：一个 次多项式在 个不同点的取值唯一确定了该多项式。 证明：假设命题不成立，存在两个不同的 次多项式 、，满足对于任何 ，有 。 令 ，则 也是一个 次多项式。对于任何 ，有 。 即 有 个根，这与代数基本定理（一个 次多项式在复数域上有且仅有 个根）相矛盾，故 并不是一个 次多项式，原命题成立，证毕。 如果我们按照定义求一个多项式的点值表示，时间复杂度为 。 已知多项式的点值表示，求其系数表示，可以使用插值。朴素的插值算法时间复杂度为 。 多项式乘法 我们定义两个多项式 与 相乘的结果为 （假设两个多项式次数相同，若不同可在后面补零）。 两个 次多项式相乘，得到的是一个 次多项式，时间复杂度为 。 如果使用两个多项式在 个点处取得的点值表示，那么 时间复杂度为 。 复数 设 、 为实数，，形如 的数叫做复数，其中 被称为虚数单位。复数域是已知最大的域。 复平面 在复平面中， 轴代表实数、 轴（除原点外的所有点）代表虚数。每一个复数 对应复平面上一个从 指向 的向量。 该向量的长度 叫做模长。表示从 轴正半轴到该向量的转角的有向（以逆时针为正方向）角叫做幅角。 复数相加遵循平行四边形定则。 复数相乘时，模长相乘，幅角相加。 单位根 下文中，如不特殊指明，均设 为 的正整数次幂。 在复平面上，以原点为圆心， 为半径作圆，所得的圆叫做单位圆。以原点为起点，单位圆的 等分点为终点，作 个向量。设所得的幅角为正且最小的向量对应的复数为 ，称为 次单位根。 由复数乘法的定义（模长相乘，幅角相加）可知，其与的 个向量对应的复数分别为 ，其中 。 单位根的幅角为周角的 ，这为我们提供了一个计算单位根及其幂的公式 单位根的性质 性质一： 从几何意义上看，在复平面上，二者表示的向量终点相同。 更具体的，有 性质二： 等式左边相当于 乘上 ，考虑其值 快速傅里叶变换 考虑多项式 的表示。将 次单位根的 到 次幂带入多项式的系数表示，所得点值向量 称为其系数向量 的离散傅里叶变换。 按照朴素算法来求离散傅里叶变换，时间复杂度仍然为 。 考虑将多项式按照系数下标的奇偶分为两部分 令 则有 假设 ，现在要求 这一步转化利用了单位根的性质一。 对于 这一步转化除性质一外，还利用到了性质二和 这一显然的结论。 注意到，当 取遍 时， 和 取遍了 。 也就是说，如果已知 和 在 处的点值，就可以在 的时间内求得 在 处的取值。而关于 和 的问题都是相对于原问题规模缩小了一半的子问题，分治的边界为一个常数项 。 根据主定理，该分治算法的时间复杂度为 这就是最常用的 FFT 算法 —— Cooley-Tukey 算法。 傅里叶逆变换 将点值表示的多项式转化为系数表示，同样可以使用快速傅里叶变换，这个过程叫做傅里叶逆变换。 设 为 的傅里叶变换。考虑另一个向量 满足 即多项式 在 处的点值表示。 将上式展开，得 考虑一个式子 当 时，两边同时乘上 得 两式相减，整理后得 分子为零，分母不为零，所以 当 时，显然 。 继续考虑上式 当 时，，否则 ，即 所以，使用单位根的倒数代替单位根，做一次类似快速傅里叶变换的过程，再将结果每个数除以 ，即为傅里叶逆变换的结果。 实现 C++ 的 STL 在头文件 complex 中提供一个复数的模板实现 std::complex&lt;T&gt;，其中 T 为实数类型，一般取 double，在对精度要求较高的时候可以使用 long double 或 __float128（不常用）。 考虑到单位根的倒数等于其共轭复数，在程序实现中，为了减小误差，通常使用 std::conj() 取得 IDFT 所需的「单位根的倒数」。 递归实现 直接按照上面得到的结论来实现即可，比较直观。 代码 const double PI = acos(-1); bool inversed = false; inline std::complex&lt;double&gt; omega(const int n, const int k) { if (!inversed) return std::complex&lt;double&gt;(cos(2 * PI / n * k), sin(2 * PI / n * k)); else return std::conj(std::complex&lt;double&gt;(cos(2 * PI / n * k), sin(2 * PI / n * k))); } inline void transform(std::complex&lt;double&gt; *a, const int n) { if (n == 1) return; static std::complex&lt;double&gt; buf[MAXN]; const int m = n / 2; // 按照系数奇偶划分为两半 for (int i = 0; i &lt; m; i++) { buf[i] = a[i * 2]; buf[i + m] = a[i * 2 + 1]; } std::copy(buf, buf + n, a); // 分治 std::complex&lt;double&gt; *a1 = a, *a2 = a + m; fft(a1, m); fft(a2, m); // 合并两个子问题 for (int i = 0; i &lt; m; i++) { std::complex&lt;double&gt; x = omega(n, i); buf[i] = a1[i] + x * a2[i]; buf[i + m] = a1[i] - x * a2[i]; } std::copy(buf, buf + n, a); } 迭代实现 递归实现的 FFT 效率不高，实际中一般采用迭代实现。 二进制位翻转 考虑递归 FFT 分治到边界时，每个数的顺序，及其二进制位。 000 001 010 011 100 101 110 111 0 1 2 3 4 5 6 7 0 2 4 6 - 1 3 5 7 0 4 - 2 6 - 1 5 - 3 7 0 - 4 - 2 - 6 - 1 - 5 - 3 - 7 000 100 010 110 001 101 011 111 发现规律，分治到边界后的下标等于原下标的二进制位翻转。 代码实现，枚举每个二进制位即可。 int k = 0; while ((1 &lt;&lt; k) &lt; n) k++; for (int i = 0; i &lt; n; i++) { int t = 0; for (int j = 0; j &lt; k; j++) if (i &amp; (1 &lt;&lt; j)) t |= (1 &lt;&lt; (k - j - 1)); if (i &lt; t) std::swap(a[i], a[t]); } 蝴蝶操作 考虑合并两个子问题的过程，假设 和 分别存在 和 中， 和 将要被存放在 和 中，合并的单位操作可表示为 考虑加入一个临时变量 ，使得这个过程可以在原地完成，不需要另一个数组 ，也就是说，将 和 存放在 和 中，覆盖原来的值 这一过程被称为蝴蝶操作。 代码 omega[k] 中保存 （IDFT 时保存 ）。 枚举 ，表示一次要将 长度的序列答案合并为长度为 的，根据单位根的性质一，有 。 void transform(std::complex&lt;double&gt; *a, const int n, const std::complex&lt;double&gt; *omega) { // 此处省略二进制位翻转的代码 for (int l = 2; l &lt;= n; l *= 2) { int m = l / 2; // 将两个长度为 m 的序列的答案合并为长度为 l 的序列的答案 for (std::complex&lt;double&gt; *p = a; p != a + n; p += l) { for (int i = 0; i &lt; m; i++) { // 蝴蝶操作 std::complex&lt;double&gt; t = omega[n / l * i] * p[m + i]; p[m + i] = p[i] - t; p[i] += t; } } } } 模板 需要注意的是，在求两个次数分别为 和 的多项式的乘积时，需要分别求出其在至少 个点处的点值，因为这样才能保证相乘后的点值能唯一确定一个 次多项式。 struct FastFourierTransform { std::complex&lt;double&gt; omega[MAXN], omegaInverse[MAXN]; void init(const int n) { for (int i = 0; i &lt; n; i++) { omega[i] = std::complex&lt;double&gt;(cos(2 * PI / n * i), sin(2 * PI / n * i)); omegaInverse[i] = std::conj(omega[i]); } } void transform(std::complex&lt;double&gt; *a, const int n, const std::complex&lt;double&gt; *omega) { int k = 0; while ((1 &lt;&lt; k) &lt; n) k++; for (int i = 0; i &lt; n; i++) { int t = 0; for (int j = 0; j &lt; k; j++) if (i &amp; (1 &lt;&lt; j)) t |= (1 &lt;&lt; (k - j - 1)); if (i &lt; t) std::swap(a[i], a[t]); } for (int l = 2; l &lt;= n; l *= 2) { int m = l / 2; for (std::complex&lt;double&gt; *p = a; p != a + n; p += l) { for (int i = 0; i &lt; m; i++) { std::complex&lt;double&gt; t = omega[n / l * i] * p[m + i]; p[m + i] = p[i] - t; p[i] += t; } } } } void dft(std::complex&lt;double&gt; *a, const int n) { transform(a, n, omega); } void idft(std::complex&lt;double&gt; *a, const int n) { transform(a, n, omegaInverse); for (int i = 0; i &lt; n; i++) a[i] /= n; } } fft; inline void multiply(const int *a1, const int n1, const int *a2, const int n2, int *res) { int n = 1; while (n &lt; n1 + n2) n *= 2; static std::complex&lt;double&gt; c1[MAXN], c2[MAXN]; for (int i = 0; i &lt; n1; i++) c1[i].real(a1[i]); for (int i = 0; i &lt; n2; i++) c2[i].real(a2[i]); fft.init(n); fft.dft(c1, n), fft.dft(c2, n); for (int i = 0; i &lt; n; i++) c1[i] *= c2[i]; fft.idft(c1, n); for (int i = 0; i &lt; n1 + n2 - 1; i++) res[i] = static_cast&lt;int&gt;(floor(c1[i].real() + 0.5)); } 参考资料 多項式 - 维基百科，自由的百科全书，Wikipedia 复平面 - 维基百科，自由的百科全书，Wikipedia 复数 (数学) - 维基百科，自由的百科全书，Wikipedia 快速傅里叶变换 - 维基百科，自由的百科全书，Wikipedia FFT &amp; NTT | ZYK1997，ZYK1997 BZOJ 3992 SDOI2015 序列统计 - Fuxey - 博客频道 - CSDN.NET，Fuxey 从多项式乘法到快速傅里叶变换 - Miskcoo's Space，Miskcoo OI 中的 FFT - zball - 博客园，zball Fourier transform，郭晓旭]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>FFT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11021」Tribles - 概率与期望]]></title>
    <url>%2Fuva-11021%2F</url>
    <content type="text"><![CDATA[有 个 Tribles，每个 Trible 只能存活一天，但在死亡之前，每个 Trible 有 的概率繁衍出 个 Tribles。求 天之后所有 Tribles 全部死亡的概率。 链接 UVa 11021 COGS 1487 题解 设 为一个 Trible 经过 天后全部死亡的概率，则 个 Trible 经过 天后全部死亡的概率为 。 根据题意，每个 Trible 每天的繁衍行为共分为 种情况，每一种情况发生的概率乘以繁衍出的 Tribles 在剩余的 天全部死亡的概率的总和即为结果。 边界条件为 。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; const int MAXN = 1000; const int MAXK = 1000; const int MAXM = 1000; int main() { int t, n, k, m; scanf("%d", &amp;t); for (int i = 1; i &lt;= t; i++) { scanf("%d %d %d", &amp;n, &amp;k, &amp;m); static double p[MAXN], f[MAXK + 1]; for (int i = 0; i &lt; n; i++) scanf("%lf", &amp;p[i]); std::fill(f, f + m + 1, 0); f[0] = 1; for (int i = 1; i &lt;= m; i++) { for (int j = 0; j &lt; n; j++) { f[i] += p[j] * pow(f[i - 1], j); } } printf("Case #%d: %.7lf\n", i, pow(f[m], k)); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>DP</tag>
        <tag>COGS</tag>
        <tag>概率与期望</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4318」OSU! - 概率与期望]]></title>
    <url>%2Fbzoj-4318%2F</url>
    <content type="text"><![CDATA[我们可以把 osu! 的规则简化与改编成以下的样子: 一共有 次操作，每次操作只有成功与失败之分，成功对应 ，失败对应 ， 次操作对应为 个长度为 的 01 串。在这个串中连续的 个 可以贡献 的分数，这 个 不能被其他连续的 所包含（也就是极长的一串 ）。 现在给出 ，以及每个操作的成功率，请你输出期望分数。 链接 BZOJ 4318 题解 设 表示前 次操作后的期望得分， 表示第 次操作成功的概率。 考虑连续 的长度 的变化，如果第 次成功，则 ，考虑其对得分 的影响。 根据期望的线性性，我们只需要求出 和 ，即可得到 乘上成功的概率，即为该次操作的期望分数增量（相对于第 次）。 考虑如何维护 与 ，仍旧是考虑期望的线性性，将式子展开。 首先，显然 有 的概率比上一次操作多 次，有 的概率直接成为 ，即 类似的，有 即 至此，、、 均可在线性时间内递推得到。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; const int MAXN = 100000; int n; double p[MAXN + 1], f[MAXN + 1]; double ex1[MAXN + 1], ex2[MAXN + 1]; inline void dp() { f[0] = 0; for (int i = 1; i &lt;= n; i++) { ex1[i] = (ex1[i - 1] + 1) * p[i]; ex2[i] = (ex2[i - 1] + 2 * ex1[i - 1] + 1) * p[i]; double t = (3 * ex2[i - 1] + 3 * ex1[i - 1] + 1) * p[i]; f[i] = f[i - 1] + t; } } int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lf", &amp;p[i]); dp(); printf("%.1lf\n", floor(f[n] * 10 + 0.5) / 10); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「省队集训 2016」Play with array - 块状链表]]></title>
    <url>%2F20160527-array%2F</url>
    <content type="text"><![CDATA[有一个长度为 的数列，支持以下两种操作： 将 移动到 的前面； 查询 中 的出现次数。 题解 将序列按照 分块，维护块状链表，将每次修改转化为一次插入一次删除，每个块记录每个数出现次数。 每次查询时，将 的答案转化为 的答案减去 的答案。对于块内部分直接查询，块外部分暴力。 时间复杂度、空间复杂度均为 。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;list&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; #define dprintf(format, ...) fprintf(stderr, format, __VA_ARGS__) const int MAXN = 100000; const int MAXN_SQRT = 316 + 1; const int MAXM = 100000; int n, m, a[MAXN]; struct BlockList { struct Block { std::list&lt;int&gt; l; std::vector&lt;int&gt; sum; Block() : sum(n) {} inline int left(const int k, const int pos) { int res = 0; std::list&lt;int&gt;::const_iterator it = l.begin(); for (int i = 0; i &lt;= pos; i++) if (*it++ == k) res++; return res; } }; std::list&lt;Block&gt; blocks; int blockCount, blockSize; inline void build(const int *a, const int n) { blockCount = floor(sqrt(n) + 1), blockSize = ceil(static_cast&lt;double&gt;(n) / blockCount); // dprintf("BlockList::build(): blockCount = %d, blockSize = %d\n", blockCount, blockSize); blocks.resize(blockCount); std::list&lt;Block&gt;::iterator b = blocks.begin(); for (int i = 0, j = 0; i &lt; blockCount; i++, b++) { for (int k = 0; k &lt;= blockSize &amp;&amp; j &lt; n; k++, j++) { b-&gt;sum[a[j]]++; b-&gt;l.push_back(a[j]); } } } inline int erase(int pos) { for (std::list&lt;Block&gt;::iterator b = blocks.begin(); b != blocks.end(); b++) { if (pos &lt; b-&gt;l.size()) { std::list&lt;int&gt;::iterator it = b-&gt;l.begin(); std::advance(it, pos); const int x = *it; b-&gt;sum[*it]--; b-&gt;l.erase(it); return x; } else pos -= b-&gt;l.size(); } throw; } inline void insert(int pos, const int x) { for (std::list&lt;Block&gt;::iterator b = blocks.begin(); b != blocks.end(); b++) { if (pos &lt; b-&gt;l.size()) { std::list&lt;int&gt;::iterator it = b-&gt;l.begin(); std::advance(it, pos); b-&gt;sum[x]++; b-&gt;l.insert(it, x); return; } else pos -= b-&gt;l.size(); } throw; } inline int query(int pos, const int k) { int ans = 0; for (std::list&lt;Block&gt;::iterator b = blocks.begin(); b != blocks.end(); b++) { if (pos &lt; b-&gt;l.size()) { ans += b-&gt;left(k, pos); break; } else { pos -= b-&gt;l.size(); ans += b-&gt;sum[k]; } } return ans; } inline void mergeNext(std::list&lt;Block&gt;::iterator b) { std::list&lt;Block&gt;::iterator next = b; next++; if (next == blocks.end()) return; for (std::list&lt;int&gt;::const_iterator it = next-&gt;l.begin(); it != next-&gt;l.end(); it++) { b-&gt;l.push_back(*it); b-&gt;sum[*it]++; } blocks.erase(next); } inline void split(std::list&lt;Block&gt;::iterator b) { std::list&lt;Block&gt;::iterator newBlock = blocks.insert(b, Block()); for (int i = 0; i &lt; b-&gt;l.size() / 2; i++) { const int &amp;x = b-&gt;l.front(); newBlock-&gt;l.push_back(x); newBlock-&gt;sum[x]++; b-&gt;sum[x]--; b-&gt;l.pop_front(); } } inline void maintain() { for (std::list&lt;Block&gt;::iterator b = blocks.begin(); b != blocks.end(); b++) { if (b-&gt;l.size() &lt;= blockSize / 2) mergeNext(b); else if (b-&gt;l.size() &gt;= blockSize * 2) split(b); } } inline void print() { for (std::list&lt;Block&gt;::const_iterator b = blocks.begin(); b != blocks.end(); b++) { dprintf("blockSize = %d\n", b-&gt;l.size()); } return; for (std::list&lt;Block&gt;::const_iterator b = blocks.begin(); b != blocks.end(); b++) { for (std::list&lt;int&gt;::const_iterator it = b-&gt;l.begin(); it != b-&gt;l.end(); it++) { dprintf("%d ", *it + 1); } } dprintf("%c", '\n'); } } list; int main() { // freopen("array.in", "r", stdin); // freopen("array.out", "w", stdout); scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) { scanf("%d", &amp;a[i]), a[i]--; } list.build(a, n); // list.print(); scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) { int t, l, r; scanf("%d %d %d", &amp;t, &amp;l, &amp;r), l--, r--; if (t == 1) { int x = list.erase(r); list.insert(l, x); // list.print(); list.maintain(); // list.print(); // dprintf("%c", '\n'); } else { int k; scanf("%d", &amp;k), k--; int R = list.query(r, k), L = l == 0 ? 0 : list.query(l - 1, k); printf("%d\n", R - L); } } fclose(stdin); fclose(stdout); // list.print(); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分块</tag>
        <tag>块状链表</tag>
        <tag>省队集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3275」Number - 最小割]]></title>
    <url>%2Fbzoj-3275%2F</url>
    <content type="text"><![CDATA[有 个正整数，需要从中选出一些数，使这些数的和最大。 若两个数 同时满足以下条件，则 不能同时被选。 存在正整数 ，使 ； 。 链接 BZOJ 3275 COGS 1389 题解 建图，把不能同时选择的数字连边，染色后发现是二分图，问题转化为二分图最大点权独立集。 从源点到所有 点连边，容量为数字，从所有 点向汇点连边，容量为数字，不能成对选择数字，从 点到 点连边，容量为正无穷，求出最小割即为损失，总和减去损失即为答案。 代码 #include &lt;cstdio&gt; #include &lt;cassert&gt; #include &lt;climits&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 3000; struct Node; struct Edge; struct Node { Edge *e, *c; int l; long long x; bool color, v; } N[MAXN + 2]; struct Edge { Node *s, *t; long long f, c; Edge *next, *r; Edge(Node *const s, Node *const t, const long long c) : s(s), t(t), f(0), c(c), next(s-&gt;e) {} }; inline void addEdge(const int u, const int v, const long long c) { N[u].e = new Edge(&amp;N[u], &amp;N[v], c); N[v].e = new Edge(&amp;N[v], &amp;N[u], 0); (N[u].e-&gt;r = N[v].e)-&gt;r = N[u].e; } struct Dinic { bool makeLevelGraph(Node *const s, Node *const t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;f &lt; e-&gt;c &amp;&amp; e-&gt;t-&gt;l == 0) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } } return false; } long long findPath(Node *const s, Node *const t, const long long limit = LLONG_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) { if (e-&gt;f &lt; e-&gt;c &amp;&amp; e-&gt;t-&gt;l == s-&gt;l + 1) { long long flow = findPath(e-&gt;t, t, std::min(limit, e-&gt;c - e-&gt;f)); if (flow &gt; 0) { e-&gt;f += flow; e-&gt;r-&gt;f -= flow; return flow; } } } return 0; } long long operator()(const int s, const int t, const int n) { long long res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { long long flow; while ((flow = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += flow; } return res; } } dinic; int n; bool flag[MAXN][MAXN]; template &lt;typename T&gt; inline T sqr(const T x) { return x * x; } template &lt;typename T&gt; inline bool isSquare(const T x) { T t = static_cast&lt;T&gt;(sqrt(static_cast&lt;double&gt;(x))); return t * t == x; } template &lt;typename T&gt; inline T gcd(const T a, const T b) { return !b ? a : gcd(b, a % b); } inline void color() { for (int i = 1; i &lt;= n; i++) { if (N[i].v) continue; std::queue&lt;Node *&gt; q; q.push(&amp;N[i]); N[i].color = true; N[i].v = true; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (!e-&gt;t-&gt;v) { e-&gt;t-&gt;v = true; e-&gt;t-&gt;color = !v-&gt;color; q.push(e-&gt;t); } else assert(e-&gt;t-&gt;color != v-&gt;color); } } } } inline void clean() { for (int i = 1; i &lt;= n; i++) { Edge *next; for (Edge *&amp;e = N[i].e; e; next = e-&gt;next, delete e, e = next); } } int main() { scanf("%d", &amp;n); long long sum = 0; for (int i = 1; i &lt;= n; i++) { scanf("%lld", &amp;N[i].x); sum += N[i].x; } for (int i = 1; i &lt;= n; i++) { for (int j = i + 1; j &lt;= n; j++) { if (isSquare(sqr(N[i].x) + sqr(N[j].x)) &amp;&amp; gcd(N[i].x, N[j].x) == 1) { flag[i][j] = flag[j][i] = true; addEdge(i, j, 0); } } } color(); clean(); const int s = 0, t = n + 1; for (int i = 1; i &lt;= n; i++) { if (N[i].color) addEdge(s, i, N[i].x); else addEdge(i, t, N[i].x); for (int j = i + 1; j &lt;= n; j++) { if (flag[i][j]) { if (N[i].color) addEdge(i, j, LLONG_MAX); else addEdge(j, i, LLONG_MAX); } } } long long maxFlow = dinic(s, t, n + 2); printf("%lld\n", sum - maxFlow); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>最小割</tag>
        <tag>二分图染色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2006」物流运输 - 最短路 + DP]]></title>
    <url>%2Fzjoi2006-trans%2F</url>
    <content type="text"><![CDATA[物流公司要把一批货物从码头 运到码头 。由于货物量比较大，需要 天才能运完。货物运输过程中一般要转停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是修改路线是一件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个 天的运输计划，使得总成本尽可能地小。 链接 BZOJ 1003 COGS 1824 题解 首先，对时间暴力枚举一段区间，对这些天内任意一天不能使用的点标记，在剩余的点中求出最短路，以得到任意几天走相同路线的最少花费（最短路乘以天数）。 设 表示第 天到第 天走相同路线的最少花费，设 表示完成前 天的运输计划并修改路线的最少花费，则 注意，当 无效，即第 天到第 天无法走同一条路线时不可转移。 最终答案为 ，时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;queue&gt; #include &lt;utility&gt; #include &lt;functional&gt; struct Node; struct Edge; const int MAXN = 20; const int MAXD = 100; struct Node { Edge *e; int d; bool flag[MAXD], invalid; } N[MAXN]; struct Edge { Node *s, *t; int w; Edge *next; Edge(Node *const s, Node *const t, const int w) : s(s), t(t), w(w), next(s-&gt;e) {} }; inline void addEdge(const int u, const int v, const int w) { N[u].e = new Edge(&amp;N[u], &amp;N[v], w); N[v].e = new Edge(&amp;N[v], &amp;N[u], w); } int d, n, k, m, c[MAXD + 1][MAXD + 1]; int f[MAXD + 1]; inline int dijkstra(const int s, const int t) { for (int i = 0; i &lt; n; i++) N[i].d = INT_MAX; std::priority_queue&lt; std::pair&lt;int, Node *&gt;, std::vector&lt; std::pair&lt;int, Node *&gt; &gt;, std::greater&lt; std::pair&lt;int, Node *&gt; &gt; &gt; q; N[s].d = 0; q.push(std::make_pair(0, &amp;N[s])); while (!q.empty()) { const std::pair&lt;int, Node *&gt; p = q.top(); q.pop(); Node *v = p.second; if (v-&gt;d != p.first) continue; if (v-&gt;d &gt; N[t].d) break; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;t-&gt;invalid) continue; if (e-&gt;t-&gt;d &gt; v-&gt;d + e-&gt;w) { e-&gt;t-&gt;d = v-&gt;d + e-&gt;w; q.push(std::make_pair(e-&gt;t-&gt;d, e-&gt;t)); } } } return N[t].d; } int main() { scanf("%d %d %d %d", &amp;d, &amp;n, &amp;k, &amp;m); for (int i = 0; i &lt; m; i++) { int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w), u--, v--; addEdge(u, v, w); } int t; scanf("%d", &amp;t); while (t--) { int u, l, r; scanf("%d %d %d", &amp;u, &amp;l, &amp;r), u--, l--, r--; std::fill(N[u].flag + l, N[u].flag + r + 1, true); } for (int i = 1; i &lt;= d; i++) { for (int j = i; j &lt;= d; j++) { for (int k = 0; k &lt; n; k++) { N[k].invalid = false; for (int l = i; l &lt;= j; l++) { if (N[k].flag[l - 1]) { N[k].invalid = true; break; } } } c[i][j] = dijkstra(0, n - 1); if (c[i][j] != INT_MAX) c[i][j] *= (j - i + 1); // printf("%d\n", c[i][j]); } } std::fill(f, f + d + 1, INT_MAX); f[0] = 0; for (int i = 1; i &lt;= d; i++) { for (int j = 0; j &lt; i; j++) { if (c[j + 1][i] != INT_MAX) { f[i] = std::min(f[i], f[j] + k + c[j + 1][i]); } } } printf("%d\n", f[d] - k); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>COGS</tag>
        <tag>最短路</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2008」杀蚂蚁 - 模拟 + 几何]]></title>
    <url>%2Fzjoi2008-antbuster%2F</url>
    <content type="text"><![CDATA[题面见杀蚂蚁的可读版本。 链接 BZOJ 1033 COGS 2048 题解 根据题意模拟即可 …… 唯一的难点是判断线段和圆的交点。先过圆心做线段的垂线，判断与线段是否有交点，如果有，则设点到线段距离为 ，圆心与线段端点距离的较大值为 ；否则设圆心与线段距离较小值为 ，较大值为 。 满足 即可 保存直线的时候可以用斜截式，但注意斜率不存在和斜率为零的特判。 还有就是不要写错变量名 …… 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;list&gt; #include &lt;algorithm&gt; typedef long double real; const int MAXN = 8; const int MAXM = 8; const int MAXS = 20; const int MAXT = 200000; const real EPS = 1e-6; int n, m, s, d, r, t, time; struct Map { int message; bool reachable; Map() : message(0), reachable(true) {} } map[MAXN + 1][MAXM + 1]; template &lt;typename T&gt; struct Point { T x, y; Point(const T x = 0, const T y = 0) : x(x), y(y) {} Map *operator-&gt;() const { return &amp;map[static_cast&lt;int&gt;(x)][static_cast&lt;int&gt;(y)]; } Point offset(const int id) const { switch (id) { case 0: return Point(x, y + 1); case 1: return Point(x + 1, y); case 2: return Point(x, y - 1); case 3: return Point(x - 1, y); default: return *this; } } bool valid() const { return x &gt;= 0 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= m; } bool operator==(const Point &amp;p) const { return x == p.x &amp;&amp; y == p.y; } }; inline bool dcmp(const real a) { return fabs(a) &lt;= EPS; } inline bool dcmp(const real a, const real b) { return dcmp(a - b); } inline bool isnan(const real x) { return x != x; } inline bool isinf(const real x) { return !isnan(x) &amp;&amp; isnan(x - x); } template &lt;typename T&gt; inline T sqr(const T &amp;x) { return x * x; } template &lt;typename Ta, typename Tb&gt; inline real distance(const Point&lt;Ta&gt; a, const Point&lt;Tb&gt; b) { return sqrt(static_cast&lt;real&gt;(sqr(a.x - b.x) + sqr(a.y - b.y))); } struct Ant { Point&lt;int&gt; position, lastPosition; int level; int hpLimit, hp; bool hasCake; int spawnTime; Ant(const int level) : position(0, 0), lastPosition(-1, -1), level(level), hpLimit(floor(4 * pow(1.1, level))), hp(hpLimit), hasCake(false), spawnTime(time) { // printf("spawn Ant(%d)\n", level); position-&gt;reachable = false; } inline void moveTo(const Point&lt;int&gt; &amp;nextPosition) { lastPosition = position; position = nextPosition; if (lastPosition == position) return; // printf("moveTo(): from [%d, %d] to [%d, %d]\n", lastPosition.x, lastPosition.y, position.x, position.y); lastPosition-&gt;reachable = true; position-&gt;reachable = false; } inline int age() const { return time - spawnTime; } inline bool attackable(const Point&lt;int&gt; &amp;p) { const real dist = distance(position, p); return dist &lt; r || dcmp(dist, r); } }; struct Line { real k, b; /* * k != nan: y = kx + b * k == nan: x = b */ Line(const Point&lt;int&gt; &amp;p1, const Point&lt;int&gt; &amp;p2) { const real x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y; if (x1 == x2) { k = NAN; b = x1; } else { k = (y2 - y1) / (x2 - x1); b = y1 - k * x1; } } Line(const real k, const Point&lt;int&gt; &amp;p1) : k(isinf(k) ? NAN : k), b(isinf(k) ? p1.x : (p1.y - k * p1.x)) {} Line(const real k, const real b) : k(k), b(b) {} Line perpendicular(const Point&lt;int&gt; &amp;p1) const { if (isnan(k)) return Line(0, p1.y); else return Line(-1.0 / k, p1); } }; struct Segment { Point&lt;int&gt; p1, p2; Line line; real length; Segment(const Point&lt;int&gt; &amp;p1, const Point&lt;int&gt; &amp;p2) : p1(p1), p2(p2), line(p1, p2) { length = distance(p1, p2); } }; Point&lt;real&gt; lineIntersection(const Line &amp;a, const Line &amp;b) { if (isnan(a.k) &amp;&amp; isnan(b.k) || a.k == b.k) throw; if (isnan(a.k)) return Point&lt;real&gt;(a.b, a.b * b.k + b.b); if (isnan(b.k)) return Point&lt;real&gt;(b.b, b.b * a.k + a.b); const real x = (b.b - a.b) / (a.k - b.k); const real y = a.k * x + a.b; return Point&lt;real&gt;(x, y); } bool pointOnSegment(const Point&lt;real&gt; &amp;p, const Segment &amp;s) { return dcmp(distance(p, s.p1) + distance(p, s.p2) - s.length); } bool segmentCircleIntersection(const Segment &amp;s, const Point&lt;int&gt; &amp;p, const real r) { Line v = s.line.perpendicular(p); Point&lt;real&gt; is = lineIntersection(v, s.line); real min, max; if (pointOnSegment(is, s)) { min = distance(is, p); max = std::max(distance(is, s.p1), distance(is, s.p2)); } else { min = distance(p, s.p1); max = distance(p, s.p2); if (min &gt; max) std::swap(min, max); } return (min &lt; r || dcmp(min, r)) &amp;&amp; (max &gt; r || dcmp(max, r)); } std::list&lt;Ant&gt; ants; std::list&lt;Ant&gt;::iterator cakeOwner = ants.end(); Point&lt;int&gt; towers[MAXS]; inline void spawn() { if (ants.size() &lt; 6) { if (map[0][0].reachable == false) return; static int cnt = -1; cnt++; ants.push_back(Ant(cnt / 6 + 1)); } } inline void incMessage() { for (std::list&lt;Ant&gt;::const_iterator it = ants.begin(); it != ants.end(); it++) { it-&gt;position-&gt;message += it-&gt;hasCake ? 5 : 2; } } inline void move() { for (std::list&lt;Ant&gt;::iterator it = ants.begin(); it != ants.end(); it++) { // static int _cnt = 0; // _cnt++; // printf("move(): _cnt = %d\n", _cnt); int id = -1; // printf("move(): lastPosition = [%d, %d]\n", it-&gt;lastPosition.x, it-&gt;lastPosition.y); for (int i = 0; i &lt; 4; i++) { Point&lt;int&gt; newPosition = it-&gt;position.offset(i); if (!newPosition.valid()) continue; if (newPosition == it-&gt;lastPosition) continue; if (!newPosition-&gt;reachable) continue; if (id == -1 || newPosition-&gt;message &gt; it-&gt;position.offset(id)-&gt;message) { id = i; } } // if (id != -1) printf("move(): checking moving to [%d, %d]\n", it-&gt;position.offset(id).x, it-&gt;position.offset(id).y); if (id != -1 &amp;&amp; (it-&gt;age() + 1) % 5 == 0) { // printf("move(): special, before = [%d, %d]\n", it-&gt;position.offset(id).x, it-&gt;position.offset(id).y); Point&lt;int&gt; newPosition; do { id = (id - 1 + 4) % 4; newPosition = it-&gt;position.offset(id); } while (!newPosition.valid() || !newPosition-&gt;reachable || newPosition == it-&gt;lastPosition); // printf("move(): special, after = [%d, %d]\n", it-&gt;position.offset(id).x, it-&gt;position.offset(id).y); } it-&gt;moveTo(it-&gt;position.offset(id)); } } inline void getCake() { if (cakeOwner != ants.end()) return; for (std::list&lt;Ant&gt;::iterator it = ants.begin(); it != ants.end(); it++) { if (it-&gt;position == Point&lt;int&gt;(n, m)) { cakeOwner = it; it-&gt;hasCake = true; it-&gt;hp = std::min(it-&gt;hpLimit, it-&gt;hp + it-&gt;hpLimit / 2); // puts("getCake(): got"); break; } } } inline void attack() { for (int i = 0; i &lt; s; i++) { // static int _cnt = 0; // _cnt++; // printf("attack(): _cnt = %d\n", _cnt); std::list&lt;Ant&gt;::iterator target = ants.end(); if (cakeOwner != ants.end() &amp;&amp; cakeOwner-&gt;attackable(towers[i])) { target = cakeOwner; } if (target == ants.end()) { for (std::list&lt;Ant&gt;::iterator it = ants.begin(); it != ants.end(); it++) { real d = distance(it-&gt;position, towers[i]); if ((d &lt; r || dcmp(d, r)) &amp;&amp; (target == ants.end() || distance(it-&gt;position, towers[i]) &lt; distance(target-&gt;position, towers[i]))) { target = it; } } } if (target != ants.end()) { target-&gt;hp -= d; Segment s(towers[i], target-&gt;position); for (std::list&lt;Ant&gt;::iterator it = ants.begin(); it != ants.end(); it++) { if (it != target &amp;&amp; segmentCircleIntersection(s, it-&gt;position, 0.5)) { // printf("attack(): _cnt = %d, through [%d, %d]\n", _cnt, it-&gt;position.x, it-&gt;position.y); it-&gt;hp -= d; } // if (it == target) printf("attack(): _cnt = %d, target [%d, %d]\n", _cnt, target-&gt;position.x, target-&gt;position.y); } } } } inline void kill() { for (std::list&lt;Ant&gt;::iterator it = ants.begin(); it != ants.end(); ) { if (it-&gt;hp &lt; 0) { it-&gt;position-&gt;reachable = true; if (it == cakeOwner) cakeOwner = ants.end(); it = ants.erase(it); } else it++; } } inline bool check() { for (std::list&lt;Ant&gt;::const_iterator it = ants.begin(); it != ants.end(); it++) { if (it-&gt;position == Point&lt;int&gt;(0, 0) &amp;&amp; it-&gt;hasCake) return false; } return true; } inline void decMessage() { for (int i = 0; i &lt;= n; i++) { for (int j = 0; j &lt;= m; j++) { if (map[i][j].message &gt; 0) map[i][j].message--; } } } int main() { freopen("data.in", "r", stdin); scanf("%d %d\n%d %d %d", &amp;n, &amp;m, &amp;s, &amp;d, &amp;r); for (int i = 0; i &lt; s; i++) { scanf("%d %d", &amp;towers[i].x, &amp;towers[i].y); towers[i]-&gt;reachable = false; } scanf("%d", &amp;t); time = 1; for (; time &lt;= t; time++) { // printf("main(): time = %d\n", time); spawn(); incMessage(); move(); getCake(); attack(); kill(); if (!check()) break; decMessage(); // for (std::list&lt;Ant&gt;::const_iterator it = ants.begin(); it != ants.end(); it++) printf("%d %d %d %d %d\n", it-&gt;age(), it-&gt;level, it-&gt;hp, it-&gt;position.y, it-&gt;position.x); // putchar('\n'); } if (time &gt; t) puts("The game is going on"); else printf("Game over after %d seconds\n", time); printf("%d\n", ants.size()); for (std::list&lt;Ant&gt;::const_iterator it = ants.begin(); it != ants.end(); it++) printf("%d %d %d %d %d\n", it-&gt;age(), it-&gt;level, it-&gt;hp, it-&gt;position.x, it-&gt;position.y); fclose(stdin); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>COGS</tag>
        <tag>模拟</tag>
        <tag>ZJOI</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3156」防御准备 - 斜率优化 DP]]></title>
    <url>%2Fbzoj-3156%2F</url>
    <content type="text"><![CDATA[我们定义战线为一条长度为 的序列，在这条战线上共设有 个检查点，从左到右依次标号为 到 。一个战线为合法战线当且仅当任意一个检查点可以通过安全检查。对于第 个点，通过安全检查的方法有两种，第一种是放置一个守卫塔，这将花费 的费用，第二种方式是放置一个木偶，放置木偶的花费等于这个检查点右侧的第一个守卫塔到它的距离。第 个点只能放置守卫塔。求最小的战线花费值。 链接 BZOJ 3156 题解 将整个序列反转，放置木偶的花费等于这个检查点左侧的第一个守卫塔到它的距离，一号检查点必须放置守卫塔。 设 表示前 个检查点通过检查的最小代价，枚举 ，在 位置放置一个守卫塔，之后一直到 的位置全部放置木偶。 斜率优化，考虑两个决策 、（），若 比 优，则有 维护决策点，使斜率递增，最优决策取队首。时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 1000000; int n; long long c[MAXN + 1], f[MAXN + 1]; inline void prepare() { std::reverse(c + 1, c + n + 1); } /* inline void force() { std::fill(f, f + n + 1, LLONG_MAX); f[0] = 0; for (int i = 1; i &lt;= n; i++) { int _j = -1; for (int j = 0; j &lt; i; j++) { if (f[i] &gt; f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2) { f[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2; _j = j; } } printf("%d --&gt; %d\n", i, _j); } } */ template &lt;typename T&gt; inline T sqr(const T &amp;x) { return x * x; } inline double x(const int i) { return f[i] + c[i + 1] + sqr(static_cast&lt;long long&gt;(i)) * 0.5 + i * 0.5; } inline double slope(const int a, const int b) { return double(x(a) - x(b)) / double(a - b); } inline void dp() { std::fill(f, f + n + 1, LLONG_MAX); f[0] = 0; static int q[MAXN]; int *l = q, *r = q; *r = 0; for (int i = 1; i &lt;= n; i++) { while (l &lt; r &amp;&amp; slope(*(l + 1), *l) &lt; i) l++; int &amp;j = *l; f[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2; // printf("%d --&gt; %d\n", i, j); if (i &lt; n) { while (l &lt; r &amp;&amp; slope(*r, *(r - 1)) &gt; slope(i, *r)) r--; *++r = i; } } } int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;c[i]); prepare(); // force(); dp(); printf("%lld\n", f[n]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>单调队列</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CEOI2004」锯木厂选址 - 斜率优化 DP]]></title>
    <url>%2Fceoi2004-two%2F</url>
    <content type="text"><![CDATA[从山顶上到山底下沿着一条直线种植了 棵老树。当地的政府决定把他们砍下来。为了不浪费任何一棵木材，树被砍倒后要运送到锯木厂。木材只能按照一个方向运输：朝山下运。山脚下有一个锯木厂。另外两个锯木厂将新修建在山路上。你必须决定在哪里修建两个锯木厂，使得传输的费用总和最小。假定运输每公斤木材每米需要一分钱。 链接 COGS 362 题解 将整个序列反转，目标变为将所有树运到 号点。 设 表示前 棵树，修建 个锯木厂的最小花费。使用滚动数组去掉第二维，设 为原有的 ， 为原有的 。 表示前 棵树全部运到 号点的花费， 表示前 棵树的总质量。 斜率优化，考虑两个决策点 、，若 比 优，则有 维护决策点，使斜率递增，最优决策取队首。时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 20000; const int MAXM = 3; int n; long long w[MAXN + 1], d[MAXN + 1], s[MAXN + 1], S[MAXN + 1]; long long g[MAXN + 1], f[MAXN + 1]; inline void prepare() { std::reverse(w + 1, w + n + 1); std::reverse(d + 1, d + n + 1); for (int i = 1; i &lt;= n; i++) { d[i] += d[i - 1]; s[i] = s[i - 1] + w[i]; S[i] = S[i - 1] + w[i] * d[i]; } } /* inline void force() { std::copy(S, S + n + 1, f); for (int k = 1; k &lt; MAXM; k++) { std::copy(f, f + n + 1, g); std::fill(f, f + n + 1, LLONG_MAX); f[0] = 0; for (int i = 1; i &lt;= n; i++) { int _j = -1; for (int j = 0; j &lt; i; j++) { if (f[i] &gt; g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) { f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]; _j = j; } } printf("%d --&gt; %d\n", i, _j); } } } */ inline long long x(const int i) { return g[i] - S[i] + s[i] * d[i + 1]; } inline double slope(const int a, const int b) { return double(x(a) - x(b)) / double(d[a + 1] - d[b + 1]); } inline void dp() { std::copy(S, S + n + 1, f); for (int k = 1; k &lt; MAXM; k++) { std::copy(f, f + n + 1, g); std::fill(f, f + n + 1, LLONG_MAX); f[0] = 0; static int q[MAXN]; int *l = q, *r = q; *r = 0; for (int i = 1; i &lt;= n; i++) { while (l &lt; r &amp;&amp; slope(*(l + 1), *l) &lt; s[i]) l++; int &amp;j = *l; f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]; // printf("%d --&gt; %d\n", i, j); if (i &lt; n) { while (l &lt; r &amp;&amp; slope(*r, *(r - 1)) &gt; slope(i, *r)) r--; *++r = i; } } } } int main() { freopen("two.in", "r", stdin); freopen("two.out", "w", stdout); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf("%lld %lld", &amp;w[i], &amp;d[i]); } prepare(); // force(); dp(); printf("%lld\n", f[n]); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>单调队列</tag>
        <tag>斜率优化</tag>
        <tag>COGS</tag>
        <tag>CEOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1597」土地购买 - 斜率优化 DP]]></title>
    <url>%2Fbzoj-1597%2F</url>
    <content type="text"><![CDATA[农夫 John 准备扩大他的农场，他正在考虑 （）块长方形的土地。每块土地的长宽满足（ 长、宽 ）。每块土地的价格是它的面积，但 FJ 可以同时购买多快土地。这些土地的价格是它们最大的长乘以它们最大的宽，但是土地的长宽不能交换。如果 FJ 买一块 的地和一块 的地，则他需要付 。FJ 希望买下所有的土地，但是他发现分组来买这些土地可以节省经费，他需要你帮助他找到最小的经费。 链接 BZOJ 1597 题解 考虑两块土地，若其中一块可将另一块完全包含，则可以将较小的一块忽略，因为它总是可以被和另一块同时购买，而不增加花费。 排序将上述情况筛除后，整个序列以一个关键字升序，另一个关键字降序。假设宽度 降序，高度 升序。设 表示购买前 块土地的最小花费，考虑哪些不和 在一起购买。 斜率优化，考虑两个决策 、，若 比 优，则有 维护决策点，使斜率递增，最优决策取队首。时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;utility&gt; #include &lt;functional&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; const int MAXN = 50000; std::pair&lt;int, int&gt; A[MAXN]; std::vector&lt; std::pair&lt;int, int&gt;* &gt; vec; int n; long long f[MAXN + 1]; inline void prepare() { std::sort(A, A + n, std::greater&lt; std::pair&lt;int, int&gt; &gt;()); std::pair&lt;int, int&gt; *last = NULL; for (int i = 0; i &lt; n; i++) { if (!last || A[i].second &gt; last-&gt;second) { vec.push_back(&amp;A[i]); last = &amp;A[i]; } } n = vec.size(); } inline long long w(const int i) { return static_cast&lt;long long&gt;(vec[i - 1]-&gt;first); } inline long long h(const int i) { return static_cast&lt;long long&gt;(vec[i - 1]-&gt;second); } inline void force() { f[0] = 0; std::fill(f + 1, f + n + 1, LLONG_MAX); for (int i = 1; i &lt;= n; i++) { int _j = -1; for (int j = 0; j &lt; i; j++) { if (f[i] &gt; f[j] + w(j + 1) * h(i)) { f[i] = f[j] + w(j + 1) * h(i); _j = j; } } // printf("%d --&gt; %d\n", i, _j); } } inline double slope(const int a, const int b) { return double(f[a] - f[b]) / double(w(b + 1) - w(a + 1)); } inline void dp() { f[0] = 0; std::fill(f + 1, f + n + 1, LLONG_MAX); static int q[MAXN + 1]; int *l = &amp;q[0], *r = &amp;q[0]; *r = 0; for (int i = 1; i &lt;= n; i++) { while (l &lt; r &amp;&amp; slope(*(l + 1), *l) &lt; h(i)) l++; int tmp = *l; f[i] = f[tmp] + w(tmp + 1) * h(i); // printf("%d --&gt; %d\n", i, tmp); if (i != n) { while (l &lt; r &amp;&amp; slope(*r, *(r - 1)) &gt; slope(*r, i)) r--; *++r = i; } } } int main() { scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%d %d", &amp;A[i].first, &amp;A[i].second); prepare(); // for (int i = 0; i &lt; n; i++) printf("%d %d\n", vec[i]-&gt;first, vec[i]-&gt;second); // force(); dp(); printf("%lld\n", f[n]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>单调队列</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2007」仓库建设 - 斜率优化 DP]]></title>
    <url>%2Fzjoi2007-storage%2F</url>
    <content type="text"><![CDATA[第 个工厂目前已有成品 件，在第 个位置建立仓库的费用是 。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于公司产品的对外销售处设置在山脚的工厂 ，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送 个单位距离的费用是 。假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据： 工厂 距离工厂 的距离 （其中 ）； 工厂 目前已有成品数量 ； 在工厂 建立仓库的费用 。 请你帮助公司寻找一个仓库建设的方案，使得总的费用（建造费用 + 运输费用）最小。 链接 BZOJ 1096 COGS 367 题解 将整个序列翻转，变为从编号大的运往编号小的，设 表示前 个工厂全部运到 号工厂的费用， 表示前 个工厂的成品总数量。 设 表示前 i 个工厂处理完成的最小花费，则 斜率优化，考虑两个决策 、（），若 比 优，则有 维护决策点，使斜率递增，最优决策取队首。时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 1000000; int n; long long d[MAXN + 1], p[MAXN + 1], c[MAXN + 1]; long long s[MAXN + 1], S[MAXN + 1]; long long f[MAXN + 1]; inline void prepare() { std::reverse(p + 1, p + n + 1); std::reverse(c + 1, c + n + 1); for (int i = n; i &gt;= 1; i--) d[i] -= d[i - 1]; std::reverse(d + 2, d + n + 1); for (int i = 1; i &lt;= n; i++) d[i] += d[i - 1]; for (int i = 1; i &lt;= n; i++) { s[i] = s[i - 1] + p[i]; S[i] = S[i - 1] + p[i] * d[i]; } } /* inline void force() { std::fill(f, f + n + 1, LLONG_MAX); f[0] = 0; for (int i = 1; i &lt;= n; i++) { int _j = -1; for (int j = 0; j &lt; i; j++) { if (f[i] &gt; f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) { f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]; _j = j; } } // printf("%d --&gt; %d\n", i, _j); } } */ inline long long x(const int i) { return f[i] + c[i + 1] - S[i] + s[i] * d[i + 1]; } inline double slope(const int a, const int b) { // printf("slope(%d, %d) = %.4lf\n", a, b, double(x(a) - x(b)) / double(d[a + 1] - d[b + 1])); return double(x(a) - x(b)) / double(d[a + 1] - d[b + 1]); } inline void dp() { std::fill(f, f + n + 1, LLONG_MAX); f[0] = 0; static int q[MAXN + 1]; int *l = q, *r = q; *r = 0; for (int i = 1; i &lt;= n; i++) { while (l &lt; r &amp;&amp; slope(*(l + 1), *l) &lt; s[i]) l++; // if (l &lt; r) { // printf("%lld %lld\n", f[*l] + c[*l + 1] + S[i] - S[*l] - (s[i] - s[*l]) * d[*l + 1], f[*(l + 1)] + c[*(l + 1) + 1] + S[i] - S[*(l + 1)] - (s[i] - s[*(l + 1)]) * d[*(l + 1) + 1]); // } int &amp;j = *l; f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]; // printf("%d --&gt; %d\n", i, j); if (i &lt; n) { while (l &lt; r &amp;&amp; slope(*r, *(r - 1)) &gt; slope(i, *r)) r--; *++r = i; } } } int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf("%lld %lld %lld", &amp;d[i], &amp;p[i], &amp;c[i]); } prepare(); // force(); dp(); printf("%lld\n", f[n]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>单调队列</tag>
        <tag>斜率优化</tag>
        <tag>COGS</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「APIO2010」特别行动队 - 斜率优化 DP]]></title>
    <url>%2Fapio2010-commando%2F</url>
    <content type="text"><![CDATA[一支部队由 名预备役士兵组成，士兵从 到 编号，要将他们拆分成若干特别行动队，同一队中队员的编号应该连续。 士兵 的初始战斗力为 一支特别行动队的初始战斗力 为各士兵初始战斗力之和。一支特别行动队的战斗力会被修正为 ，其中 、、 已知，。 求出将所有士兵组成若干特别行动队的最大总战斗力。 链接 BZOJ 1911 题解 设 表示前 名士兵分成若干特别行动队的最大战斗力， 表示前缀和。 枚举 ，将第 到 个分在同一队里，状态转移方程为 时间复杂度为 ，超时，需要优化。 考虑两个决策点 、（），若 比 优，则有 不等式右边单调递减，左边分母上的前缀和单调递增。 用单调队列存储所有决策点，维护一个上凸壳，从左到后两两之间的斜率递减，且均小于当前的 ，每次最优决策从最左边取得。 时间复杂度为 。 代码 #include &lt;cstdio&gt; const int MAXN = 1000000; int n; long long a[MAXN], A, B, C; long long s[MAXN + 1], f[MAXN + 1]; template &lt;typename T&gt; inline T sqr(const T &amp;x) { return x * x; } inline long long y(const int a) { return f[a] + A * sqr(s[a]) - B * s[a]; } inline long long x(const int a) { return s[a]; } inline long long g(const int i) { return 2 * A * s[i]; } inline double slope(const int a, const int b) { return static_cast&lt;double&gt;(y(a) - y(b)) / static_cast&lt;double&gt;(x(a) - x(b)); } int main() { int n; scanf("%d", &amp;n); scanf("%lld %lld %lld", &amp;A, &amp;B, &amp;C); for (int i = 0; i &lt; n; i++) scanf("%lld", &amp;a[i]); for (int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + a[i - 1]; static long long q[MAXN + 1]; long long *l = q, *r = q; *r = 0; for (int i = 1; i &lt;= n; i++) { while (l &lt; r &amp;&amp; slope(*(l + 1), *l) &gt; g(i)) l++; int j = *l; // int _j = -1; // for (int j = 0; j &lt; i; j++) { // if (_j == -1 || f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C &gt; f[_j] + A * sqr(s[i] - s[_j]) + B * (s[i] - s[_j]) + C) _j = j; // } // j = _j; // printf("i = %d, j = %d\n", i, j); f[i] = f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C; // printf("i = %d, _j = %d\n", i, _j); while (l &lt; r &amp;&amp; slope(*r, *(r - 1)) &lt; slope(i, *r)) r--; *++r = i; } printf("%lld\n", f[n]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>APIO</tag>
        <tag>单调队列</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU 632」Rikka with Array - 数位 DP]]></title>
    <url>%2Fhdu-5632%2F</url>
    <content type="text"><![CDATA[设 表示 的二进制表示中 的数量，求满足 的数对 的数量。 链接 HDU 5632 题解 数位 DP，设 表示二进制表示的最后 位，之前各位组成的数的差（）为 ，是否 或 ，、 的之前所有位是否均达到上界的合法数对数量。 转移时枚举 、 的下一位分别是 或者 即可。 注意，不需要考虑 的情况，因为确定了二进制较高位满足一大一小后，较低位不会使其大小关系更改，即这种状态不可能合法。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXT = 10; const int MAXN = 300; const int MAXN_BIT = 997; // 996.5784284662087 const int MOD = 998244353; const int FLAG = 2; int n; bool a[MAXN_BIT]; int mem[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG]; // bool calced[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG]; bool i[MAXN_BIT], j[MAXN_BIT]; /* inline void _set(const int n, const bool i, const bool j) { ::i[::n - n] = i; ::j[::n - n] = j; } inline void _print() { for (int i = 0; i &lt; n; i++) putchar(::i[i] ? '1' : '0'); putchar('\n'); for (int i = 0; i &lt; n; i++) putchar(::j[i] ? '1' : '0'); putchar('\n'); putchar('\n'); } */ inline int dp(const int n, const int gap, const bool iLessThanJ, const bool limited1, const bool limited2) { // gap : (A[i] - A[j]) int &amp;ans = mem[n][gap + MAXN_BIT][iLessThanJ][limited1][limited2]; if (ans != -1) return ans; if (n == 0) { if (iLessThanJ &amp;&amp; gap &gt; 0) ans = 1; // , _print(); else ans = 0; } else { ans = 0; int limit1, limit2; bool &amp;next = a[::n - n]; if (limited1) limit1 = next; else limit1 = 1; if (limited2) limit2 = next; else limit2 = 1; // printf("next = %d\n", next); // 0 0 // _set(n, 0, 0); ans += dp(n - 1, gap, iLessThanJ, limited1 &amp;&amp; next == 0, limited2 &amp;&amp; next == 0 ); ans %= MOD; // 0 1 if (limit2 == 1) { // _set(n, 0, 1); ans += dp(n - 1, gap - 1, true, limited1 &amp;&amp; next == 0, limited2 &amp;&amp; next == 1 ); ans %= MOD; } // 1 0 if (limit1 == 1 &amp;&amp; iLessThanJ) { // _set(n, 1, 0); ans += dp(n - 1, gap + 1, true, limited1 &amp;&amp; next == 1, limited2 &amp;&amp; next == 0 ); ans %= MOD; } // 1 1 if (limit1 == 1 &amp;&amp; limit2 == 1) { // _set(n, 1, 1); ans += dp(n - 1, gap, iLessThanJ, limited1 &amp;&amp; next == 1, limited2 &amp;&amp; next == 1 ); ans %= MOD; } } // if (n == ::n - 1) printf("f[%d][%d][%s][%s][%s] = %d\n", n, gap, iLessThanJ ? "&lt;" : "=", limited1 ? "*" : " ", limited2 ? "*" : " ", ans); return ans; } inline int solve(const char *s) { memset(mem, 0xff, sizeof(mem)); // memset(calced, 0, sizeof(calced)); n = 0; int len = strlen(s); static int num[MAXN]; for (int i = 0; i &lt; len; i++) num[i] = s[i] - '0'; while (1) { int r = 0; bool allZero = true; for (int i = 0; i &lt; len; i++) { if (num[i] != 0) allZero = false; r = r * 10 + num[i]; num[i] = r / 2; r %= 2; } if (allZero) break; a[n++] = r; } std::reverse(a, a + n); if (n == 0) return 0; int ans = 0; // 0 0 // _set(n, 0, 0); ans += dp( n - 1, 0, false, false, false ); ans %= MOD; // 0 1 // _set(n, 0, 1); ans += dp( n - 1, -1, true, false, true ); ans %= MOD; // 1 1 // _set(n, 1, 1); ans += dp( n - 1, 0, false, true, true ); ans %= MOD; return ans; } int main() { int t; scanf("%d", &amp;t); while (t--) { static char s[MAXN + 1]; scanf("%s", s); printf("%d\n", solve(s)); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位 DP</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2009」windy 数 - 数位 DP]]></title>
    <url>%2Fscoi2009-windy%2F</url>
    <content type="text"><![CDATA[windy 定义了一种 windy 数。不含前导零且相邻两个数字之差至少为 的正整数被称为 windy 数。 windy 想知道，在 和 之间，包括 和 ，总共有多少个 windy 数？ 链接 BZOJ 1026 题解 数位 DP，设 表示最后 位数，这 位数的前一位数是 ，之前是否有非零数（如果前面全是零则不考虑差分限制），是否达到上界，的总数量。 PS：不允许有前导零的实现方式是，允许前导零，但不对前导零设置限制。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXX = 2000000000; const int MAXN = 10; const int MINGAP = 2; const int CHARSET_SIZE = 10; const int FLAG = 2; int a[MAXN], n; int mem[MAXN][CHARSET_SIZE][FLAG][FLAG]; bool calced[MAXN][CHARSET_SIZE][FLAG][FLAG]; inline int dp(const int n, const int last, const bool notZero, const bool limited) { int &amp;ans = mem[n][last][notZero][limited]; if (calced[n][last][notZero][limited]) return ans; calced[n][last][notZero][limited] = true; if (n == 0) { ans = 1; } else { int limit; if (limited) limit = a[::n - n]; else limit = CHARSET_SIZE - 1; for (int i = 0; i &lt;= limit; i++) { if (notZero &amp;&amp; abs(i - last) &lt; MINGAP) continue; ans += dp(n - 1, i, notZero || i != 0, limited &amp;&amp; i == limit); } } return ans; } inline int solve(const char *s) { std::fill(a, a + n, 0); int len = strlen(s); for (int i = 0; i &lt; len; i++) a[i] = s[len - i - 1] - '0'; std::reverse(a, a + n); // for (int i = 0; i &lt; n; i++) putchar('0' + a[i]); // putchar('\n'); memset(mem, 0, sizeof(mem)); memset(calced, 0, sizeof(calced)); int ans = 0; for (int i = 0; i &lt;= a[0]; i++) { ans += dp(n - 1, i, i != 0, i == a[0]); } return ans; } int main() { int l, r; scanf("%d %d", &amp;l, &amp;r); char s1[MAXN + 1], s2[MAXN + 1]; sprintf(s1, "%d", l - 1); sprintf(s2, "%d", r); n = strlen(s2); printf("%d\n", solve(s2) - solve(s1)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>数位 DP</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 628D」Magic Numbers - 数位 DP]]></title>
    <url>%2Fcf-628d%2F</url>
    <content type="text"><![CDATA[我们认为一个数是 d-magic 的，当且仅当数字 出现在这个数字的十进制表示的所有偶数位上，而不会出现在其它位上。 例如， 是 7-magic 的，但 不是 7-magic 的。 找出能被 m 整除的 d-magic 的数字在区间 内的数量。 链接 Codeforces 628D 题解 数位 DP，设 表示数字的最后 位，最高位最大为 ，模 的余数为 的数量。 对于 的限制，我们通常定义函数 表示 中的数量，求出 ，但这道题目中 是高精度数，不方便做减法，可以先求出 ，然后特判 是否有效。 代码 // #pragma comment(linker, "/STACK:102400000,102400000") #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 2000; const int MAXM = 2000; const int MAXD = 9; const int MOD = 1e9 + 7; const int LIMIT_UNLIMITED = 10; int a[MAXN]; int mem[MAXN + 1][11][MAXM + 1]; bool calced[MAXN + 1][11][MAXM + 1]; int pow10[MAXN + 1]; int n, d, m; bool isEven[MAXN]; inline void prepare() { pow10[0] = 1; for (int i = 1; i &lt;= MAXN; i++) { pow10[i] = static_cast&lt;long long&gt;(pow10[i - 1]) * 10 % m; } } inline int modm(const int r) { return ((r % m) + m) % m; } inline int mul(const int x, const int n) { return static_cast&lt;long long&gt;(pow10[n]) * x % m; } inline int dec(const int r, const int x) { return modm(r - x); } // int A[MAXN]; inline int dp(const int n, const int limit, const int r) { int &amp;ans = mem[n][limit][r]; if (calced[n][limit][r]) return ans; calced[n][limit][r] = true; if (n == 0) { if (r == 0) ans = 1; else ans = 0; // if (ans == 1) { // for (int i = 0; i &lt; ::n; i++) putchar('0' + A[i]); // putchar('\n'); // } } else { int next; if (n != 1) next = a[::n - n + 1]; else next = LIMIT_UNLIMITED; int _l, _r; if (isEven[n]) _l = d, _r = std::min(limit, d); else _l = 0, _r = std::min(limit, 9); for (int i = _l; i &lt;= _r; i++) { // A[::n - n] = i; if (!isEven[n] &amp;&amp; i == d) continue; // if (isEven[n] &amp;&amp; i != d) continue; int t; if (i &lt; limit || limit == LIMIT_UNLIMITED) { t = LIMIT_UNLIMITED; } else { t = next; } ans = (ans + dp( n - 1, t, dec(r, mul(i, n - 1)) )) % MOD; } } // if (r == 178) printf("f[%d][%d][%s][%d] = %d\n", n, limit, isEven ? "true" : "false", r, ans); return ans; } inline int solve(const char *s) { memset(mem, 0, sizeof(mem)); memset(calced, 0, sizeof(calced)); for (int i = 0; i &lt; n; i++) a[i] = s[i] - '0'; int ans = 0, &amp;limit = a[0]; for (int i = 1; i &lt;= std::min(limit, 9); i++) { if (i == d) continue; int t; if (i &lt; limit || n == 1) { t = LIMIT_UNLIMITED; } else { t = a[1]; } // A[0] = i; ans = (ans + dp(n - 1, t, dec(0, mul(i, n - 1)))) % MOD; } // printf("solve(%s) = %d\n", s, ans); return ans; } inline int judge(const char *s) { int r = 0; bool isEven = false; for (int i = 0; i &lt; n; i++) { if (!isEven &amp;&amp; s[i] - '0' == d) return 0; if (isEven &amp;&amp; s[i] - '0' != d) return 0; r = modm(r - mul(s[i] - '0', n - i - 1)); isEven ^= 1; } return r == 0 ? 1 : 0; } int main() { // int size = 16 &lt;&lt; 20; // char *p = (char *)malloc(size) + size; // __asm__("movq %0, %%rsp\n" :: "r"(p)); // __asm__("movl %0, %%esp\n" :: "r"(p)); static char s1[MAXN + 1], s2[MAXN + 1]; scanf("%d %d\n%s\n%s", &amp;m, &amp;d, s1, s2); prepare(); n = strlen(s1); isEven[n - 1] = true; for (int i = n - 2; i &gt;= 0; i--) isEven[i] = !isEven[i + 1]; int ans = (solve(s2) - solve(s1) + judge(s1)) % MOD; printf("%d\n", (ans + MOD) % MOD); // exit(0); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Codeforces</tag>
        <tag>数位 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU 2089」不要 62 - 数位 DP]]></title>
    <url>%2Fhdu-2089%2F</url>
    <content type="text"><![CDATA[不吉利的数字为所有含有 或 的号码。例如： 都属于不吉利号码。但是， 虽然含有 和 ，但不是 连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 链接 HDU 2089 题解 数位 DP，设 表示号码的最后 位，这 位的上一个字符是 ，之前的字符是否全部紧贴上界，的总数量。 每次枚举这 位的最高位，特判 ，特判连续的 即可。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; const int MAXX = 1000000; const int MAXN = 7; const int CHARSET_SIZE = 10; const int FLAG = 2; int a[MAXN], n; int mem[MAXN + 1][CHARSET_SIZE][FLAG]; bool calced[MAXN + 1][CHARSET_SIZE][FLAG]; inline int dp(const int n, const int last, const bool flag) { int &amp;ans = mem[n][last][flag]; if (calced[n][last][flag]) return ans; calced[n][last][flag] = true; if (n == 0) { ans = 1; } else { int limit; if (flag) limit = a[::n - n]; else limit = CHARSET_SIZE - 1; for (int i = 0; i &lt;= limit; i++) { if (last == 6 &amp;&amp; i == 2 || i == 4) continue; ans += dp(n - 1, i, flag &amp;&amp; i == limit); } } // printf("dp(%d, %d) = %d\n", n, last, ans); return ans; } inline int solve(const int x) { char s[MAXN + 1]; sprintf(s, "%d", x); n = strlen(s); for (int i = 0; i &lt; n; i++) a[i] = s[i] - '0'; memset(mem, 0, sizeof(mem)); memset(calced, 0, sizeof(calced)); int ans = 0; for (int i = 0; i &lt;= a[0]; i++) { if (i == 4) continue; ans += dp(n - 1, i, i == a[0]); // printf("[%d, %d] -&gt; %d\n", n - 1, i, dp(n - 1, i, i == a[0])); } return ans; } int main() { int l, r; while (scanf("%d %d", &amp;l, &amp;r), !(l == 0 &amp;&amp; r == 0)) { printf("%d\n", solve(r) - solve(l - 1)); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位 DP</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU 5462」King's Order - 数位 DP]]></title>
    <url>%2Fhdu-5642%2F</url>
    <content type="text"><![CDATA[由于国王的口吃并没有治愈，所以传令中可能出现：“让第三军-军-军，到前线去”这样的命令。由于大洋国在军队中安插了间谍，战事紧急，很多时候前线的指挥官不能分清哪些命令真正来自国王。但国王的命令有一个特点，他每次连续重复的字符最多 次. 所以说他的命令中没有：“让第三军-军-军-军，到前线去”，但是可以有：“让第三军-军，到前线去”。 此时将军找到了你，你需要告诉他，给定命令的长度长度为 ，有多少种不同的命令可以是国王发出的。（也就是求长度为 的合格字符串的个数）当然，国王可能说出一句话没有犯任何口吃，就像他那次演讲一样。 链接 HDU 5642 题解 数位 DP，设 表示长度为 的字符串，最后四个字符中两两是否相等，最后一个字符是 ，状态转移时，枚举最后一个字符，如果三个标志位均为真，则状态非法，答案为零。 每次不需要重新计算，利用之前计算过的值即可。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; const int MAXT = 10; const int MAXN = 2000; const int MOD = 1000000007; const int CHARSET_SIZE = 26; int mem[MAXN + 1][2][2][2][CHARSET_SIZE + 1]; bool calced[MAXN + 1][2][2][2][CHARSET_SIZE + 1]; inline int dp(const int n, const bool c2EqualToC1, const bool c3EqualToC2, const bool c4EqualToC3, const int c4) { int &amp;ans = mem[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4]; if (calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4]) return ans; calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4] = true; if (c2EqualToC1 &amp;&amp; c3EqualToC2 &amp;&amp; c4EqualToC3) { ans = 0; } else if (n == 0) { ans = 1; } else { ans = 0; for (int i = 0; i &lt; CHARSET_SIZE; i++) { ans += dp(n - 1, c3EqualToC2, c4EqualToC3, i == c4, i); ans %= MOD; } } return ans; } // inline void cleanUp() { // memset(mem, 0, sizeof(mem)); // memset(calced, 0, sizeof(calced)); // } int main() { int t; scanf("%d", &amp;t); while (t--) { int n; scanf("%d", &amp;n); printf("%d\n", dp(n, false, false, false, CHARSET_SIZE)); // cleanUp(); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位 DP</tag>
        <tag>HDU</tag>
        <tag>BestCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主席树学习笔记]]></title>
    <url>%2Fchairman-tree-notes%2F</url>
    <content type="text"><![CDATA[主席树是一种数据结构，其主要应用是区间第 大问题。 权值线段树 传统的线段树用于维护一条线段上的区间，可以方便地查询区间信息。而如果将线段树转化为『权值线段树』，每个叶子节点存储某个元素出现次数，一条线段的总和表示区间内所有数出现次数的总和。 利用权值线段树可以方便地求出整体第 大 —— 从根节点向下走，如果 小于等于左子树大小，说明第 大在左子树的区间中，在左子树中继续查找即可；否则，说明第 大在右子树的区间中，此时将 减去左子树大小，并在右子树中继续查找。 查找过程类似平衡树，时间复杂度为 。 前缀和 上述算法可以用来处理整个序列上的第 大，而我们可以对于一个长度为 的序列 建立 棵上述的权值线段树，第 棵表示『 ~ 的所有数』组成的权值线段树。如果要查询 中的第 大，可以使用第 棵线段树减去第 棵线段树，得到整个区间组成的权值线段树，并进行上述算法得到区间中的第 大。 这个算法存在两个问题： 每个线段树要占用 的空间，算法的空间复杂度为 ，占用空间过多； 建立每棵线段树至少要用 的时间，每次查询又要用 的时间构建区间的权值线段树，总时间复杂度 。 看上去还不如每次直接提取出区间，并使用后线性选择得到答案的 的朴素算法优秀。 主席树 仔细思考，发现上述算法的 棵线段树中，相邻的两棵线段树仅有 个节点不同，因此本质不同的节点只有 个。我们可以充分利用这一特点，每次只重新创建与上次所不同的节点，相同的节点直接使用前一棵的即可。 为了节省空间，可以将第 棵线段树置为空，每次插入一个新叶子节点时接入一条长度为 的链。总空间、时间复杂度仍为 查询时构造整棵线段树，需要构造 个节点，但每次查询只会用到 个节点，直接动态构造这些节点即可。为了方便，可以不显式构造这些节点，而是直接用两棵线段树上的值相减。 模板 POJ 2104 动态分配内存会超时，需要静态分配内存。 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;new&gt; const int MAXN = 100000; const int MAXM = 5000; template &lt;size_t SIZE&gt; struct MemoryPool { char buf[SIZE], *cur; MemoryPool() : cur(buf) {} void *alloc(const int size) { if (cur == buf + SIZE) return malloc(size); else { char *p = cur; cur += size; return p; } } }; MemoryPool&lt;(4 + 4 + 8 + 8 + 4) * MAXN * 10&gt; pool; struct ChairmanTree { struct Node { int l, r; Node *lc, *rc; int cnt; Node(const int l, const int r, Node *lc = NULL, Node *rc = NULL) : l(l), r(r), lc(lc), rc(rc), cnt((lc ? lc-&gt;cnt : 0) + (rc ? rc-&gt;cnt : 0)) {} Node(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {} void pushDown() { if (lc &amp;&amp; rc) return; int mid = l + ((r - l) &gt;&gt; 1); if (!lc) lc = new (pool.alloc(sizeof(Node))) Node(l, mid); if (!rc) rc = new (pool.alloc(sizeof(Node))) Node(mid + 1, r); } Node *insert(const int num) { if (num &lt; l || num &gt; r) return this; else if (num == l &amp;&amp; num == r) return new (pool.alloc(sizeof(Node))) Node(l, r, this-&gt;cnt + 1); else { const int mid = l + ((r - l) &gt;&gt; 1); pushDown(); if (num &lt;= mid) return new (pool.alloc(sizeof(Node))) Node(l, r, lc-&gt;insert(num), rc); else return new (pool.alloc(sizeof(Node))) Node(l, r, lc, rc-&gt;insert(num)); } } int rank() const { return lc ? lc-&gt;cnt : 0; } } *root[MAXN + 1]; int n; void build(const int a[], const int n) { this-&gt;n = n; root[0] = new (pool.alloc(sizeof(Node))) Node(0, n - 1); for (int i = 1; i &lt;= n; i++) { root[i] = root[i - 1]-&gt;insert(a[i - 1]); } } int query(const int l, const int r, int k) { Node *L = root[l - 1], *R = root[r]; int min = 0, max = n - 1; while (min != max) { L-&gt;pushDown(), R-&gt;pushDown(); int mid = min + ((max - min) &gt;&gt; 1), t = R-&gt;rank() - L-&gt;rank(); if (k &lt;= t) L = L-&gt;lc, R = R-&gt;lc, max = mid; else k -= t, L = L-&gt;rc, R = R-&gt;rc, min = mid + 1; } return min; } } t; int n, m, a[MAXN]; int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); static int set[MAXN]; std::copy(a, a + n, set); std::sort(set, set + n); int *end = std::unique(set, set + n); for (int i = 0; i &lt; n; i++) a[i] = std::lower_bound(set, end, a[i]) - set; t.build(a, n); for (int i = 0; i &lt; m; i++) { int l, r, k; scanf("%d %d %d", &amp;l, &amp;r, &amp;k); int ans = t.query(l, r, k); printf("%d\n", set[ans]); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2016」树 - 最近公共祖先 + 主席树]]></title>
    <url>%2Fhnoi2016-tree%2F</url>
    <content type="text"><![CDATA[小 A 想做一棵很大的树，但是他手上的材料有限，只好用点小技巧了。开始，小 A 只有一棵结点数为 的树，结点的编号为 ，其中结点 为根；我们称这颗树为模板树。小 A 决定通过这棵模板树来构建一颗大树。构建过程如下： 将模板树复制为初始的大树； 以下 3，4，5 步循环执行 次； 选择两个数字 ，其中 ， 当前大树的结点数； 将模板树中以结点 为根的子树复制一遍，挂到大树中结点 的下方（也就是说，模板树中的结点 为根的子树复制到大树中后，将成为大树中结点 的子树)； 将新加入大树的结点按照在模板树中编号的顺序重新编号。例如，假设在进行 4 步之前大树有 个结点，模板树中以 为根的子树共有 个结点，那么新加入模板树的 个结点在大树中的编号将是 ；大树中这 个结点编号的大小顺序和模板树中对应的 个结点的大小顺序是一致的。 现在他想问你，树中一些结点对的距离是多少。 链接 BZOJ 4539 COGS 2052 题解 在新树中用一个节点代表模板树中的一棵子树，存储每个节点在模板树中的根，其真实父节点在模板树中的节点，边设置为新节点到其新树中父节点的根节点的距离。对新树和模板树分别进行树链剖分。 需要从编号求出在新树中的节点时，记录新树中每个节点代表的区间，进行二分查找。需要求出模板树中的节点时，先求出在区间内的编号，再做区间第 大查询，使用主席树即可。 求距离时，分三种情况讨论： 两个点在新树中的统一节点内，直接在模板树中找最近公共租先； 两个点在新树中的节点的的最近公共租先为其中一个节点，分别求出多段距离相加减； 其他情况，比情况 2 复杂一些，方法类似。 总时间复杂度为 ，具体实现细节见代码。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;stack&gt; #include &lt;algorithm&gt; const int MAXN = 100000; const int MAXM = 100000; const int MAXQ = 100000; struct Range { long long l, r; Range(const long long l = 0, const long long r = 0) : l(l), r(r) {} }; struct Node; struct TemplateTreeNode; struct TargetTreeNode; struct Node { int id, depth, size, pos, posEnd; long long dist; Node *parent, *child, *top; bool visited; }; template &lt;typename T&gt; struct Edge { T *s, *t; long long w; Edge&lt;T&gt; *next; Edge(T *const s, T *const t, const long long w) : s(s), t(t), w(w), next(s-&gt;e) {} }; struct TemplateTreeNode : public Node { Edge&lt;TemplateTreeNode&gt; *e; } templateTree[MAXN]; struct TargetTreeNode : public Node { Edge&lt;TargetTreeNode&gt; *e; TemplateTreeNode *rootInTemplateTree, *parentInTemplateTree; Range idRange; friend bool operator&lt;(const TargetTreeNode &amp;v, const long long x) { return v.idRange.r &lt; x; } } targetTree[MAXM + 1]; struct ChairmanTree { struct SegmentTree { int l, r, mid; SegmentTree *lc, *rc; int cnt; SegmentTree(const int l, const int r, SegmentTree *const lc = NULL, SegmentTree *const rc = NULL) : l(l), r(r), mid(l + ((r - l) &gt;&gt; 1)), lc(lc), rc(rc), cnt((lc ? lc-&gt;cnt : 0) + (rc ? rc-&gt;cnt : 0)) {} SegmentTree(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {} void pushDown() { if (!lc) lc = new SegmentTree(l, mid); if (!rc) rc = new SegmentTree(mid + 1, r); } SegmentTree *insert(const int num) { if (num &lt; l || num &gt; r) return this; else if (num == l &amp;&amp; num == r) return new SegmentTree(l, r, cnt + 1); else { pushDown(); if (num &lt;= mid) return new SegmentTree(l, r, lc-&gt;insert(num), rc); else return new SegmentTree(l, r, lc, rc-&gt;insert(num)); } } int rank() const { return lc ? lc-&gt;cnt : 0; } } *root[MAXN + 1]; int n; void build(const int *a, const int n) { this-&gt;n = n; root[0] = new SegmentTree(0, n - 1); for (int i = 1; i &lt;= n; i++) root[i] = root[i - 1]-&gt;insert(a[i - 1]); } int query(const int l, const int r, int k) { SegmentTree *L = root[l - 1], *R = root[r]; int min = 0, max = n - 1; while (min != max) { L-&gt;pushDown(), R-&gt;pushDown(); int mid = min + ((max - min) &gt;&gt; 1), t = R-&gt;rank() - L-&gt;rank(); if (k &lt;= t) L = L-&gt;lc, R = R-&gt;lc, max = mid; else k -= t, L = L-&gt;rc, R = R-&gt;rc, min = mid + 1; } return min; } } chairmanTree; int n, m, q, dfsSequence[MAXN]; int cnt; template &lt;typename T&gt; inline void addEdge(T *const N, const int u, const int v, const long long w) { N[u].e = new Edge&lt;T&gt;(&amp;N[u], &amp;N[v], w); N[v].e = new Edge&lt;T&gt;(&amp;N[v], &amp;N[u], w); } template &lt;typename T&gt; inline void cut(T *const N, const int n) { std::stack&lt;T *&gt; s; s.push(&amp;N[0]); N[0].depth = 1; N[0].dist = 0; while (!s.empty()) { T *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; for (Edge&lt;T&gt; *e = v-&gt;e; e; e = e-&gt;next) { if (!e-&gt;t-&gt;depth) { e-&gt;t-&gt;depth = v-&gt;depth + 1; e-&gt;t-&gt;dist = v-&gt;dist + e-&gt;w; e-&gt;t-&gt;parent = v; s.push(e-&gt;t); } } } else { v-&gt;size = 1; for (Edge&lt;T&gt; *e = v-&gt;e; e; e = e-&gt;next) { if (static_cast&lt;T *&gt;(e-&gt;t-&gt;parent) == v) { v-&gt;size += e-&gt;t-&gt;size; if (!v-&gt;child || v-&gt;child-&gt;size &lt; e-&gt;t-&gt;size) v-&gt;child = e-&gt;t; } } s.pop(); } } for (int i = 0; i &lt; n; i++) N[i].visited = false; int time = -1; s.push(&amp;N[0]); N[0].depth = 1; while (!s.empty()) { T *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; if (v-&gt;parent == NULL || v != static_cast&lt;T *&gt;(v-&gt;parent-&gt;child)) v-&gt;top = v; else v-&gt;top = v-&gt;parent-&gt;top; v-&gt;pos = ++time; for (Edge&lt;T&gt; *e = v-&gt;e; e; e = e-&gt;next) { if (static_cast&lt;T *&gt;(e-&gt;t-&gt;parent) == v) { if (e-&gt;t != v-&gt;child) s.push(e-&gt;t); } } if (v-&gt;child) s.push(static_cast&lt;T *&gt;(v-&gt;child)); } else { v-&gt;posEnd = time; s.pop(); } } } template &lt;typename T&gt; inline T *lca(T *const u, T *const v) { Node *a = u, *b = v; while (a-&gt;top != b-&gt;top) { if (a-&gt;top-&gt;depth &lt; b-&gt;top-&gt;depth) std::swap(a, b); a = a-&gt;top-&gt;parent; } if (a-&gt;depth &gt; b-&gt;depth) std::swap(a, b); return static_cast&lt;T *&gt;(a); } template &lt;typename T&gt; inline T *lcaDown(T *const u, T *const v, T *&amp;uDown, T *&amp;vDown) { T *p = lca(u, v); struct { T *operator()(Node *const p, Node *const v) { Node *tmp = v; while (tmp-&gt;top-&gt;parent != p) { if (p-&gt;top == tmp-&gt;top) return static_cast&lt;T *&gt;(p-&gt;child); tmp = tmp-&gt;top-&gt;parent; } return static_cast&lt;T *&gt;(tmp-&gt;top); } } down; uDown = down(p, u), vDown = down(p, v); return p; } template &lt;typename T&gt; inline long long calcDist(T *const u, T *const v) { const T *p = lca(u, v); return (u-&gt;dist - p-&gt;dist) + (v-&gt;dist - p-&gt;dist); } template &lt;typename T&gt; inline long long getDist(T *const u, T *const v) { return llabs(u-&gt;dist - v-&gt;dist); } inline void getNode(const long long id, TargetTreeNode *&amp;targetTreeNode, TemplateTreeNode *&amp;templateTreeNode) { targetTreeNode = NULL; templateTreeNode = NULL; targetTreeNode = std::lower_bound(targetTree, targetTree + cnt, id); /*for (int i = 0; i &lt;= cnt; i++) { if (id &gt;= targetTree[i].idRange.l &amp;&amp; id &lt;= targetTree[i].idRange.r) { targetTreeNode = &amp;targetTree[i]; break; } }*/ // printf("%ld\n", targetTreeNode - targetTree); if (targetTreeNode == NULL) throw; if (targetTreeNode == &amp;targetTree[0]) templateTreeNode = &amp;templateTree[id]; else { const int k = id - targetTreeNode-&gt;idRange.l; TemplateTreeNode *root = targetTreeNode-&gt;rootInTemplateTree; const int x = chairmanTree.query(root-&gt;pos + 1, root-&gt;posEnd + 1, k + 1); templateTreeNode = &amp;templateTree[x]; return; // static int tmp[MAXN]; // std::copy(dfsSequence + root-&gt;pos, dfsSequence + root-&gt;pos + root-&gt;size, tmp); // // std::nth_element(tmp, tmp + root-&gt;size, tmp + k); // std::sort(tmp, tmp + root-&gt;size); // templateTreeNode = &amp;templateTree[tmp[k]]; } } inline long long query(const long long u, const long long v) { TargetTreeNode *aTarget, *bTarget; TemplateTreeNode *aTemplate, *bTemplate; getNode(u, aTarget, aTemplate), getNode(v, bTarget, bTemplate); if (aTarget == bTarget) { return calcDist(aTemplate, bTemplate); } else { TargetTreeNode *aDown, *bDown; TemplateTreeNode *aUp, *bUp; TargetTreeNode *pTarget = lcaDown(aTarget, bTarget, aDown, bDown); if (aTarget-&gt;depth &gt; bTarget-&gt;depth) std::swap(aTarget, bTarget), std::swap(aTemplate, bTemplate), std::swap(aDown, bDown); aUp = static_cast&lt;TemplateTreeNode *&gt;(aDown-&gt;parentInTemplateTree); bUp = static_cast&lt;TemplateTreeNode *&gt;(bDown-&gt;parentInTemplateTree); long long d = 0; if (aTarget == pTarget) { d += getDist(bTarget, pTarget); d -= getDist(bUp, pTarget-&gt;rootInTemplateTree); d += calcDist(bUp, aTemplate); d += getDist(bTemplate, bTarget-&gt;rootInTemplateTree); } else { d += getDist(aTarget, pTarget) + getDist(bTarget, pTarget); d -= getDist(bUp, pTarget-&gt;rootInTemplateTree); d -= getDist(aUp, pTarget-&gt;rootInTemplateTree); d += calcDist(aUp, bUp); d += getDist(bTemplate, bTarget-&gt;rootInTemplateTree); d += getDist(aTemplate, aTarget-&gt;rootInTemplateTree); } return d; } } int main() { // freopen("tree_tenderRun.in", "r", stdin); // freopen("tree_tenderRun.out", "w", stdout); scanf("%d %d %d", &amp;n, &amp;m, &amp;q); for (int i = 0; i &lt; n - 1; i++) { templateTree[i].id = i; int u, v; scanf("%d %d", &amp;u, &amp;v), u--, v--; addEdge(templateTree, u, v, 1); } cut&lt;TemplateTreeNode&gt;(templateTree, n); for (int i = 0; i &lt; n; i++) dfsSequence[templateTree[i].pos] = i; chairmanTree.build(dfsSequence, n); targetTree[0].id = 0; targetTree[0].rootInTemplateTree = &amp;templateTree[0]; targetTree[0].idRange = Range(0, n - 1); long long lastEnd = n - 1; for (int i = 1; i &lt;= m; i++) { cnt = i; targetTree[i].id = i; long long a, b; scanf("%lld %lld", &amp;a, &amp;b), a--, b--; targetTree[i].idRange = Range(lastEnd + 1, lastEnd + templateTree[a].size); lastEnd = targetTree[i].idRange.r; TargetTreeNode *V; TemplateTreeNode *v; getNode(b, V, v); addEdge(targetTree, V-&gt;id, i, getDist(v, V-&gt;rootInTemplateTree) + 1); targetTree[i].rootInTemplateTree = &amp;templateTree[a]; targetTree[i].parentInTemplateTree = v; } cut&lt;TargetTreeNode&gt;(targetTree, m + 1); for (int i = 0; i &lt; q; i++) { long long u, v; scanf("%lld %lld", &amp;u, &amp;v), u--, v--; printf("%lld\n", query(u, v)); } // fclose(stdin); // fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>BZOJ</tag>
        <tag>最近公共祖先</tag>
        <tag>HNOI</tag>
        <tag>COGS</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2016」网络 - 树链剖分 + DFS 序]]></title>
    <url>%2Fhnoi2016-network%2F</url>
    <content type="text"><![CDATA[一个简单的网络系统可以被描述成一棵无根树。两个服务器进行数据的交互时，数据会经过连接这两个服务器的路径上的所有服务器（包括这两个服务器自身）。当路径上的某个服务器出现故障，无法正常运行时，数据便无法交互。此外，每个数据交互请求都有一个重要度。在每一个时刻，只有可能出现下列三种事件中的一种： 在某两个服务器之间出现一条新的数据交互请求； 某个数据交互结束请求； 某个服务器出现故障。 系统会在任何故障发生后立即修复。也就是在出现故障的时刻之后，这个服务器依然是正常的。但在服务器产生故障时依然会对需要经过该服务器的数据交互请求造成影响。你的任务是在每次出现故障时，维护未被影响的请求中重要度的最大值。 链接 BZOJ 4538 COGS 2215 题解 对树进行树链剖分，并得到其 DFS 序。树上的一条路经转化为 DFS 序上的 个区间。 考虑一条未完成的交互请求不会受到某服务器故障的影响，当且仅当这条交互请求不经过这台服务器。所以只需要维护不经过某台服务器的请求即可。一条请求会影响树的 DFS 序上 个区间，其补集即为不经过的服务器，仍然是 个区间。 再就是维护重要度最大的请求，可以在线段树的每个节点上维护一个堆，并将标记永久化（不下传标记，用从根到叶子的一条链上的值更新答案），同时存储每条请求是否已结束，并及时将堆顶已结束的请求删除。 总时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; #include &lt;utility&gt; const int MAXN = 100000; const int MAXM = 200000; struct Node; struct Edge; struct Node { Edge *e; Node *p, *c, *t; int d, i, s; bool v; } N[MAXN]; struct Edge { Node *s, *t; Edge *next; Edge(Node *const s, Node *const t) : s(s), t(t), next(s-&gt;e) {} }; struct SegmentTree { int l, r; SegmentTree *lc, *rc; std::priority_queue&lt; std::pair&lt;int, bool *&gt; &gt; q; SegmentTree(const int l, const int r, SegmentTree *const lc, SegmentTree *const rc) : l(l), r(r), lc(lc), rc(rc) {} ~SegmentTree() { if (lc) delete lc; if (rc) delete rc; } void update(const int l, const int r, const std::pair&lt;int, bool *&gt; &amp;p) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) /* printf("&gt; [%d, %d]\n", this-&gt;l, this-&gt;r), */ q.push(p); else lc-&gt;update(l, r, p), rc-&gt;update(l, r, p); } int query(const int i) { if (i &lt; this-&gt;l || i &gt; this-&gt;r) return -1; else { int ans = -1; if (i &gt;= this-&gt;l &amp;&amp; i &lt;= this-&gt;r) { while (!q.empty() &amp;&amp; *q.top().second) q.pop(); if (!q.empty()) ans = std::max(ans, q.top().first); } if (lc) ans = std::max(ans, lc-&gt;query(i)); if (rc) ans = std::max(ans, rc-&gt;query(i)); return ans; } } } *seg; inline void addEdge(const int u, const int v) { N[u].e = new Edge(&amp;N[u], &amp;N[v]); N[v].e = new Edge(&amp;N[v], &amp;N[u]); } int n, m; bool del[MAXM]; inline SegmentTree *buildSegment(const int l, const int r) { if (l &gt; r) return NULL; else if (l == r) return new SegmentTree(l, r, NULL, NULL); else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) &gt;&gt; 1)), buildSegment(l + ((r - l) &gt;&gt; 1) + 1, r)); } inline void cut() { std::stack&lt;Node *&gt; s; s.push(&amp;N[0]); N[0].d = 1; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;v) { v-&gt;v = true; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;d) { e-&gt;t-&gt;d = v-&gt;d + 1; e-&gt;t-&gt;p = v; s.push(e-&gt;t); } } else { v-&gt;s = 1; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { v-&gt;s += e-&gt;t-&gt;s; if (!v-&gt;c || v-&gt;c-&gt;s &lt; e-&gt;t-&gt;s) v-&gt;c = e-&gt;t; } s.pop(); } } for (int i = 0; i &lt; n; i++) N[i].v = false; s.push(&amp;N[0]); int time = -1; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;v) { v-&gt;v = true; if (!v-&gt;p || v != v-&gt;p-&gt;c) v-&gt;t = v; else v-&gt;t = v-&gt;p-&gt;t; v-&gt;i = ++time; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;p == v &amp;&amp; e-&gt;t != v-&gt;c) s.push(e-&gt;t); if (v-&gt;c) s.push(v-&gt;c); } else s.pop(); } seg = buildSegment(0, n - 1); } inline void update(const int u, const int v, const std::pair&lt;int, bool *&gt; &amp;p) { Node *a = &amp;N[u], *b = &amp;N[v]; std::vector&lt; std::pair&lt;int, int&gt; &gt; vec; while (a-&gt;t != b-&gt;t) { if (a-&gt;t-&gt;d &lt; b-&gt;t-&gt;d) std::swap(a, b); vec.push_back(std::make_pair(a-&gt;t-&gt;i, a-&gt;i)); a = a-&gt;t-&gt;p; } if (a-&gt;i &gt; b-&gt;i) std::swap(a, b); vec.push_back(std::make_pair(a-&gt;i, b-&gt;i)); if (vec.empty()) return; std::sort(vec.begin(), vec.end()); std::pair&lt;int, int&gt; last = std::make_pair(-1, -1); for (std::vector&lt; std::pair&lt;int, int&gt; &gt;::const_iterator it = vec.begin(); it != vec.end(); it++) { seg-&gt;update(last.second + 1, it-&gt;first - 1, p); // printf("[%d, %d]\n", last.second + 1, it-&gt;first - 1); last = *it; } seg-&gt;update(last.second + 1, n - 1, p); // printf("[%d, %d]\n", last.second + 1, n - 1); } inline int query(const int x) { // printf("query(%d)\n", x); return seg-&gt;query(N[x].i); } int main() { freopen("network_tenderRun.in", "r", stdin); freopen("network_tenderRun.out", "w", stdout); scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n - 1; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v), u--, v--; addEdge(u, v); } cut(); // for (int i = 0; i &lt; n; i++) printf("#%d: i = %d\n", i + 1, N[i].i); for (int i = 0; i &lt; m; i++) { int c; scanf("%d", &amp;c); if (c == 0) { int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w), u--, v--; update(u, v, std::make_pair(w, &amp;del[i])); } else if (c == 1) { int t; scanf("%d", &amp;t), t--; del[t] = true; } else if (c == 2) { int x; scanf("%d", &amp;x), x--; printf("%d\n", query(x)); } } fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>BZOJ</tag>
        <tag>HNOI</tag>
        <tag>COGS</tag>
        <tag>DFS 序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2016」最小公倍数 - 分块 + 并查集]]></title>
    <url>%2Fhnoi2016-multiple%2F</url>
    <content type="text"><![CDATA[给定一张 个顶点 条边的无向图（顶点编号为 ），每条边上带有权值。所有权值都可以分解成 的形式。现在有 个询问，每次询问给定四个参数 、、 和 ，请你求出是否存在一条顶点 到 之间的路径，使得路径依次经过的边上的权值的最小公倍数为 。 链接 BZOJ 4537 COGS 2241 CodeVS 4890 题解 因为路径可以不是简单路径，所以只要两个点在同一连通块内，就一定可以找到一条连接它们的路径。多个数写成 和 的幂的积的形式的数 的最小公倍数，为这些数中 的最高次幂乘以 的最高次幂，即 。 问题转化为，判断是否能选取若干条组成同一连通块的边，保证给定的两个点相连通，并且连通块内 和 的最大值分别等于给定的值。 显然，边上的 和 中的任意一个比询问的对应值要大，则这条边不会对询问产生影响。考虑对于某一次询问，从小到大加入 和 均小于等于询问值的边，使用并查集维护连通性和连通块内的最大值，并在加入所有边后判断连通块内最大值是否等于询问值。总时间复杂度为 ，超时。 注意到，如果我们将边按照 排序，并离线处理所有询问，可以每次将 小于等于某个询问的边按照 再次排序，得到所有对答案有贡献的边。 考虑将所有边按照 排序后分为 块，每次处理某一块时，取出之前所有块中的边（这些边中的 均小于等于当前块内的所有询问中的 ），并将其按照 排序。取出询问值 在当前块范围内的所有询问，也将其按照 排序。将取出的所有边增量加入并查集，并同时依次处理所有取出的询问。而块内的边也会对块内询问有影响，每处理一次询问时，枚举块内所有边，用上文中的暴力方式将其加入并查集，并在处理完一次询问后将操作撤销。 撤销并查集的方法是，维护一个栈，栈内存储所有被修改的位置及其原本的值，以栈的大小作为状态。恢复时，从栈顶弹出，每次将原本的值修改回去，直到栈大小等于原本的栈大小。注意这里不能使用路径压缩，而是要使用按秩合并。 分析一下上述算法的时间复杂度：每个询问只会被处理最多一次，处理每次询问时遍历了大小为 的块，其中对并查集进行了最多 次，这部分的时间复杂度为 。处理块之前的边时，每条边最多参与 次排序，每个询问最多参与 次排序，这部分的时间复杂度为 。取 ，则总时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; // #include &lt;cstring&gt; // #include &lt;cassert&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; #include &lt;utility&gt; #include &lt;vector&gt; const int MAXN = 50000; const int MAXM = 100000; const int MAXQ = 50000; struct UnionFindSet { int p[MAXN], rk[MAXN], a[MAXN], b[MAXN]; // int n; std::stack&lt; std::pair&lt;int *, int&gt; &gt; s; inline void init(const int n) { // this-&gt;n = n; for (int i = 0; i &lt; n; i++) p[i] = i, rk[i] = 1, a[i] = -1, b[i] = -1; while (!s.empty()) s.pop(); } inline int find(const int x) { // assert(x &lt; n); return p[x] == x ? x : find(p[x]); } inline int find(const int x, int &amp;a, int &amp;b) { // assert(x &lt; n); if (p[x] == x) { a = this-&gt;a[x], b = this-&gt;b[x]; return x; } return find(p[x], a, b); } inline void merge(const int x, const int y, const int a, const int b) { int _x = find(x), _y = find(y); if (_x != _y) { if (rk[_x] == rk[_y]) { s.push(std::make_pair(&amp;rk[_y], rk[_y])); rk[_y]++; } else if (rk[_x] &gt; rk[_y]) { std::swap(_x, _y); } s.push(std::make_pair(&amp;this-&gt;a[_y], this-&gt;a[_y])); s.push(std::make_pair(&amp;this-&gt;b[_y], this-&gt;b[_y])); s.push(std::make_pair(&amp;p[_x], p[_x])); p[_x] = _y; this-&gt;a[_y] = std::max(this-&gt;a[_y], this-&gt;a[_x]); this-&gt;a[_y] = std::max(this-&gt;a[_y], a); this-&gt;b[_y] = std::max(this-&gt;b[_y], this-&gt;b[_x]); this-&gt;b[_y] = std::max(this-&gt;b[_y], b); } else { s.push(std::make_pair(&amp;this-&gt;a[_y], this-&gt;a[_y])); s.push(std::make_pair(&amp;this-&gt;b[_y], this-&gt;b[_y])); this-&gt;a[_x] = std::max(this-&gt;a[_x], a); this-&gt;b[_x] = std::max(this-&gt;b[_x], b); } } inline size_t status() { return s.size(); } inline void restore(const size_t s) { while (this-&gt;s.size() &gt; s) { const std::pair&lt;int *, int&gt; p = this-&gt;s.top(); *p.first = p.second; this-&gt;s.pop(); } } } ufs; struct Edge { int u, v, a, b; } E[MAXM]; struct Query { int u, v, a, b; // , cnt; bool ans; // , solved; } Q[MAXQ]; int n, m, q; // bool ans[MAXQ]; inline bool compareByA(const Edge &amp;a, const Edge &amp;b) { return a.a &lt; b.a; } inline bool compareByB(const Edge &amp;a, const Edge &amp;b) { return a.b &lt; b.b; } inline bool compareQueryByB(const Query *a, const Query *b) { return a-&gt;b &lt; b-&gt;b; } /* inline void forceSolve() { for (int i = 0; i &lt; q; i++) { ufs.init(n); for (int j = 0; j &lt; m; j++) { if (E[j].a &lt;= Q[i].a &amp;&amp; E[j].b &lt;= Q[i].b) ufs.merge(E[j].u, E[j].v, E[j].a, E[j].b); } int a, b; if (ufs.find(Q[i].u, a, b) == ufs.find(Q[i].v)) { if (a == Q[i].a &amp;&amp; b == Q[i].b) Q[i].ans = true; else Q[i].ans = false; } else Q[i].ans = false; } } */ inline void solve() { std::sort(E, E + m, &amp;compareByA); int blockSize = floor(sqrt(m) + 1); // printf("blockSize = %d\n", blockSize); for (int i = 0; i &lt; m; i += blockSize) { int curr = std::min(m - 1, i); // printf("curr = %d, curr + blockSize = %d\n", curr, curr + blockSize); std::sort(E, E + curr, &amp;compareByB); ufs.init(n); std::vector&lt;Query *&gt; vec; for (int j = 0; j &lt; q; j++) { if (Q[j].a &gt;= E[curr].a &amp;&amp; (curr + blockSize &gt;= m || Q[j].a &lt; E[curr + blockSize].a)) { vec.push_back(&amp;Q[j]); // printf("getting queries -&gt; saved { %d -&gt; %d, [%d, %d] }\n", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b); } else { // printf("getting queries -&gt; ignored { %d -&gt; %d, [%d, %d] }\n", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b); } } std::sort(vec.begin(), vec.end(), &amp;compareQueryByB); int j = 0; for (std::vector&lt;Query *&gt;::const_iterator it = vec.begin(); it != vec.end(); it++) { Query *p = *it; while (j &lt; curr &amp;&amp; E[j].b &lt;= p-&gt;b) { Edge &amp;e = E[j]; ufs.merge(e.u, e.v, e.a, e.b); // printf("E(%d -&gt; %d, [%d, %d])\n", e.u + 1, e.v + 1, e.a, e.b); j++; } // static char restoreBuffers[sizeof(UnionFindSet)]; // memcpy(restoreBuffers, &amp;ufs, sizeof(UnionFindSet)); size_t s = ufs.status(); for (int k = curr; k &lt; std::min(curr + blockSize, m); k++) { // for (int k = 0; k &lt; m; k++) { Edge &amp;e = E[k]; if (e.a &lt;= p-&gt;a &amp;&amp; e.b &lt;= p-&gt;b) { ufs.merge(e.u, e.v, e.a, e.b); } } int a, b; if (ufs.find(p-&gt;u, a, b) == ufs.find(p-&gt;v)) { if (a == p-&gt;a &amp;&amp; b == p-&gt;b) p-&gt;ans = true; else p-&gt;ans = false; } else p-&gt;ans = false; // assert(p-&gt;ans == ans[&amp;*p - Q]); // if (p - Q + 1 &gt;= 200 &amp;&amp; p - Q + 1 &lt;= 220) { // printf("Q(%d -&gt; %d, [%d, %d]) = %s\n", p-&gt;u + 1, p-&gt;v + 1, p-&gt;a, p-&gt;b, p-&gt;ans ? "Yes" : "No"); // } // p-&gt;cnt++; // p-&gt;solved = true; ufs.restore(s); // memcpy(&amp;ufs, restoreBuffers, sizeof(UnionFindSet)); } } } int main() { freopen("multiple.in", "r", stdin); freopen("multiple.out", "w", stdout); scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) { scanf("%d %d %d %d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].a, &amp;E[i].b); E[i].u--, E[i].v--; } scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++) { scanf("%d %d %d %d", &amp;Q[i].u, &amp;Q[i].v, &amp;Q[i].a, &amp;Q[i].b); Q[i].u--, Q[i].v--; } // forceSolve(); solve(); for (int i = 0; i &lt; q; i++) { // assert(Q[i].solved); // printf("%d ", Q[i].cnt); puts(Q[i].ans ? "Yes" : "No"); } fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>BZOJ</tag>
        <tag>HNOI</tag>
        <tag>CodeVS</tag>
        <tag>COGS</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTSC2016 & APIO2016 行纪]]></title>
    <url>%2Fctsc-apio-2016%2F</url>
    <content type="text"><![CDATA[第一次参加 CTSC &amp; APIO，流水账如下。 5.1 早上五点来到了北京，转了两路地铁一路公交又走了段路，终于到了昆泰酒店 …… 因为来的有点早，还不能开房，报名人员也没来，只好先在大厅坐下了，感觉这酒店网速不给力啊 QAQ 八点开了房，住在十楼，双人间。和我住一间屋的还没来，估计是莱芜或者青岛的神犇？qwq 过了会青岛二中的来了，Oxer 和我住一间屋。去旁边屋里膜了一发 yts1999 大爷，RP++ 看了看报名表，看到 Teachk 来了，于是找他面基去了 ovo 还有大连的好几个神犇（虽然我都不认识 和 HA 的小伙伴碰了碰头，CXC 并没有来（唉。。。） 中午一起去次饭了 QwQ 食堂的饭好评 只是学校有点远喔 …… 下午睡了一会，醒来去他们那里，~sui 和 Fancy 在给他们学校高一的同学讲课，讲完~过了一会我们就去试机了 COGS 观光团到齐了嘛 QwQ ~然而好多人、姓名、ID 对不起来~ 顺便参观了一下八十中的教学楼，好高端 ovo 选手用机操作系统是 NOI Linux（Ubuntu 14.04 LTS）好评！ ~（想想 SDOI 连个像样的编程环境都没有真是太反人类了啊喂~ Fancy 问我怎样才能把 vim 配置背下来，于是我把每一行的含义给她讲了一遍 然而 sui 表示缩写多好记呀~ ~我会告诉你们我第一次在 JSOI 考场上写 vim 配置的时候还列出所有命令找了一遍？~ 过一会安师大附中的神犇们来了，在喊试机题目是哪年的 NOI 题目，水水水 …… ~听不下去了就和小伙伴走了~ 逛了逛校园就去次下午饭了~这里的饭真好次呀~ 次完饭回到酒店，上完厕所发现自己 QQ 登不上了（smg …… 喂喂喂我刚才不就是说了一句 %fqk 吗怎么成不良信息了 …… 换了个 QQ 号，顺便找到 DQS 神犇加回了之前的群 …… ~辣鸡腾讯，吃枣药丸！~ 晚上找小伙伴们玩，然后被拉到另一个房间，发现 COGS 观光团的人都在。 sui：这就是 Menci！ 众人：%%%%% …… ~Menci：mdzz … &amp;@!#@%~&amp; ……~ 他们说 wmd 明后天会来监考，然后我随口问了一句 Chenyao 怎么不来 …… 他们给我指了一下屋子里的某个人，说，这就是 Chenyao …… ~mdzz ……~ ~Chenyao 真的好萌好帅呀 Orz！~ 看他们玩了一个叫做『妙不可言』的神奇的卡牌游戏 …… 玩了一局之后他们墙裂要求我加入，于是我也没拒绝 …… 愉♂快地玩完一局之后发现时间不早了，回屋洗澡睡觉 …… qwq 5.2 CTSC2016 Day1 七点钟从酒店出发，和他们一起去了学校 早饭还不错嘛，油条、鸡蛋、煎饼没有果子、豆浆、包子 …… 怎么就我一个在图书馆考啊喂 …… 泥萌都在教学楼 …… 图书馆在哪里啊喂 …… 哦 …… 就在教学楼旁边 …… 图书馆外面遇到了青岛二中的 dms 神犇，膜了一发 …… 诶怎么还不入场 …… 都八点半了啊喂 …… 入场之后看了下电脑上的时间，八点四十多 …… ~mdzz ……~ 喝水看题 …… 第一题，蛤？题意都读不懂语文水平真是太差了 …… 第三题，提交答案？蛤？（此处省略一张 这题能做？.jpg） 第二题，Suffix Array？写个后缀数组打打暴力吧，怎么这么小气才给 5 分暴力分啊 …… 开始敲后缀数组 …… 二十分钟后，后缀数组敲完了 …… 对拍一下吧 …… 诶怎么显示出错的两行都一样？ 自己看看输出文件吧，发现有两个排名被弄反了 …… 跟踪调试了好久，发现某个地方漏了个 else …… ~mdzz ……~ 码好爆搜，试试样例 …… 样例一过了 …… 样例二输出小了很多 …… 调了好久调不出来，最后输出了，诶发现字符串怎么变短了 …… 诶这个 n 怎么变小了 …… ~mdzz~，忘了清数组了 …… 清了数组又试了下样例，怎么还是不对啊喂 …… 开始各种乱调 …… 调了一个小时，答案没变 …… ~今天上午就杠这题了！杠出来就有 5 分了！~ 『选手注意，第二题第二个样例改为 ……』 啊，所以说我的是对的？ ~mdzz 我都调了一个多小时了啊喂~ 看来第二题有 5 分了，冷静下来读了读第一题题意，发现能读懂了，尝试写了下 5 分暴力，很快调出来了 …… 看到了一二两题都有好多部分分，但是不好搞啊 …… 看了下 T3，根本不可做啊，题答怎么玩啊我不会 …… 还剩二十分钟了，想想把 T3 全填上随机数吧 …… 说不定能有几分 …… 出了考场，外面下雨了，打开手机接着接到了 Fancy 的电话 …… Fancy：我们等了你十多分钟，没等到你，就先去食堂了 Menci：&amp;@!#@%~&amp; …… 要不让 sui 来接我吧 …… ~mdzz 为什么只有图书馆延时了啊喂 ……~ 和他们讨论了一下题 『第三题第一个点组合数、第二个点 01 背包、第 X 个点矩阵乘法，还真是十合一 ……』 蛤？ 『第一题题意读不懂啊 …… 第二题中间的部分分可以打表找规律 ……』 蛤？ 『第三题搞了搞前两个点，后面的全输出 0 ……』 蛤？ 蛤？蛤？ mdzz …… 我为什么要输出随机数啊喂，输出 0 才能得分啊喂 …… ~我怎么感觉就我分数最低啊喂 ……~ 下午讲题，全程听不懂 …… 听不懂 …… XD 第一题 yts1999 用一种奇怪的方法用超哥线段树搞了搞部分分 …… 蛤？ 第三题十个点十个算法 …… 弃疗保平安 …… 看了成绩，5 + 5 + 2 = 12 分，第三题随机数炸了 …… 果然就我分最低，Fancy 输出 0 拿了 15 分 …… 感觉要 Fe 滚粗了 …… 晚上，sui 给我讲了 HNOI 的几道题，于是我在调题，~他们都去颓了~。 5.3 上午，集训队论文答辩，听懂的东西不多啊 …… QAQ（窝还是太弱辣 faebdc 讲的网络流还是挺赞的 …… 下午报告会，大家都说不想去了 …… 于是打算在酒店碎觉 …… 然后接到 Fancy 的电话，说不参加报告会取消明天比赛资格 …… 蛤？赶紧起来走吧 …… 在讨论组里问了一下，他们表示都不去 …… 来到之后报告会已经开始了 …… 人好少 QAQ 看来是没这回事 …… mdzz …… 睡觉睡不着了还是打开电脑看题吧 qwq …… sui 打开电脑打一个叫『以撒』（← 是不是这两个字啊喂 0.0）的游戏，好高端 ovo，Fancy 拿出 Kindle 看知乎日报，好高端 ovo …… 放眼望去整个报告厅基本上都在干正事（大雾 …… 晚上正在调题的时候，Fancy 拿起手机问我这人是谁 …… woc … 这不是 fqk 神犇么！！！ fqk：Fancy 是男的女的？ Menci：&amp;@!#@%~&amp; …… fqk：wori …（躲在椅子下面.jpg）你常说的 HA 的小伙伴我以为都是男的 …… 我是 sb …… （fqk 本来就是 s（hen）b（en）啊 2333 5.4 CTSC2016 Day2 还是在图书馆，不过这次准时开考了 喝水看题 …… 第一题，蛤？ 第二题，蛤？ 第三题，提交答案，蛤？ 完了这是要爆零的节奏吗 QAQ 嗯先看看题答吧 …… XD 第一个点数据好小，写个爆搜试试 …… 爆搜调出来了，10 分到手 搜了一下第二个点，爆内存了，爆内存前得到的最优解才 3 分，不行啊，看看数据试试 …… 只有一个人，没有负边，没有限制 …… 这不是网络流么 2333 敲了个网络流，还没敲完 …… mdzz …… 啥网络流啊 …… 嗯 …… 试试 SPFA 最长路 qwq …… 二十分钟后 …… md怎么一分多种还没跑完，该不会进环了吧 …… mdzz …… 这数据有（you）环（du）！ 一想，这不是 APIO2009 的 atm 那题么 …… 无奈开始码 Tarjan …… Tarjan 调了快一个小时，我真弱啊这么基础的算法都要调这么久 …… 缩点跑最长路，发现答案是对的，然后就是怎么输出路径的问题了 …… 脑补了一下，把一个强连通分量走完，然后走到下一个 …… 嗯好像没错，开始写吧 …… 写完开始调，诶这个函数怎么没有被调用 …… ~mdzz ……~ 怎么只有一个强连通分量啊喂 …… 不过这样简单一些，直接走完整个强连通分量就好了 思路是，考虑一棵搜索树上，每条边都能被访问到 只要可以沿着原来的边回溯回去，就可以很容易地走完所有边 于是在每次回溯的时候再跑一遍另一个搜索，搜出一条路径来 写完之后调了半个小时，开 O3 跑了一分多种终于跑出来了 打开输出文件一看，有大约 n 平方条边 …… 输出文件 3M+ checker 跑了一秒多，答案是对的，20 分有了 …… 看了下，发现这个点和其他点不一样，这个程序跑不出其他的点 QAQ 只好爆搜，但每个点都连个可行解都搜不出来 …… 还剩不到二十分钟了，弃疗吧 …… XD 前两题都没写 …… 中午在食堂遇见 Dashgua，他说第三题直接 SPFA，遇到环就跳出来，就有 70 分了 …… ~mdzz ……~ 感觉自己真的连 Cu 都拿不到啊 …… dms 说他 A 了一提，太神啦！ 下午讲题，很多人吐槽题答被乱搞好几十分，个个的程序都比我简单 …… ~mdzz ……~ 晚上闭幕式，中间的游戏环节有个猜谜，明明我猜出来了但主持人没听到 qwq（O(E) 不是 SPFA 还能是啥啊喂 宣读获奖名单，果然 Fe 滚粗了 QAQ 回到酒店，被青岛二中的拐走了，yts1999、Oxer、dms、heheda 等几位神犇都在 …… 于是他们教我一种叫做『够级』的扑克牌游戏 2333 …… 玩了几局之后就跑下去了 qwq 想起来还没找胜利一中的 abclzr 神犇面基呢，于是就先去找到了他聊了一会，lzr 好神啊！ KZ 要我帮他调一下 Ubuntu、Windows 双系统的时间设置 …… 虽然没搞过但听起来好简单的样子 调了好久最后发现改改时区就可以 …… 5.5 休息日。 上午他们睡到很晚才起来 …… 去学校次早饭回来的路上，讨论组里 KZ：把 Menci 叫过来，我们要吃饭 …… Fancy：Menci 能吃吗？ ~Menci：&amp;@!#@%~&amp;~ ~此处应有『一脸茫然.jpg』~ 回来之后调了一会题又该次中午饭了 qvq Fancy 说她小姨要带她去天安门，好高端 …… 其他人商量着去香山，窝表示对此并不感兴趣 …… 于是中午自己回来了，睡醒觉就四点多了，写了一会题，不知不觉一道题写了 N 天了 …… 晚上看见 SDOI 群里有人搞大新闻 ……（此处省略 &amp;@!#@%~&amp;）…… 233333333 5.6 听说 fqk 的学长要来讲课？太神辣！ 到了讲厅，抢了第一排的座位近距离围观，然而并不能听懂什么高端的 XXXX 搜索算法 Orz，下课期间上去问了问，还真是 fqk 的学长（这还有假？ 唉，听不懂弃疗吧 qwq …… 晚上把 HNOI 某树调出来了，又按照神兽的做法写了写 APIO 练习赛的交互，好水的题 qwq APIO 的题不可能这么水吧 5.7 APIO2016 Day1 APIO 的开考时间晚一些，可以提前进场 qwq 于是就可以先写好 vim 配置了 …… 省常中的 Johann 神犇坐我左边，%%% …… 题目有纸张和 PDF 的，在线评测实时反馈，好高端 qwq 喝水看题 …… 第一题，蛤？打个暴力试试 …… 第二题，蛤？第一个子任务我都不会啊 …… 第三题，蛤？交互，限制啥啥啥次数？ 打好了第一题暴力，冷静下来想了想其实第一个子任务就是一个序列，求所有单调上升序列数量。怎么跟食物链这么像呢 …… 建图拓扑排序然后直接 DP 嘛 …… 半个小时才调出来（暴露水平了 XD 第二题第一个子任务 …… 试试平均数？不行啊，打个暴力吧 …… 发现答案是全部变成这些数中的其中一个，那就枚举一遍这些数吧 …… 两个半小时拿了 16 分了 …… 看第三题，上来一个小时啥都不会，后来一想，~mdzz~ …… 直接从两边向中间逼近，然后得到整个序列不就好了 …… 提交，30.38 分 …… 这样就有 46.38 分了 …… 还不够啊，想想第二个子任务 …… 脑补了一下感觉二分复杂度是对的，随便写了一个交上去发现才 42 分，哪里不对？卡卡常试试 …… 卡了卡常交上去发现 WA 了，发现漏情况了，改了之后又交上去 …… 诶，怎么不评测了 …… 用 CMS 自带的提问功能问了一下主办方，被告知服务器不稳定 ……（~辣鸡服务器，毁我比赛~ 于是只好自己对拍，发现是对的，继续卡常数，发现卡不到很低了，感觉这不是正解~（当然不是）~…… 最后又交了一下，还是评不出来，而且没给加时 …… 就这样结束了 下午讲题，T3 正解分块 …… 我傻逼了都想到鸽笼原理的怎么就不分块呢 …… T2 我原本想到的子任务 2 的树形 DP 是对的，没时间写了啊 …… QAQ 发现又是就我分低，这是三题签到分啊，又要 Fe 滚粗了么 XD 晚上他们都去 THU 看智能体大赛了，然而我表示并不想去，就会酒店找湖北的小伙伴玩了 QwQ 和 Fuxey 和 Sengxian 他们聊了一晚上，十一点多才回去 …… qwq Sengxian 表示他才是真·签到分，46.38 分 23333 5.8 听课。 上午讲物理引擎 …… smg …… 拿出笔记本电脑准备写 sui 给我讲的题 …… 诶怎么开不了机 …… mdzz …… 昨晚忘关机了，没电了 XD 于是 Fancy 把笔记本电脑借给了我，写了一上午的题，还是没调出来 …… 下午还是听不懂课，继续调题 …… 然而 Fancy 的电脑也没电了 XD 晚上闭幕式 …… Cu 线好低，46 分就有 …… 回到酒店又被青岛二中的拐走了，zdw1999 竟然也被拐过去了 qvq 打了两局保皇 …… 于是又去找 HA 的小伙伴了 …… 刚进房间大家都很兴奋的样子 …… ~这是要搞个大新闻？~ ~（由于某些原因，此处删除若干字）~ 然后继续调今天上午写的题，过了样例，交到 COGS 上，WWTTTTTTTT，弃疗 …… 最后帮 Fancy 搞了搞 Ubuntu 下的指纹识别，KZ 表示也要我帮他弄弄，然而已经快十二点了 …… XD 5.9 早上八点去次饭，get 成就 最后一个走出食堂 23333 晚上的火车，于是先在酒店待了一上午 …… 考虑到车站环境并不太好，又在酒店大厅里待了一下午 …… qwq 晚上就要坐车回去咯 …… 再见 ……]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[莫队算法学习笔记]]></title>
    <url>%2Fmo-algorithm-notes%2F</url>
    <content type="text"><![CDATA[算法竞赛中有这样一类题目，给定一个序列 ，每次查询 区间的信息。这类题目没有修改操作，只有查询，并且操作没有加密（允许离线），莫队算法就是针对这类题目的一个离线算法。 莫队算法的核心思想是，假如我们已经知道了 的答案，又可以很方便地向 、、、 扩展，就可以实现让答案在每个询问之间转移。假设每次扩展的时间为 ，又因为每次转移最多有 次扩展，所以算法总时间复杂度为 ，通常会超时。 我们可以将区间分为 块，每块的大小为 ，并且将询问以左端点所在的块为第一关键字、以右端点为第二关键字排序，之后再进行上述算法。 排序后，只有第一关键字不同的询问之间才会产生块之间的转移，而又因为共有 块，所以不同块之间的转移最多发生 次，不同块之间转移的总次数为 。每一块的大小为 ，即每一块内最多有 个不同的区间。所以，每经过一个块，都要进行 次转移，乘上总块数 ，即相同块内的转移的总次数为 。 每次扩展的时间复杂度不同时，适当调整块的大小，可以降低使整个算法的时间复杂度。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>学习笔记</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2016」序列 - 莫队 + RMQ]]></title>
    <url>%2Fhnoi2016-sequence%2F</url>
    <content type="text"><![CDATA[给定长度为 的序列：，记为 。类似的，（）是指序列：。若 ，则称 是 的子序列。 现在有 个询问，每个询问给定两个数 和 ，，求 的不同子序列的最小值之和。 链接 BZOJ 4540 题解 Sengxian 的题解 对于无修改的区间询问，我们可以将操作离线，采用莫队算法解决。 为便于叙述，定义 为位置 处的元素（即 ）； 为左端点属于 ，右端点为 的所有子序列。 已知区间 的答案，考虑新加入的元素 对询问的影响。新元素加入后，产生了 个子序列，它们是 。 中存在一个最小值 ，使得 的最小值均为 ，举个例子 位置 1 2 3 4 5 6 7 8 9 10 值 5 7 3 1 5 2 8 3 6 4 标记 区间 的最小值均为 ，即 。 考虑剩下的 个子序列，从 向左走，经过的所有比 大的元素，以这些元素的位置为左端点， 为右端点的所有子序列的最小值均为 。直到到达第一个比 小的元素（例子中的 ），其位置记做 。 位置 1 2 3 4 5 6 7 8 9 10 值 5 7 3 1 5 2 8 3 6 4 标记 右边有 个子序列，他们的最小值均为 ，这些子序列对答案的贡献为 。 仿照刚才的做法，继续向左找第一个小于 的元素，其值为 ，即 。 位置 1 2 3 4 5 6 7 8 9 10 值 5 7 3 1 5 2 8 3 6 4 标记 右边有 个子序列，他们的最小值均为 ，这些子序列对答案的贡献为 。 继续向左找，找到第一个比 小的元素，其值为 ，即 ，注意此时已经找到整个区间内的最小值，左端点在 及其左侧的所有子序列对答案的贡献已经被考虑过，恰好只剩下 个子序列，其最小值均为 ，这些子序列对答案的贡献为 。 若直接使用上述算法计算每个元素的贡献，单次计算的时间复杂度为 ，超时。 定义 为区间 的最小值所在的位置，设 为区间 内除最小值之外的其它值对答案的贡献，则有 注意到整个式子除边界条件中的 之外，和 是无关的。 设 为从 位置一直向左跳，直到跳到所有元素中的最小值，用上述方法计算出的贡献总和，则有 注意到刚才的例子中，，即最后一跳的位置和最小值的右边一个位置向左跳跳到的位置相同。所以 使用单调栈算法（保持栈底到栈顶的元素单调递增）预处理出每个 ，之后可以在 的时间内递推出 。区间向左扩展时同理，向右边跳即可。 而对于 RMQ，使用稀疏表在 的时间内预处理后，即可在 的时间内回答每次查询。最终，每次转移的时间降为 ，总时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; // #include &lt;cassert&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; const int MAXN = 100000; const int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812 const int MAXM = 100000; struct Element { int val; Element *left, *right; long long sumLeft, sumRight; bool operator&lt;(const Element &amp;x) const { return val &lt; x.val; } bool operator&lt;=(const Element &amp;x) const { return val &lt;= x.val; } } a[MAXN]; int n, m, logTable[MAXN + 1]; Element *st[MAXN][MAXLOGN + 1]; long long ans[MAXN]; struct Query { int l, r; long long *ans; bool operator&lt;(const Query &amp;x) const { static int blockSize = floor(sqrt(n)); if (l / blockSize == x.l / blockSize) return r &lt; x.r; else return l / blockSize &lt; x.l / blockSize; } } Q[MAXM]; inline Element *min(Element *const a, Element *const b) { if (!a) return b; if (!b) return a; return *a &lt; *b ? a : b; } inline void sparseTable() { for (int i = 0; i &lt; n - 1; i++) st[i][0] = min(&amp;a[i], &amp;a[i + 1]); st[n - 1][0] = &amp;a[n - 1]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) { for (int i = 0; i &lt; n; i++) { if (i + (1 &lt;&lt; (j - 1)) &lt; n) { st[i][j] = min(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); } } } for (int i = 0; i &lt;= n; i++) { logTable[i] = floor(log2(i)); } } inline Element *rmq(const int l, const int r) { if (l == r) return &amp;a[l]; else { int t = logTable[r - l]; return min(st[l][t], st[r - (1 &lt;&lt; t)][t]); } } inline void prepare() { std::stack&lt;Element *&gt; s; s.push(&amp;a[0]); for (int i = 1; i &lt; n; i++) { while (!s.empty() &amp;&amp; a[i] &lt;= *s.top()) s.pop(); if (!s.empty()) a[i].left = s.top(); else a[i].left = NULL; s.push(&amp;a[i]); } for (int i = 0; i &lt; n; i++) { Element *x = &amp;a[i]; if (x-&gt;left == NULL) { x-&gt;sumLeft = 0; } else { x-&gt;sumLeft = x-&gt;left-&gt;sumLeft + (x - x-&gt;left) * static_cast&lt;long long&gt;(x-&gt;val); } } s.push(&amp;a[n - 1]); for (int i = n - 2; i &gt;= 0; i--) { while (!s.empty() &amp;&amp; a[i] &lt;= *s.top()) s.pop(); if (!s.empty()) a[i].right = s.top(); else a[i].right = NULL; s.push(&amp;a[i]); } for (int i = n - 1; i &gt;= 0; i--) { Element *x = &amp;a[i]; if (x-&gt;right == NULL) { x-&gt;sumRight = 0; } else { x-&gt;sumRight = x-&gt;right-&gt;sumRight + (x-&gt;right - x) * static_cast&lt;long long&gt;(x-&gt;val); } } sparseTable(); std::sort(Q, Q + m); for (int i = 0; i &lt; n; i++) { // printf("%lld %lld\n", a[i].sumLeft, a[i].sumRight); // printf("%d: sumLeft = %lld, sumRight = %lld, ", a[i].val, a[i].sumLeft, a[i].sumRight); // if (a[i].left == NULL) printf("left = NULL, "); // else printf("left = %ld[%d], ", a[i].left - a, a[i].left-&gt;val); // if (a[i].right == NULL) printf("right = NULL\n"); // else printf("right = %ld[%d]\n", a[i].right - a, a[i].right-&gt;val); } } inline long long expandRight(const int l, const int r) { // printf("[%d, %d]\n", l, r); Element *pos = rmq(l, r); return (pos - &amp;a[l] + 1) * static_cast&lt;long long&gt;(pos-&gt;val) + a[r].sumLeft - pos-&gt;sumLeft; } inline long long expandLeft(const int l, const int r) { // printf("[%d, %d]\n", l, r); Element *pos = rmq(l, r); return (&amp;a[r] - pos + 1) * static_cast&lt;long long&gt;(pos-&gt;val) + a[l].sumRight - pos-&gt;sumRight; } inline void mo() { int l = 0, r = 0; long long ans = a[0].val; for (int i = 0; i &lt; m; i++) { const Query &amp;q = Q[i]; // assert(l &lt;= r); while (r &lt; q.r) r++, ans += expandRight(l, r); while (l &gt; q.l) l--, ans += expandLeft(l, r); while (r &gt; q.r) ans -= expandRight(l, r), r--; while (l &lt; q.l) ans -= expandLeft(l, r), l++; *q.ans = ans; } } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i].val); for (int i = 0; i &lt; m; i++) { scanf("%d %d", &amp;Q[i].l, &amp;Q[i].r); Q[i].l--, Q[i].r--; Q[i].ans = &amp;ans[i]; } prepare(); mo(); for (int i = 0; i &lt; m; i++) printf("%lld\n", ans[i]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>莫队</tag>
        <tag>HNOI</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2016」食物链 - 拓扑排序 + DP]]></title>
    <url>%2Fhaoi2016-chain%2F</url>
    <content type="text"><![CDATA[给 个物种和 条能量流动关系，求其中的食物链条数。 链接 BZOJ 4562 COGS 2266 题解 题意中没有说清楚食物链的概念，根据样例可知，由生产者走向最高级消费者的简单路径，多条食物链可以有重叠。 我们令边的方向为生产者到最高级消费者，对整张图进行拓扑排序，同时 DP 出从入度为零的点（生产者）到该点的路径条数（一定是简单路径）。 所有出度为零（保证是最高级消费者）且原入度不为零（保证不是生产者，单独一个生产者没有消费者不算食物链）的点上的路径条数和即为食物链数量。 代码 #include &lt;cstdio&gt; #include &lt;queue&gt; const int MAXN = 100000; const int MAXM = 200000; struct Node; struct Edge; struct Node { Edge *e; int originInDegree, inDegree, outDegree; int cnt; } N[MAXN]; struct Edge { Node *s, *t; Edge *next; Edge(Node *const s, Node *const t) : s(s), t(t), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t) { N[s].e = new Edge(&amp;N[s], &amp;N[t]); N[s].outDegree++, N[t].inDegree++, N[t].originInDegree++; } int n, m; inline void toposort() { std::queue&lt;Node *&gt; q; for (int i = 0; i &lt; n; i++) { if (N[i].inDegree == 0) N[i].cnt = 1, q.push(&amp;N[i]); } while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) { e-&gt;t-&gt;cnt += v-&gt;cnt; if (!--e-&gt;t-&gt;inDegree) { q.push(e-&gt;t); } } } } int main() { freopen("chain_2016.in", "r", stdin); freopen("chain_2016.out", "w", stdout); scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v), u--, v--; addEdge(u, v); } toposort(); int ans = 0; for (int i = 0; i &lt; n; i++) { if (N[i].outDegree == 0 &amp;&amp; N[i].originInDegree != 0) ans += N[i].cnt; } printf("%d\n", ans); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>COGS</tag>
        <tag>HAOI</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2009」游戏 - 博弈 + 二分图匹配]]></title>
    <url>%2Fjsoi2009-game%2F</url>
    <content type="text"><![CDATA[在 的迷宫中有一个棋子，AA 首先任意选择棋子放置的位置。然后，YY 和 AA 轮流将棋子移动到相邻的格子里。 游戏的规则规定，在一次游戏中，同一个格子不能进入两次，且不能将棋子移动到某些格子中去。当玩家无法继续移动棋子时，游戏结束，最后一个移动棋子的玩家赢得了游戏。 求 AA 初始将棋子放在哪些格子会有必胜策略。 链接 BZOJ 1443 题解 题目要求 AA 初始放置棋子的位置，使得 AA 有必胜策略，即为求必败态（因为 AA 是后手）。 对网格图进行奇偶染色，建立二分图，求出有效格子的最大匹配。 考虑将初始点放置在非匹配点上，如果此时没有任何边与其相连，则 YY 负，否则 YY 一定会沿着一条非匹配边走向另一个匹配点（如果这个点是非匹配点，则匹配这条边后，总匹配数可以增加，显然与最大匹配相矛盾），此时 AA 一定可以沿着一条匹配边走回来，状态恢复到初始状态，最终 YY 找不到一条非匹配边，负。 我们得到结论：不在最大匹配上的点，一定是先手必败点。 而如果一个点在最大匹配上，我们考虑这样一条路径，从该点开始沿着匹配边 - 非匹配边 - 匹配边 - 非匹配边 …… 走下去，如果这条路径的长度（边的数量）为偶数，则终点和起点在（二分图划分中的）同一集合中。此时将整个路径中每条边时候匹配取反，则整张图仍然是一个最大匹配。 另一个结论：如果一个点不一定在最大匹配上，则它一定是先手必败点。 使用 Dinic 算法求出二分图最大匹配后，在残量网络上进行 BFS，从源点开始，始终沿着不满流的边走，所有经过的且在左侧的点均不一定在最大匹配上，右边同理。 考虑上述算法的正确性，从源点走向的第一个点一定是非匹配点，继续走一步，一定是沿着非匹配边会走到右侧点，再走一步，一定是沿着匹配边的反向边走回左侧。显然，每次走到左侧的点时，路径长度均为偶数，且沿着二分图中的匹配边 - 非匹配边 - 匹配边 - 非匹配边 …… 得证。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; const int MAXN = 100; const int DX[4] = { 1, 0, -1, 0 }; const int DY[4] = { 0, 1, 0, -1 }; struct Node; struct Edge; struct Node { Edge *e, *c; int l; bool fs, ft; } N[MAXN * MAXN + 2]; struct Edge { Node *s, *t; int f, c; Edge *next, *r; Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t, const int c) { N[s].e = new Edge(&amp;N[s], &amp;N[t], c); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0); (N[s].e-&gt;r = N[t].e)-&gt;r = N[s].e; } struct Dinic { bool makeLevelGraph(Node *const s, Node *const t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;l == 0 &amp;&amp; e-&gt;f &lt; e-&gt;c) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } return false; } int findPath(Node *const s, Node *const t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) if (e-&gt;t-&gt;l == s-&gt;l + 1 &amp;&amp; e-&gt;f &lt; e-&gt;c) { int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c - e-&gt;f)); if (f &gt; 0) { e-&gt;f += f, e-&gt;r-&gt;f -= f; return f; } } return 0; } int operator()(const int s, const int t, const int n) { int ans = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) ans += f; } return ans; } } dinic; int n, m; char invalid[MAXN][MAXN]; struct Point { int i, j; Point(const int i, const int j) : i(i), j(j) {} operator int() const { return i * m + j + 1; } bool valid() const { return i &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; m &amp;&amp; !invalid[i][j]; } Point offset(const int dx, const int dy) const { return Point(i + dx, j + dy); } }; inline void bfs(const int s, const int t) { std::queue&lt;Node *&gt; q; q.push(&amp;N[s]); N[s].fs = true; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;f &lt; e-&gt;c &amp;&amp; !e-&gt;t-&gt;fs) { e-&gt;t-&gt;fs = true; q.push(e-&gt;t); } } q.push(&amp;N[t]); N[t].ft = true; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;r-&gt;f &lt; e-&gt;r-&gt;c &amp;&amp; !e-&gt;t-&gt;ft) { // printf("%ld to %ld\n", v - N + 1, e-&gt;t - N + 1); e-&gt;t-&gt;ft = true; q.push(e-&gt;t); } } } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) { char s[MAXN + 1]; scanf("%s", s); for (int j = 0; j &lt; m; j++) { invalid[i][j] = (s[j] == '#'); } } const int s = 0, t = n * m + 1; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { Point p(i, j); if (!p.valid()) continue; if ((i + j) % 2 == 0) { for (int k = 0; k &lt; 4; k++) { Point p2 = p.offset(DX[k], DY[k]); if (p2.valid()) { addEdge(p, p2, 1); } } if (!invalid[i][j]) addEdge(s, p, 1); } else if (!invalid[i][j]) addEdge(p, t, 1); } } int maxFlow = dinic(s, t, n * m + 2); if (maxFlow == 0) puts("LOSE"); else { puts("WIN"); bfs(s, t); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) { if ((i + j) % 2 == 0) { if (N[Point(i, j)].fs) printf("%d %d\n", i + 1, j + 1); } else { if (N[Point(i, j)].ft) printf("%d %d\n", i + 1, j + 1); } } } // printf("%d\n", maxFlow); /* for (int i = 0; i &lt; n * m + 2; i++) { for (Edge *e = N[i].e; e; e = e-&gt;next) { if (e-&gt;c &gt; 0) printf("E(%ld, %ld, %d, [%d])\n", e-&gt;s - N, e-&gt;t - N, e-&gt;c, e-&gt;f); } } */ return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>二分图匹配</tag>
        <tag>JSOI</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2008」玩具装箱 - 斜率优化 DP]]></title>
    <url>%2Fhnoi2008-toy%2F</url>
    <content type="text"><![CDATA[P 教授有编号为 ~ 的 件玩具，第 件玩具经过压缩后变成一维长度为 。为了方便整理，P 教授要求在一个一维容器中的玩具编号是连续的。如果将第 件玩具到第 个玩具放到一个容器中，那么容器的长度将为 。如果容器长度为 。其制作费用为 。其中 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容 器，甚至超过 。但他希望费用最小。 链接 BZOJ 1010 CodeVS 1319 COGS 1330 题解 动态规划，设 表示前 i 件玩具放进若干个容器中的最小费用，前缀和 。 转移时枚举前面多少个装在同一个箱子里，设它为 ，则第 ~ 个装在同一个箱子里，长度为 ，即 直接计算的复杂度为 ，超时，考虑优化。 设 ，，上面的方程可以转化为 考虑两个决策 和 （），若 a 比 b 优，当且仅当 左边成为了斜率的形式，三个式子都是单调的，因此可以用一个单调队列维护每个决策，保证最优决策在队首，两两决策点形成的斜率递增，每次状态转移复杂度降为 ，总时间复杂度为 。 代码 #include &lt;cstdio&gt; const int MAXN = 50000; int n, L, a[MAXN]; long long s[MAXN + 1], f[MAXN + 1]; template &lt;typename T&gt; inline T sqr(const T &amp;x) { return x * x; } inline long long g(const int i) { return s[i] + i - L - 1; } inline long long h(const int j) { return s[j] + j; } inline double slope(const int a, const int b) { return double((f[a] + sqr(h(a))) - (f[b] + sqr(h(b)))) / double(h(a) - h(b)); } int main() { scanf("%d %d", &amp;n, &amp;L); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + a[i - 1]; static long long q[MAXN]; long long *l = q, *r = q - 1; *++r = 0; for (int i = 1; i &lt;= n; i++) { while (l &lt; r &amp;&amp; slope(*(l + 1), *l) &lt;= 2 * g(i)) l++; f[i] = f[*l] + sqr(g(i) - h(*l)); while (l &lt; r &amp;&amp; slope(*r, *(r - 1)) &gt; slope(i, *r)) r--; *++r = i; } printf("%lld\n", f[n]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>单调队列</tag>
        <tag>斜率优化</tag>
        <tag>HNOI</tag>
        <tag>CodeVS</tag>
        <tag>COGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2016」飞机调度 - 最短路 + 网络流]]></title>
    <url>%2Fjsoi2016-flight%2F</url>
    <content type="text"><![CDATA[JSOI 王国里有 个机场，编号为 到 。从 号机场到 号机场需要飞行 的时间。由于风向，地理位置和航空管制的因素， 和 并不一定相同。 此外，由于飞机降落之后需要例行维修和加油。当一架飞机降落 号机场时，需要花费 的维护时间才能再次起飞。 JS Airways 一共运营 条航线，其中第 条直飞航线需要在 时刻从 机场起飞，不经停，飞往 机场。 为了简化问题，我们假设 JS Airway 可以在 时刻在任意机场布置任意多架加油维护完毕的飞机；为了减少飞机的使用数，我们允许 JS Airways 增开任意多条临时航线以满足飞机的调度需求。 JYY 想知道，理论上 JS Airways 最少需要多少架飞机才能完成所有这 个航班。 题解 根据题意，从 机场经过 机场飞往 机场（不计在 、 的维护时间）所需时间为 ，所以我们可以先使用 Floyd 求出任意两个机场之间经过若干次中转可以到达的最短时间。 考虑两条航线 和 ，若一架飞机飞完 后可以接着飞 ，则需要满足的条件为（二者之一）： 的终点为 的起点，且 的着陆时间加上维护时间早于 的起飞时间； 的着陆时间加上从 的终点经过若干次中转到 的起点所用时间加上若干次维护时间早于 的起飞时间。 根据上述两个条件，可以建立一张有向无环图， 有边当且仅当一架飞机飞完 航线后可以接着飞 航线。即一架飞机连续飞的航线组成了图中的一条路径，题目中要求飞机数最少，即可转化为使用最少的路径覆盖整个图，转化为二分图匹配模型，使用网络流解决即可。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 500; const int MAXM = 500; struct Node; struct Edge; struct Node { Edge *e, *c; int l; bool flag; } N[MAXM * 2 + 2]; struct Edge { Node *s, *t; int f, c; Edge *next, *r; Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s-&gt;e) {} }; inline void addEdge(const int s, const int t, const int c) { // printf("(%d, %d, %d)\n", s, t, c); N[s].e = new Edge(&amp;N[s], &amp;N[t], c); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0); N[s].e-&gt;r = N[t].e, N[t].e-&gt;r = N[s].e; } struct Dinic { bool makeLevelGraph(Node *const s, Node *const t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;l == 0 &amp;&amp; e-&gt;f &lt; e-&gt;c) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } return false; } int findPath(Node *const s, Node *const t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) if (e-&gt;t-&gt;l == s-&gt;l + 1 &amp;&amp; e-&gt;f &lt; e-&gt;c) { int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c - e-&gt;f)); if (f &gt; 0) { e-&gt;f += f, e-&gt;r-&gt;f -= f; return f; } } return 0; } int operator()(const int s, const int t, const int n) { int ans = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) ans += f; } return ans; } } dinic; struct Airline { int s, t, time; } A[MAXM]; int n, m, p[MAXN], t[MAXN][MAXN], d[MAXN][MAXN]; int S, T; inline void floyd() { for (int k = 0; k &lt; n; k++) for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) if (i != j) d[i][j] = std::min(d[i][j], d[i][k] + p[k] + d[k][j]); // for (int i = 0; i &lt; n; i++) { // for (int j = 0; j &lt; n; j++) printf("%d ", d[i][j]); // putchar('\n'); // } } inline void addEdge(const int u, const int v) { // printf("(%d, %d)\n", u, v); if (!N[u].flag) addEdge(S, u, 1), N[u].flag = true; addEdge(u, v + m, INT_MAX); if (!N[v + m].flag) addEdge(v + m, T, 1), N[v + m].flag = true; } int main() { freopen("flight.in", "r", stdin); // freopen("flight.out", "w", stdout); scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;p[i]); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf("%d", &amp;t[i][j]), d[i][j] = t[i][j]; floyd(); for (int i = 0; i &lt; m; i++) scanf("%d %d %d", &amp;A[i].s, &amp;A[i].t, &amp;A[i].time), A[i].s--, A[i].t--; // for (int i = 0; i &lt; n; i++) printf("%d\n", p[i]); // for (int i = 0; i &lt; m; i++) printf("%d %d %d\n", A[i].s, A[i].t, A[i].time); S = 0, T = m * 2 + 1; for (int i = 1; i &lt;= m; i++) { Airline &amp;a = A[i - 1]; for (int j = 1; j &lt;= m; j++) { Airline &amp;b = A[j - 1]; if ( (a.time + t[a.s][a.t] + p[a.t] + d[a.t][b.s] + p[b.s] &lt;= b.time) || (a.time + t[a.s][a.t] + p[a.t] &lt;= b.time &amp;&amp; a.t == b.s) ) { addEdge(i, j); } } } int flow = dinic(S, T, m * 2 + 2); printf("%d\n", m - flow); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>最短路</tag>
        <tag>JSOI</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CQOI2016」手机号码 - 数位 DP]]></title>
    <url>%2Fcqoi2016-number%2F</url>
    <content type="text"><![CDATA[工具需要检测的号码特征有两个：号码中要出现至少 个相邻的相同数字，号码中不能同时出现 和 。号码必须同时包含两个特征才满足条件。满足条件的号码例如：、、。而不满足条件的号码例如：、。 手机号码一定是 位数，前不含前导的 。工具接收两个数 和 ，自动统计出 区间内所有满足条件的号码数量。 和 也是 位的手机号码。 链接 BZOJ 4521 题解 设 表示小于等于 的电话号码中合法的数量， 即为答案。 计算 时枚举最高位，使用数位 DP，状态为： 从前到后依次表示：还剩几位、最高位最大是几（ 表示从这一位开始均不限制）、上一位是几、上一位与上上一位是否相等、是否已有三个相邻的相同数字、是否已有 、是否已有 。 转移时，枚举最高位上的数，如果最高位 ，则之后的位上的数的大小均无限制。如果上上一位于上一位相等且当前位于上一位相等，认为已有三个相邻的相同数字。 每次数位 DP 的时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const long long MINN = 1e10; const long long MAXN = 1e11 - 1; const int LEN = 11; int a[LEN]; long long mem[LEN][11][10][2][2][2][2]; bool calced[LEN][11][10][2][2][2][2]; long long f(const int n, const int limit, const int last, const bool equal, const bool flag, const bool four, const bool eight) { long long &amp;ans = mem[n][limit][last][equal][flag][four][eight]; if (calced[n][limit][last][equal][flag][four][eight]) return ans; calced[n][limit][last][equal][flag][four][eight] = true; // printf("f(n = %d, limit = %d, last = %d, [%s], [%s], [%s], [%s])\n", n, limit, last, equal ? "equal" : "", flag ? "flag" : "", four ? "four" : "", eight ? "eight" : ""); ans = 0; if (n == 1) { for (int i = 0; i &lt;= std::min(limit, 9); i++) { if (i == 4 &amp;&amp; eight) continue; if (i == 8 &amp;&amp; four) continue; if (flag || (equal &amp;&amp; i == last)) ans++; } } else { int &amp;next = a[LEN - n + 1]; for (int i = 0; i &lt;= std::min(limit, 9); i++) { if (i == 4 &amp;&amp; eight) continue; if (i == 8 &amp;&amp; four) continue; int t; if (i &lt; limit || limit &gt; 9) { t = 10; } else t = next; ans += f(n - 1, t, i, i == last, flag || (equal &amp;&amp; i == last), four || (i == 4), eight || (i == 8)); } } return ans; } inline long long solve(const long long num) { if (num &lt; MINN) return 0; char s[LEN + 1]; sprintf(s, "%lld", num); for (int i = 0; i &lt; LEN; i++) a[i] = s[i] - '0'; memset(mem, 0, sizeof(mem)); memset(calced, 0, sizeof(calced)); int &amp;limit = a[0]; long long ans = 0; for (int i = 1; i &lt;= limit; i++) { int t; if (i &lt; limit) t = 10; else t = a[1]; ans += f(LEN - 1, t, i, false, false, i == 4, i == 8); } return ans; } int main() { // freopen("number.in", "r", stdin); // freopen("number.out", "w", stdout); long long l, r; scanf("%lld %lld", &amp;l, &amp;r); long long L = solve(l - 1), R = solve(r); // printf("%lld\n%lld\n", L, R);; printf("%lld\n", R - L); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>数位 DP</tag>
        <tag>CQOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CQOI2016」不同的最小割 - 分治 + 网络流]]></title>
    <url>%2Fcqoi2016-cuts%2F</url>
    <content type="text"><![CDATA[对于一个图，某个对图中结点的划分将图中所有结点分成两个部分，如果结点 ， 不在同一个部分中，则称这个划分是关于 ， 的割。对于带权图来说，将所有顶点处在不同部分的边的权值相加所得到的值定义为这个割的容量，而 ， 的最小割指的是在关于 ， 的割中容量最小的割。 考虑有 个点的无向连通图中所有点对的最小割的容量，共能得到 个数值。这些数值中互不相同的有多少个呢？ 链接 BZOJ 4519 题解 首先从所有点中，任选两个点 、 做最小割，可以得到 和 两个集合。 然后从 集合（ 集合对应相同）中任选一个点 ，做 和 的最小割（全局），得到两个集合 、，取出 和 的交集，作为新的集合递归下去。直到集合中只剩下一个点为止。 上述操作共进行了 次，所得的所有最小割容量中不同的数量即为答案。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;tr1/unordered_set&gt; const int MAXN = 7800; const int MAXM = 78000; const int S = 1; const int T = -1; struct Node; struct Edge; struct Node { Edge *e, *c; int l, set, lastSet, time; } N[MAXN]; struct Edge { Node *s, *t; int f, c; Edge *next, *r; Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s-&gt;e) {} }; struct Dinic { bool makeLevelGraph(Node *const s, Node *const t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;f &lt; e-&gt;c &amp;&amp; e-&gt;t-&gt;l == 0) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } return false; } int findPath(Node *const s, Node *const t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) if (e-&gt;f &lt; e-&gt;c &amp;&amp; e-&gt;t-&gt;l == s-&gt;l + 1) { const int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c - e-&gt;f)); if (f &gt; 0) { e-&gt;f += f, e-&gt;r-&gt;f -= f; // printf("[%ld =&gt; %ld] = %d\n", s - N + 1, t - N + 1, f); return f; } } return 0; } int operator()(const int s, const int t, const int n) { int ans = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { // puts("Leveled!"); int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) ans += f; } // printf("dinic(%d, %d, %d) = %d\n", s + 1, t + 1, n, ans); return ans; } } dinic; inline void addEdge(const int u, const int v, const int c) { N[u].e = new Edge(&amp;N[u], &amp;N[v], c); N[v].e = new Edge(&amp;N[v], &amp;N[u], c); N[u].e-&gt;r = N[v].e, N[v].e-&gt;r = N[u].e; } int n, m; inline void cleanUp() { for (int i = 0; i &lt; n; i++) for (Edge *e = N[i].e; e; e = e-&gt;next) e-&gt;f = 0; } inline void minCut(const int s, const int t) { for (int i = 0; i &lt; n; i++) N[i].set = T; static int time = 0; time++; const int S = 1, T = -1; std::queue&lt;Node *&gt; q; q.push(&amp;N[s]); N[s].set = S; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;f &lt; e-&gt;c &amp;&amp; e-&gt;t-&gt;time != time) { e-&gt;t-&gt;time = time; e-&gt;t-&gt;set = S; q.push(e-&gt;t); } } } inline void reMark(const std::vector&lt;int&gt; &amp;vs, const std::vector&lt;int&gt; &amp;vt) { for (std::vector&lt;int&gt;::const_iterator p = vs.begin(); p != vs.end(); p++) N[*p].lastSet = S; for (std::vector&lt;int&gt;::const_iterator p = vt.begin(); p != vt.end(); p++) N[*p].lastSet = T; } std::tr1::unordered_set&lt;int&gt; set; inline void solve(const int s, const int t, const int lastSet) { cleanUp(); int f = dinic(s, t, n); set.insert(f); minCut(s, t); std::vector&lt;int&gt; vs, vt; for (int i = 0; i &lt; n; i++) { if (N[i].set == S &amp;&amp; (N[i].lastSet == lastSet || lastSet == 0)) vs.push_back(i); else if (N[i].set == T &amp;&amp; (N[i].lastSet == lastSet || lastSet == 0)) vt.push_back(i); } for (std::vector&lt;int&gt;::const_iterator p = vs.begin(); p != vs.end(); p++) if (*p != s) { reMark(vs, vt); solve(s, *p, S); break; } for (std::vector&lt;int&gt;::const_iterator p = vt.begin(); p != vt.end(); p++) if (*p != t) { reMark(vs, vt); solve(*p, t, T); break; } } inline int solve() { if (n &lt; 2) return 0; else { solve(0, 1, 0); return set.size(); } } int main() { // freopen("cuts.in", "r", stdin); // freopen("cuts.out", "w", stdout); scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) { int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w), u--, v--; addEdge(u, v, w); } printf("%d\n", solve()); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>分治</tag>
        <tag>CQOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2016」灯塔 - 分块 + RMQ]]></title>
    <url>%2Fjsoi2016-light%2F</url>
    <content type="text"><![CDATA[JSOI 的国境线上有 一座连续的山峰，其中第 座的高度是 。为了简单起见，我们认为这 座山峰排成了连续一条直线。 如果在第 座山峰上建立一座高度为 的灯塔，JYY 发现，这座灯塔能够照亮第 座山峰，当且仅当满足如下不等式： JSOI 国王希望对于每一座山峰，JYY 都能提供建造一座能够照亮全部其他山峰的灯塔所需要的最小高度。你能帮助 JYY 么？ 题解 题目要求计算所有 打表可以发现 的取值有 种，而对于每种取值， 总是连续的最多两段区间。 考虑每个 对 的影响，当 相同时，只有 最大的 会对 有影响。 枚举 i，然后枚举 的值，问题转化为求一段区间内 的最大值，即 RMQ 问题，使用稀疏表即可解决。 总时间复杂度为 ，最大的数据要跑接近 3s …… 代码 #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; const int MAXN = 100000; const int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812 int n, a[MAXN]; int st[MAXN][MAXLOGN + 1]; template &lt;typename T&gt; inline T sqr(const T x) { return x * x; } template &lt;typename T&gt; inline void cmax(T &amp;x, const T &amp;y) { if (y &gt; x) x = y; } template &lt;typename T&gt; inline void cmin(T &amp;x, const T &amp;y) { if (y &lt; x) x = y; } inline void sparseTable() { for (int i = 0; i &lt; n - 1; i++) st[i][0] = std::max(a[i], a[i + 1]); st[n - 1][0] = a[n - 1]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) { for (int i = 0; i &lt; n; i++) { st[i][j] = std::max(st[i][j - 1], st[std::min(i + (1 &lt;&lt; (j - 1)), n - 1)][j - 1]); } } } inline int query(const int l, const int r) { /* if (l &gt; r) return 0; int res = 0; for (int i = l; i &lt;= r; i++) cmax(res, a[i - 1]); return res; */ if (l &gt; r) return 0; else if (l == r) return a[l - 1]; else { int t = floor(log2(r - l)); return std::max(st[l - 1][t], st[r - 1 - (1 &lt;&lt; t)][t]); } } inline void getRange(const int i, const int s, int &amp;l1, int &amp;r1, int &amp;l2, int &amp;r2) { if (s == 0) l1 = r1 = l2 = r2 = i; else if (s == 1) l1 = r1 = i - 1, l2 = r2 = i + 1; else { int l = sqr(s - 1) + 1, r = sqr(s); l1 = i - r, r1 = i - l, l2 = i + l, r2 = i + r; } if (l1 &lt; 1) l1 = 1; if (l2 &lt; 1) l2 = 1; if (r1 &gt; n) r1 = n; if (r2 &gt; n) r2 = n; // printf("i = %d, s = %d, [%d, %d], [%d, %d]\n", i, s, l1, r1, l2, r2); } inline int solve(const int i) { int max = 0; static int lim = ceil(sqrt(n)); for (int s = 0; s &lt;= lim; s++) { int l1, r1, l2, r2; getRange(i, s, l1, r1, l2, r2); cmax(max, query(l1, r1) - a[i - 1] + s); cmax(max, query(l2, r2) - a[i - 1] + s); } return max; /* int p = 0; for (int j = 1; j &lt;= n; j++) { int s = ceil(sqrt(abs(i - j))); printf("(%d, %d) -&gt; %d\n", i, j ,s); p = std::max(p, a[j - 1] + s - a[i - 1]); } return p; */ } int main() { freopen("light.in", "r", stdin); // freopen("light.out", "w", stdout); scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); sparseTable(); for (int i = 1; i &lt;= n; i++) { printf("%d\n", solve(i)); } fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>乱搞</tag>
        <tag>RMQ</tag>
        <tag>JSOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2016」储能表 - 二进制]]></title>
    <url>%2Fsdoi2016-table%2F</url>
    <content type="text"><![CDATA[有一个 行 列的表格，行从 到 编号，列从 到 编号。 每个格子都储存着能量。最初，第 行第 列的格子储存着 点能量。所以，整个表格储存的总能量是， 随着时间的推移，格子中的能量会渐渐减少。一个时间单位，每个格子中的能量都会减少 。显然，一个格子的能量减少到 之后就不会再减少了。 也就是说， 个时间单位后，整个表格储存的总能量是， 给出一个表格，求 个时间单位后它储存的总能量。 由于总能量可能较大，输出时对 取模。 链接 COGS 2220 BZOJ 4513 题解 正解是数位 DP …… 这里讲一种乱搞做法 …… 考虑异或的性质： 性质一：对于任意 ，，必有 证明：之前两个数的从低到高第 位均为 ，现在均为 ，异或后结果不变。 性质二：对于任意 ，必有 证明：反证法，假设 ，则有 、，即 ，与题设矛盾。 性质三：对于任意 ， 的所有数与 的异或所得结果取遍 的所有数。 证明：显然，有性质 2 可知这些数互不相同，并且二进制最多有 位，不可能大于等于 ，即这 个互不相同的数都在 内。 设 ，为方便阅读， 表示列数， 表示行数。 打表找规律，先从最简单的开始搞。不考虑 ，当 （）时，结果为 可以看到，整个矩阵的每一行包含了 的所有数字。直接使用等差数列求和公式计算即可。 稍复杂的情况，设 ，。当 时，打表结果为 左上角的黑色部分可以直接规约到第一种情况。红色的部分中，参与异或运算的一个数多了一个二进制位，根据性质三，这一部分能取到 的所有数。绿色部分同理。 对于黄色部分，相当于去掉了 和 的最高位后的一个子问题，递归计算即可。 更复杂的情况，当 （因为 所以不可能存在 ）时，打表结果为 由性质三得，左边黑色部分取遍了 ，可用等差数列求和公式直接计算，右边部分都大于等于 ，将它们同时减去 后即为 的情况，递归处理后为每个数加上 即可。 现在考虑 对结果的影响，我们在计算一个等差数列 时，前面所有 的项都会变成 ，后面所有项减去 ，相当于一个以 开始，长度为 的等差数列，代入公式即可。 对于最后一种情况的递归，需要在 中将 的最高位去掉。最后为每个数加上时，对每个数的增量减去 即可。 每次递归时，会去掉 二进制最高位上的 ，其他的计算都可以在常数时间内完成，总时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXT = 5000; const long long MAXN = 1e18; const long long MAXM = 1e18; const long long MAXK = 1e18; const int MAXP = 1e9; long long p = MAXP; /* template &lt;typename T&gt; inline int bitsCount(const T &amp;x) { for (int i = sizeof(T) * 8 - 1; i &gt;= 0; i--) if (x &amp; ((T)1 &lt;&lt; i)) return i + 1; return 0; } */ template &lt;typename T&gt; inline void bitsPrint(const T &amp;x) { for (int i = sizeof(T) * 8 - 1; i &gt;= 0; i--) if (x &amp; ((T)1 &lt;&lt; i)) putchar('1'); else putchar('0'); putchar('\n'); } template &lt;typename T&gt; inline T lowbit(const T &amp;x) { return x &amp; -x; } template &lt;typename T&gt; inline int log2(T x) { int ans = 0; while (x &gt;&gt;= 1) ans++; return ans; } template &lt;typename T&gt; inline T mul(T x, T y, const T &amp;z = 1) { // (x * y) / z, z is 1 or 2; if (z == 2) { if (x &amp; 1) y &gt;&gt;= 1; else if (y &amp; 1) x &gt;&gt;= 1; else throw; } return (x % p) * (y % p) % p; } inline long long sumTimes(long long first, long long n, const long long k, const long long t) { // printf("from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\n", first, first + n - 1, first, (first + n - 1), n, t); first -= k; if (first &lt; 1) n -= (1 - first), first = 1; // printf("from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\n", first, first + n - 1, first, (first + n - 1), n, t); if (n &lt;= 0) return 0; return mul(mul(first + (first + n - 1), n, 2ll), t); } long long solve(long long n, long long m, long long k) { // printf("solve(%lld, %lld, %lld)\n", n, m, k); if (n == 0 || m == 0) return 0; if (k &lt; 0) k = 0; if (n &lt; m) std::swap(n, m); if (n == m &amp;&amp; lowbit(n) == n) { return sumTimes(1, n - 1, k, m); } int N = log2(n), M = log2(m); long long centerWidth = (1ll &lt;&lt; N), centerHeight = (1ll &lt;&lt; M); if (N == M) { long long rightWidth = n - centerWidth, rightHeight = centerHeight; long long bottomWidth = centerWidth, bottomHeight = m - centerHeight; long long rightSum = sumTimes(centerWidth, rightHeight, k, rightWidth); long long bottomSum = sumTimes(centerHeight, bottomWidth, k, bottomHeight); long long sideSum = solve(rightWidth, bottomHeight, k); long long centerSum = solve(bottomWidth, rightHeight, k); return ((rightSum + bottomSum) % p + (sideSum + centerSum) % p) % p; } else { long long leftWidth = (1ll &lt;&lt; N), leftHeight = m; long long rightWidth = n - leftWidth, rightHeight = leftHeight; long long leftSum = sumTimes(0, leftWidth, k, leftHeight); long long rightSum = solve(rightWidth, rightHeight, k - leftWidth); if (leftWidth &gt; k) { rightSum += mul(mul(leftWidth - k, m), n - leftWidth); rightSum %= p; } return (leftSum + rightSum) % p; } } int main() { freopen("menci_table.in", "r", stdin); freopen("menci_table.out", "w", stdout); int t; scanf("%d", &amp;t); while (t--) { long long n, m, k; scanf("%lld %lld %lld %lld", &amp;n, &amp;m, &amp;k, &amp;p); printf("%lld\n", solve(n, m, k)); } // long long n, m, k; // scanf("%lld %lld %lld", &amp;n, &amp;m, &amp;k); // bitsPrint(n), bitsPrint(m); // printf("lowbit(%lld) = %lld\nbitsCount(%lld) = %d\n2 ^ bitsCount(%lld) = %d\n", n, lowbit(n), n, bitsCount(n), n, 1 &lt;&lt; (bitsCount(n))); // bitsPrint((1 &lt;&lt; bitsCount(n)) - 1); /*long long ans = 0; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { int t = std::max((i ^ j) - k, 0ll); printf("%3d", t); ans += t; } putchar('\n'); }*/ // printf("ans = %lld\n", ans); // printf("%lld\n", solve(n, m, k)); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>COGS</tag>
        <tag>位运算</tag>
        <tag>SDOI</tag>
        <tag>二进制</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2016」征途 - 斜率优化 DP]]></title>
    <url>%2Fsdoi2016-journey%2F</url>
    <content type="text"><![CDATA[Pine 开始了从 地到 地的征途。 从 地到 地的路可以划分成 段，相邻两段路的分界点设有休息站。 Pine 计划用 天到达 地。除第 天外，每一天晚上 Pine 都必须在休息站过夜。所以，一段路必须在同一天中走完。 Pine 希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。 帮助 Pine 求出最小方差是多少。 设方差是 ，可以证明， 是一个整数。为了避免精度误差，输出结果时输出 。 链接 COGS 2225 BZOJ 4518 题解 设 为每一天的路程，，题目要求即为最小化 将上式展开，整理得 因为 是个常数， 是个常数，所以只要最小化 即可 设 表示前 段路，分成 天的最优方案对应上式的值，则有 直接以这个式子进行划分DP，状态数为 ，时间复杂度为 ，预计得分 60 分。 尝试进行优化。首先，二维的状态存储，显然第一维是可以滚动的，设 。考虑 的两个取值 和 （），若 比 优，则有 左边是一个斜率的式子，分子和分母都是单调的，右边也是单调的。使用一个单调队列来存储一些决策点，使得从前到后每一个决策点都比下一个决策点更优，需要满足的条件是： 较后面的一对点组成的斜率比较前面一对点大； 第 个点与第 个点（）组成的斜率大于 （如果小于，说明较靠后的 点更优）。 因为斜率是单调递增的，所以第 2 条只需要使前两个元素满足条件即可。 枚举 ，不需要枚举 ，而是从单调队列中寻找最优决策点。首先检查队首元素，使其满足条件 2，此时队首即为最优解；然后将当前决策点作为新的 加入到队列尾部，需要先删除一些决策点使得条件 1 被满足。因为每个决策点最多会被添加、删除各一次，所以状态转移的代价为均摊 ，总时间复杂度降为 ，可以通过本题。 注意正无穷的取值，合理取值可以避免特判。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 3000; const int MAXM = 3000; int n, m, a[MAXN + 1], s[MAXN + 1]; long long f[MAXN + 1], g[MAXN + 1]; template &lt;typename T&gt; inline T sqr(const T x) { return x * x; } inline double slope(const int a, const int b) { // printf("K(%d, %d)\n", a, b); return (double)(g[a] - g[b] + sqr(s[a]) - sqr(s[b])) / (double)(s[a] - s[b]); } int main() { freopen("menci_journey.in", "r", stdin); freopen("menci_journey.out", "w", stdout); scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + a[i]; for (int i = 1; i &lt;= n; i++) f[i] = INT_MAX; for (int j = 1; j &lt;= m; j++) { memcpy(g, f, sizeof(f)); memset(f, 0, sizeof(f)); static int q[MAXN]; int l = 0, r = -1; q[++r] = 0; for (int i = 1; i &lt;= n; i++) { while (l &lt; r &amp;&amp; slope(q[l + 1], q[l]) &lt; 2 * s[i]) l++; int t = q[l]; f[i] = g[t] + sqr(s[i] - s[t]); while (l &lt; r &amp;&amp; slope(q[r], q[r - 1]) &gt; slope(q[r], i)) r--; q[++r] = i; } } // for (int i = 1; i &lt;= n; i++) printf("s[%d] = %lld\n", i, s[i]); printf("%d\n", (int)(f[n] * m - sqr(s[n]))); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>单调队列</tag>
        <tag>斜率优化</tag>
        <tag>COGS</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2016」游戏 - 树链剖分]]></title>
    <url>%2Fsdoi2016-game%2F</url>
    <content type="text"><![CDATA[Alice 和 Bob 在玩一个游戏。 游戏在一棵有 个点的树上进行。最初，每个点上都只有一个数字，那个数字是 。 有时，Alice 会选择一条从 到 的路径，在这条路径上的每一个点上都添加一个数字。对于路径上的一个点 ，若 与 的距离是 ，那么 Alice 在点 上添加的数字是 。 有时，Bob 会选择一条从 到 的路径。他需要先从这条路径上选择一个点，再从那个点上选择一个数字。 Bob 选择的数字越小越好，但大量的数字让 Bob 眼花缭乱。Bob 需要你帮他找出他能够选择的最小的数字。 链接 BZOJ 4515 COGS 2222 题解 首先，树链剖分，转化成链上的操作，使用线段树维护。 对一条路径上的每个点添加一个数字，设 ，可以把这条路径分为两条链，即 、。 设 为 u、v 两点间距离，则左边一条路径上每一个点被赋的值为 注意到，后面的 是一个常数。 右边的一条路径上每个点被赋的值为 同理，后面的 也是一个常数。 这样，我们得到了两个直线的斜截式方程，问题转化为：在序列上给一段区间添加一条直线；求一段区间内所有直线方程带入 值后的最小 值。 这个问题可以使用线段树解决，每个节点维护： 区间最小值； 在当前节点 mid（区间中点）处取得值最小的一条直线。 因为所有叶子节点的 mid 构成了整条线段，所以这样维护一定可以取得最小值。 注意到直线的方程这种标记是不能合并的，所以每当添加一条直线的时候，判断这条直线在区间左端点、区间中点、区间右端点处带入得到的值是否比原有直线更优。 如果左右端点都取不到更优值，则中点一定取不到更优值，且子节点的中点（整个区间）都取不到更优值，因为一次函数的图像是单调的。此时直接舍弃新的直线即可。 如果左右端点都能取到更优值，同理，中点一定能取到更优值，且子节点的中点（整个区间）都能取到更优值。此时直接更新舍弃旧的直线即可。 其他的情况，均为左右端点之一能取到更优值。如果中点能取到更优值，可以将新旧直线互换，并将左右端点能否取到更优值取反。即转化为，只有左右端点之一能取到更优值。 此时的两条直线图像是这样的（因为带入的横坐标是离散的，所以真实的情况并不一定是直线，此处便于理解画成直线）： 旧直线为浅色，新直线为深色。可以看出在左端点处，新直线取得更优值，因为新直线已经不可能对当前节点（的中点处）有贡献，而只可能对左半个区间（的中点）有贡献，所以直接在线段树上向左子树下放即可。这是一个递归的过程。 这样有一个问题，当前区间的新直线可能对两个子节点所控制的区间的中点的值有贡献，而查询时有可能查询到两个子节点而忽略当前节点。为了解决此问题，在查询子节点时，先尝试将自身记录的直线下放下去。 树链剖分会产生最多 条重链，线段树上一次查询或修改操作会访问最多 个节点，每个标记最多被下传 次，所以该算法的时间复杂度为 。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;stack&gt; const int MAXN = 100000; const int MAXM = 100000; struct Node; struct Edge; struct SegmentTree; struct Node { Edge *e; int d, s, i, id; long long dist; bool v; Node *p, *c, *t; } N[MAXN], *dfs[MAXN]; struct Edge { Node *s, *t; long long w; Edge *next; Edge(Node *s, Node *t, const long long w) : s(s), t(t), w(w), next(s-&gt;e) {} }; struct Line { long long k, b; Line() : k(0), b(LLONG_MAX) {} Line(const long long k, const long long b) : k(k), b(b) { /* printf(" Line(%lld, %lld)\n", k, b); */} long long operator()(const int i) const { return k * dfs[i]-&gt;dist + b; } long long operator()(const int i, const int j, const int k) { long long ans = LLONG_MAX; ans = std::min(ans, this-&gt;operator()(i)); ans = std::min(ans, this-&gt;operator()(j)); ans = std::min(ans, this-&gt;operator()(k)); return ans; } operator bool() const { return k != 0 || b != LLONG_MAX; } }; struct SegmentTree { int l, r, m; SegmentTree *lc, *rc; Line f; long long val; bool covered; SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + ((r - l) &gt;&gt; 1)), lc(lc), rc(rc), val(123456789123456789LL) {} ~SegmentTree() { if (lc) delete lc; if (rc) delete rc; } /* bool test(const Line &amp;f) { return f(l) &lt;= this-&gt;f(l) &amp;&amp; f(m) &lt;= this-&gt;f(m) &amp;&amp; f(r) &lt;= this-&gt;f(r); } */ void pushDown() { if (lc &amp;&amp; f) lc-&gt;update(lc-&gt;l, lc-&gt;r, this-&gt;f); if (rc &amp;&amp; f) rc-&gt;update(rc-&gt;l, rc-&gt;r, this-&gt;f); /* if (lc &amp;&amp; f &amp;&amp; (!lc-&gt;f || lc-&gt;test(f))) lc-&gt;f = f, lc-&gt;val = std::min(lc-&gt;val, lc-&gt;f(lc-&gt;l, lc-&gt;m, lc-&gt;r)); if (rc &amp;&amp; f &amp;&amp; (!rc-&gt;f || rc-&gt;test(f))) rc-&gt;f = f, rc-&gt;val = std::min(rc-&gt;val, rc-&gt;f(rc-&gt;l, rc-&gt;m, rc-&gt;r)); */ } void cover(Line f) { // pushDown(); bool L = (f(l) &lt; this-&gt;f(l)), R = (f(r) &lt; this-&gt;f(r)), M = (f(m) &lt; this-&gt;f(m)); if (!L &amp;&amp; !R) return; if (L &amp;&amp; R) { this-&gt;f = f; val = std::min(val, this-&gt;f(l, m, r)); return; } if (M) { std::swap(f, this-&gt;f); L ^= 1, R ^= 1; } if (L) lc-&gt;cover(f); if (R) rc-&gt;cover(f); val = std::min(val, this-&gt;f(l, m, r)); val = std::min(val, lc-&gt;val); val = std::min(val, rc-&gt;val); // printf("val[%d, %d] = %lld\n", l, r, val); } void update(const int l, const int r, const Line &amp;f) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) cover(f); else { // pushDown(); lc-&gt;update(l, r, f); rc-&gt;update(l, r, f); // val = std::min(val, this-&gt;f(this-&gt;l, this-&gt;m, this-&gt;r)); val = std::min(val, lc-&gt;val); val = std::min(val, rc-&gt;val); } } long long query(const int l, const int r) { // printf("val[%d, %d] (with m = %d) = %lld\n", this-&gt;l, this-&gt;r, m, val); if (l &gt; this-&gt;r || r &lt; this-&gt;l) return LLONG_MAX; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) { long long ans = LLONG_MAX; ans = std::min(ans, val); // ans = std::min(ans, f(std::max(l, this-&gt;l))); // ans = std::min(ans, f(std::min(r, this-&gt;r))); // printf("query(%d, %d) in [%d, %d] = %lld\n", l, r, this-&gt;l, this-&gt;r, ans); return ans; } else { pushDown(); long long ans = LLONG_MAX; // if (l &lt;= this-&gt;m &amp;&amp; r &gt;= this-&gt;m) ans = std::min(ans, f(m)); /*if (covered) { ans = std::min(ans, f(std::max(l, this-&gt;l))); ans = std::min(ans, f(std::min(r, this-&gt;r))); }*/ ans = std::min(ans, lc-&gt;query(l, r)); ans = std::min(ans, rc-&gt;query(l, r)); // printf("query(%d, %d) in [%d, %d] = %lld\n", l, r, this-&gt;l, this-&gt;r, ans); return ans; } } } *segment; int n, m; SegmentTree *buildSegment(const int l, const int r) { if (l &gt; r) return NULL; else if (l == r) return new SegmentTree(l, r, NULL, NULL); else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) &gt;&gt; 1)), buildSegment(l + ((r - l) &gt;&gt; 1) + 1, r)); } inline void addEdge(const int u, const int v, const long long w) { N[u].e = new Edge(&amp;N[u], &amp;N[v], w); N[v].e = new Edge(&amp;N[v], &amp;N[u], w); } inline void cut() { std::stack&lt;Node *&gt; s; s.push(&amp;N[0]); N[0].d = 1; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;v) { v-&gt;v = true; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;d) { e-&gt;t-&gt;d = v-&gt;d + 1; e-&gt;t-&gt;dist = v-&gt;dist + e-&gt;w; e-&gt;t-&gt;p = v; s.push(e-&gt;t); } } else { v-&gt;s = 1; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;p == v) { v-&gt;s += e-&gt;t-&gt;s; if (v-&gt;c == NULL || v-&gt;c-&gt;s &lt; e-&gt;t-&gt;s) v-&gt;c = e-&gt;t; } s.pop(); } } for (int i = 0; i &lt; n; i++) N[i].v = false; int time = -1; s.push(&amp;N[0]); while (!s.empty()) { Node *v = s.top(); if (!v-&gt;v) { v-&gt;v = true; v-&gt;i = ++time; dfs[v-&gt;i] = v; if (!v-&gt;p || v != v-&gt;p-&gt;c) v-&gt;t = v; else v-&gt;t = v-&gt;p-&gt;t; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;p == v &amp;&amp; e-&gt;t != v-&gt;c) s.push(e-&gt;t); if (v-&gt;c) s.push(v-&gt;c); } else s.pop(); } segment = buildSegment(0, n - 1); } inline int lca(const int u, const int v) { Node *a = &amp;N[u], *b = &amp;N[v]; while (a-&gt;t != b-&gt;t) { if (a-&gt;t-&gt;d &lt; b-&gt;t-&gt;d) std::swap(a, b); a = a-&gt;t-&gt;p; } return a-&gt;d &lt; b-&gt;d ? a-&gt;id : b-&gt;id; } inline void update(const int u, const int v, const Line &amp;f) { Node *a = &amp;N[u], *b = &amp;N[v]; while (a-&gt;t != b-&gt;t) { if (a-&gt;t-&gt;d &lt; b-&gt;t-&gt;d) std::swap(a, b); segment-&gt;update(a-&gt;t-&gt;i, a-&gt;i, f); a = a-&gt;t-&gt;p; } if (a-&gt;i &gt; b-&gt;i) std::swap(a, b); segment-&gt;update(a-&gt;i, b-&gt;i, f); } inline long long query(const int u, const int v) { long long ans = LLONG_MAX; Node *a = &amp;N[u], *b = &amp;N[v]; while (a-&gt;t != b-&gt;t) { if (a-&gt;t-&gt;d &lt; b-&gt;t-&gt;d) std::swap(a, b); ans = std::min(ans, segment-&gt;query(a-&gt;t-&gt;i, a-&gt;i)); // printf("ans = %lld\n", ans); a = a-&gt;t-&gt;p; } if (a-&gt;i &gt; b-&gt;i) std::swap(a, b); ans = std::min(ans, segment-&gt;query(a-&gt;i, b-&gt;i)); // printf("ans = %lld\n", ans); return ans; } int main() { freopen("menci_game.in", "r", stdin); freopen("menci_game.out", "w", stdout); scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) N[i].id = i; for (int i = 0; i &lt; n - 1; i++) { int u, v; long long w; scanf("%d %d %lld", &amp;u, &amp;v, &amp;w), u--, v--; addEdge(u, v, w); } cut(); // for (int i = 0; i &lt; n; i++) printf("order(%d) = %d\n", i + 1, N[i].i); for (int i = 0; i &lt; m; i++) { int x, s, t; scanf("%d %d %d", &amp;x, &amp;s, &amp;t), s--, t--; if (x == 1) { long long a, b; scanf("%lld %lld", &amp;a, &amp;b); int p = lca(s, t); // printf("(%lld, %lld)\n", -a, a * N[s].dist + b); // printf("(%lld, %lld)\n", a, (N[s].dist - 2 * N[p].dist) * a + b); if (p != s) update(s, p, Line(-a, a * N[s].dist + b)); if (p != t || (p == s &amp;&amp; p == t)) update(p, t, Line(a, (N[s].dist - 2 * N[p].dist) * a + b)); } else { printf("%lld\n", query(s, t)); } } fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>最近公共祖先</tag>
        <tag>李超树</tag>
        <tag>COGS</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全错位排列递推公式的推导]]></title>
    <url>%2Fderangement-number%2F</url>
    <content type="text"><![CDATA[将按照顺序排列的 ~ 打乱，重新排列，要求每个元素都不能在自己原有的位置上，求方案总数。 设答案为 。 首先考虑第 号位置上放哪个元素，有 种方案，假设放的是 ； 考虑把 号元素放在哪个位置，如果我们删掉 号位置（不再考虑原有的 号元素），然后把 号元素的标号改为 ，这样问题就成为了一个子问题 。 但是这样考虑是有问题的 —— 原有的 号元素被编号为 1 后，就再也不可能被放到 1 号位置了，但原问题中，这是一种可行方案，所以要把这种情况加上。如果把 号元素放到 1 号位置，可以不再考虑这两个位置，问题转化为另一个子问题 。 这样，我们得到一个递推式]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乘法逆元的几种计算方法]]></title>
    <url>%2Fmul-inverse%2F</url>
    <content type="text"><![CDATA[乘法逆元是数论中重要的内容，也是 OI 中常用到的数论算法之一。所以，如何高效的求出乘法逆元是一个值得研究的问题。 这里我们只讨论当模数为素数的情况，因为如果模数不为素数，则不一定每个数都有逆元。 定义 在 的意义下我们把 的乘法逆元写作 。 乘法逆元有如下的性质： 乘法逆元的一大应用是模意义下的除法，除法在模意义下并不是封闭的，但我们可以根据上述公式，将其转化为乘法。 费马小定理 要求 为素数。 上述公式可变形为 由乘法逆元的定义， 即为 的乘法逆元。 使用快速幂计算 ，总时间复杂度为 。 代码 inline int pow(const int n, const int k) { long long ans = 1; for (long long num = n, t = k; t; num = num * num % MOD, t &gt;&gt;= 1) if (t &amp; 1) ans = ans * num % MOD; return ans; } inline int inv(const int num) { return pow(num, MOD - 2); } 扩展欧几里得 扩展欧几里得（EXGCD）算法可以在 的时间内求出关于 、 的方程 的一组整数解 当 为素数时，，此时有 时间复杂度为 。 代码 void exgcd(const int a, const int b, int &amp;g, int &amp;x, int &amp;y) { if (!b) g = a, x = 1, y = 0; else exgcd(b, a % b, g, y, x), y -= x * (a / b); } inline int inv(const int num) { int g, x, y; exgcd(num, MOD, g, x, y); return ((x % MOD) + MOD) % MOD; } 递推法 设 ，（，），则有 两边同时乘上 ，得 移项，得 即 我们可以利用这个式子进行递推，边界条件为 ，时间复杂度为 。 代码 inv[1] = 1; for (int i = 2; i &lt;= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>数论</tag>
        <tag>乘法逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2016」排列计数 - 组合数学 + 错位排列]]></title>
    <url>%2Fsdoi2016-permutation%2F</url>
    <content type="text"><![CDATA[求有多少种长度为 的序列 ，满足以下条件： ~ 这 个数在序列中各出现了一次 若第 个数 的值为 ，则称 是稳定的。序列恰好有 个数是稳定的 满足条件的序列可能很多，序列数对 取模。 链接 COGS 2224 BZOJ 4517 题解 根据条件一，我们得知这是一个全排列。 对于条件二，我们可以先从 个数中选出 个，使它们的值是稳定的，然后使剩下的 全部错位排列。 设 表示长度为 i 的序列的错位排列数，答案即为 代码 #include &lt;cstdio&gt; const int MAXT = 500000; const int MAXN = 1000000; const int MAXM = 1000000; const int MOD = 1e9 + 7; long long fac[MAXN + 1], inv[MAXN + 1], facInv[MAXN + 1], f[MAXN + 1]; /* inline int pow(const int n, const int k) { long long ans = 1; for (long long num = n, t = k; t; num = num * num % MOD, t &gt;&gt;= 1) if (t &amp; 1) ans = ans * num % MOD; return ans; } void exgcd(const int a, const int b, int &amp;g, int &amp;x, int &amp;y) { if (!b) g = a, x = 1, y = 0; else exgcd(b, a % b, g, y, x), y -= x * (a / b); } inline int inv(const int num) { int g, x, y; exgcd(num, MOD, g, x, y); return ((x % MOD) + MOD) % MOD; } */ inline int C(const int n, const int k) { if (k == 0) return 1; return fac[n] * facInv[k] % MOD * facInv[n - k] % MOD; } inline void prepare() { fac[0] = 1; for (int i = 1; i &lt;= MAXN; i++) fac[i] = fac[i - 1] * i % MOD; inv[1] = 1; for (int i = 2; i &lt;= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD; facInv[0] = 1; for (int i = 1; i &lt;= MAXN; i++) facInv[i] = facInv[i - 1] * inv[i] % MOD; f[0] = 0, f[1] = 0, f[2] = 1; for (int i = 3; i &lt;= MAXN; i++) { f[i] = (i - 1) * (f[i - 1] + f[i - 2]) % MOD; } } inline int solve(const int n, const int m) { if (n &lt; m || n == 0) return 0; else if (n == m) return 1; else { return C(n, m) * f[n - m] % MOD; } } int main() { freopen("menci_permutation.in", "r", stdin); freopen("menci_permutation.out", "w", stdout); prepare(); int t; scanf("%d", &amp;t); while (t--) { int n, m; scanf("%d %d", &amp;n, &amp;m); printf("%d\n", solve(n, m)); } fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>COGS</tag>
        <tag>组合数</tag>
        <tag>组合数学</tag>
        <tag>错位排列</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2016」生成魔咒 - 后缀数组]]></title>
    <url>%2Fsdoi2016-incantation%2F</url>
    <content type="text"><![CDATA[魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 、 拼凑起来形成一个魔咒串 。 一个魔咒串 的非空字串被称为魔咒串 的生成魔咒。 例如 时，它的生成魔咒有 、、、、 五种。 时，它的生成魔咒有 、、 三种。 最初 为空串。共进行 次操作，每次操作是在 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 共有多少种生成魔咒。 链接 COGS 2223 BZOJ 4516 题解 如果没有加入字符的操作，可以直接使用后缀数组的 计算。有了在结尾加入字符的操作，我们可以将整个串反转，变成在开头加入字符，这样相当于每次添加一个后缀。 将操作离线，得到最终的串，对它建立后缀数组和稀疏表。 用一个 std::set 维护当前已经被加入的后缀的排名，以方便查询当前加入的后缀的排名前、后一位的后缀。 考虑每次加入一个新的后缀对答案的贡献。统计每个时刻串中的重复子串数量，设新加入的后缀为 ，排在它前、后一位的后缀分别为 、。 在加入之前，、 的排名是相邻的，而现在不相邻了，需要减去它们的最长公共前缀长度。加入之后，、 都与 相邻，需要加上它们的最长公共前缀长度。 根据等差数列求和公式，长度为 的字符串的总子串数量为 每次用总子串数量减去重复数量即可。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;set&gt; const int MAXN = 100000; const int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812 int n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1]; inline void ary(const int *a, const int n) { for (int i = 0; i &lt; n - 1; i++) printf("%d ", a[i]); printf("%d\n", a[n - 1]); } inline void suffixArray() { static int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1; for (int i = 0; i &lt; n; i++) buc[a[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) rk[i] = buc[a[i] - 1]; for (int t = 1; t &lt; n; t &lt;&lt;= 1) { for (int i = 0; i &lt; n; i++) fir[i] = rk[i]; for (int i = 0; i &lt; n; i++) sec[i] = (i + t &gt;= n) ? -1 : fir[i + t]; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[sec[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) tmp[n - buc[sec[i]]--] = i; std::fill(buc - 1, buc + n, 0); for (int i = 0; i &lt; n; i++) buc[fir[i]]++; for (int i = 0; i &lt; n; i++) buc[i] += buc[i - 1]; for (int j = 0, i; j &lt; n; j++) i = tmp[j], sa[--buc[fir[i]]] = i; for (int j = 0, i, last = -1; j &lt; n; j++) { i = sa[j]; if (last == -1) rk[i] = 0; else if (fir[i] == fir[last] &amp;&amp; sec[i] == sec[last]) rk[i] = rk[last]; else rk[i] = rk[last] + 1; last = i; } } for (int i = 0, k = 0; i &lt; n; i++) { if (rk[i] == 0) k = 0; else { if (k &gt; 0) k--; int j = sa[rk[i] - 1]; while (i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; a[i + k] == a[j + k]) k++; } ht[rk[i]] = k; } } inline void sparseTable() { for (int i = 0; i &lt; n - 1; i++) st[i][0] = ht[i + 1]; for (int t = 1; (1 &lt;&lt; t) &lt; n; t++) { for (int i = 0, j = (1 &lt;&lt; t); i &lt; n; i++) { if (i + j &gt;= n) break; st[i][t] = std::min(st[i][t - 1], st[i + (1 &lt;&lt; (t - 1))][t - 1]); } } } inline int lcp(int a, int b) { if (a &gt; b) std::swap(a, b); // printf("%d %d\n", a, b); int res; if (a == b) res = n - a; else { int t = (int)floor(log2(b - a)); res = std::min(st[a][t], st[b - (1 &lt;&lt; t)][t]); } // static char s[MAXN]; // for (int i = 0; i &lt; n; i++) s[i] = ::a[i] + 'a'; // printf("LCP( '%s', '%s' ) = %d\n", &amp;s[sa[a]], &amp;s[sa[b + 1]], res); return res; } std::set&lt;int&gt; s; inline int queryPred(const int r) { std::set&lt;int&gt;::const_iterator a = s.lower_bound(r); if (a == s.begin()) return -1; else return *--a; } inline int querySucc(const int r) { std::set&lt;int&gt;::const_iterator a = s.lower_bound(r); if (a == s.end()) return -1; else return *a; } template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; while (ch = getchar(), !(ch &gt;= '0' &amp;&amp; ch &lt;= '9')); do x = x * 10 + ch - '0'; while (ch = getchar(), (ch &gt;= '0' &amp;&amp; ch &lt;= '9')); } template &lt;typename T&gt; inline void write(T x) { static char s[64]; int len = 0; do s[len++] = x % 10; while (x /= 10); while (len--) putchar(s[len] + '0'); putchar('\n'); } int main() { freopen("menci_incantation.in", "r", stdin); freopen("menci_incantation.out", "w", stdout); // scanf("%d", &amp;n); read(n); // for (int i = n - 1; i &gt;= 0; i--) scanf("%d", &amp;a[i]); for (int i = n - 1; i &gt;= 0; i--) read(a[i]); static int set[MAXN]; std::copy(a, a + n, set); std::sort(set, set + n); int *end = std::unique(set, set + n); for (int i = 0; i &lt; n; i++) a[i] = std::lower_bound(set, end, a[i]) - set; suffixArray(); sparseTable(); int cnt = 0; for (int i = n - 1; i &gt;= 0; i--) { int pred = queryPred(rk[i]); int succ = querySucc(rk[i]); if (pred != -1 &amp;&amp; succ != -1) cnt -= lcp(pred, succ); if (pred != -1) cnt += lcp(pred, rk[i]); if (succ != -1) cnt += lcp(rk[i], succ); s.insert(rk[i]); // printf("%lld\n", (long long)(n - i) * (n - i + 1) / 2 - cnt); write((long long)(n - i) * (n - i + 1) / 2 - cnt); } // for (int i = 0; i &lt; n; i++) printf("%lld\n", ans[i]); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>BZOJ</tag>
        <tag>后缀数组</tag>
        <tag>COGS</tag>
        <tag>RMQ</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 694」Distinct Substrings - 后缀数组]]></title>
    <url>%2Fspoj-694%2F</url>
    <content type="text"><![CDATA[给定一个字符串，求该字符串含有的本质不同的子串数量。 链接 SPOJ 694 题解 每个子串都是原字符串的某个后缀的前缀，所以我们可以统计每个后缀的前缀数量。在后缀数组中，排名第 的后缀与排名第 的后缀有 个相同的前缀，所以要从答案中减去这些。 设数组下标从 1 开始，则答案为 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXT = 20; const int MAXN = 1000; const int CHARSET_SIZE = 256; char s[MAXN]; int n, sa[MAXN + 1], rk[MAXN + 1], ht[MAXN + 1]; inline void suffixArray() { static int fir[MAXN], sec[MAXN], tmp[MAXN + 1], _buc[MAXN + 2], *buc = _buc + 1; std::fill(sa + 1, sa + n + 1, 0); std::fill(rk + 1, rk + n + 1, 0); std::fill(ht + 1, ht + n + 1, 0); std::fill(fir, fir + n, 0); std::fill(sec, sec + n, 0); std::fill(tmp + 1, tmp + n + 1, 0); std::fill(buc, buc + MAXN + 1, 0); for (int i = 0; i &lt; n; i++) buc[(int)s[i]]++; for (int i = 0; i &lt; CHARSET_SIZE; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) rk[i + 1] = buc[(int)s[i] - 1] + 1; for (int t = 1; t &lt;= n; t &lt;&lt;= 1) { for (int i = 0; i &lt; n; i++) fir[i] = rk[i + 1]; for (int i = 0; i &lt; n; i++) sec[i] = (i + t &gt;= n) ? 0 : fir[i + t]; std::fill(buc, buc + n + 1, 0); for (int i = 0; i &lt; n; i++) buc[sec[i]]++; for (int i = 0; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int i = 0; i &lt; n; i++) tmp[buc[sec[i]]--] = i; std::fill(buc, buc + n + 1, 0); for (int i = 0; i &lt; n; i++) buc[fir[i]]++; for (int i = 0; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int j = n, i; j &gt; 0; j--) i = tmp[j], sa[buc[fir[i]]--] = i + 1; for (int i = 1; i &lt;= n; i++) rk[sa[i]] = i; for (int j = 1, i, last = 0; j &lt;= n; j++, last = i) { i = sa[j] - 1; if (last &amp;&amp; fir[i] == fir[last] &amp;&amp; sec[i] == sec[last]) rk[i + 1] = rk[last + 1]; } } for (int i = 1, t = 0; i &lt;= n; i++) { if (rk[i] == 1) continue; int j = sa[rk[i] - 1]; if (t &gt; 0) t--; while (s[i + t - 1] == s[j + t - 1]) t++; ht[rk[i]] = t; } } int main() { int t; scanf("%d", &amp;t); while (t--) { scanf("%s", s); n = strlen(s); suffixArray(); int ans = 0; for (int i = 1; i &lt;= n; i++) { ans += (n - i + 1) - ht[i]; } printf("%d\n", ans); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组学习笔记]]></title>
    <url>%2Fsuffix-array-notes%2F</url>
    <content type="text"><![CDATA[在 OI 竞赛中，有一类题目是面向字符串的。这类题目往往要求选手的程序快速地求出给定的字符串的某些信息，这就需要一些对应的数据结构和算法来维护字符串。后缀数组就是一个这样的数据结构 —— 它通过对字符串后缀的处理，可以方便地得到子串的信息。 定义 字符串 连续的一段字符组成的串叫做字符串，更广义地，任何一个由可比较大小的元素组成的数组都可称为字符串。字符串的下标从 开始，长度为 。 后缀： 表示字符串 从第 个位置开始的后缀，即由 ~ 组成的子串。 字符串的比较： 两个字符串大小的比较，从首位开始，一位一位地按照 ASCII 码比较，如果从某位置开始不相同，则认为该位置处字符 ASCII 码小的字符串小； 如果一个字符串比较完了最后一位，而另一个没有，则认为前者（长度小的）小； 如果两个字符串长度相同并且所有位置上的字符均相同，则认为两个字符串相等。 注意，同一个字符串的两个后缀是不可能相等的，因为无法满足相等的必要条件长度相同。 后缀数组： 是一个一维数组，保存了对字符串 的所有后缀排序后的结果。 表示第 小的后缀在原串中的起始位置。 名次数组： 是一个一维数组，按起始位置保存了每个后缀在 中的排名。 表示 的排名，即 （第 小的后缀的排名为 ）。 高度数组： 是一个一维数组，保存了相邻两个后缀的最长公共前缀（Longest Common Prefix，LCP）长度。 即 表示存在的最大的 ，满足对于任何 有 。 后缀数组与名次数组的构造 朴素构造算法 如果我们直观地通过定义来构造后缀数组与名次数组（即将每个后缀看做独立的字符串进行快速排序），时间复杂度为 ，但平方级别的复杂度通常是无法承受的。 上述构造方法的瓶颈在于字符串的比较，原串的每个后缀的长度是 级别的，最坏情况下需要 次比较操作才能得到两个后缀的大小关系。 基于 Hash 的优化 考虑对字符串进行 Hash。使用 BKDRHash 算法 地预处理整个字符串后，可以 地得到任意子串的 Hash 值，比较两个子串是否相等。 这样，我们就得到了一个改进算法：比较两个后缀时，二分它们的 LCP 长度，并比较第一位不同的字符，总时间复杂度为 。 使用 Hash 来构造后缀数组的好处在于时间复杂度较低，并且可以动态维护（使用 std::set），坏处在于 Hash 的不稳定性。 倍增算法 上述两个算法，我们都是将两个后缀看做独立字符串进行比较，而忽视了后缀之间的内在联系。一个更优的算法是倍增算法，它的主要思路是，每次利用上一次的结果，倍增计算出从每个位置 开始长度为 的子串的排名。 算法的开始，我们有 "heheda"，从每个位置开始，长度为 的子串的排名分别为： h e h e d a 3 2 3 2 1 0 为了求出长度为 的子串的排名，我们以每个位置 开始，长度为 的子串的排名作为位置 的第一关键字，以每个位置 开始，长度为 的子串的排名作为位置 的第二关键字，进行双关键字排序。 对于 的位置，我们用一个比其他所有值都小的数作为它的第二关键字，即 。 h e h e d a 3 2 3 2 1 0 2 3 2 1 0 -1 4 4 2 1 0 重复以上过程，求出长度为 的子串的排名： h e h e d a 4 3 4 2 1 0 2 1 0 -1 5 3 4 2 1 0 可以看出，这时候 数组的最终值已被求出。而对于任何一组数据，显然可以在最坏情况下 轮上述过程后，求出 数组的最终值。 如果使用快速排序来实现双关键字排序，总时间复杂度为 ，实现难度比 Hash 的方法要低，并且更稳定。而考虑到每个关键字均为 的整数，我们可以使用 的基数排序，来将总时间复杂度将为 。 代码 首先，将原数据进行离散化，保证每个元素的值在 内。 static int set[MAXN + 1], a[MAXN + 1]; std::copy(s + 1, s + n + 1, set + 1); std::sort(set + 1, set + n + 1); int *end = std::unique(set + 1, set + n + 1); for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(set + 1, end, s[i]) - set; fir 和 sec 分别表示第一关键字和第二关键字，buc 表示基数排序所用的桶。关键字的取值范围为 。 static int fir[MAXN + 1], sec[MAXN + 1], tmp[MAXN + 1], buc[MAXN + 1]; 对每个单独的字符进行排序，得到它们的排名。 for (int i = 1; i &lt;= n; i++) buc[a[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int i = 1; i &lt;= n; i++) rk[i] = buc[a[i] - 1] + 1; 进行 次迭代（下文代码均为循环内操作）。 for (int t = 1; t &lt;= n; t *= 2) 设置每个位置的第一、第二关键字。 for (int i = 1; i &lt;= n; i++) fir[i] = rk[i]; for (int i = 1; i &lt;= n; i++) sec[i] = i + t &gt; n ? 0 : rk[i + t]; 对第二关键字进行排序， 存储第 大的第二关键字的所在位置。 注意 --buc[sec[i]] 得到的是一个 的值， 减去它可以得到一个 的值。 std::fill(buc, buc + n + 1, 0); for (int i = 1; i &lt;= n; i++) buc[sec[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int i = 1; i &lt;= n; i++) tmp[n - --buc[sec[i]]] = i; 对第一关键字进行排序，按照 中的顺序依次领取排名，在 中靠前的位置将较早领取排名，而较早领取到的排名较大。 注意 buc[fir[i]]-- 是一个 的值。 std::fill(buc, buc + n + 1, 0); for (int i = 1; i &lt;= n; i++) buc[fir[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int j = 1, i; j &lt;= n; j++) i = tmp[j], sa[buc[fir[i]]--] = i; 按照后缀数组 中的顺序求出名次数组 ，因为中间过程中排名会有并列，所以要分情况讨论： 没有前一名，当前位置的排名为 ； 当前位置和前一名位置的第一、第二关键字均相等，当前位置的排名与前一位置的排名相等； 当前位置和前一名位置的第一或第二关键字不相等，当前位置的排名为前一位置的排名 ； 如果没有并列排名，说明已经排好序，可以提前跳出。 bool unique = true; for (int j = 1, i, last = 0; j &lt;= n; j++) { i = sa[j]; if (!last) rk[i] = 1; else if (fir[i] == fir[last] &amp;&amp; sec[i] == sec[last]) rk[i] = rk[last], unique = false; else rk[i] = rk[last] + 1; last = i; } if (unique) break; 由于倍增算法时间复杂度较为优秀，并且实现难度不高，在实践中较为常用。另外，后缀数组也有线性的构造方法，例如 DC3，但其实现难度较高，实际应用不如倍增算法广。 高度数组的计算 后缀数组的大部分应用，都需要高度数组 的辅助，如果我们按照定义去计算 ，最坏的时间复杂度为 。平方级别的复杂度仍然是无法承受的。 性质 定义 表示从第 个位置开始的后缀与排在其前一名的后缀的最长公共前缀，即当 时，有 对于 ，有一个结论 当 时，结论显然是成立的，下面我们主要考虑 的情况。 令 ，，即排在第 个位置的后缀和排在它前面一位的后缀； 令 ，，即排在第 个位置的后缀和排在它前面一位的后缀。 我们需要证明 。 现在换一个字符串 "heheheda" 作为例子，关系对应如下： 1 heheheda heheda 4 2 eheheda eheda 3 3 heheda heda 2 4 eheda eda 1 5 heda eheheda 0 6 eda da 7 da a 8 a - 当 时， 与 的第一个字符必定相等，同时去掉其第一个字符后，所得的两个新的后缀的最长公共前缀长度为 。这两个后缀不一定是 和 （如果它们排名 不相邻的话），但在后缀数组中，这两个后缀一定确定了一个包含 和 的区间（考虑位置靠前或靠后的后缀的影响），所以，结合下文中关于最长公共前缀的部分内容， 一定不会比它更小。 代码 有了这一性质，我们可以按照 的顺序递推。 设 （即上文的 ），显然在计算每个 时， 每次减小 ，最多增加到 ，所以这个过程的时间复杂度为 。 相对于前面 的过程，线性的复杂度已经不会成为瓶颈。 for (int i = 1, k = 0; i &lt;= n; i++) { if (rk[i] == 1) k = 0; else { if (k &gt; 0) k--; int j = sa[rk[i] - 1]; while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; a[i + k] == a[j + k]) k++; } ht[rk[i]] = k; } 值得注意的是， 的值是无效的，因为排名最靠前的后缀没有前一名。 最长公共前缀 通过高度数组 ，我们可以得到排名相邻的两个后缀的最长公共前缀。 对于排名不相邻的两个后缀，它们的前缀的相似性比相邻后缀要差。显然排名不相邻的两个后缀的最长公共前缀长度一定不会比这两个后缀在后缀数组中确定的一段区间中任意两个相邻后缀的最长公共前缀长度更长。 所以，求出这段区间内最小的 值即为这两个不相邻后缀的最长公共前缀长度。 问题转化为区间最值查询（Range Minimum/Maximum Query，RMQ）问题，可以使用稀疏表（Sparse Table，ST）算法解决。该算法在 的时间内预处理，并在 的时间内完成每个询问。 模板 inline void suffixArray() { static int set[MAXN + 1], a[MAXN + 1]; std::copy(s + 1, s + n + 1, set + 1); std::sort(set + 1, set + n + 1); int *end = std::unique(set + 1, set + n + 1); for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(set + 1, end, s[i]) - set; static int fir[MAXN + 1], sec[MAXN + 1], tmp[MAXN + 1], buc[MAXN + 1]; for (int i = 1; i &lt;= n; i++) buc[a[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int i = 1; i &lt;= n; i++) rk[i] = buc[a[i] - 1] + 1; for (int t = 1; t &lt;= n; t *= 2) { for (int i = 1; i &lt;= n; i++) fir[i] = rk[i]; for (int i = 1; i &lt;= n; i++) sec[i] = i + t &gt; n ? 0 : rk[i + t]; std::fill(buc, buc + n + 1, 0); for (int i = 1; i &lt;= n; i++) buc[sec[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int i = 1; i &lt;= n; i++) tmp[n - --buc[sec[i]]] = i; std::fill(buc, buc + n + 1, 0); for (int i = 1; i &lt;= n; i++) buc[fir[i]]++; for (int i = 1; i &lt;= n; i++) buc[i] += buc[i - 1]; for (int j = 1, i; j &lt;= n; j++) i = tmp[j], sa[buc[fir[i]]--] = i; bool unique = true; for (int j = 1, i, last = 0; j &lt;= n; j++) { i = sa[j]; if (!last) rk[i] = 1; else if (fir[i] == fir[last] &amp;&amp; sec[i] == sec[last]) rk[i] = rk[last], unique = false; else rk[i] = rk[last] + 1; last = i; } if (unique) break; } for (int i = 1, k = 0; i &lt;= n; i++) { if (rk[i] == 1) k = 0; else { if (k &gt; 0) k--; int j = sa[rk[i] - 1]; while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; a[i + k] == a[j + k]) k++; } ht[rk[i]] = k; } }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>后缀数组</tag>
        <tag>稀疏表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDOI2016 Round1 行纪]]></title>
    <url>%2Fsdoi2016-round1%2F</url>
    <content type="text"><![CDATA[第一次参加省选，感觉还是要写点什么比较好吧，哪怕记记流水账 …… Day 0 早上，火车到了济南，打电话问了问老师要坐哪路公交车 …… 到了酒店开了房，感觉还不错 …… 然而老师要到下午才能赶过来 …… 下午正睡觉，老师给我打电话说让我赶紧过去 …… 报道啊啊啊啊 …… 坐公交车去了山师报道 …… 考场在山师附中 …… 路不远这两天不用坐车了吧，走着也没关系诶 …… 下午回去调了道费用流，练练 EK 模板 …… 晚上去超市买了两个士力架，两盒牛奶，一块香皂 …… 回酒店我竟然记得路！果然自己一个人出来一趟学会了认路的技能吗 QwQ …… 晚上调了一道组合数学，还是 yts1999 出的题，%%%！ 睡觉睡不着，又用手机上 Blog 看了看模板 …… Day 1 早上大约七点半到了考点，抽了号 …… 早就知道这里的电脑是 XP 系统，还好之前集训时熟悉的 Windows 下的操作 …… 7:59 准时发题，和 WC 一样是纸质的 …… 喝水看题 …… 第一题：异或？异或有什么性质来着？难道是线性基？肯定不是啊喂 …… 看这样子像个 DP？打个表找找规律吧 …… 30min 过去了 …… …… 然而并没有什么规律，打好 20 分暴力放在一边 …… 第二题：一个数是另一个数的约数 …… 一个数除以另一个数是质数 …… 等等！数据这么大怎么判断质数！Miller – Rabin 我不会啊啊啊啊 …… 写个线性筛 + 试除吧 …… 匹配？收益大于等于零？看起来像是要二分的样子。跑费用流？等等！这是不是二分图啊！ papapa 敲了个二分图染色，跑了 的数据发现是二分图 …… 虽然不会证就当它是吧反正我不会带花树再说了带花树 也过不了啊喂！ 建图还是要先二分图染色再重建的 …… 常数会不会太大？算了就这样吧 …… 几分钟敲了个 EK 模板，还好昨天刚敲过 …… 一个半小时（具体时间记不清了）后样例过了 …… 写对拍 …… 诶这暴力咋写？ 把每个数拆成 个数搞，复杂度爆炸但是对拍足够了吧 …… 半个小时后开始对拍 …… Wrong Answer on Test #7？md 暴力写错了 …… 滚去改 Wrong Answer on Test #13？md 又是暴力写错了 …… 滚去改 然后就是一堆 Accepted …… 先放在那里吧 …… 第三题：树？！我会树剖！ 这标记是什么鬼 …… 根本不会啊 …… 难道是 SegmentTree Beats？先打个暴力吧 …… 每次询问一遍 BFS 相当的暴力，嗯样例能过 …… 部分分有 的点，写个树剖吧 …… …… 十一点半了 …… 树剖写完了，赶紧对拍 …… Wrong Answer on Test #18？缩小数据范围试试 …… 该不会暴力又写错了吧 …… Wrong Answer on Test #32 …… 数据范围够小了手算下 …… 嗯我的树剖写错了 …… md 这线段树什么鬼 …… 改线段树 …… md 我的树剖根本没有计算出 size 啊怎么剖出来的 …… s.top() 接着 s.pop() 蛤？…… 改完树剖已经 12:40 了 …… 对拍终于不出错了 …… 回去看 T2 …… maya 忘了写静态内存了 …… 改改改 …… T2 复杂度有点大？就当他是 跑得出 吧 …… 来组 试试 …… 答案好几万，跑了 1.5s …… 啊啊啊啊啊啊啊啊啊怎么办来不及优化了啊 …… 算了，T 就 T 吧 …… 回去检查检查文件 …… 下午知道了成绩，140，rank9，还算可以吧 …… heheda AK 了！ std rank2！ …… 感觉明天要考字符串、反演、法法塔之类的 …… 啥都不会，药丸啊 …… 晚上赶紧写了个 KMP 模板 …… 也许明天打暴力用得到？ 其实，Day1 成绩好未必是一件好事？起点越高，失败后便摔得越惨吧。 但愿 Day2 不会滚粗。 Day 2 今天不用抽号了，去的晚一点没关系 …… 7:50 进了考场 wow 昨天的目录还在，不用重新写对拍了诶 …… 7:57 准时发题 …… 喝水看题 …… 第一题：maya这不是集训原题的弱化版吗！完了我不会啊啊啊啊怎么办，暴力后缀数组能有 60 分啊啊啊啊，他们肯定至少能写出来 60 分啊啊啊啊，今天注定滚粗了啊啊啊啊啊 先打个 30 分暴力吧，std::set&lt; std::vector&lt;int&gt; &gt; 够暴力吧 …… 第二题：maya计数问题！前段时间写过不少类似的题吧，推推式子看 …… 我们先来求没有稳定数的排列数 …… 然后至少一个稳定的排列数量 …… 诶这个好像要容斥？ 二十分钟后，脑海里一片空白 …… 这种题他们肯定都会啊，我怎么就是想不出来啊啊啊啊，第一题怎么办 …… 先打个 10 分暴力吧 …… 枚举全排列 …… 第三题：好像是个 DP？10 分可以爆搜？ 的划分 DP 可以 30 分？不管了，先回去想想第一题吧 …… 也许还有希望 …… 嗯 …… 后缀数组，先用 std::sort 写个暴力后缀数组再说 …… 好像求出 height 可以统计子串数？让我想想 …… height 表示排名相邻两个后缀的最长公共前缀长度 …… 这个好像可以线性递推？不管了，写个暴力吧 …… 于是我有了一个 的后缀数组 …… 让我想想，每个后缀对答案的贡献是 …… 1.5h 过去了，终于把暴力后缀数组写完，暴力求 height 写完，统计子串数量写完 …… 手敲了一组大数据，答案和暴力结果一样，感觉推导的应该没问题 …… 求 height 明显复杂度太高吧？让我想想怎么线性递推 …… 对于某个后缀的 height，当这个后缀与前一个后缀的首个字符相等时，结果为后一个字符所对应后缀的 height + 1，否则为 0 …… 用 "heheda" 作为例子手算了一下，感觉没问题 …… 恩好像没问题，就这样写吧 …… 实在不知道递推顺序，就记忆搜索吧 …… 嗯，让我想想后缀数组复杂度能不能降一降，写个倍增试试？ 倍增的框架敲上了，想想怎么基数排序来着 …… 怎么基数排序来着 …… 将近半个小时过去了，还是没想到怎么基数排序 …… 算了吧，直接丢给 std::sort 做双关键字吧！ 于是我的后缀数组变成了 …… 让我再试组数据 …… 啊啊啊啊啊怎么和暴力结果不一样啊！！！ 后缀数组把倍增换成原来的暴力排序，结果还是不对 …… 难道是 height 求错了？ 改成原来的平方暴力 …… 嗯，好像是对的 …… maya我递推式推错了 …… 怎么办怎么办怎么办！ 看了看时间已经十一点半多了 …… 算了吧，换成平方暴力！ 后缀数组的复杂度定格为 …… 瓶颈依然是 height 的平方 …… 药丸 …… 赶紧写第三题！ 乘上一个整数表示方差？看来要维护两个信息啊 …… 和的平方与平方的和 …… 啥玩意 …… 还是记忆搜索吧 …… 写完自认为能有 30 分的 DP 之后已经 12:40 了 …… 赶紧测测样例，maya样例不过啊 …… 输出中间结果试试 …… maya除不开啊 …… 一定是我式子推错了吧 …… 赶紧换成 double 就算精度炸了说不定还有希望啊 …… 恩就这样吧 …… 样例总算过了 …… 12:50，赶紧检查一下前两题，文件输入输出写好 …… 关文件 …… 调试代码去掉 …… maya第二题的表打错了啊啊啊赶紧重新打 …… 13:00 结束 …… 深感药丸 …… 听讲题 …… Day1 T1 数位DP？ T2 好像我的做法不是正解？正解没有二分 …… 怪不得跑这么慢 …… T3 有点类似超哥线段树的东西？不懂啊 Orz Day2 T1 后缀自动机裸题？后缀数组搞一搞就好？ 唉后悔没学后缀数组了 …… T2 叫什么错位排列？maya我就剩一点容斥就能推出 60 分做法了啊啊啊啊啊 …… T3 斜率优化？好像我暴力的式子也推错了 …… 爆零啦 …… 成绩出来了 …… 90 分滚粗 …… 直接掉到 60 多名了 …… 果然 Day1 的 Flag 生效了？ 下午坐火车走了，晚上回到了临沂 ……]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「POJ 3461」Oulipo - KMP]]></title>
    <url>%2Fpoj-3461%2F</url>
    <content type="text"><![CDATA[给出两个字符串，求一个字符串在另一个字符串中的出现次数。 题解 KMP 裸题，拿来练练模板 …… 注意 next 千万不要声明成 char 型，别问我为什么要说这个 …… 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; const int MAXN = 10000; const int MAXM = 1000000; int m, n, next[MAXN + 1]; char s[MAXM + 1], p[MAXN + 1]; inline void getNext() { next[0] = -1; for (int i = 0, j = -1; i &lt; n; ) { if (j == -1 || p[i] == p[j]) next[++i] = ++j; else j = next[j]; } } inline int kmp() { getNext(); int ans = 0; for (int i = 0, j = 0; i &lt; m; ) { if (j == -1 || s[i] == p[j]) i++, j++; else j = next[j]; if (j == n) ans++, j = next[j]; } return ans; } int main() { int t; scanf("%d", &amp;t), getchar(); while (t--) { gets(p); gets(s); n = strlen(p); m = strlen(s); // n = readLine(p); // m = readLine(s); printf("%d\n", kmp()); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法模板</tag>
        <tag>KMP</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2016」数字配对 - 费用流]]></title>
    <url>%2Fsdoi2016-pair%2F</url>
    <content type="text"><![CDATA[有 种数字，第 种数字是 、有 个，权值是 。 若两个数字 、 满足， 是 的倍数，且 是一个质数，那么这两个数字可以配对，并获得 的价值。 一个数字只能参与一次配对，可以不参与配对。 在获得的价值总和不小于 的前提下，求最多进行多少次配对。 链接 BZOJ 4514 COGS 2221 题解 线性筛预处理质数（到 肯定够用了），用试除法判断质数，可以匹配的数字连边，做一遍二分图染色。 源点到所有 点连边，容量为 费用为 ；所有 点向汇点连边，容量为 费用为 ；可以匹配的数字从 点向 点连边，容量为无穷大，费用为 。 先求出整张网络的最大流作为二分的上界。然后建立超级源点，并从超级源点向源点连边，二分这条边的容量，用费用流检验，如果费用 说明可行。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; const int MAXN = 200; const int MAXA = 1e9; const int MAXP = 1e6; struct Node; struct Edge; struct Node { Edge *e, *in; int c, f; long long d; bool q; } N[MAXN + 3]; struct Edge { Node *s, *t; int f, c; long long w; Edge *next, *r; Edge(Node *s, Node *t, const int c, const long long w) : s(s), t(t), f(0), c(c), w(w), next(s-&gt;e) {} } *limE; template &lt;typename T, size_t SIZE&gt; struct MemoryPool { char buf[SIZE * sizeof(T)], *cur; MemoryPool() { reset(); } void reset() { cur = buf; } T *alloc() { if (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T)); else { char *p = cur; cur += sizeof(T); return (T *)p; } } }; MemoryPool&lt;Edge, MAXN * MAXN * 10&gt; pool; inline Edge *addEdge(int u, int v, const int c, const long long w) { // printf("E(%d, %d, %d, %d)\n", u, v, c, w); N[u].e = &amp;(*(pool.alloc()) = Edge(&amp;N[u], &amp;N[v], c, w)); N[v].e = &amp;(*(pool.alloc()) = Edge(&amp;N[v], &amp;N[u], 0, -w)); N[u].e-&gt;r = N[v].e, N[v].e-&gt;r = N[u].e; return N[u].e; } inline void edmondskarp(const int s, const int t, const int n, int &amp;flow, long long &amp;cost) { flow = cost = 0; while (1) { for (int i = 0; i &lt; n; i++) { N[i].q = false; N[i].in = NULL; N[i].f = 0; N[i].d = LLONG_MAX; } std::queue&lt;Node *&gt; q; q.push(&amp;N[s]); N[s].d = 0, N[s].f = INT_MAX; while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;q = false; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;f &lt; e-&gt;c &amp;&amp; e-&gt;t-&gt;d &gt; v-&gt;d + e-&gt;w) { e-&gt;t-&gt;d = v-&gt;d + e-&gt;w; e-&gt;t-&gt;in = e; e-&gt;t-&gt;f = std::min(v-&gt;f, e-&gt;c - e-&gt;f); if (!e-&gt;t-&gt;q) { e-&gt;t-&gt;q = true; q.push(e-&gt;t); } } } } if (N[t].d == LLONG_MAX) return; for (Edge *e = N[t].in; e; e = e-&gt;s-&gt;in) { e-&gt;f += N[t].f; e-&gt;r-&gt;f -= N[t].f; } flow += N[t].f; cost += N[t].f * N[t].d; // printf("cost = %d\n", -cost); } } int n, s, ss, t; struct Number { int a, b, c, t; bool operator&lt;(const Number &amp;o) const { return a &lt; o.a; } } a[MAXN + 1]; inline void color() { for (int i = 1; i &lt;= n; i++) { if (N[i].c != 0) continue; std::queue&lt;Node *&gt; q; q.push(&amp;N[i]); N[i].c = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;t-&gt;c == 0) { e-&gt;t-&gt;c = (v-&gt;c == 1) ? -1 : 1; q.push(e-&gt;t); } else { // if (e-&gt;t-&gt;c == v-&gt;c) throw; } } } } } inline bool check(const int limit) { for (int i = 0; i &lt; n + 3; i++) { for (Edge *e = N[i].e; e; e = e-&gt;next) { e-&gt;f = 0; } } limE-&gt;c = limit; int flow; long long cost; edmondskarp(ss, t, n + 3, flow, cost); // printf("cost = %d\n", cost); return cost &lt;= 0; } inline int solve() { limE-&gt;c = INT_MAX; int flow; long long cost; edmondskarp(ss, t, n + 3, flow, cost); int l = 0, r = flow; while (l &lt; r) { // printf("(%d, %d)\n", l, r); int mid = l + ((r - l) &gt;&gt; 1) + 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } bool isNotPrime[MAXP + 1]; int primes[MAXP], cnt; inline void euler() { isNotPrime[0] = isNotPrime[1] = true; for (int i = 2; i &lt;= MAXP; i++) { if (!isNotPrime[i]) { primes[cnt++] = i; } for (int j = 0; j &lt; cnt; j++) { if (primes[j] * i &gt; MAXP) break; isNotPrime[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } inline bool isPrime(const int x) { if (x &lt;= MAXP &amp;&amp; isNotPrime[x]) return false; if (x == 1) return false; for (int i = 0; i &lt; cnt; i++) { int &amp;p = primes[i]; if (p * p &gt; x) return true; if (x % p == 0) return false; } return true; } int main() { freopen("pair.in", "r", stdin); freopen("pair.out", "w", stdout); euler(); scanf("%d", &amp;n); int sum = 0; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i].a); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i].b), sum += a[i].b; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i].c); std::sort(a + 1, a + n + 1); bool valid[MAXN + 1][MAXN + 1]; for (int i = 1; i &lt;= n; i++) { Number &amp;xi = a[i]; for (int j = 1; j &lt; i; j++) { Number &amp;xj = a[j]; if (xi.a % xj.a == 0 &amp;&amp; isPrime(xi.a / xj.a)) { valid[i][j] = true; addEdge(i, j, 0, 0); } } } color(); for (int i = 1; i &lt;= n; i++) { a[i].t = N[i].c; N[i].e = NULL; } pool.reset(); s = 0, ss = n + 1, t = n + 2; for (int i = 1; i &lt;= n; i++) { Number &amp;xi = a[i]; for (int j = 1; j &lt; i; j++) { Number &amp;xj = a[j]; if (valid[i][j]) { // if (xi.t == xj.t) puts("failed!"); if (xi.t == 1) { addEdge(i, j, INT_MAX, -(long long)xi.c * xj.c); } else { addEdge(j, i, INT_MAX, -(long long)xi.c * xj.c); } } } if (N[i].c == 1) { addEdge(s, i, xi.b, 0); } else { addEdge(i, t, xi.b, 0); } } limE = addEdge(ss, s, sum, 0); printf("%d\n", solve()); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>Edmonds-Karp</tag>
        <tag>费用流</tag>
        <tag>数论</tag>
        <tag>COGS</tag>
        <tag>线性筛</tag>
        <tag>二分答案</tag>
        <tag>SDOI</tag>
        <tag>素数判定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4403」序列统计 - 组合数]]></title>
    <url>%2Fbzoj-4403%2F</url>
    <content type="text"><![CDATA[给定三个正整数 、 和 ，统计长度在 到 之间，元素大小都在 到 之间的单调不降序列的数量。输出答案对 取模的结果。 链接 BZOJ 4403 题解 问题等价于，从 中选择 个数（可重复）的方案数。 设 答案为 直接算组合数会超时，需要用 Lucas 定理 当 时，直接使用公式计算即可。 不要预处理逆元，用到的时候用费马小定理计算即可。 代码 #include &lt;cstdio&gt; const int MAXN = 1e9; const int MOD = 1e6 + 3; const int PHI_MOD = MOD - 1; long long fac[MOD]; inline long long pow(const long long x, const long long n) { long long ans = 1; for (long long num = x, t = n; t; num = num * num % MOD, t &gt;&gt;= 1) if (t &amp; 1) ans = ans * num % MOD; return ans; } inline void makeTable() { fac[0] = 1; for (int i = 1; i &lt; MOD; i++) fac[i] = fac[i - 1] * i % MOD; } inline long long inv(const long long x) { return pow(x, PHI_MOD - 1); } long long lucas(const int n, const int m) { if (n &lt; m) return 0; else if (n &lt; MOD &amp;&amp; m &lt; MOD) return fac[n] * inv(fac[m]) % MOD * inv(fac[n - m]) % MOD; return lucas(n / MOD, m / MOD) * lucas(n % MOD, m % MOD) % MOD; } inline int solve(const int n, const int l, const int r) { return ((lucas(n + r - l + 1, r - l + 1) - 1) + MOD) % MOD; } int main() { makeTable(); int t; scanf("%d", &amp;t); while (t--) { int n, l, r; scanf("%d %d %d", &amp;n, &amp;l, &amp;r); printf("%d\n", solve(n, l, r)); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>数论</tag>
        <tag>Lucas 定理</tag>
        <tag>乘法逆元</tag>
        <tag>组合数</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2014」支线剧情 - 费用流]]></title>
    <url>%2Fahoi2014-story%2F</url>
    <content type="text"><![CDATA[游戏中有 个剧情点，由 到 编号，第 个剧情点可以经过不同的支线剧情，前往 种不同的新的剧情点。当然如果为 ，则说明 号剧情点是游戏的一个结局了。 开始处在 号剧情点。任何一个剧情点都是从 号剧情点可达的。从任意剧情点出发，都不能再回到这个剧情点。要想回到之前的剧情点，唯一的方法就是开始新的游戏，回到 号剧情点。可以在任何时刻退出游戏并重新开始。求花费最少的时间，看完所有不同的支线剧情。 链接 BZOJ 3876 题解 题目是一个这样的模型：给出一个带权 DAG，从每个点均可回到 1 号点且不需要花费，求从 1 号点出发遍历整个 DAG 的最小花费。 建立有上下界的费用流模型。 对于原图中的每条边 ，转化为 表示可以经过一次或多次这条边。对于不是 号点的任意一点 ，连接 表示在任意一点可无限次回到 号点。 考虑去掉容量下界，对于原图中的每条边 ，连接 ，表示这条边至少被走一次，连接 表示把从源点强行流给 的流量补给汇点。 实际上， 类型的边是可以合并的，实现时只需要连边 。 代码 #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;climits&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; const int MAXN = 300; const int MAXK = 50; struct Node; struct Edge; struct Node { Edge *e, *in; int f, d; bool q; } N[MAXN + 2]; struct Edge { Node *s, *t; int f, c, w; Edge *next, *r; Edge(Node *const s, Node *const t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s-&gt;e) {} }; template &lt;typename T, size_t SIZE&gt; struct MemoryPool { char buf[SIZE * sizeof(T)], *cur; MemoryPool() : cur(buf) {} T *alloc() { if (cur == buf + (SIZE * sizeof(T))) return (T *)malloc(sizeof(T)); else { char *p = cur; cur += sizeof(T); return (T *)p; } } }; MemoryPool&lt;Edge, MAXN * MAXK * 5&gt; pool; inline void addEdge(const int s, const int t, const int c, const int w) { N[s].e = &amp;(*(pool.alloc()) = Edge(&amp;N[s], &amp;N[t], c, w)); N[t].e = &amp;(*(pool.alloc()) = Edge(&amp;N[t], &amp;N[s], 0, -w)); N[s].e-&gt;r = N[t].e, N[t].e-&gt;r = N[s].e; } inline void edmondskarp(const int s, const int t, const int n, int &amp;flow, int &amp;cost) { flow = cost = 0; while (1) { for (int i = 0; i &lt; n; i++) { N[i].q = false; N[i].in = NULL; N[i].f = 0; N[i].d = INT_MAX; } N[s].f = INT_MAX, N[s].d = 0; std::queue&lt;Node *&gt; q; q.push(&amp;N[s]); while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;q = false; for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;f &lt; e-&gt;c &amp;&amp; e-&gt;t-&gt;d &gt; v-&gt;d + e-&gt;w) { e-&gt;t-&gt;d = v-&gt;d + e-&gt;w; e-&gt;t-&gt;in = e; e-&gt;t-&gt;f = std::min(v-&gt;f, e-&gt;c - e-&gt;f); if (!e-&gt;t-&gt;q) { e-&gt;t-&gt;q = true; q.push(e-&gt;t); } } } } if (N[t].d == INT_MAX) return; for (Edge *e = N[t].in; e; e = e-&gt;s-&gt;in) { e-&gt;f += N[t].f; e-&gt;r-&gt;f -= N[t].f; } flow += N[t].f, cost += N[t].d * N[t].f; } } int n; int main() { scanf("%d", &amp;n); const int s = 0, t = n + 1; for (int u = 1, k; u &lt;= n; u++) { scanf("%d", &amp;k); for (int j = 0, v, w; j &lt; k; j++) { scanf("%d %d", &amp;v, &amp;w); addEdge(u, v, INT_MAX, w); addEdge(s, v, 1, w); } addEdge(u, t, k, 0); if (u != 1) addEdge(u, 1, INT_MAX, 0); } int flow, cost; edmondskarp(s, t, n + 2, flow, cost); printf("%d\n", cost); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>AHOI</tag>
        <tag>BZOJ</tag>
        <tag>Edmonds-Karp</tag>
        <tag>上下界网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 std::stack 实现非递归 DFS]]></title>
    <url>%2Fnon-recursion-dfs-with-stack%2F</url>
    <content type="text"><![CDATA[众所周知，在有些省份（比如山东、河南），省选时使用 Windows 垃圾系统评测，而 Windows 下默认的系统栈非常小（只有 1M），这造成了有些 DFS 相关算法无法通过极端数据，而是发生『栈溢出』的错误。一种解决方法是使用非递归的 DFS。 框架 我们通常这样实现递归 DFS： void dfs(Iterator x) { x-&gt;visited = true; x-&gt;initialization(); for (Iterator i = x-&gt;subIterators.begin(); i != x-&gt;subIterators.end(); i++) { if (!i-&gt;visited) { x-&gt;pushDown(i); dfs(i); x-&gt;pushUpBack(); } else x-&gt;pushUp(i); } x-&gt;exit(); } 第一次访问每个元素时，标记它为访问过，并对其进行初始化操作；枚举所有子元素，分为『未访问过』和『已访问过』分别进行处理。 为了将这个过程转化为非递归，我们使用一个栈来存储 DFS 搜索树上的一条链。 void dfs(Iterator start) { std::stack&lt;Iterator&gt; s; s.push(start); start-&gt;pushed = true; while (!s.empty()) { Iterator x = s.top(); if (!x-&gt;visited) { x-&gt;visited = true; x-&gt;initialization(); x-&gt;currentSubIterator = x-&gt;subIterators.begin(); } if (x-&gt;currentSubIterator != x-&gt;subIterators.end()) { Iterator &amp;i = x-&gt;currentSubIterator; if (!i-&gt;pushed) { x-&gt;pushDown(i); i-&gt;predecessor = x; i-&gt;pushed = true; s.push(i); } else { x-&gt;pushUp(i); } i++; } else { x-&gt;exit(); x-&gt;predecessor-&gt;pushUpBack(i); s.pop(); } } } Tarjan 强连通分量模板 struct Node { Edge *firstEdge, *currentEdge, *inEdge; Connected *connected; int dfn, low; bool inStack, visited, pushed; } nodes[MAXN]; struct Edge { Node *from, *to; Edge *next; Edge(Node *from, Node *to) : from(from), to(to), next(from-&gt;firstEdge) {} }; struct Connected { int size; } connecteds[MAXN]; int n; inline int tarjan() { int timeStamp = 0, count = 0; for (int i = 0; i &lt; n; i++) { if (nodes[i].visited) continue; std::stack&lt;Node *&gt; s, t; s.push(&amp;nodes[i]); nodes[i].pushed = true; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; v-&gt;currentEdge = v-&gt;firstEdge; v-&gt;dfn = v-&gt;low = timeStamp++; v-&gt;inStack = true; t.push(v); } if (v-&gt;currentEdge) { Edge *&amp;e = v-&gt;currentEdge; if (!e-&gt;to-&gt;pushed) s.push(e-&gt;to), e-&gt;to-&gt;pushed = true, e-&gt;to-&gt;inEdge = e; else if (e-&gt;to-&gt;inStack) v-&gt;low = std::min(v-&gt;low, e-&gt;to-&gt;dfn); e = e-&gt;next; } else { if (v-&gt;dfn == v-&gt;low) { v-&gt;connected = &amp;connecteds[count++]; Node *u; do { u = t.top(); t.pop(); u-&gt;inStack = false; u-&gt;connected = v-&gt;connected; u-&gt;connected-&gt;size++; } while (u != v); } if (v-&gt;inEdge) v-&gt;inEdge-&gt;from-&gt;low = std::min(v-&gt;inEdge-&gt;from-&gt;low, v-&gt;low); s.pop(); } } } return count; } 树链剖分模板 树链剖分的 DFS 过程比较特殊，我们可以每次将一个节点的所有子节点压入栈中，所有子树全部遍历完后回溯回来上传信息。 struct Node { Edge *e; Node *c, *p; int size, pos, posEnd; bool visited; Path *path; } N[MAXN]; struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {} }; struct Path { Node *top; Path(Node *top) : top(top) {} }; inline void cut() { std::stack&lt;Node *&gt; s; s.push(&amp;N[0]); while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;p == NULL &amp;&amp; e-&gt;t != v-&gt;p) e-&gt;t-&gt;p = v, s.push(e-&gt;t); } else { v-&gt;size = 1; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;p == v) { v-&gt;size += e-&gt;t-&gt;size; if (v-&gt;c == NULL || v-&gt;c-&gt;size &lt; e-&gt;t-&gt;size) v-&gt;c = e-&gt;t; } s.pop(); } } for (int i = 0; i &lt; n; i++) N[i].visited = false; s.push(&amp;N[0]); int time = -1; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; v-&gt;pos = ++time; if (!v-&gt;p || v != v-&gt;p-&gt;c) v-&gt;path = new Path(v); else v-&gt;path = v-&gt;p-&gt;path; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;p == v &amp;&amp; e-&gt;t != v-&gt;c) s.push(e-&gt;t); if (v-&gt;c) s.push(v-&gt;c); } else v-&gt;posEnd = time, s.pop(); } }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>算法模板</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>DFS</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性筛法筛素数、莫比乌斯函数、欧拉函数]]></title>
    <url>%2Feuler-sieve%2F</url>
    <content type="text"><![CDATA[线性筛法（欧拉筛法）可以在 的时间内获得 的所有素数。算法保证每个合数都会被它的最小质因子筛掉，所以复杂度是线性的。同时，我们可以利用这一特性，结合积性函数的性质，在 的时间内筛出一些积性函数的值。 欧拉函数 欧拉函数 的定义为：小于 的正整数中与 互质的数的个数，。 当 为质数时，根据定义，显然有 。 设 ，其中 为素数，则有 设 为 最小质因子，，在线性筛中， 通过 被筛掉。 当 ，即 时， 含有 的所有质因子，则有 当 ，即 时， 与 互质，根据积性函数的性质有 莫比乌斯函数 莫比乌斯函数 的定义： 设 ，其中 为素数 当 为质数时，根据定义，显然有 。 设 为 最小质因子，，在线性筛中， 通过 被筛掉。 当 ，即 时，由定义得 当 ，即 时， 有 个质因子，此时我们分情况讨论，若 ，即 的所有质因子次数均为 ，根据定义有 若 ，说明 ，根据定义显然有 此时 仍然成立。 模板 bool isNotPrime[MAXN + 1]; int mu[MAXN + 1], phi[MAXN + 1], primes[MAXN + 1], cnt; inline void euler() { isNotPrime[0] = isNotPrime[1] = true; mu[1] = 1; phi[1] = 1; for (int i = 2; i &lt;= MAXN; i++) { if (!isNotPrime[i]) { primes[++cnt] = i; mu[i] = -1; phi[i] = i - 1; } for (int j = 1; j &lt;= cnt; j++) { int t = i * primes[j]; if (t &gt; MAXN) break; isNotPrime[t] = true; if (i % primes[j] == 0) { mu[t] = 0; phi[t] = phi[i] * primes[j]; break; } else { mu[t] = -mu[i]; phi[t] = phi[i] * (primes[j] - 1); } } } }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>数论</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2011」Problem b - 莫比乌斯反演]]></title>
    <url>%2Fhaoi2011-problemb%2F</url>
    <content type="text"><![CDATA[对于给出的 个询问，每次求有多少个数对 ，满足 ，，且 ，函数为 和 的最大公约数。 链接 BZOJ 2301 COGS 548 题解 问题为：求 设 根据容斥原理，答案即为 现在的问题就是求出 函数的值 设 构造函数 由莫比乌斯反演得 这时候我们已经可以暴力计算 了 int ans = 0; for (int d = 1; d &lt;= (n / k); d++) { ans += mu[d] * (n / (k * d)) * (m / (k * d)); } 但是这样的复杂度还是会超时的，我们考虑分块计算。 注意到我们的代码中多次出现了形如 的式子，考虑构造一个新函数 此时的 已经可以分块计算了，通过预处理 的前缀和，我们可以在 的时间内回答一组询问。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXT = 50000; const int MAXN = 50000; const int MAXK = 50000; bool isNotPrime[MAXN + 1]; int mu[MAXN + 1], s[MAXN + 1], primes[MAXN + 1], cnt; inline void getPrimes() { isNotPrime[0] = isNotPrime[1] = true; mu[1] = 1; for (int i = 2; i &lt;= MAXN; i++) { if (!isNotPrime[i]) { primes[cnt++] = i; mu[i] = -1; } for (int j = 0; j &lt; cnt; j++) { int t = i * primes[j]; if (t &gt; MAXN) break; isNotPrime[t] = true; if (i % primes[j] == 0) { mu[t] = 0; break; } else mu[t] = -mu[i]; } } for (int i = 1; i &lt;= MAXN; i++) s[i] = s[i - 1] + mu[i]; } inline int gcd(const int a, const int b) { return !b ? a : gcd(b, a % b); } inline int solve(int n, int m, const int k) { if (n &gt; m) std::swap(n, m); n /= k, m /= k; int ans = 0; for (int l = 1, r; l &lt;= n; l = r + 1) { r = std::min(n / (n / l), m / (m / l)); ans += (s[r] - s[l - 1]) * ((n / l) * (m / l)); } return ans; /*int ans = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (gcd(i, j) == k) ans++; return ans;*/ /*int ans = 0; for (int d = 1; d &lt;= (n / k); d++) { ans += mu[d] * (n / (k * d)) * (m / (k * d)); }*/ // printf("solve(%d, %d, %d) = %d\n", n, m, k, ans); return ans; } inline int solve(const int a, const int b, const int c, const int d, const int k) { return solve(b, d, k) - solve(a - 1, d, k) - solve(b, c - 1, k) + solve(a - 1, c - 1, k); } int main() { getPrimes(); int t; scanf("%d", &amp;t); while (t--) { int a, b, c, d, k; scanf("%d %d %d %d %d", &amp;a, &amp;b, &amp;c, &amp;d, &amp;k); printf("%d\n", solve(a, b, c, d, k)); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>数论</tag>
        <tag>COGS</tag>
        <tag>线性筛</tag>
        <tag>莫比乌斯反演</tag>
        <tag>HAOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2820」YY的GCD - 莫比乌斯反演]]></title>
    <url>%2Fbzoj-2820%2F</url>
    <content type="text"><![CDATA[求 ， 且 为质数的 数量。 链接 BZOJ 2820 题解 首先，我们只需要处理 的情况，当 的情况只需要交换 和 即可。 设小于 质数为 ，则答案为 根据莫比乌斯反演，我们有 令 ，我们在外层枚举 然后对每个质因子计算 设 考虑线性筛求 的过程，当 时 当 时 线性筛后分块处理即可。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;vector&gt; const int MAXT = 10000; const int MAXN = 10000000; const int MAXM = 10000000; bool isNotPrime[MAXN + 1]; int miu[MAXN + 1], f[MAXN + 1], s[MAXN + 1]; std::vector&lt;int&gt; primes; inline void getPrimes() { primes.reserve(MAXN); isNotPrime[0] = isNotPrime[1] = true; for (int i = 2; i &lt;= MAXN; i++) { if (!isNotPrime[i]) { primes.push_back(i); miu[i] = -1; f[i] = 1; } for (std::vector&lt;int&gt;::const_iterator p = primes.begin(); p != primes.end() &amp;&amp; i * *p &lt;= MAXN; p++) { isNotPrime[i * *p] = true; if (i % *p == 0) { miu[i * *p] = 0; f[i * *p] = miu[i]; break; } else { miu[i * *p] = -miu[i]; f[i * *p] = miu[i] - f[i]; } } } for (int i = 1; i &lt;= MAXN; i++) s[i] = s[i - 1] + f[i]; } inline long long solve(const int n, const int m) { long long ans = 0; for (int l = 1, r; l &lt;= n; l = r + 1) { r = std::min(n / (n / l), m / (m / l)); ans += (s[r] - s[l - 1]) * static_cast&lt;long long&gt;(n / l) * static_cast&lt;long long&gt;(m / l); } return ans; } int main() { getPrimes(); int t; scanf("%d", &amp;t); while (t--) { int n, m; scanf("%d %d", &amp;n, &amp;m); if (n &gt; m) std::swap(n, m); printf("%lld\n", solve(n, m)); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>BZOJ</tag>
        <tag>数论</tag>
        <tag>线性筛</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3511」土地划分 - 最小割]]></title>
    <url>%2Fbzoj-3511%2F</url>
    <content type="text"><![CDATA[给定一张 个点 条边的无向连通图，初始时 号点属于集合 ， 号点属于集合 。现在要将其他点划分进两个集合，并使得评分最高，评分方式如下： 对于点 ，划给 集合得 分，划给 集合得 分； 对于一条边 ，若它连接两个 集合点，则得 分，若它连接两个 集合点，则得 分，否则将扣除 分。 链接 BZOJ 3511 题解 建立最小割模型，使 集合的点与 连通， 集合的点与 连通。 对于每个点 ，连边 ，割掉这条边表示它不被放在 集合中；连边 ，割掉这条边表示它不被放在 集合中。 对于已经确定的点 和点 ，连两条容量为正无穷的边 和 ，这两条边都不会被割掉。 对于原图中的每条边，将其转化为容量为 的双向边，并对于两个端点，连接 。 如果两个端点都在 集合中，那么两条容量为 的边会被割掉，如果两个端点都在 集合中，那么两条容量为 的边会被割掉，否则会割掉一条容量为 ，一条容量为 的边，并且中间的边也会被割掉。 求出最小割即为损失， 减去损失即为答案。 输入的数字可能有奇数，可以把所有数字乘以二再进行处理。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 10000; const int MAXM = 40000; struct Node; struct Edge; struct Node { Edge *e, *c; int l; } N[MAXN + 2]; struct Edge { Node *s, *t; int f, c; Edge *next, *r; Edge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s-&gt;e) {} }; template &lt;typename T, size_t SIZE&gt; struct MemoryPool { char buf[SIZE * sizeof(T)], *cur; MemoryPool() : cur(buf) {} T *alloc() { if (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T)); else { T *p = (T *)cur; cur += sizeof(T); return p; } } }; int n, m; MemoryPool&lt;Edge, MAXM * 5 * 2 + MAXN * 2 * 2&gt; pool; struct Dinic { bool makeLevelGraph(Node *s, Node *t, const int n) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;l == 0 &amp;&amp; e-&gt;f &lt; e-&gt;c) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } return false; } int findPath(Node *s, Node *t, int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) { if (e-&gt;t-&gt;l == s-&gt;l + 1 &amp;&amp; e-&gt;f &lt; e-&gt;c) { int f = findPath(e-&gt;t, t, std::min(limit, e-&gt;c - e-&gt;f)); if (f &gt; 0) { e-&gt;f += f, e-&gt;r-&gt;f -= f; return f; } } } return 0; } int operator()(const int s, const int t, const int n) { int ans = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) ans += f; } return ans; } } dinic; inline void addEdge(const int s, const int t, const int c, const int rc = 0) { N[s].e = &amp;(*(pool.alloc()) = Edge(&amp;N[s], &amp;N[t], c)); N[t].e = &amp;(*(pool.alloc()) = Edge(&amp;N[t], &amp;N[s], rc)); N[s].e-&gt;r = N[t].e, N[t].e-&gt;r = N[s].e; } int main() { scanf("%d %d", &amp;n, &amp;m); int sum = 0; const int s = 0, t = n + 1; addEdge(s, 1, INT_MAX), addEdge(n, t, INT_MAX); for (int i = 2; i &lt;= n - 1; i++) { int va; scanf("%d", &amp;va), va *= 2; sum += va; addEdge(s, i, va); } for (int i = 2; i &lt;= n - 1; i++) { int vb; scanf("%d", &amp;vb), vb *= 2; sum += vb; addEdge(i, t, vb); } for (int i = 0; i &lt; m; i++) { int u, v, ea, eb, ec; scanf("%d %d %d %d %d", &amp;u, &amp;v, &amp;ea, &amp;eb, &amp;ec); ea *= 2, eb *= 2, ec *= 2; sum += ea, sum += eb; int c = (ea / 2 + eb / 2 + ec); addEdge(u, v, c, c); addEdge(s, u, ea / 2), addEdge(s, v, ea / 2); addEdge(u, t, eb / 2), addEdge(v, t, eb / 2); } int minCut = dinic(s, t, n + 2); printf("%d\n", (sum - minCut) / 2); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>安徽集训</tag>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2008」越狱 - 计数原理]]></title>
    <url>%2Fbzoj-1008%2F</url>
    <content type="text"><![CDATA[监狱有连续编号为 的 个房间，每个房间关押一个犯人，有M种宗教，每个犯人可能信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。 链接 BZOJ 1008 题解 考虑计算「不会越狱的方案数」，用「方案总数」减去「不会越狱的方案数」即可。 方案总数：一共 个位置，每个位置有 种选择，总方案数为 。 不会越狱的方案数：第一个位置有 种选择，之后每个位置都不能与上一个位置相同，即有 种选择，方案数为 。 所以答案为 。 代码 #include &lt;cstdio&gt; const long long MAXN = 1e12; const long long MAXM = 1e8; const long long MOD = 100003; inline long long pow(const long long x, const long long n) { long long ans = 1; for (long long num = x % MOD, k = n; k; num = num * num % MOD, k &gt;&gt;= 1) if (k &amp; 1) ans = ans * num % MOD; // for (int i = 0; i &lt; n; i++) ans = ans * x % MOD; return ans; } int main() { long long m, n; scanf("%lld %lld", &amp;m, &amp;n); long long ans = pow(m, n) - m * pow(m - 1, n - 1); printf("%lld\n", (ans % MOD + MOD) % MOD); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
        <tag>BZOJ</tag>
        <tag>HNOI</tag>
        <tag>计数原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2253」纸箱堆叠 - CDQ 分治 + DP]]></title>
    <url>%2Fbzoj-2253%2F</url>
    <content type="text"><![CDATA[给定 个三元组 ，定义 当且仅当 且 且 。求 的最长上升子序列长度。 链接 BZOJ 2253 题解 CDQ 分治，对于一段区间 ，先递归计算好 的答案，然后处理前一半对后一半的 DP 值的贡献，然后递归计算 的答案。 因为 DP 需要有序，所以不能先将两边处理完后再处理本层的影响，也不能归并排序。 注意 的划分，因为我们整个序列一开始按照 排序，所以必须保证划分的两个区间中，左边的所有 要小于右边，所以要在一个使两边 不同的位置划分 。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 50000; struct Triple { int a, b, c, *dp; Triple() {} Triple(int a, int b, int c, int *dp) : a(a), b(b), c(c), dp(dp) {} } a[MAXN + 1]; int n, f[MAXN + 1]; inline void sort3(int &amp;a, int &amp;b, int &amp;c) { int min = std::min(a, std::min(b, c)); int max = std::max(a, std::max(b, c)); int mid; if (a != min &amp;&amp; a != max) mid = a; else if (c != min &amp;&amp; c != max) mid = c; else mid = b; a = min, b = mid, c = max; } inline void init(int x, int p) { static long long exp[MAXN * 3 + 1]; exp[1] = x; for (int i = 2; i &lt;= 3 * n; i++) { exp[i] = exp[i - 1] * x % p; } for (int i = 1; i &lt;= n; i++) { int x = exp[i * 3 - 2], y = exp[i * 3 - 1], z = exp[i * 3]; sort3(x, y, z); a[i] = Triple(x, y, z, &amp;f[i]); } } inline void discrete() { static int set[MAXN + 1]; for (int i = 1; i &lt;= n; i++) set[i] = a[i].c; std::sort(set + 1, set + n + 1); int *end = std::unique(set + 1, set + n + 1); for (int i = 1; i &lt;= n; i++) a[i].c = std::lower_bound(set + 1, end, a[i].c) - set; } struct BIT { int a[MAXN + 1]; static int lowbit(int x) { return x &amp; -x; } void update(int pos, int x) { for (int i = pos; i &lt;= n; i += lowbit(i)) a[i] = std::max(a[i], x); } int query(int pos) { int res = 0; for (int i = pos; i &gt; 0; i -= lowbit(i)) res = std::max(res, a[i]); return res; } void clear(int pos) { for (int i = pos; i &lt;= n; i += lowbit(i)) { if (!a[i]) break; a[i] = 0; } } } bit; inline bool compareByA(const Triple &amp;a, const Triple &amp;b) { return a.a &lt; b.a; } inline bool compareByB(const Triple &amp;a, const Triple &amp;b) { return a.b &lt; b.b; } inline void print(Triple *l, Triple *r) { for (Triple *p = l; p &lt;= r; p++) { printf("%lu: (%d, %d, %d, f = %d)\n", p - a, p-&gt;a, p-&gt;b, p-&gt;c, *p-&gt;dp); if (p == (l + (r - l) / 2)) puts("[mid]"); } puts(""); } inline Triple *divide(Triple *l, Triple *r) { Triple *mid = l + (r - l) / 2; while (mid &lt; r &amp;&amp; mid-&gt;a == (mid + 1)-&gt;a) mid++; if (mid == r) { mid = l + (r - l) / 2; while (mid &gt; l &amp;&amp; mid-&gt;a == (mid - 1)-&gt;a) mid--; if (mid == l) return NULL; return mid; } return mid; } inline void cdq(Triple *l, Triple *r) { if (l == r) { return; } Triple *mid = divide(l, r); if (!mid) return; cdq(l, mid); std::sort(l, mid + 1, compareByB); std::sort(mid + 1, r + 1, compareByB); // print(l, r); for (Triple *p1 = l, *p2 = mid + 1; p1 &lt;= mid || p2 &lt;= r; ) { if ((p1 &lt;= mid &amp;&amp; p1-&gt;b &lt;= p2-&gt;b) || p2 &gt; r) { bit.update(p1-&gt;c, *p1-&gt;dp + 1); p1++; } else { *p2-&gt;dp = std::max(*p2-&gt;dp, bit.query(p2-&gt;c - 1)); p2++; } } for (Triple *q = l; q &lt;= mid; q++) { bit.clear(q-&gt;c); } std::sort(mid, r + 1, compareByA); cdq(mid + 1, r); } /* inline void force() { for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt; i; j++) { if (a[j].a &lt; a[i].a &amp;&amp; a[j].b &lt; a[i].b &amp;&amp; a[j].c &lt; a[i].c) f[i] = std::max(f[i], f[j] + 1); } // printf("f[%d] = %d\n", i, f[i]); } } */ int main() { int x, p; scanf("%d %d %d", &amp;x, &amp;p, &amp;n); init(x, p); // std::random_shuffle(a + 1, a + n + 1); std::sort(a + 1, a + n + 1, compareByA); discrete(); cdq(a + 1, a + n); // force(); int ans = 0; for (int i = 1; i &lt;= n; i++) ans = std::max(ans, f[i] + 1); //, printf("(%d, %d, %d)\n", a[i].a, a[i].b, a[i].c); printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>CDQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「省选模拟赛」完美理论 - 最大权闭合图]]></title>
    <url>%2F20160404-theory%2F</url>
    <content type="text"><![CDATA[有两棵点集相同的树，顶点编号为 ，每个点都有一个权值，你需要选择一个点集的子集，使得这个子集在两棵树上都是一个连通块。你要选出权值和最大的子集，你只需要输出最大的权值和。 题解 首先，我们可以枚举一个点，使得这个点在选择的连通块中，限制转化为：选择了某个点，就必须选择它的父节点。 于是这就是经典的最大权闭合图问题，用最小割模型解决即可。 40分代码（暴搜 + 树形DP） #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;utility&gt; const int MAXN = 100; const int MAXT = 50; struct Node; struct Edge; struct Node { Edge *e; int id, depth; bool visited; struct TreeDPAnswer { bool calced; int val; } ans[2]; } N[2][MAXN]; struct Edge { Node *t; Edge *next; Edge(Node *s, Node *t) : t(t), next(s-&gt;e) {} }; inline void addEdge(const int i, const int u, const int v) { N[i][u].e = new Edge(&amp;N[i][u], &amp;N[i][v]); N[i][v].e = new Edge(&amp;N[i][v], &amp;N[i][u]); } int n, a[MAXN], f[MAXN], ans; std::pair&lt;int, int&gt; E[2][MAXN - 1]; inline int check() { int start = -1, tot = 0, sum = 0; for (int i = 0; i &lt; n; i++) if (f[i]) start = i, tot++, N[0][i].visited = N[1][i].visited = false, sum += a[i]; for (int i = 0; i &lt; 2; i++) { std::queue&lt;Node *&gt; q; q.push(&amp;N[i][start]); N[i][start].visited = true; int cnt = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (f[e-&gt;t-&gt;id] &amp;&amp; !e-&gt;t-&gt;visited) e-&gt;t-&gt;visited = true, q.push(e-&gt;t), cnt++; } // printf("cnt = %d, tot = %d, sum = %d\n", cnt, tot, sum); if (cnt &lt; tot) return -1; } return sum; } inline void search(int i = 0) { if (i == n) { ans = std::max(ans, check()); return; } f[i] = true; search(i + 1); f[i] = false; search(i + 1); } inline void bfsDepth() { std::queue&lt;Node *&gt; q; q.push(&amp;N[0][0]); N[0][0].depth = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (!e-&gt;t-&gt;depth) e-&gt;t-&gt;depth = v-&gt;depth + 1, q.push(e-&gt;t); } } int dp(Node *v, const bool flag) { int &amp;ans = v-&gt;ans[flag].val; if (v-&gt;ans[flag].calced) return ans; v-&gt;ans[flag].calced = true; ans = 0; if (flag) { int sum = 0; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;depth == v-&gt;depth + 1) { // ans = std::max(ans, dp(e-&gt;t, false)); int t = dp(e-&gt;t, true); if (t &gt; 0) sum += t; } sum += a[v-&gt;id]; ans = std::max(ans, sum); } else { for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;depth == v-&gt;depth + 1) { ans = std::max(ans, dp(e-&gt;t, false)); } ans = std::max(ans, dp(v, true)); } // printf("dp(%d[with `w` = %d], %d) = %d\n", v-&gt;id, a[v-&gt;id], flag ? 1 : 0, ans); return ans; } inline int solve(const bool useTreeDP) { if (!useTreeDP) { ans = 0; search(); return ans; } else { bfsDepth(); return dp(&amp;N[0][0], false); } } inline void cleanUp() { for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; n; j++) { N[i][j].id = j; Edge *next; for (Edge *&amp;e = N[i][j].e; e; next = e-&gt;next, delete e, e = next); N[i][j].depth = 0; N[i][j].ans[0].calced = N[i][j].ans[1].calced = false; N[i][j].ans[0].val = N[i][j].ans[1].val = 0; } std::fill(a, a + n, 0); } int main() { freopen("theory.in", "r", stdin); freopen("theory.out", "w", stdout); int t; scanf("%d", &amp;t); while(t--) { scanf("%d", &amp;n); cleanUp(); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); for (int i = 0; i &lt; 2; i++) for (int j = 0, u, v; j &lt; n - 1; j++) { scanf("%d %d", &amp;u, &amp;v), u--, v--; E[i][j] = std::make_pair(std::min(u, v), std::max(u, v)); addEdge(i, u, v); } std::sort(E[0], E[0] + n - 1); std::sort(E[1], E[1] + n - 1); bool useTreeDP = std::equal(E[0], E[0] + n - 1, E[1]); printf("%d\n", solve(useTreeDP)); } fclose(stdin); fclose(stdout); return 0; } 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;vector&gt; const int MAXN = 100; const int MAXT = 50; struct Node; struct Edge; struct Node { Edge *e, *c; int l; } N[MAXN + 2]; struct Edge { Node *t; int f, c; Edge *next, *r; Edge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s-&gt;e) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, const int n) { for (int i = 0; i &lt; n; i++) N[i].c = N[i].e, N[i].l = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;next) { if (e-&gt;f &lt; e-&gt;c &amp;&amp; e-&gt;t-&gt;l == 0) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == t) return true; else q.push(e-&gt;t); } } } return false; } int findPath(Node *s, Node *t, const int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;next) { if (e-&gt;f &lt; e-&gt;c &amp;&amp; e-&gt;t-&gt;l == s-&gt;l + 1) { int f = findPath(e-&gt;t, t, std::min(e-&gt;c - e-&gt;f, limit)); if (f &gt; 0) { e-&gt;f += f, e-&gt;r-&gt;f -= f; return f; } } } return 0; } int operator()(const int s, const int t, const int n) { int ans = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int f; while ((f = findPath(&amp;N[s], &amp;N[t])) &gt; 0) ans += f; } return ans; } } dinic; inline void addEdge(const int s, const int t, const int c) { N[s].e = new Edge(&amp;N[s], &amp;N[t], c); N[t].e = new Edge(&amp;N[t], &amp;N[s], 0); N[s].e-&gt;r = N[t].e, N[t].e-&gt;r = N[s].e; } struct TreeNode; struct TreeEdge; int n, a[MAXN]; struct TreeNode { TreeEdge *e; int id; bool visited; int w() const { return a[id]; } } T[2][MAXN]; struct TreeEdge { TreeNode *t; TreeEdge *next; TreeEdge(TreeNode *s, TreeNode *t) : t(t), next(s-&gt;e) {} }; inline void addTreeEdge(const int x, const int u, const int v) { T[x][u].e = new TreeEdge(&amp;T[x][u], &amp;T[x][v]); T[x][v].e = new TreeEdge(&amp;T[x][v], &amp;T[x][u]); } inline void cleanUpNetwork() { for (int i = 0; i &lt; n + 2; i++) { Edge *next; for (Edge *&amp;e = N[i].e; e; next = e-&gt;next, delete e, e = next); } } inline int solve(const int root) { const int s = 0, t = n + 1; int sum = 0; for (int i = 0; i &lt; n; i++) { if (a[i] &gt; 0) addEdge(s, i + 1, a[i]), sum += a[i]; else addEdge(i + 1, t, -a[i]); } for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; n; j++) T[i][j].visited = (j == root) ? true : false; std::queue&lt;TreeNode *&gt; q; q.push(&amp;T[i][root]); while (!q.empty()) { TreeNode *v = q.front(); q.pop(); for (TreeEdge *e = v-&gt;e; e; e = e-&gt;next) { if (!e-&gt;t-&gt;visited) { e-&gt;t-&gt;visited = true; addEdge(e-&gt;t-&gt;id + 1, v-&gt;id + 1, INT_MAX); q.push(e-&gt;t); } } } } int ans = sum - dinic(s, t, n + 2); cleanUpNetwork(); return ans; } inline void cleanUp() { for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; n; j++) { TreeEdge *next; for (TreeEdge *&amp;e = T[i][j].e; e; next = e-&gt;next, delete e, e = next); } } int main() { freopen("theory.in", "r", stdin); // freopen("theory.out", "w", stdout); int t; scanf("%d", &amp;t); while (t--) { scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]), T[0][i].id = T[1][i].id = i; for (int i = 0; i &lt; 2; i++) for (int j = 0, u, v; j &lt; n - 1; j++) { scanf("%d %d", &amp;u, &amp;v), u--, v--; // printf("(%d, %d)\n", u, v); addTreeEdge(i, u, v); } int ans = 0; for (int i = 0; i &lt; n; i++) ans = std::max(ans, solve(i)); printf("%d\n", ans); cleanUp(); } fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>安徽集训</tag>
        <tag>Dinic</tag>
        <tag>暴力</tag>
        <tag>最大权闭合图</tag>
        <tag>树形 DP</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TJOI2013」最长上升子序列 - 离线 + 树状数组]]></title>
    <url>%2Ftjoi2013-lis%2F</url>
    <content type="text"><![CDATA[给定一个序列，初始为空。现在我们将 到 的数字插入到序列中，每次将一个数字插入到一个特定的位置。每插入一个数字，我们都想知道此时最长上升子序列长度是多少？ 链接 BZOJ 3173 题解 首先，将操作离线，可以得到最终序列中每个元素的位置。 因为是从小到大加入，所以对某个元素的答案有贡献的元素仅为位置比它小且在它之前加入的元素，所以直接用一个树状数组维护前缀最大值即可。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 100000; template &lt;typename T&gt; struct Splay { enum Relation { L = 0, R = 1 }; struct Node { Node *c[2], *p, **r; T v; int s; bool b; Node(Node *p, Node **r, const T &amp;v, bool b = false) : p(p), r(r), v(v), s(1), b(b) {} ~Node() { if (c[L]) delete c[L]; if (c[R]) delete c[R]; } Relation relation() const { return this == p-&gt;c[L] ? L : R; } void maintain() { s = (c[L] ? c[L]-&gt;s : 0) + (c[R] ? c[R]-&gt;s : 0) + 1; } void rotate() { Relation x = relation(); Node *o = p; if (o-&gt;p) o-&gt;p-&gt;c[o-&gt;relation()] = this; p = o-&gt;p; o-&gt;c[x] = c[x ^ 1]; if (c[x ^ 1]) c[x ^ 1]-&gt;p = o; c[x ^ 1] = o; o-&gt;p = this; o-&gt;maintain(), maintain(); if (!p) *r = this; } void splay(const Node *t = NULL) { while (p != t) { if (p-&gt;p == t) rotate(); else if (p-&gt;relation() == relation()) p-&gt;rotate(), rotate(); else rotate(), rotate(); } } int rank() { return c[L] ? c[L]-&gt;s : 0; } } *r; Splay() : r(NULL) { buildBound(L), buildBound(R); } ~Splay() { delete r; } void buildBound(Relation x) { Node **v = &amp;r, *p = NULL; while (*v) p = *v, p-&gt;s++, v = &amp;p-&gt;c[x]; *v = new Node(p, &amp;r, 0, true); } Node *select(int k) { Node *v = r; for (int x = k + 1; x != v-&gt;rank() + 1; ) { if (x &lt; v-&gt;rank() + 1) v = v-&gt;c[L]; else x -= v-&gt;rank() + 1, v = v-&gt;c[R]; } return v; } void insert(int i, const T &amp;v) { Node *a = select(i), *b = select(i + 1); a-&gt;splay(), b-&gt;splay(a); b-&gt;c[L] = new Node(b, &amp;r, v), b-&gt;s++, b-&gt;s++; } void dfs(Node *v, T *a, int &amp;i) { if (!v) return; dfs(v-&gt;c[L], a, i), v-&gt;b || (a[v-&gt;v - 1] = ++i), dfs(v-&gt;c[R], a, i); } void fetch(T *a) { int i = 0; dfs(r, a, i); } }; int n, a[MAXN]; struct BinaryIndexedTree { int a[MAXN]; static int lowbit(const int x) { return x &amp; -x; } void update(const int i, const int v) { for (int j = i; j &lt;= n; j += lowbit(j)) a[j - 1] = std::max(a[j - 1], v); } int query(const int i) { int x = 0; for (int j = i; j &gt; 0; j -= lowbit(j)) x = std::max(x, a[j - 1]); return x; } } b; Splay&lt;int&gt; s; int main() { scanf("%d", &amp;n); for (int x = 1, i; x &lt;= n; x++) { scanf("%d", &amp;i), s.insert(i, x); } s.fetch(a); for (int i = 0, l = 0; i &lt; n; i++) { int t = b.query(a[i] - 1) + 1; b.update(a[i], t); printf("%d\n", l = std::max(l, t)); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>BZOJ</tag>
        <tag>Splay</tag>
        <tag>离线</tag>
        <tag>TJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BeiJing2006」狼抓兔子 - 最小割]]></title>
    <url>%2Fbzoj-1001%2F</url>
    <content type="text"><![CDATA[左上角点为 ，右下角点为 ，有以下三种类型的道路： 道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角 的窝里，现在它们要跑到右下解 的窝中去，狼王开始伏击这些兔子。当然为了保险起见，如果一条道路上最多通过的兔子数为 ，狼王需要安排同样数量的 只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦. 链接 BZOJ 1001 题解 Dinic 模板题，注意注意内存就好 …… 边直接加双向边，反向边的容量和原边相等即可。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 1000; const int MAXM = 1000; struct Node; struct Edge; struct Node { Edge *e, *c; int l; } N[MAXN * MAXM + 2]; struct Edge { Node *t; int c; Edge *n, *r; Edge(Node *s, Node *t, const int c) : t(t), c(c), n(s-&gt;e) {} }; inline void addEdge(int s, int t, int c) { N[s].e = new Edge(&amp;N[s], &amp;N[t], c); N[t].e = new Edge(&amp;N[t], &amp;N[s], c); N[s].e-&gt;r = N[t].e, N[t].e-&gt;r = N[s].e; } struct Dinic { int augment(Node *s, Node *t, const int h = INT_MAX) { if (s == t) return h; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;n) { if (e-&gt;c &gt; 0 &amp;&amp; e-&gt;t-&gt;l == s-&gt;l + 1) { int f = augment(e-&gt;t, t, std::min(e-&gt;c, h)); if (f) { e-&gt;c -= f, e-&gt;r-&gt;c += f; return f; } } } return 0; } int operator()(const int s, const int t, const int n) { int r = 0; while (1) { for (int i = 0; i &lt; n; i++) N[i].l = 0, N[i].c = N[i].e; bool f = false; std::queue&lt;Node *&gt; q; q.push(&amp;N[s]), N[s].l = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;n) if (!e-&gt;t-&gt;l &amp;&amp; e-&gt;c &gt; 0) { e-&gt;t-&gt;l = v-&gt;l + 1; if (e-&gt;t == &amp;N[t]) { f = true; break; } else q.push(e-&gt;t); } } if (!f) return r; for (int f; f = augment(&amp;N[s], &amp;N[t]); r += f); } } } dinic; int n, m; inline int id(const int i, const int j) { return (i - 1) * m + j; } int main() { scanf("%d %d", &amp;n, &amp;m); const int s = 0, t = n * m + 1; addEdge(s, id(1, 1), INT_MAX), addEdge(id(n, m), t, INT_MAX); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m - 1; j++) { int c; scanf("%d", &amp;c); addEdge(id(i, j), id(i, j + 1), c); } } for (int i = 1; i &lt;= n - 1; i++) { for (int j = 1; j &lt;= m; j++) { int c; scanf("%d", &amp;c); addEdge(id(i, j), id(i + 1, j), c); } } for (int i = 1; i &lt;= n - 1; i++) { for (int j = 1; j &lt;= m - 1; j++) { int c; scanf("%d", &amp;c); addEdge(id(i, j), id(i + 1, j + 1), c); } } printf("%d\n", dinic(s, t, n * m + 2)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2014」起床困难综合征 - 位运算 + 贪心]]></title>
    <url>%2Fnoi2014-sleep%2F</url>
    <content type="text"><![CDATA[drd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd 的防御战线由 扇防御门组成。每扇防御门包括一个运算 和一个参数 ，其中运算一定是 ，， 中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为 ，则其通过这扇防御门后攻击力将变为 。最终 drd 受到的伤害为对方初始攻击力 依次经过所有 扇防御门后转变得到的攻击力。由于 atm 水平有限，他的初始攻击力只能为 到 之间的一个整数（即他的初始攻击力只能在 ，，， 中任选，但在通过防御门之后的攻击力不受 的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害。 链接 BZOJ 3668 题解 贪心从高位到低位枚举，检验当前位在初始值为 情况下的答案是否可以为 ，如果不能则检验当前位初始值能否为 ，并检验当前位在初始值为 情况下的答案是否可以为 。 注意要用 unsigned int，否则会变成负数。 代码 #include &lt;cstdio&gt; const int MAXN = 100000; const int MAXM = 1e9; enum OperatorType { And = 0, Or = 1, Xor = 2 }; struct BitwiseOperator { OperatorType type; bool bits[32]; } ops[MAXN]; int n; unsigned int m; inline bool check(const int k, const bool value) { bool flag = value; for (int i = 0; i &lt; n; i++) { if (ops[i].type == And) flag &amp;= ops[i].bits[k]; else if (ops[i].type == Or) flag |= ops[i].bits[k]; else if (ops[i].type == Xor) flag ^= ops[i].bits[k]; } return flag; } inline unsigned int solve() { unsigned int num = 0, ans = 0; for (int i = 32 - 1; i &gt;= 0; i--) { if (check(i, 0)) ans |= (1 &lt;&lt; i); else if ((num | (1 &lt;&lt; i)) &lt;= m &amp;&amp; check(i, 1)) ans |= (1 &lt;&lt; i), num |= (1 &lt;&lt; i); } return ans; } int main() { // freopen("sleep.in", "r", stdin); // freopen("sleep.out", "w", stdout); scanf("%d %u", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) { BitwiseOperator &amp;op = ops[i]; char str[sizeof("AND")]; int x; scanf("%s %d", str, &amp;x); if (str[0] == 'A') op.type = And; else if (str[0] == 'O') op.type = Or; else if (str[0] == 'X') op.type = Xor; for (int i = 0; i &lt; 32; i++) op.bits[i] = ((x &amp; (1 &lt;&lt; i)) == 0) ? false : true; // for (int i = 0; i &lt; 32; i++) putchar(op.bits[i] ? '1' : '0'); // putchar('\n'); } printf("%u\n", solve()); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>贪心</tag>
        <tag>位运算</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2015」树上操作 - 树链剖分 + DFS序]]></title>
    <url>%2Fhaoi2015-t2%2F</url>
    <content type="text"><![CDATA[有一棵点数为 的树，以点 为根，且树点有边权。然后有 个操作，分为三种： 把某个节点 的点权增加 。 把某个节点 为根的子树中所有点的点权都增加 。 询问某个节点 到根的路径中所有点的点权和。 链接 BZOJ 4034 COGS 1963 题解 裸树剖 + DFS 序，注意要开 long long，要不然和暴力分一样 …… 代码 #include &lt;cstdio&gt; #include &lt;stack&gt; const int MAXN = 100000; const int MAXM = 100000; struct Node; struct Edge; struct Path; struct Node { Edge *e; Node *c, *p; int size, pos, posEnd; bool visited; Path *path; } N[MAXN]; struct Edge { Node *s, *t; Edge *next; Edge(Node *s, Node *t) : s(s), t(t), next(s-&gt;e) {} }; inline void addEdge(const int u, const int v) { N[u].e = new Edge(&amp;N[u], &amp;N[v]); N[v].e = new Edge(&amp;N[v], &amp;N[u]); } struct SegmentTree { int l, r; SegmentTree *lc, *rc; long long value, lazy; SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), value(0), lazy(0) {} void cover(const long long delta) { value += delta * (r - l + 1), lazy += delta; } void pushDown() { if (lazy) { if (lc) lc-&gt;cover(lazy); if (rc) rc-&gt;cover(lazy); lazy = 0; } } void update(const int l, const int r, const long long delta) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) cover(delta); else { pushDown(); value = 0; if (lc) lc-&gt;update(l, r, delta), value += lc-&gt;value; if (rc) rc-&gt;update(l, r, delta), value += rc-&gt;value; } } long long query(const int l, const int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return value; else { pushDown(); long long result = 0; if (lc) result += lc-&gt;query(l, r); if (rc) result += rc-&gt;query(l, r); return result; } } } *segment; SegmentTree *buildSegmentTree(const int l, const int r) { if (l &gt; r) return NULL; else if (l == r) return new SegmentTree(l, r, NULL, NULL); else return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) &gt;&gt; 1)), buildSegmentTree(l + ((r - l) &gt;&gt; 1) + 1, r)); } struct Path { Node *top; Path(Node *top) : top(top) {} }; int n, m; long long a[MAXN]; inline void cut() { std::stack&lt;Node *&gt; s; s.push(&amp;N[0]); while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;p == NULL &amp;&amp; e-&gt;t != v-&gt;p) e-&gt;t-&gt;p = v, s.push(e-&gt;t); } else { v-&gt;size = 1; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;p == v) { v-&gt;size += e-&gt;t-&gt;size; if (v-&gt;c == NULL || v-&gt;c-&gt;size &lt; e-&gt;t-&gt;size) v-&gt;c = e-&gt;t; } s.pop(); } } for (int i = 0; i &lt; n; i++) N[i].visited = false; s.push(&amp;N[0]); int time = -1; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; v-&gt;pos = ++time; if (!v-&gt;p || v != v-&gt;p-&gt;c) v-&gt;path = new Path(v); else v-&gt;path = v-&gt;p-&gt;path; for (Edge *e = v-&gt;e; e; e = e-&gt;next) if (e-&gt;t-&gt;p == v &amp;&amp; e-&gt;t != v-&gt;c) s.push(e-&gt;t); if (v-&gt;c) s.push(v-&gt;c); } else v-&gt;posEnd = time, s.pop(); } segment = buildSegmentTree(0, n - 1); for (int i = 0; i &lt; n; i++) segment-&gt;update(N[i].pos, N[i].pos, a[i]); } inline long long queryToRoot(const int x) { Node *v = &amp;N[x]; long long sum = 0; while (v) { sum += segment-&gt;query(v-&gt;path-&gt;top-&gt;pos, v-&gt;pos); v = v-&gt;path-&gt;top-&gt;p; } return sum; } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf("%lld", &amp;a[i]); for (int i = 0, u, v; i &lt; n - 1; i++) scanf("%d %d", &amp;u, &amp;v), u--, v--, addEdge(u, v); cut(); for (int i = 0, cmd; i &lt; m; i++) { scanf("%d", &amp;cmd); if (cmd == 1) { int x, a; scanf("%d %d", &amp;x, &amp;a), x--; segment-&gt;update(N[x].pos, N[x].pos, a); } else if (cmd == 2) { int x, a; scanf("%d %d", &amp;x, &amp;a), x--; segment-&gt;update(N[x].pos, N[x].posEnd, a); } else if (cmd == 3) { int x; scanf("%d", &amp;x), x--; printf("%lld\n", queryToRoot(x)); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>线段树</tag>
        <tag>BZOJ</tag>
        <tag>HAOI</tag>
        <tag>DFS 序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2296」随机种子 - 数论基础]]></title>
    <url>%2Fbzoj-2296%2F</url>
    <content type="text"><![CDATA[给定一个数 （），求一个数 满足： 的十进制表示中包含 0 ~ 9 的所有数； ； 。 链接 BZOJ 2296 题解 做这题需要有点数论基础，构造方法并不难，首先为了满足性质 1，我们可以令 n 的十进制表示中的前 10 位为 ，这样我们只需要考虑后 6 位即可。 设 ，想象我们通过若干次减法把 减到了 ，所以我们只要令 即可。 注意 0 的特判。 代码 #include &lt;cstdio&gt; const int MAXT = 100; const int MAXX = 1e6; int main() { int t; scanf("%d", &amp;t); long long base = 9876543210 * 1e6; for (int i = 0; i &lt; t; i++) { int x; scanf("%d", &amp;x); printf("%lld\n", x == 0 ? -1LL : base + (x - base % x)); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>安徽集训</tag>
        <tag>BZOJ</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2038」小Z的袜子 - 莫队]]></title>
    <url>%2Fbzoj-2038%2F</url>
    <content type="text"><![CDATA[给一个数列 ~ ，给出 个询问，每次询问 ~ 中，任选两个数相同的概率。 题解 先按照 分块，以区间左端点所在块为第一关键字，区间右端点为第二关键字排序，使用莫队算法。 问题可转化为：求 ~ 中相等的数字对数。 记某个时刻每个数字 的出现次数为 考虑每个数字对答案的贡献，答案为： 每加进来或删去一个数字时，可以重新计算单个数字对答案的贡献来得到新的答案。 计算出相等的对数后，除以总对数即为最终答案。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; const int MAXN = 50000; const int MAXM = 50000; long long gcd(const long long a, const long long b) { return !b ? a : gcd(b, a % b); } struct Fraction { long long a, b; void print() const { const long long g = gcd(a, b); printf("%lld/%lld\n", a / g, b / g); } }; struct Query { int id, l, r; Fraction ans; } Q[MAXM]; int n, m; int a[MAXN]; bool compareByBlock(const Query &amp;a, const Query &amp;b) { static int s = floor(sqrt(m) + 1); if (a.l / s == b.l / s) return a.r &lt; b.r; else return a.l / s &lt; b.l / s; } bool compareById(const Query &amp;a, const Query &amp;b) { return a.id &lt; b.id; } inline long long calc(const long long x) { return x * (x - 1); } inline void work() { static int cnt[MAXN]; bool flag = false; long long x = 0; for (int i = 0, l, r; i &lt; m; i++) { Query &amp;q = Q[i]; q.l--, q.r--; if (!flag) { l = q.l, r = q.r, flag = true; for (int i = l; i &lt;= r; i++) x -= calc(cnt[a[i]]), x += calc(++cnt[a[i]]); } else { while (q.l &lt; l) l--, x -= calc(cnt[a[l]]), x += calc(++cnt[a[l]]); while (q.r &gt; r) r++, x -= calc(cnt[a[r]]), x += calc(++cnt[a[r]]); while (q.l &gt; l) x -= calc(cnt[a[l]]), x += calc(--cnt[a[l]]), l++; while (q.r &lt; r) x -= calc(cnt[a[r]]), x += calc(--cnt[a[r]]), r--; } q.ans.a = x, q.ans.b = calc(q.r - q.l + 1); } } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]), a[i]--; for (int i = 0; i &lt; m; i++) scanf("%d %d", &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; std::sort(Q, Q + m, &amp;compareByBlock); work(); std::sort(Q, Q + m, &amp;compareById); for (int i = 0; i &lt; m; i++) Q[i].ans.print(); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>安徽集训</tag>
        <tag>分块</tag>
        <tag>BZOJ</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「省选模拟赛」扔鸡蛋 - DP]]></title>
    <url>%2F20160331-naive%2F</url>
    <content type="text"><![CDATA[有 层楼，第 层以下扔鸡蛋会碎，你有 个鸡蛋，找出这个 需要多少次实验。 题解 用 表示用 i 个鸡蛋做 j 次实验最多能测试出多少层的楼，考虑第一个鸡蛋是否摔碎，即： 第二维大小取 即可，当询问 时，在 中二分查找 即可。 注意当 时答案非常大，需要特判。 当 时，答案为 。 当 时，设答案为 ，有： 当 时，难以推出公式，我们可以再为 1 ~ 3 开一个 数组，第二维开到 即可。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; const int MAXT = 100000; const unsigned long long MAXN = 1e18; const int LIM = 100000; const int LIM2 = LIM * 20; const int MAXK = 64; template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; while (ch = getchar(), !(ch &gt;= '0' &amp;&amp; ch &lt;= '9')); do x = x * 10 + (ch - '0'); while (ch = getchar(), (ch &gt;= '0' &amp;&amp; ch &lt;= '9')); } template &lt;typename T&gt; inline void write(T x) { char s[20]; register int cnt = 0; do s[cnt++] = x % 10; while (x /= 10); while (cnt--) putchar(s[cnt] + '0'); putchar('\n'); } unsigned long long f[MAXK + 1][LIM + 1], f2[3 + 1][LIM2 + 1]; int cnt[MAXK + 1]; int main() { freopen("naive.in", "r", stdin); // freopen("naive.out", "w", stdout); for (int i = 1; i &lt;= MAXK; i++) { cnt[i] = LIM; for (int j = 1; j &lt;= LIM; j++) { f[i][j] = f[i - 1][j - 1] + f[i][j - 1] + 1; if (f[i][j] &gt;= MAXN) { cnt[i] = j; break; } } } for (int i = 1; i &lt;= 3; i++) { cnt[i] = LIM2; for (int j = 1; j &lt;= LIM2; j++) { f2[i][j] = f2[i - 1][j - 1] + f2[i][j - 1] + 1; if (f2[i][j] &gt;= MAXN) { cnt[i] = j; break; } } } // for (int i = 1; i &lt;= 10; i++) write(cnt[i]); int t; scanf("%d", &amp;t); while (t--) { unsigned long long n; int k; read(n), read(k); if (k == 1) write(n); else if (k == 2) write((long long)ceil((sqrt(8 * n + 1) - 1) / 2)); else if (k == 3) { int ans = std::lower_bound(f2[k], f2[k] + cnt[k], n) - f2[k]; printf("%d\n", ans); } else { int ans = std::lower_bound(f[k], f[k] + cnt[k], n) - f[k]; printf("%d\n", ans); } } fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>安徽集训</tag>
        <tag>DP</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2015」小凸解密码 - set]]></title>
    <url>%2Fscoi2015-password%2F</url>
    <content type="text"><![CDATA[给定一个环形数列 和运算符序列 ，可以从任意一个位置作为起点计算 ，方法为： ； 当 时，； 当 时，； 每次可以修改 和 中的某一个元素，询问以指定起点开始计算 得到的环形数列 中距离 最远的零区间中距离 最近的零的距离。 链接 BZOJ 4447 题解 首先，可以发现在没有修改的情况下，指定的不同起点只是起点得到的值不同，我们先直接递推计算出 B，查询的时候修改 查询完改回去。一次修改只会影响两个位置（ 和 ）。 所以问题转化为，维护一个环形零一串，每次修改一个位置，查询到某个位置的最近零区间。 用 set 维护每一个零区间，然后各种分情况讨论 …… 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;set&gt; const int MAXN = 100000; const int MAXM = 100000; const int MOD = 10; struct ZeroRange { int l, r; ZeroRange(int pos) : l(pos) {} ZeroRange(int l, int r) : l(l), r(r) {} }; bool operator&lt;(const ZeroRange &amp;a, const ZeroRange &amp;b) { return a.l &lt; b.l; } bool operator&lt;(int x, const ZeroRange &amp;range) { return x &lt; range.l; } int n, m, A[MAXN], a[MAXN * 2]; char C[MAXN]; std::set&lt;ZeroRange&gt; s; inline void update(int pos, int newValue) { if (newValue == 0 &amp;&amp; a[pos] != 0) { for (int x = pos; x &lt; n * 2; x += n) { std::set&lt;ZeroRange&gt;::iterator next = s.lower_bound(x); std::set&lt;ZeroRange&gt;::iterator prev = --s.lower_bound(x); if (next-&gt;l == x + 1 &amp;&amp; prev-&gt;r == x - 1) { ZeroRange range(prev-&gt;l, next-&gt;r); s.erase(next), s.erase(prev), s.insert(range); } else if (next-&gt;l == x + 1) { ZeroRange range(x, next-&gt;r); s.erase(next), s.insert(range); } else if (prev-&gt;r == x - 1) { ZeroRange range(prev-&gt;l, x); s.erase(prev), s.insert(range); } else s.insert(ZeroRange(x, x)); } } else if (newValue != 0 &amp;&amp; a[pos] == 0) { for (int x = pos; x &lt; n * 2; x += n) { std::set&lt;ZeroRange&gt;::iterator self = --s.upper_bound(x); if (x != self-&gt;l &amp;&amp; x != self-&gt;r) { ZeroRange range1(self-&gt;l, x - 1), range2(x + 1, self-&gt;r); s.erase(self), s.insert(range1), s.insert(range2); } else if (x != self-&gt;r) { ZeroRange range(x + 1, self-&gt;r); s.erase(self), s.insert(range); } else if (x != self-&gt;l) { ZeroRange range(self-&gt;l, x - 1); s.erase(self), s.insert(range); } else s.erase(self); } } a[pos] = a[pos + n] = newValue; } inline int calc(int a, int b, char opt) { if (opt == '+') return (a + b) % MOD; else return (a * b) % MOD; } inline void update(int pos, int num, char opt) { A[pos] = num, C[pos] = opt; update(pos, calc(A[pos], A[(pos - 1 + n) % n], C[pos])); update((pos + 1) % n, calc(A[(pos + 1) % n], A[pos], C[(pos + 1) % n])); } inline int dist(int x, int y) { if (x &gt; y) std::swap(x, y); return std::min(y - x, n + x - y); } inline int dist(int pos, const ZeroRange &amp;range) { if (range.l == INT_MAX || range.l == INT_MIN) return -1; else if (range.l &lt; n &amp;&amp; range.r &gt;= n) { if (pos % n &gt;= range.l &amp;&amp; pos % n &lt;= range.r) return 0; else if (pos % n + n &gt;= range.l &amp;&amp; pos % n + n &lt;= range.r) return 0; } if (pos % n &gt;= range.l % n &amp;&amp; pos % n &lt;= range.r % n) return 0; else return std::min(dist(pos % n, range.l % n), dist(pos % n, range.r % n)); } inline int query(int pos) { int bak = a[pos]; update(pos, A[pos]); int ans; /* if (s.size() == 3 &amp;&amp; a[pos] == 0) ans = 0; else */ if (s.size() == 2) ans = -1; else if (s.size() == 3) ans = dist(pos, *++s.begin()); else { ans = -1; bool flag = (++s.begin())-&gt;l == ((--(--s.end()))-&gt;r + 1) % n; int oppositePos = ((pos - n / 2) + n) % n; std::set&lt;ZeroRange&gt;::iterator opposite = --s.upper_bound(oppositePos); if (opposite == s.begin()) opposite = --s.upper_bound(oppositePos + n); if (flag &amp;&amp; (opposite == ++s.begin())) opposite = --s.upper_bound(oppositePos + n); // if (flag &amp;&amp; (opposite == --(--s.end()))) opposite--; if (opposite != s.begin() &amp;&amp; !(flag &amp;&amp; (opposite == ++s.begin() || opposite == --(--s.end())))) ans = std::max(ans, dist(pos, *opposite)); if (opposite != ++s.begin()) { std::set&lt;ZeroRange&gt;::iterator prev = opposite; prev--; if (!(flag &amp;&amp; prev == ++s.begin())) ans = std::max(ans, dist(pos, *prev)); } if (opposite != --s.end()) { std::set&lt;ZeroRange&gt;::iterator next = opposite; next++; // while (next-&gt;r != INT_MAX &amp;&amp; flag &amp;&amp; next == --(--s.end())) next++; if (!(flag &amp;&amp; next == --(--s.end()))) ans = std::max(ans, dist(pos, *next)); } } update(pos, bak); return ans; } int main() { // freopen("password.in", "r", stdin); // freopen("password.out", "w", stdout); scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) { scanf("%d", &amp;A[i]); while (C[i] = getchar(), C[i] != '+' &amp;&amp; C[i] != '*'); } for (int i = 0; i &lt; n; i++) a[i] = a[i + n] = calc(A[i], A[(i - 1 + n) % n], C[i]); for (int l = 0; l &lt; n * 2; ) { if (a[l] == 0) { int r = l; while (r + 1 &lt; n * 2 &amp;&amp; a[r + 1] == 0) r++; s.insert(ZeroRange(l, r)); l = r + 1; } else l++; } s.insert(ZeroRange(INT_MIN, INT_MIN)), s.insert(ZeroRange(INT_MAX, INT_MAX)); for (int i = 0; i &lt; m; i++) { int type, pos; scanf("%d %d", &amp;type, &amp;pos); if (type == 1) { int num; char opt; scanf("%d", &amp;num); while (opt = getchar(), opt != '+' &amp;&amp; opt != '*'); update(pos, num, opt); } else printf("%d\n", query(pos)); } fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>安徽集训</tag>
        <tag>BZOJ</tag>
        <tag>乱搞</tag>
        <tag>set</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2015」小凸玩密室 - 树形 DP]]></title>
    <url>%2Fscoi2015-light%2F</url>
    <content type="text"><![CDATA[密室是一棵有 个节点的完全二叉树，每个节点有一个灯泡。点亮所有灯泡即可逃出密室。每个灯泡有个权值 ，每条边也有个权值 。点亮第 个灯泡不需要花费，之后每点亮 个新的灯泡 的花费，等于上一个被点亮的灯泡 到这个点 的距离 ，乘以这个点的权值 。在点灯的过程中，要保证任意时刻所有被点亮的灯泡必须连通，在点亮一个灯泡后必须先点亮其子树所有灯泡才能点亮其他灯泡。请告诉他们，逃出密室的最少花费是多少。 链接 BZOJ 4446 题解 动态规划，用 表示走完 及其子树再走到其第 层祖先的另一个孩子的最小代价。 当 为叶子节点时，直接走过去 当 只有左儿子时，先走到左孩子，再从左孩子走过去 当 既有左儿子，又有右儿子时，考虑先走哪个最优 另一个 DP： 表示走完 及其子树再走到其第 层祖先的最小代价。 当 为叶子节点时，直接走过去 当 只有左儿子时，先走到左孩子，再从左孩子走过去 当 既有左儿子，又有右儿子时，考虑先走哪个最优 状态表示中， 表示停在任意位置，因为计算 的时候任何一个点走到 的花费都是 。 枚举从哪个点开始，如果从根开始，答案为 ，否则先走自己，再走兄弟，再走父亲，再走父亲的兄弟的顺序，直到走到根，取所有答案的最小值。 代码 #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;algorithm&gt; const int MAXN = 200000; const int MAXLOGN = 18; int n, l[MAXN + 1]; long long a[MAXN + 1], b[MAXN + 1], d[MAXN + 1], f[MAXN + 1][MAXLOGN + 1], g[MAXN + 1][MAXLOGN + 1]; inline void dp() { for (int x = n; x; x--) { for (int i = l[x] - 1; i &gt;= 0; i--) { int lchild = x &lt;&lt; 1, rchild = lchild + 1, target = x &gt;&gt; (l[x] - i - 1) ^ 1; if (lchild &gt; n) { f[x][i] = a[target] * (d[x] + d[target] - (d[target &gt;&gt; 1] &lt;&lt; 1)); } else if (rchild &gt; n) { f[x][i] = f[lchild][i] + a[lchild] * b[lchild]; } else { f[x][i] = std::min( a[lchild] * b[lchild] + f[lchild][l[x]] + f[rchild][i], a[rchild] * b[rchild] + f[rchild][l[x]] + f[lchild][i] ); } } } for (int x = n; x; x--) { for (int i = l[x]; i &gt;= 0; i--) { int lchild = x &lt;&lt; 1, rchild = lchild + 1, target = x &gt;&gt; (l[x] - i); if (lchild &gt; n) { g[x][i] = a[target] * (d[x] - d[target]); } else if (rchild &gt; n) { g[x][i] = g[lchild][i] + a[lchild] * b[lchild]; } else { g[x][i] = std::min( a[lchild] * b[lchild] + f[lchild][l[x]] + g[rchild][i], a[rchild] * b[rchild] + f[rchild][l[x]] + g[lchild][i] ); } } } } inline long long calc(int x) { long long result = g[x][l[x] - 1]; for (; x != 1; x &gt;&gt;= 1) { int brother = x ^ 1, parent = x &gt;&gt; 1; if (brother &gt; n) { result += a[parent &gt;&gt; 1] * b[parent]; } else { result += a[brother] * b[brother] + g[brother][l[parent] - 1]; } } return result; } inline long long solve() { long long ans = g[1][0]; for (int i = 2; i &lt;= n; i++) ans = std::min(ans, calc(i)); return ans; } int main() { // freopen("light.in", "r", stdin); // freopen("light.out", "w", stdout); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf("%lld", &amp;a[i]); } for (int i = 2; i &lt;= n; i++) { scanf("%lld", &amp;b[i]); } l[1] = 1, d[1] = 0; for (int i = 2; i &lt;= n; i++) { l[i] = l[i &gt;&gt; 1] + 1; d[i] = d[i &gt;&gt; 1] + b[i]; } dp(); printf("%lld\n", solve()); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>安徽集训</tag>
        <tag>DP</tag>
        <tag>树形 DP</tag>
        <tag>BZOJ</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2143」飞飞侠 - 最短路]]></title>
    <url>%2Fbzoj-2143%2F</url>
    <content type="text"><![CDATA[飞国是一个 的矩形方阵，每个格子代表一个街区。飞国是没有交通工具的。飞侠完全靠地面的弹射装置来移动。每个街区都装有弹射装置。使用弹射装置是需要支付一定费用的。而且每个弹射装置都有自己的弹力。设第 行第 列的弹射装置有 的费用和 的弹力。并规定有相邻边的格子间距离是 。那么，任何飞侠都只需要在 支付 的费用就可以任 意选择弹到距离不超过 的位置了。 有三个飞侠，分别叫做 X、Y、Z。现在它们决定聚在一起玩，于是想往其中一人的位置集合。告诉你 个飞侠的坐标，求往哪里集合大家需要花的费用总和最低。 链接 BZOJ 2143 题解 直接裸最短路只能过 40%，考虑从每个位置能走到的位置的坐标最多为 ，为空中的每个位置建立节点，从地面到空中 高度需要 的花费，从空中每个位置到其前后左右位置，高度下降一个单位，花费为 0。这样做有效的减少了边的数量，虽然点变多了，但 Dijkstra 的堆优化效果会更加明显。 然而这样还是过不了的 …… 考虑到 Dijkstra 贪心选择最近点的特点，如果从堆中取出的点的到起点距离比三个飞侠的到起点的距离还要大，就可以直接剪枝。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;cstdlib&gt; #include &lt;queue&gt; const int MAXN = 150; const int MAXM = 150; struct Node { int dist; } nodes[MAXN][MAXM][MAXN + MAXM + 1]; int n, m, a[MAXN][MAXM], b[MAXN][MAXM]; struct Point { int x, y, k; Point(int x = 0, int y = 0, int k = 0) : x(x), y(y), k(k) {} Node *operator-&gt;() const { return &amp;nodes[x][y][k]; } Point up(int k) { return Point(x, y, k); } Point move(int x, int y) { return Point(this-&gt;x + x, this-&gt;y + y, k - 1); } bool isValid() { return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; k &gt;= 0; } int a() { return ::a[x][y]; } int b() { return ::b[x][y]; } struct Compare { bool operator()(const Point &amp;a, const Point &amp;b) { return a-&gt;dist &gt; b-&gt;dist; } }; } p[3]; void dijkstra(const Point &amp;start) { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { for (int k = 0; k &lt;= n + m; k++) { nodes[i][j][k].dist = INT_MAX; } } } start-&gt;dist = 0; std::priority_queue&lt;Point, std::vector&lt;Point&gt;, Point::Compare&gt; q; q.push(start); while (!q.empty()) { Point p = q.top(); q.pop(); if (p-&gt;dist &gt; ::p[0]-&gt;dist &amp;&amp; p-&gt;dist &gt; ::p[1]-&gt;dist &amp;&amp; p-&gt;dist &gt; ::p[2]-&gt;dist) continue; if (p.k == 0) { Point up = p.up(p.b()); if (up-&gt;dist &gt; p-&gt;dist + p.a()) up-&gt;dist = p-&gt;dist + p.a(), q.push(up); } else { Point side; if ((side = p.move(0, 1)).isValid() &amp;&amp; side-&gt;dist &gt; p-&gt;dist) side-&gt;dist = p-&gt;dist, q.push(side); if ((side = p.move(0, -1)).isValid() &amp;&amp; side-&gt;dist &gt; p-&gt;dist) side-&gt;dist = p-&gt;dist, q.push(side); if ((side = p.move(1, 0)).isValid() &amp;&amp; side-&gt;dist &gt; p-&gt;dist) side-&gt;dist = p-&gt;dist, q.push(side); if ((side = p.move(-1, 0)).isValid() &amp;&amp; side-&gt;dist &gt; p-&gt;dist) side-&gt;dist = p-&gt;dist, q.push(side); if ((side = p.move(0, 0)).isValid() &amp;&amp; side-&gt;dist &gt; p-&gt;dist) side-&gt;dist = p-&gt;dist, q.push(side); } } // puts("&gt;_&lt;"); } int main() { // freopen("fly.in", "r", stdin); // freopen("fly.out", "w", stdout); scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { scanf("%d", &amp;b[i][j]); if (b[i][j] &gt; n + m) b[i][j] = n + m; } } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { scanf("%d", &amp;a[i][j]); } } for (int i = 0; i &lt; 3; i++) scanf("%d %d", &amp;p[i].x, &amp;p[i].y), p[i].x--, p[i].y--; int dist[3][3]; for (int i = 0; i &lt; 3; i++) { dijkstra(p[i]); for (int j = 0; j &lt; 3; j++) { dist[i][j] = p[j]-&gt;dist; } } int ans = INT_MAX; char ansPos = '\0'; for (int i = 0; i &lt; 3; i++) { if (dist[0][i] == INT_MAX || dist[1][i] == INT_MAX || dist[2][i] == INT_MAX) continue; int tmp = dist[0][i] + dist[1][i] + dist[2][i]; if (tmp &lt; ans) ans = tmp, ansPos = 'X' + i; } if (ans == INT_MAX) puts("NO"); else printf("%c\n%d\n", ansPos, ans); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>安徽集训</tag>
        <tag>BZOJ</tag>
        <tag>Dijkstra</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2015」国旗计划 - 贪心 + 倍增]]></title>
    <url>%2Fscoi2015-flag%2F</url>
    <content type="text"><![CDATA[A 国幅员辽阔，边境线上设有 个边防站，顺时针编号 至 。每名边防战士常驻两个边防站，并且善于在这两个边防站之间长途奔袭，我们称这两个边防站之间的路程是这个边防战士的奔袭区间。每名战士的奔袭区间都不会被其他战士的奔袭区间所包含。 现在，局长希望知道，至少需要多少名战士，才能使得他们的奔袭区间覆盖全部的边境线。局长还希望知道对于每一名战士，在他必须参加国旗计划的前提下，至少需要多少名战士才能覆盖全部边境线。 链接 BZOJ 4444 题解 首先，明确一个贪心的思路：对于任何一个战士，选择他后要选择的下一个，一定是在他后面并且与他奔袭区间交集最小的（因为所有的区间完全覆盖并且没有相互包含）。 把所有区间翻倍存储，以左端点排序。 40 分：枚举每个战士，在他之后的所有战士中确定一个与他奔袭区间交集最小的，作为他的下一个（时间复杂度 ）；然后对于每个询问从该战士开始不断找下一个战士，直到找回来为止； 70 分：把找「下一个战士」的复杂度优化为 ，使用 std::upper_bound，用当前战士的区间右端点和其他区间的左端点比较，返回的结果 -1 即为要找的「下一个战士」。 100 分：思考回答询问时的过程，每次线性地向后扫描做了很多重复的工作，考虑到无论从那个战士出发，经过的相同位置向后的路线都是相同的，所以可以先 地预处理出一个稀疏表，用 表示战士 向后找 次所到达的战士，然后就可以 地回答每个询问了。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 200000; const int MAXLOGN = 18; struct Fighter { int id, l, r, ans; Fighter *next[MAXLOGN + 1]; } fighters[MAXN * 2]; int n, m, ans[MAXN]; bool operator&lt;(const Fighter &amp;a, const Fighter &amp;b) { return a.l &lt; b.l; } bool operator&lt;(int r, const Fighter &amp;a) { return r &lt; a.l; } int main() { freopen("flag.in", "r", stdin); // freopen("flag.out", "w", stdout); scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) { Fighter &amp;a = fighters[i]; a.id = i; scanf("%d %d", &amp;a.l, &amp;a.r); if (a.l &gt; a.r) a.r += m; fighters[i + n].l = a.l + m, fighters[i + n].r = a.r + m; } std::sort(fighters, fighters + n * 2); for (int i = 0; i &lt; n * 2; i++) { Fighter &amp;a = fighters[i]; a.next[0] = std::upper_bound(fighters, fighters + n * 2, a.r) - 1; } for (int j = 1; (1 &lt;&lt; j) &lt;= n * 2; j++) { for (int i = 0; i &lt; n * 2; i++) { Fighter &amp;a = fighters[i]; if (a.next[j - 1]) { a.next[j] = a.next[j - 1]-&gt;next[j - 1]; } } } for (int i = 0; i &lt; n; i++) { Fighter *p = &amp;fighters[i]; for (int j = MAXLOGN; j &gt;= 0; j--) { if (p-&gt;next[j] &amp;&amp; p-&gt;next[j]-&gt;r &lt; fighters[i].l + m) { ans[fighters[i].id] += (1 &lt;&lt; j); p = p-&gt;next[j]; } } } for (int i = 0; i &lt; n; i++) { printf("%d ", ans[i] + 2); } putchar('\n'); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>安徽集训</tag>
        <tag>BZOJ</tag>
        <tag>倍增</tag>
        <tag>贪心</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2015」情报传递 - 离线 + Link-Cut Tree]]></title>
    <url>%2Fscoi2015-message%2F</url>
    <content type="text"><![CDATA[奈特公司有着庞大的情报网络。情报网络中共有 名情报员。每名情报员有若干名下线，除 1 名大头目外其余 名情报员有且仅有 1 名上线。每名情报员只能与自己的上、下线联系，同时，情报网络中任意两名情报员一定能够通过情报网络传递情报。奈特公司每天会派发以下两种任务中的一个任务： 搜集情报：指派 号情报员搜集情报； 传递情报：将一条情报从 号情报员传递给 号情报员。 情报员最初处于潜伏阶段，危险值为 0；一旦某个情报员开始搜集情报，他的危险值就会持续增加，每天增加 1 点危险值（开始搜集情报的当天危险值仍为 0，第 2 天危险值为 1，以此类推）。传递情报并不会使情报员的危险值增加。 为了保证传递情报的过程相对安全，每条情报都有一个风险控制值 。公司认为，传递这条情报的所有情报员中，危险值大于 的情报员将对该条情报构成威胁。现在，奈特公司希望知道，对于每个传递情报任务，参与传递的情报员有多少个，其中对该条情报构成威胁的情报员有多少个。 链接 BZOJ 4448 题解 因为整个网络是一棵树，所以可以用一棵 Link-Cut Tree 来维护。 前 30 分，无修改操作，直接求出两点距离。 30 ~ 60 分，保证 ，修改直接单点修改值为 1，查询直接查询有多少 1 即可。 后 40 分，考虑到对于每个查询操作，只有距离它 天之前的修改操作对它有贡献，所以可以将操作离线，保证每次修改后直接处理查询即可。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; const int MAXN = 200000; const int MAXM = 200000; struct LinkCutTree { enum Relation { L = 0, R = 1 }; struct Node { Node *child[2], *parent, *pathParent; int value, sum, size; bool reversed; Node() : parent(NULL), pathParent(NULL), value(0), sum(0), size(1), reversed(false) { child[L] = child[R] = NULL; } void pushDown() { if (reversed) { std::swap(child[L], child[R]); if (child[L]) child[L]-&gt;reversed ^= 1; if (child[R]) child[R]-&gt;reversed ^= 1; reversed = false; } } void maintain() { sum = value, size = 1; if (child[L]) sum += child[L]-&gt;sum, size += child[L]-&gt;size; if (child[R]) sum += child[R]-&gt;sum, size += child[R]-&gt;size; } Relation relation() { return this == parent-&gt;child[L] ? L : R; } void rotate() { if (parent-&gt;parent) parent-&gt;parent-&gt;pushDown(); parent-&gt;pushDown(), pushDown(); std::swap(pathParent, parent-&gt;pathParent); Relation x = relation(); Node *oldParent = parent; if (oldParent-&gt;parent) oldParent-&gt;parent-&gt;child[oldParent-&gt;relation()] = this; parent = oldParent-&gt;parent; if (child[x ^ 1]) child[x ^ 1]-&gt;parent = oldParent; oldParent-&gt;child[x] = child[x ^ 1]; child[x ^ 1] = oldParent; oldParent-&gt;parent = this; oldParent-&gt;maintain(), maintain(); } void splay() { while (parent != NULL) { if (parent-&gt;parent == NULL) rotate(); else { parent-&gt;parent-&gt;pushDown(), parent-&gt;pushDown(); if (parent-&gt;relation() == relation()) parent-&gt;rotate(), rotate(); else rotate(), rotate(); } } pushDown(); } void expose() { splay(); if (child[R]) { std::swap(child[R]-&gt;parent, child[R]-&gt;pathParent); child[R] = NULL; maintain(); } } bool splice() { splay(); if (!pathParent) return false; pathParent-&gt;expose(); pathParent-&gt;child[R] = this; pathParent-&gt;maintain(); std::swap(parent, pathParent); return true; } void access() { expose(); while (splice()); } void evert() { access(); splay(); reversed ^= 1; } } nodes[MAXN]; void query(int u, int v, int &amp;size, int &amp;sum) { nodes[u - 1].evert(); nodes[v - 1].access(); nodes[v - 1].splay(); size = nodes[v - 1].size; sum = nodes[v - 1].sum; } void update(int u, int value) { nodes[u - 1].splay(); nodes[u - 1].value = value; nodes[u - 1].maintain(); } void link(int u, int v) { nodes[v - 1].evert(); nodes[v - 1].splay(); nodes[v - 1].pathParent = &amp;nodes[u - 1]; } } lct; struct Day { int id; int task; int u, v, c; bool operator&lt;(const Day &amp;other) const { return c &lt; other.c; } } days[MAXM]; int n, m; inline void bfs() { std::queue&lt;Tree *&gt; q; q.push(&amp;nodes[0]); nodes[0].depth = 1; while (!q.empty()) { Tree *t = q.front(); q.pop(); for (Tree *c = t-&gt;firstChild; c; c = c-&gt;next) { c-&gt;depth = t-&gt;depth + 1; q.push(c); } } } inline void work() { for (int i = 0; i &lt; m; i++) { if (days[i].task == 2) lct.update(days[i].u, 1); else { int size, sum; lct.query(days[i].u, days[i].v, size, sum); printf("%d %d\n", size, sum); } } } int main() { // freopen("message.in", "r", stdin); // freopen("message.out", "w", stdout); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) { int u; scanf("%d", &amp;u); if (u != 0) lct.link(u, i); } scanf("%d", &amp;m); bool flag1 = true, flag2 = true; for (int i = 0; i &lt; m; i++) { days[i].id = i; scanf("%d", &amp;days[i].task); if (days[i].task == 2) scanf("%d", &amp;days[i].u), days[i].c = i; else { int tmp; scanf("%d %d %d", &amp;days[i].u, &amp;days[i].v, &amp;tmp); days[i].c = i - tmp; } } std::sort(days, days + m); work(); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>安徽集训</tag>
        <tag>数据结构</tag>
        <tag>高级数据结构</tag>
        <tag>BZOJ</tag>
        <tag>Link-Cut Tree</tag>
        <tag>离线</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2015」小凸玩矩阵 - 二分图匹配]]></title>
    <url>%2Fscoi2015-matrix%2F</url>
    <content type="text"><![CDATA[小方给小凸一个 （）的矩阵 ，要求小秃从其中选出 个数，其中任意两个数字不能在同一行或同一列，现小凸想知道选出来的 个数中第 大的数字的最小值是多少。 链接 BZOJ 4443 题解 二分第 大的数是多少，然后建二分图，用行匹配列，检验匹配数是不是大于等于 。 注意，是第 大，不是第 小！ 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 250; const int MAXM = 250; const int MAXK = 250; const int CACHE_FIX = 3; struct Node; struct Edge; struct Node { Edge *firstEdge, *currentEdge; int level; } nodes[MAXN + MAXM + 2]; struct Edge { Node *from, *to; int capacity, flow; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from-&gt;firstEdge) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, int n) { for (int i = 0; i &lt; n; i++) nodes[i].level = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == 0) { e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; else q.push(e-&gt;to); } } } return false; } int findPath(Node *s, Node *t, int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;currentEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == s-&gt;level + 1) { int flow = findPath(e-&gt;to, t, std::min(limit, e-&gt;capacity - e-&gt;flow)); if (flow &gt; 0) { e-&gt;flow += flow; e-&gt;reversedEdge-&gt;flow -= flow; return flow; } } } return 0; } int operator()(int s, int t, int n) { int ans = 0; while (makeLevelGraph(&amp;nodes[s], &amp;nodes[t], n)) { for (int i = 0; i &lt; n; i++) nodes[i].currentEdge = nodes[i].firstEdge; int flow; while ((flow = findPath(&amp;nodes[s], &amp;nodes[t])) &gt; 0) ans += flow; } return ans; } } dinic; inline void addEdge(int from, int to, int capacity) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } int n, m, k, a[MAXN + CACHE_FIX][MAXM], max; void cleanUp() { for (int i = 0; i &lt; n + m + 2; i++) { Edge *next; for (Edge *&amp;e = nodes[i].firstEdge; e; next = e-&gt;next, delete e, e = next); } } bool check(int limit) { cleanUp(); const int s = 0, t = n + m + 1; for (int i = 1; i &lt;= n; i++) addEdge(s, i, 1); for (int j = 1; j &lt;= m; j++) addEdge(n + j, t, 1); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (a[i - 1][j - 1] &lt;= limit) addEdge(i, n + j, 1); } } int maxFlow = dinic(s, t, n + m + 2); // printf("%d\n", maxFlow); return maxFlow &gt;= n - k + 1; } inline int solve() { static int tmp[MAXN * MAXM]; for (int i = 0, c = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { tmp[c++] = a[i][j]; } } std::sort(tmp, tmp + n * m); int *l = tmp, *r = std::unique(tmp, tmp + n * m) - 1; while (l &lt; r) { int *const mid = l + ((r - l) &gt;&gt; 1); if (check(*mid)) r = mid; else l = mid + 1; } return *l; } int main() { // freopen("matrix.in", "r", stdin); // freopen("matrix.out", "w", stdout); scanf("%d %d %d", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { scanf("%d", &amp;a[i][j]); } } printf("%d\n", solve()); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>安徽集训</tag>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>二分答案</tag>
        <tag>二分图匹配</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「省选模拟赛」染色 - 树链剖分]]></title>
    <url>%2F20160318-color%2F</url>
    <content type="text"><![CDATA[给定一棵 个节点的树，树的节点标号从 开始。每个节点可以是白色或黑色，初始时每个节点的颜色为白色。要求支持以下两种操作： 将节点 涂黑； 查询节点 到所有黑点距离之和。 题解 先预处理出所有点到根的距离之和，维护当前所有黑点到根的距离之和 和黑点总数 。 考虑询问由根节点的向它的某个子节点 u 移动，则答案为： 即 树链剖分，用线段树维护 在链上的总和，每次 计算。 代码 #include &lt;cstdio&gt; #include &lt;stack&gt; #include &lt;algorithm&gt; const int MAXN = 100000; const int MAXM = 100000; struct SegmentTree { int l, r; SegmentTree *lchild, *rchild; int blackCount; int count, lazyCount, base; long long sum; SegmentTree(int l, int r, SegmentTree *lchild, SegmentTree *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), blackCount(0), count(0), lazyCount(0), base(0), sum(0) {} ~SegmentTree() { if (lchild) delete lchild; if (rchild) delete rchild; } void pushDown() { if (lazyCount) { if (lchild) lchild-&gt;lazyCount += lazyCount, lchild-&gt;count += lazyCount, lchild-&gt;sum += (long long)lchild-&gt;base * lazyCount; if (rchild) rchild-&gt;lazyCount += lazyCount, rchild-&gt;count += lazyCount, rchild-&gt;sum += (long long)rchild-&gt;base * lazyCount; lazyCount = 0; } } long long querySum(int l, int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return sum; else { pushDown(); long long result = 0; if (lchild) result += lchild-&gt;querySum(l, r); if (rchild) result += rchild-&gt;querySum(l, r); // printf("sq(%d, %d) = %d\n", l, r, result); return result; } } int queryCount(int l, int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return count; else { pushDown(); int result = 0; if (lchild) result += lchild-&gt;queryCount(l, r); if (rchild) result += rchild-&gt;queryCount(l, r); // printf("sq(%d, %d) = %d\n", l, r, result); return result; } } void updateCount(int l, int r, int delta) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) lazyCount += delta, count += delta, sum += (long long)delta * base; else { pushDown(); sum = count = 0; if (lchild) lchild-&gt;updateCount(l, r, delta), count += lchild-&gt;count, sum += lchild-&gt;sum; if (rchild) rchild-&gt;updateCount(l, r, delta), count += rchild-&gt;count, sum += rchild-&gt;sum; } } void setBase(int x, int base) { if (x &gt; this-&gt;r || x &lt; this-&gt;l) return; else if (x == this-&gt;l &amp;&amp; x == this-&gt;r) this-&gt;base = base; else { if (lchild) lchild-&gt;setBase(x, base); if (rchild) rchild-&gt;setBase(x, base); this-&gt;base = lchild-&gt;base + rchild-&gt;base; } } int queryBlackCount(int l, int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return blackCount; else { pushDown(); int result = 0; if (lchild) result += lchild-&gt;queryBlackCount(l, r); if (rchild) result += rchild-&gt;queryBlackCount(l, r); return result; } } void updateBlackCount(int x, int delta) { if (x &gt; this-&gt;r || x &lt; this-&gt;l) return; else if (x == this-&gt;l &amp;&amp; x == this-&gt;r) blackCount += delta; else { pushDown(); blackCount = 0; if (lchild) lchild-&gt;updateBlackCount(x, delta), blackCount += lchild-&gt;blackCount; if (rchild) rchild-&gt;updateBlackCount(x, delta), blackCount += rchild-&gt;blackCount; } } }; SegmentTree *buildSegmentTree(int l, int r) { if (l &gt; r) return NULL; else if (l == r) return new SegmentTree(l, r, NULL, NULL); else return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) &gt;&gt; 1)), buildSegmentTree(l + ((r - l) &gt;&gt; 1) + 1, r)); } struct Tree; struct Path; struct Tree { Tree *firstChild, *next, *parent, *maxSizeChild; bool visited, colored; Path *path; int size, depth, pos, posEnd; long long cost, costPrefixSum; } trees[MAXN]; struct Path { Tree *top; int length; Path(Tree *top) : top(top), length(1) {} }; inline void addRelation(int child, int parent) { trees[child].parent = &amp;trees[parent]; trees[child].next = trees[parent].firstChild; trees[parent].firstChild = &amp;trees[child]; } int n, m, blackCount; long long sum; SegmentTree *segment; inline void cut() { std::stack&lt;Tree *&gt; s; s.push(&amp;trees[0]); trees[0].depth = 1; trees[0].costPrefixSum = 0; while (!s.empty()) { Tree *t = s.top(); if (!t-&gt;visited) { t-&gt;visited = true; for (Tree *c = t-&gt;firstChild; c; c = c-&gt;next) { c-&gt;depth = t-&gt;depth + 1; c-&gt;costPrefixSum = t-&gt;costPrefixSum + c-&gt;cost; s.push(c); } } else { t-&gt;size = 1; for (Tree *c = t-&gt;firstChild; c; c = c-&gt;next) { t-&gt;size += c-&gt;size; if (t-&gt;maxSizeChild == NULL || t-&gt;maxSizeChild-&gt;size &lt; c-&gt;size) t-&gt;maxSizeChild = c; } s.pop(); } } for (int i = 0; i &lt; n; i++) trees[i].visited = false; s.push(&amp;trees[0]); int timeStamp = 0; while (!s.empty()) { Tree *t = s.top(); if (!t-&gt;visited) { t-&gt;visited = true; if (t-&gt;parent == NULL || t-&gt;parent-&gt;maxSizeChild != t) t-&gt;path = new Path(t); else t-&gt;path = t-&gt;parent-&gt;path, t-&gt;path-&gt;length++; t-&gt;pos = ++timeStamp; for (Tree *c = t-&gt;firstChild; c; c = c-&gt;next) { if (c != t-&gt;maxSizeChild) s.push(c); } if (t-&gt;maxSizeChild) s.push(t-&gt;maxSizeChild); } else { t-&gt;posEnd = timeStamp; s.pop(); } } segment = buildSegmentTree(1, n); for (int i = 0; i &lt; n; i++) { segment-&gt;setBase(trees[i].pos, trees[i].cost); } } inline int queryDist(int u, int v) { if (u == v) return 0; Tree *a = &amp;trees[u], *b = &amp;trees[v]; int sum = 0; while (a-&gt;path != b-&gt;path) { if (a-&gt;path-&gt;top-&gt;depth &lt; b-&gt;path-&gt;top-&gt;depth) std::swap(a, b); sum += segment-&gt;querySum(a-&gt;path-&gt;top-&gt;pos, a-&gt;pos); // printf("query(%d, %d)::sum = %d\n", u, v, sum); a = a-&gt;path-&gt;top-&gt;parent; } if (a-&gt;pos &gt; b-&gt;pos) std::swap(a, b); sum += segment-&gt;querySum(a-&gt;pos, b-&gt;pos); sum -= a-&gt;cost; return sum; } inline void updateToBlack(int u) { if (trees[u].colored) return; trees[u].colored = true; sum += trees[u].costPrefixSum; for (Tree *t = &amp;trees[u]; t; t = t-&gt;path-&gt;top-&gt;parent) { segment-&gt;updateCount(t-&gt;path-&gt;top-&gt;pos, t-&gt;pos, 1); } segment-&gt;updateBlackCount(trees[u].pos, 1); blackCount++; } inline long long queryAllDist(int u) { Tree *t = &amp;trees[u]; int childBlackCount = segment-&gt;queryBlackCount(t-&gt;pos, t-&gt;posEnd); long long tmp = 0; for (Tree *t = &amp;trees[u]; t; t = t-&gt;path-&gt;top-&gt;parent) tmp += segment-&gt;querySum(t-&gt;path-&gt;top-&gt;pos, t-&gt;pos); return sum + t-&gt;costPrefixSum * blackCount - 2 * tmp; } int main() { // freopen("color.in", "r", stdin); // freopen("color.out", "w", stdout); scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt; n; i++) { int parent; scanf("%d", &amp;parent); addRelation(i, parent); } for (int i = 1; i &lt; n; i++) { scanf("%lld", &amp;trees[i].cost); } cut(); for (int i = 0; i &lt; m; i++) { int t, u; scanf("%d %d", &amp;t, &amp;u); if (t == 1) updateToBlack(u); else printf("%lld\n", queryAllDist(u)); } fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>安徽集训</tag>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
        <tag>线段树</tag>
        <tag>高级数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「省选模拟赛」小奇的糖果 - 扫描线 + 链表]]></title>
    <url>%2F20160319-candy%2F</url>
    <content type="text"><![CDATA[有 个彩色糖果在平面上。小奇想在平面上取一条水平的线段，并拾起它上方或下方的所有糖果。求出最多能够拾起多少糖果，使得获得的糖果并不包含所有的颜色。 题解 对纵坐标离散化。 用树状数组维护「当前」横坐标在某个区间内的糖果数量。 用链表维护「当前」某个糖果左边右边与它横坐标最近的两个糖果。 扫描线从上往下扫，初始时树状数组为满，扫到某个新纵坐标把一条直线上所有糖果从树状数组中删掉。对于每个扫描到的糖果，先把它从链表中删掉，考虑这种颜色不选，统计它左边和它右边两个与它颜色相同的糖果之间的糖果数量，更新答案。 跑扫描线之前还要先算出每两个相邻的糖果之间的答案。 题目中允许取上边或下边，只需要将纵坐标取反即可。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;set&gt; #include &lt;list&gt; const int MAXT = 3; const int MAXN = 100000; const int MAXK = 100000; struct Candy { int xOrigin, yOrigin; int x, y; int color; std::list&lt;Candy&gt;::iterator p; } candies[MAXN]; bool compareByY(const Candy &amp;a, const Candy &amp;b) { return a.y &lt; b.y; } bool compareByX(const Candy &amp;a, const Candy &amp;b) { return a.x &lt; b.x; } int n, k, xSet[MAXN], ySet[MAXN], cx, cy; std::list&lt;Candy&gt; list[MAXK]; struct BinaryIndexedTree { int a[MAXN]; static int lowbit(int x) { return x &amp; -x; } void update(int pos, int delta) { for (int i = pos; i &lt;= n; i += lowbit(i)) a[i - 1] += delta; } int sum(int pos) { int result = 0; for (int i = pos; i &gt; 0; i -= lowbit(i)) result += a[i - 1]; return result; } int query(int l, int r) { // printf("query(%d, %d) = %d\n", l, r, sum(r) - sum(l - 1)); return sum(r) - sum(l - 1); } void clear() { memset(a, 0, sizeof(a)); } } bit; inline int solve() { bit.clear(); for (int i = 0; i &lt; k; i++) list[i].clear(); std::sort(candies, candies + n, &amp;compareByX); for (int i = 0; i &lt; n; i++) { candies[i].p = list[candies[i].color].insert(list[candies[i].color].end(), candies[i]); bit.update(candies[i].x, 1); } std::sort(candies, candies + n, &amp;compareByY); int ans = 0; for (int i = 0; i &lt; k; i++) { int last = 0; for (std::list&lt;Candy&gt;::const_iterator p = list[i].begin(); p != list[i].end(); p++) { ans = std::max(ans, bit.query(last + 1, p-&gt;x - 1)); last = p-&gt;x; } ans = std::max(ans, bit.query(last + 1, n)); } for (int i = 0; i &lt; n; i++) { if (i == 0 || candies[i].y != candies[i - 1].y) { for (int j = i; j &lt; n &amp;&amp; candies[j].y == candies[i].y; j++) { bit.update(candies[j].x, -1); } } int l, r; std::list&lt;Candy&gt;::iterator &amp;p = candies[i].p; if (p != list[candies[i].color].begin()) { std::list&lt;Candy&gt;::const_iterator prev = p; prev--; l = prev-&gt;x + 1; } else l = 1; std::list&lt;Candy&gt;::const_iterator next = p; next++; if (next != list[candies[i].color].end()) { r = next-&gt;x - 1; } else r = n; ans = std::max(ans, bit.query(l, r)); list[candies[i].color].erase(p); } return ans; } int main() { // freopen("candy.in", "r", stdin); // freopen("candy.out", "w", stdout); int t; scanf("%d", &amp;t); while (t--) { scanf("%d %d", &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) { scanf("%d %d %d", &amp;candies[i].xOrigin, &amp;candies[i].yOrigin, &amp;candies[i].color), candies[i].color--; xSet[i] = candies[i].xOrigin; ySet[i] = candies[i].yOrigin; } int *xEnd, *yEnd; std::sort(xSet, xSet + n); std::sort(ySet, ySet + n); xEnd = std::unique(xSet, xSet + n); yEnd = std::unique(ySet, ySet + n); cx = xEnd - xSet; cy = yEnd - ySet; for (int i = 0; i &lt; n; i++) { candies[i].x = std::lower_bound(xSet, xEnd, candies[i].xOrigin) - xSet + 1; candies[i].y = std::lower_bound(ySet, yEnd, candies[i].yOrigin) - ySet + 1; } int ans = 0; ans = std::max(ans, solve()); for (int i = 0; i &lt; n; i++) candies[i].y = -candies[i].y; ans = std::max(ans, solve()); printf("%d\n", ans); } fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>安徽集训</tag>
        <tag>扫描线</tag>
        <tag>树状数组</tag>
        <tag>离散化</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「省选模拟赛」小奇的集合 - 矩阵乘法]]></title>
    <url>%2F20160319-set%2F</url>
    <content type="text"><![CDATA[有一个大小为 的可重集 ，小奇每次操作可以加入一个数 （， 均属于 ），求 次操作后它可获得的 的和的最大值（数据保证这个值为非负数）。 题解 每次要取的都是最大的和次大的，考虑最大的和次大的都是非负数正数的情况，使用矩阵乘法（ 为最大值， 为次大值， 为当前总和）： 对于次大值为负的情况，先模拟，直到为正再用矩阵乘法。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; const int MAXN = 100000; const int MAXK = 1000000000; const int MOD = 10000007; template&lt;typename T&gt; struct Matrix { T a[3][3]; Matrix(T x1 = 1, T x2 = 0, T x3 = 0, T x4 = 0, T x5 = 1, T x6 = 0, T x7 = 0, T x8 = 0, T x9 = 1) { a[0][0] = x1, a[0][1] = x2, a[0][2] = x3; a[1][0] = x4, a[1][1] = x5, a[1][2] = x6; a[2][0] = x7, a[2][1] = x8, a[2][2] = x9; } const T &amp;operator()(int i, int j) const { return a[i][j]; } T &amp;operator()(int i, int j) { return a[i][j]; } void print() { for (int i = 0; i &lt; 3; i++) { printf("[ "); for (int j = 0; j &lt; 3; j++) { printf("%lld ", a[i][j]); } printf("] "); } putchar('\n'); } }; template &lt;typename T&gt; Matrix&lt;T&gt; operator*(const Matrix&lt;T&gt; &amp;a, const Matrix&lt;T&gt; &amp;b) { Matrix&lt;T&gt; r( 0, 0, 0, 0, 0, 0, 0, 0, 0 ); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { for (int k = 0; k &lt; 3; k++) { r(i, j) = (r(i, j) + (a(i, k) * b(k, j)) % MOD) % MOD; } } } // r.print(); return r; } template &lt;typename T&gt; Matrix&lt;T&gt; pow(Matrix&lt;T&gt; m, int x) { Matrix&lt;T&gt; ans; /*for (int i = 0; i &lt; x - 1; i++) ans = ans * m; return ans;*/ for (; x; x &gt;&gt;= 1, m = m * m){ // printf("x = %d\n", x); if (x &amp; 1) ans = ans * m; } return ans; } int max = INT_MIN, max2 = INT_MIN, sum; int main() { // freopen("set.in", "r", stdin); // freopen("set.out", "w", stdout); int n, k; scanf("%d %d", &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) { int num; scanf("%d", &amp;num); sum = (sum + num) % MOD; if (num &gt; max) max2 = max, max = num; else if (num &gt; max2) max2 = num; } while (max2 &lt; 0) { k--; int num = max + max2; sum = (sum + num) % MOD; if (num &gt; max) max2 = max, max = num; else if (num &gt; max2) max2 = num; } Matrix&lt;long long&gt; base( 1, 1, 0, 1, 0, 0, 1, 1, 1 ); Matrix&lt;long long&gt; init( max % MOD, 0, 0, max2 % MOD, 0, 0, sum % MOD, 0, 0 ); Matrix&lt;long long&gt; result = pow(base, k) * init; // printf("%d\n", (sum + (result(2, 0) * max) % MOD + (result(2, 1) * max2) % MOD) % MOD); printf("%d\n", (result(2, 0) + MOD) % MOD); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>安徽集训</tag>
        <tag>快速幂</tag>
        <tag>数学</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2008」洞穴勘测 - Link-Cut Tree]]></title>
    <url>%2Fsdoi2008-cave%2F</url>
    <content type="text"><![CDATA[如果监测到洞穴 和洞穴 之间出现了一条通道，终端机上会显示一条指令 Connect u v；如果监测到洞穴 和洞穴 之间的通道被毁，终端机上会显示一条指令 Destroy u v。辉辉希望能随时通过终端机发出指令 Query u v，向监测仪询问此时洞穴 和洞穴 是否连通。已知在第一条指令显示之前，洞穴群中没有任何通道存在。 链接 BZOJ 2049 CodeVS 1839 题解 最简单的 Link-Cut Tree 模板题。 相当于能拆的并查集。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 10000; const int MAXM = 200000; struct LinkCutTree { enum Relation { L = 0, R = 1 }; struct Node { Node *child[2], *parent, *pathParent; bool reversed; Node() : parent(NULL), pathParent(NULL), reversed(false) { child[0] = child[1] = NULL; } Relation relation() { return this == parent-&gt;child[L] ? L : R; } void pushDown() { if (reversed) { std::swap(child[L], child[R]); if (child[L]) child[L]-&gt;reversed ^= 1; if (child[R]) child[R]-&gt;reversed ^= 1; reversed = false; } } void rotate() { if (parent-&gt;parent) parent-&gt;parent-&gt;pushDown(); parent-&gt;pushDown(), pushDown(); Node *oldParent = parent; Relation r = relation(); if (oldParent-&gt;parent) oldParent-&gt;parent-&gt;child[oldParent-&gt;relation()] = this; parent = oldParent-&gt;parent; if (child[r ^ 1]) child[r ^ 1]-&gt;parent = oldParent; oldParent-&gt;child[r] = child[r ^ 1]; oldParent-&gt;parent = this; child[r ^ 1] = oldParent; std::swap(pathParent, oldParent-&gt;pathParent); } void splay() { while (parent != NULL) { if (parent-&gt;parent) parent-&gt;parent-&gt;pushDown(); parent-&gt;pushDown(), pushDown(); if (parent-&gt;parent == NULL) rotate(); else if (parent-&gt;relation() == relation()) parent-&gt;rotate(), rotate(); else rotate(), rotate(); } pushDown(); } void expose() { splay(); if (child[R]) { std::swap(child[R]-&gt;pathParent, child[R]-&gt;parent); child[R] = NULL; } } bool splice() { splay(); if (!pathParent) return false; pathParent-&gt;expose(); pathParent-&gt;child[R] = this; std::swap(parent, pathParent); return true; } void access() { expose(); while (splice()); } Node *findRoot() { access(); splay(); Node *v = this; while (v-&gt;pushDown(), v-&gt;child[L]) v = v-&gt;child[L]; return v; } void evert() { access(); splay(); reversed ^= 1; } } nodes[MAXN]; void link(int u, int v) { nodes[v - 1].evert(); nodes[v - 1].pathParent = &amp;nodes[u - 1]; } void cut(int u, int v) { nodes[u - 1].evert(); nodes[v - 1].access(); nodes[u - 1].splay(); nodes[u - 1].child[R] = NULL; nodes[v - 1].parent = NULL; } Node *find(int u) { return nodes[u - 1].findRoot(); } } lct; int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) { char command[sizeof("Connect")]; int u, v; scanf("%s %d %d", command, &amp;u, &amp;v); if (command[0] == 'C') lct.link(u, v); else if (command[0] == 'D') lct.cut(u, v); else if (command[0] == 'Q') { if (lct.find(u) == lct.find(v)) puts("Yes"); else puts("No"); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>高级数据结构</tag>
        <tag>BZOJ</tag>
        <tag>CodeVS</tag>
        <tag>Link-Cut Tree</tag>
        <tag>动态树</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学学习笔记]]></title>
    <url>%2Fcombinatorics-notes%2F</url>
    <content type="text"><![CDATA[计数原理、排列、组合、递推关系、等差数列求和公式、自然数平方和公式、二项式定理。 计数原理 加法原理 做一件事有 种途径，每种途径有 个不同的方案，则做这件事的方案数为 乘法原理 做一件事有 个步骤，每个步骤有 个不同的方案，则做这件事的方案数为 容斥原理 统计多个集合的并的元素数量：先加上所有集合的元素的元素数量，再减去『多加的』每两个集合相交的元素数量，再加上『多减的』每三个集合相交的元素数量 …… 即等式左边是多个集合的并的元素数量，等式右边每一项是几个几何的交的元素数量，每一项的符号取决于元素数量的奇偶。 排列 全排列 把 个元素按照不同顺序排列，设总方案数为 （定义 ），考虑第一个元素摆放的位置，得出公式 即 。 普通排列 从 个元素中取 个，按照不同顺序排列，设总方案数为 ，每次选一个数，第一次有 种选择，第二次有 种选择，直到第 次有 种选择，即 将上式与 对比，缺少 及之后的项，即 有重复元素的全排列 从 种元素，第 种有 个，设 ，为了保证答案不重复，可以先求出 ，再除去每种元素重复的情况，即 组合 组合数 从 n 个元素中选择 k 个，顺序无关，设总方案数为 。把排列数 看做先从 n 各种选择 k 个元素，再对 k 个元素做全排列，即 移项得 组合数的性质 全选或全不选只有一种方案。 选择 个拿走相当于选择 个留下。 考虑最后一个选还是不选（Pascal 公式，常用来递推计算组合数表）。 可重复选择的组合 从 n 种无限多的元素中选择 k 个，共有 种方案。 组合数的计算 组合数表 用 Pascal 公式递推，组合数太大要开高精度或者取模。 BigInt combo[MAXN + 1][MAXN + 1]; inline void makeComboTable() { for (int i = 1; i &lt;= MAXN; i++) { combo[i][0] = combo[i][i] = 1; for (int j = 1; j &lt; i; j++){ combo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1]; } } } inline BigInt &amp;C(int n, int k) { return combo[n][k]; } 单个计算 书上有用 double 来算的，因为中间乘法 long long 可能会溢出，不知道那样会不会损失精度。 long long C(long long n, long long k) { long long result = 1; for (int i = 1; i &lt;= k; i++) { result = result * (n - i + 1) / i; } return result; } 递推关系 Fibonacci 数列 楼梯上共有 个台阶，一次可以走一个或两个，总方案数为 边界为 Catalan 数 给定一个凸 边形，用 条不相交的直线将它剖分成 个三角形，设方案总数为 。 对每个顶点编号，第 个顶点编号为 。作三角形 （），该三角形左边是一个 边形，右边是一个 边形，即 公式 等差数列 设数列 对于任意的 满足 ，则有 求和公式为 自然数平方和 不会证。 二项式定理]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 10253」Series-Parallel Networks - 整数划分 + 组合数]]></title>
    <url>%2Fuva-10253%2F</url>
    <content type="text"><![CDATA[串并联网络有两个端点，一个是源，一个是汇，递归定义如下： 一条单独的边是串并联网络； 若 和 是串并联网络，则将它们的源和汇分别接在一起也能得到串并联网络（并联）； 若 和 是串并联网络，则将 的源和 的汇接在一起也能得到串并联网络（串联）； 并联或串联在一起的各个部分可以调换顺序，顺序改变后的串并联网络和之前是相同的。求 条边能组成多少种不同的串并联网络。 链接 UVa 10253 题解 书上的解法，考虑每个串并联网络都是一棵树，组成网络的几个部分是树的子节点，那么叶子节点就对应了网络中的边，并且整棵树从根到叶子，父子关系所代表的连接方式是交替着的，某一层是并联，则下一层即为串联。同一种树的形态，第一层的连接方式不同，也就对应了两个网络。 问题转化为，求有多少子节点有序且有 个叶子节点的形态不同的树。设 为答案，则可以根据各个子树所『分得』的叶子节点数量来递归求解 —— 回溯法枚举 的整数划分，就得到了单层子树所有的情况。 假设整数划分的某一种方案中，有 个 ，求这 棵子树的方案数可使用组合数：从 个中选择 个，可重复选择，答案为 。计算出每一组子树的方案数，相乘即为根节点的答案。 最终答案为 ，注意 时答案为 。 代码 #include &lt;cstdio&gt; #include &lt;vector&gt; const int MAXN = 30; long long solve(int n); void search(std::vector&lt;int&gt; &amp;v, int t, int r); long long C(long long n, long long m) { long long result = 1; for (int k = 1; k &lt;= m; k++) { result = result * (n - k + 1) / k; } return result; } long long process(std::vector&lt;int&gt; &amp;v) { long long ans = 1; int count = 0, last = 0; for (int i = 0; i &lt; (int)v.size(); i++) { if (last != v[i] &amp;&amp; last != 0) { ans *= C(solve(last) + count - 1, count); count = 1; } else { count++; } last = v[i]; } ans *= C(solve(last) + count - 1, count); // printf("process = %lld\n", ans); return ans; } long long divide(std::vector&lt;int&gt; &amp;v, int r, int t = 1) { if (r == 0) { if (v.size() == 1) return 0; // for (std::vector&lt;int&gt;::const_iterator p = v.begin(); p != v.end(); p++) printf("%d ", *p); // putchar('\n'); // return 0; return process(v); } long long ans = 0; for (int i = t; i &lt;= r; i++) { v.push_back(i); ans += divide(v, r - i, i); v.pop_back(); } return ans; } long long solve(int n) { static long long mem[MAXN]; static bool calced[MAXN]; long long &amp;ans = mem[n - 1]; if (calced[n - 1]) return ans; calced[n - 1] = true; if (n == 1) return ans = 1; std::vector&lt;int&gt; v; ans = divide(v, n); // printf("f(%d) = %lld\n", n, ans); return ans; } int main() { for (int n; ~scanf("%d", &amp;n) &amp;&amp; n != 0; printf("%lld\n", n == 1 ? 1 : solve(n) * 2)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计数原理</tag>
        <tag>组合数</tag>
        <tag>递推</tag>
        <tag>UVa</tag>
        <tag>回溯</tag>
        <tag>整数划分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11361」Investigating Div-Sum Property - 数位 DP]]></title>
    <url>%2Fuva-11361%2F</url>
    <content type="text"><![CDATA[问在区间 内有多少数 满足： 是 的倍数； 的各位数之和是 的倍数。 链接 UVa 11361 题解 设 表示 的各位数之和， 表示 内有多少正整数 满足 且 ，问题转化为求 。 设 表示有多少 位数 满足 且 ，计算 函数可以枚举最高位数字 1 ~ 9，并递归计算。 函数也可以递归求，设参数 的最高位上的数为 ，则可以先在 枚举最高位上的数，此时后面的低位数是任意的，可以由 函数来计算；最后令最高位为 ，递归处理低位的数，累加起来就是答案。 题目有坑， 较大时结果直接为零 …… 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; const int MAXT = 99; const int MAXX = 1 &lt;&lt; 31; const int MAXK = 9999; const int MAXK_HEHE = 100; int k, pow10[12]; long long mem[11][MAXK_HEHE + 1][MAXK_HEHE + 1]; bool calced[11][MAXK_HEHE + 1][MAXK_HEHE + 1]; inline void makeTable() { pow10[0] = 1; for (int i = 1; i &lt;= 11; i++) pow10[i] = pow10[i - 1] * 10; } inline int length(int x) { int result = 0; do result++; while (x /= 10); return result; } inline int sum(int x) { int result = 0; do result += x % 10; while (x /= 10); return result; } inline int mod(int a, int b) { return (a % b + b) % b; } int f(int x, int m1, int m2) { long long &amp;ans = mem[x][m1][m2]; if (calced[x][m1][m2]) return ans; calced[x][m1][m2] = true; ans = 0; if (x == 1) { for (int i = 0; i &lt;= 9; i++) { if (i % k == m1 &amp;&amp; i % k == m2) ans++; } } else { for (int i = 0; i &lt;= 9; i++) { ans += f(x - 1, mod(m1 - i, k), mod(m2 - i * pow10[x - 1] % k, k)); } } // printf("f(%d, %d, %d) = %d\n", x, m1, m2, ans); return ans; } int dp(int x, int m1, int m2) { int ans = 0; if (x &lt; 10) { for (int i = 0; i &lt;= x; i++) { if (i % k == m1 &amp;&amp; i % k == m2) ans++; } } else { int n = length(x), first = x / pow10[n - 1]; for (int i = 0; i &lt; first; i++) { ans += f(n - 1, mod(m1 - i, k), mod(m2 - pow10[n - 1] * i, k)); } ans += dp(x % pow10[n - 1], mod(m1 - first, k), mod(m2 - pow10[n - 1] * first, k)); } return ans; } /* inline int solve(int x) { int n = length(x), left = 0; int ans = 0; for (int i = n - 1; i &gt; 0; i--) { int curr = (x % pow10[i + 1]) / pow10[i]; // printf("curr = %d\n", curr); for (int j = 0; j &lt; curr; j++) { int t = left * 10 + j; // printf("sum(t) = %d; %d\n", sum(t), t * pow10[i - 1]); ans += f(i, mod(k - sum(t), k), mod(t * pow10[i] % k, k)); } left = left * 10 + curr; } for (int i = 0; i &lt;= x % 10; i++) { if ((x - i) % k == 0 &amp;&amp; sum(x - i) % k == 0) ans++; } return ans; } */ inline void cleanUp() { memset(mem, 0, sizeof(mem)); memset(calced, 0, sizeof(calced)); } int main() { makeTable(); int t; scanf("%d", &amp;t); for (int i = 0; i &lt; t; i++) { int a, b; scanf("%d %d %d", &amp;a, &amp;b, &amp;k); if (k &gt;= 100) puts("0"); // hehe else printf("%d\n", dp(b, 0, 0) - dp(a - 1, 0, 0)); cleanUp(); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>DP</tag>
        <tag>数位 DP</tag>
        <tag>递推</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度加、减、乘模板]]></title>
    <url>%2Fbigint-template%2F</url>
    <content type="text"><![CDATA[今天早上写了一道高精度的题，一口气敲完了高精度加、减、乘。现在把模板放在这备用着 …… 需要者自取。 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;vector&gt; struct BigInt { std::vector&lt;char&gt; v; BigInt() { *this = 0; } BigInt(int x) { *this = x; } BigInt &amp;operator=(int x) { v.clear(); do v.push_back(x % 10); while (x /= 10); return *this; } BigInt &amp;operator=(const BigInt &amp;x) { v.resize(x.v.size()); memcpy(const_cast&lt;char *&gt;(v.data()), x.v.data(), x.v.size() * sizeof(char)); return *this; } }; std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const BigInt &amp;x) { for (int i = x.v.size() - 1; i &gt;= 0; i--) out &lt;&lt; (char)(x.v[i] + '0'); return out; } BigInt operator+(const BigInt &amp;a, const BigInt &amp;b) { BigInt result; result.v.clear(); bool flag = false; for (int i = 0; i &lt; (int)std::max(a.v.size(), b.v.size()); i++) { int tmp = 0; if (i &lt; (int)a.v.size()) tmp += a.v[i]; if (i &lt; (int)b.v.size()) tmp += b.v[i]; if (flag) tmp++, flag = false; if (tmp &gt;= 10) tmp -= 10, flag = true; result.v.push_back(tmp); } if (flag) result.v.push_back(1); return result; } BigInt &amp;operator+=(BigInt &amp;a, const BigInt &amp;b) { return a = a + b; } BigInt operator-(const BigInt &amp;a, const BigInt &amp;b) { BigInt result; result.v.clear(); bool flag = false; for (int i = 0; i &lt; (int)a.v.size(); i++) { int tmp = a.v[i]; if (i &lt; (int)b.v.size()) tmp -= b.v[i]; if (flag) tmp--, flag = false; if (tmp &lt; 0) tmp += 10, flag = true; result.v.push_back(tmp); } int size = result.v.size(); while (size &gt; 1 &amp;&amp; result.v[size - 1] == 0) size--; result.v.resize(size); return result; } BigInt operator*(const BigInt &amp;a, const BigInt &amp;b) { BigInt result; result.v.resize(a.v.size() + b.v.size()); for (int i = 0; i &lt; (int)a.v.size(); i++) { for (int j = 0; j &lt; (int)b.v.size(); j++){ result.v[i + j] += a.v[i] * b.v[j]; result.v[i + j + 1] += result.v[i + j] / 10; result.v[i + j] %= 10; } } int size = result.v.size(); while (size &gt; 1 &amp;&amp; result.v[size - 1] == 0) size--; result.v.resize(size); return result; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 1362」Exploring Pyramids - 区间 DP + 计数原理]]></title>
    <url>%2Fuva-1362%2F</url>
    <content type="text"><![CDATA[给定一棵树的欧拉序列，树的子节点是有序的，求有多少棵树满足这个欧拉序列。 链接 UVa 1362 题解 书上的解法，用 表示欧拉序列 中的第 到第 个字符所表示的树的数量，则有： 当 时，； 当 时，，因为欧拉序列的第一个点和最后一个点都必须是根节点。 欧拉序列的一个特点是，每一次回溯到根都会将根节点记录下来。所以我们可以枚举中转点 ，当 时，递归计算 区间内（第一棵子树）的答案和 区间的答案（其它子树），并将其相乘。 多组数据一定要清数组，一定要清数组，一定要清数组 …… 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; const int MAXN = 300; const long long MOD = 1000000000; char str[MAXN + 1]; long long search(int i, int j, bool reset = false) { static long long mem[MAXN][MAXN]; static bool calced[MAXN][MAXN]; if (reset) { memset(mem, 0, sizeof(mem)); memset(calced, 0, sizeof(calced)); } long long &amp;ans = mem[i][j]; if (calced[i][j]) return ans; calced[i][j] = true; if (i == j) return ans = 1; else if (str[i] != str[j]) return ans = 0; else { ans = 0; for (int k = i + 2; k &lt;= j; k++) { if (str[i] != str[k]) continue; ans += search(i + 1, k - 1) * search(k, j) % MOD; ans %= MOD; } } return ans; } int main() { for (; ~scanf("%s", str); printf("%lld\n", search(0, strlen(str) - 1, true))); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>DP</tag>
        <tag>计数原理</tag>
        <tag>区间 DP</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 1737」Connected Graph - 组合数 + 计数原理 + 递推]]></title>
    <url>%2Fpoj-1737%2F</url>
    <content type="text"><![CDATA[给定 （）个点，在平面上固定其位置，求这些点最多能组成多少个不同的无向连通图。 链接 POJ 1737 题解 统计连通图的方案数是困难的，但我们可以轻易地计算出用 N 个点组成任意图的方案数：因为 N 个点的无向图最多有 条边，考虑每条边选或不选，则共有 种不同的图。 求出任意图的方案数后，只要再求出非连通图的方案数，就可以得到答案。考虑 个点组成的非连通图中的点 ，它一定处于一个由 （）个点组成的连通分量中，点 确定后，组成这个连通分量还需要 个点，总方案数为 ；每个连通分量都是一个连通图，可以递归来求；考虑完一个连通分量，图的剩余部分（与该连通分量隔离的 个点）是一个任意图，也可以递归来求。 设 个点组成连通图的方案数为 、组成非连通图的方案数为 、组成任意图的方案数为 ，则递归计算 的公式为： 需要使用高精度。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; const int MAXN = 50; struct BigInt; BigInt &amp;countConnectedGraphs(int n); BigInt &amp;countNonConnectedGraphs(int n); inline BigInt &amp;countAllGraphs(int n); struct BigInt { std::vector&lt;char&gt; v; BigInt() { *this = 0; } BigInt(int x) { *this = x; } BigInt &amp;operator=(int x) { v.clear(); do v.push_back(x % 10); while (x /= 10); return *this; } BigInt &amp;operator=(const BigInt &amp;x) { v.resize(x.v.size()); memcpy(const_cast&lt;char *&gt;(v.data()), x.v.data(), x.v.size() * sizeof(char)); return *this; } }; std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const BigInt &amp;x) { for (int i = x.v.size() - 1; i &gt;= 0; i--) out &lt;&lt; (char)(x.v[i] + '0'); return out; } BigInt operator+(const BigInt &amp;a, const BigInt &amp;b) { BigInt result; result.v.clear(); bool flag = false; for (int i = 0; i &lt; (int)std::max(a.v.size(), b.v.size()); i++) { int tmp = 0; if (i &lt; (int)a.v.size()) tmp += a.v[i]; if (i &lt; (int)b.v.size()) tmp += b.v[i]; if (flag) tmp++, flag = false; if (tmp &gt;= 10) tmp -= 10, flag = true; result.v.push_back(tmp); } if (flag) result.v.push_back(1); return result; } BigInt &amp;operator+=(BigInt &amp;a, const BigInt &amp;b) { return a = a + b; } BigInt operator-(const BigInt &amp;a, const BigInt &amp;b) { BigInt result; result.v.clear(); bool flag = false; for (int i = 0; i &lt; (int)a.v.size(); i++) { int tmp = a.v[i]; if (i &lt; (int)b.v.size()) tmp -= b.v[i]; if (flag) tmp--, flag = false; if (tmp &lt; 0) tmp += 10, flag = true; result.v.push_back(tmp); } int size = result.v.size(); while (size &gt; 1 &amp;&amp; result.v[size - 1] == 0) size--; result.v.resize(size); return result; } BigInt operator*(const BigInt &amp;a, const BigInt &amp;b) { BigInt result; result.v.resize(a.v.size() + b.v.size()); for (int i = 0; i &lt; (int)a.v.size(); i++) { for (int j = 0; j &lt; (int)b.v.size(); j++){ result.v[i + j] += a.v[i] * b.v[j]; result.v[i + j + 1] += result.v[i + j] / 10; result.v[i + j] %= 10; } } int size = result.v.size(); while (size &gt; 1 &amp;&amp; result.v[size - 1] == 0) size--; result.v.resize(size); return result; } BigInt combo[MAXN + 1][MAXN + 1]; inline void makeComboTable() { for (int i = 1; i &lt;= MAXN; i++) { combo[i][0] = combo[i][i] = 1; for (int j = 1; j &lt; i; j++){ combo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1]; } } } inline BigInt &amp;C(int n, int k) { return combo[n][k]; } BigInt &amp;countConnectedGraphs(int n) { static bool calced[MAXN + 1]; static BigInt mem[MAXN + 1]; BigInt &amp;ans = mem[n]; if (calced[n]) return ans; calced[n] = true; ans = countAllGraphs(n) - countNonConnectedGraphs(n); return ans; } BigInt &amp;countNonConnectedGraphs(int n) { static bool calced[MAXN + 1]; static BigInt mem[MAXN + 1]; BigInt &amp;ans = mem[n]; if (calced[n]) return ans; calced[n] = true; for (int k = 1; k &lt;= n - 1; k++) { ans += C(n - 1, k - 1) * countConnectedGraphs(k) * countAllGraphs(n - k); } return ans; } inline BigInt &amp;countAllGraphs(int n) { static bool calced[MAXN + 1]; static BigInt mem[MAXN + 1]; BigInt &amp;ans = mem[n]; if (calced[n]) return ans; calced[n] = true; BigInt x = 2; int t = n * (n - 1) / 2; for (ans = 1; t; t &gt;&gt;= 1, x = x * x) { if (t &amp; 1) ans = ans * x; } return ans; } int main() { makeComboTable(); for (int n; ~scanf("%d", &amp;n) &amp;&amp; n &gt; 0; ) { std::cout &lt;&lt; countConnectedGraphs(n) &lt;&lt; std::endl; } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>高精度</tag>
        <tag>计数原理</tag>
        <tag>组合数</tag>
        <tag>POJ</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11174」Stand in a Line - 计数原理 + 乘法逆元]]></title>
    <url>%2Fuva-11174%2F</url>
    <content type="text"><![CDATA[分别属于多个家族的 （）个人想要站成一排，但没有人想站在他爹前面，求方案总数。 链接 UVa 11174 题解 题目描述的父子关系组成了一个森林，每个家族对应一棵树，我们可以添加一个虚拟节点，让它成为每个家族祖先的「父亲」，然后求出整棵树的方案数即为答案。 用 表示以 为根的子树的方案数，用 表示以 为根的子树的大小。 首先， 的几棵子树各自的排列方案是相互独立的，可以使用乘法原理来计算。 还要注意一点， 的几棵子树的节点是可以穿插排列的，即只需要保证每对父子的相对位置而整体是无序的。如果对所有子树的节点做全排列，那么改变了原有的父子相对位置的排列方案都是无效的，即同一种穿插方式中多次改变父子相对位置只有一次有效。我们可以把同一个子树的节点看做相同的，然后做有重复元素的全排列，就可以得到正确结果，因为每一种排列都对应且只对应一种顺序。 「子树各自的排列方案」和「节点的穿插顺序」是相互独立的，因此要用乘法原理。 用 表示 的子节点的集合，则递归计算的公式为： 公式中使用了除法，模意义下的除以一个数等于乘以这个数的乘法逆元，所以要在程序开始时递推预处理出所有数的阶乘，并求出对应的乘法逆元。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; const long long MOD = 1000000007; const int MAXN = 40000; struct Tree { Tree *firstChild, *parent, *next; int childCount, size; long long ans; long long solve(); } trees[MAXN + 1]; long long fac[MAXN + 1], facInverse[MAXN + 1]; void exgcd(long long a, long long b, long long &amp;g, long long &amp;x, long long &amp;y) { if (b == 0) { g = a; x = 1, y = 0; } else { exgcd(b, a % b, g, y, x); y -= x * (a / b); } } long long inverse(long long num) { long long g, x, y; exgcd(num, MOD, g, x, y); return (x % MOD + MOD) % MOD; } void makeTable() { fac[0] = 1; for (int i = 1; i &lt;= MAXN; i++) { fac[i] = fac[i - 1] * i % MOD; facInverse[i] = inverse(fac[i]); } } void addRelation(int child, int parent) { trees[child].parent = &amp;trees[parent]; trees[child].next = trees[parent].firstChild; trees[parent].firstChild = &amp;trees[child]; trees[parent].childCount++; } void cleanUp(int n) { memset(trees, 0, sizeof(Tree) * (n + 1)); } long long Tree::solve() { for (Tree *c = firstChild; c; c = c-&gt;next) { c-&gt;solve(); size += c-&gt;size; } size++; ans = fac[size - 1]; for (Tree *c = firstChild; c; c = c-&gt;next) { ans = ans * c-&gt;ans % MOD; ans = ans * facInverse[c-&gt;size] % MOD; } return ans; } int main() { makeTable(); int t; scanf("%d", &amp;t); for (int i = 0; i &lt; t; i++) { int n, m; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) { int child, parent; scanf("%d %d", &amp;child, &amp;parent); addRelation(child, parent); } for (int i = 1; i &lt;= n; i++) { if (trees[i].parent == NULL) addRelation(i, 0); } printf("%lld\n", trees[0].solve()); cleanUp(n); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>计数原理</tag>
        <tag>乘法逆元</tag>
        <tag>递推</tag>
        <tag>UVa</tag>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11137」Ingenuous Cubrency - 递推 / 背包 DP]]></title>
    <url>%2Fuva-11137%2F</url>
    <content type="text"><![CDATA[给出一个正整数 （），求有多少种方案把 表示成几个正整数的立方和的形式。 链接 UVa 11137 题解 书上的解法：用 表示使用不超过 的整数的立方和表示数 的方案数。以 i 为阶段进行递推，对于每个 j，枚举新一个 项的系数 使 ，用 去更新 。最后 即为答案。 书上在最后提到可以优化。考虑将每个立方数看做物品，将 1000 看做背包，则问题转化为：求装满背包的方案。 直接进行完全背包即可。 代码 解法一 #include &lt;cstdio&gt; const int MAXN = 10000; const int MAXI = 21; unsigned long long f[MAXI][MAXN + 1]; inline int cube(int x) { return x * x * x; } inline void makeTable() { f[0][0] = 1; for (int i = 1; i &lt;= MAXI; i++) { for (int j = 0; j &lt;= MAXN; j++) { for (int x = 0, tmp; (tmp = j + x * cube(i)) &lt;= MAXN; x++) f[i][tmp] += f[i - 1][j]; } } } int main() { makeTable(); for (int n; ~scanf("%d", &amp;n); ) { printf("%llu\n", f[MAXI][n]); } return 0; } 解法二 #include &lt;cstdio&gt; const int MAXN = 10000; const int MAXI = 21; unsigned long long f[MAXN + 1]; inline int cube(int x) { return x * x * x; } inline void makeTable() { f[0] = 1; for (int i = 1; i &lt;= MAXI; i++) { for (int c = cube(i), j = c; j &lt;= MAXN; j++) { f[j] += f[j - c]; } } } int main() { makeTable(); for (int n; ~scanf("%d", &amp;n); ) { printf("%llu\n", f[n]); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>DP</tag>
        <tag>背包 DP</tag>
        <tag>递推</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11375」Matches - 递推]]></title>
    <url>%2Fuva-11375%2F</url>
    <content type="text"><![CDATA[有 个火柴，用这些火柴能摆出非负整数，摆出的数不能有前导零，火柴不必用完，求方案总数。 链接 UVa 11375 题解 首先考虑不存在数字 0 的情况，用 表示用 个火柴棒能摆出的方案总数，用 表示摆出数字 x 使用的火柴棒数量。 前导零是不被允许的，所以初始状态要把 1 ~ 9 几个数字的方案数加一。 每次递推用 去更新 （），表示在 表示的数字尾部添加一个 所得的方案。 递推计算完成后求出前缀和 即为答案，如果 则需要将答案加一（考虑单独的数字 0）。 需要使用高精度。 代码 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; const int MAXT = 100; const int MAXN = 2000; const int C[] = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 }; struct BigInt { std::vector&lt;char&gt; v; BigInt() {} BigInt(int x) { *this = x; } BigInt &amp;operator=(int x) { v.clear(); do v.push_back(x % 10); while (x /= 10); } }; std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const BigInt &amp;x) { const std::vector&lt;char&gt; &amp;v = x.v; for (int i = v.size() - 1; i &gt;= 0; i--) out &lt;&lt; (char)(v[i] + '0'); return out; } BigInt operator+(const BigInt &amp;a, const BigInt &amp;b) { BigInt r; r.v.reserve(std::max(a.v.size(), b.v.size()) + 1); bool flag = false; for (int i = 0; i &lt; std::max(a.v.size(), b.v.size()); i++) { int tmp = 0; if (i &lt; a.v.size()) tmp += a.v[i]; if (i &lt; b.v.size()) tmp += b.v[i]; if (flag) tmp++, flag = false; if (tmp &gt;= 10) tmp -= 10, flag = true; r.v.push_back(tmp); } if (flag) r.v.push_back(1); return r; } BigInt &amp;operator+=(BigInt &amp;a, const BigInt &amp;b) { return a = a + b; } BigInt f[MAXN + 1], sum[MAXN + 1]; inline void makeTable() { for (int i = 1; i &lt; 10; i++) f[C[i]] += 1; for (int i = 1; i &lt;= MAXN; i++) { for (int j = 0; j &lt; 10; j++) { if (i + C[j] &lt;= MAXN) f[i + C[j]] += f[i]; } } sum[2] = f[2]; for (int i = 3; i &lt;= MAXN; i++) sum[i] = sum[i - 1] + f[i]; } int main() { makeTable(); int n; while (~scanf("%d", &amp;n)) { if (n == 0 || n == 1) puts("0"); else if (n &lt; 6) std::cout &lt;&lt; sum[n] &lt;&lt; std::endl; else std::cout &lt;&lt; sum[n] + 1 &lt;&lt; std::endl; } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>高精度</tag>
        <tag>递推</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11538」Chess Queen - 计数原理]]></title>
    <url>%2Fuva-11538%2F</url>
    <content type="text"><![CDATA[在一个 棋盘中放置两个皇后，使得它们可以相互攻击，求方案总数。 链接 UVa 11538 题解 两个皇后可以互相攻击，当且仅当它们在「同一行」或「同一列」或「同一对角线」。这三种情况互相独立，可以用加法原理。 考虑「同一行」的情况，用 表示在一个 行 列的棋盘中放置两个皇后在同一行的方案数。令 ，此时第一个皇后有 种放置方法，第二个有 种，即 推广到多行的情况，每一行的情况互不影响，可以用加法原理，即： 「同一列」和「同一行」原理相同，行列数互换后代入上式即可。 「同一对角线」的情况比较复杂，假设 ，则同一方向的对角线中，有 条的长度为 （蓝色部分），剩下的两边分别有 条长度递增。 中间的一撮所对应的情况相当于在一个 行 列的棋盘中放置，使得两个皇后在同一行，即 。 两边长度递增的对角线也要按照类似「同一行」的方法推导，即： 但是根据题目的数据范围， 地每次计算是会超时的，考虑展开。 分别使用平方和公式和等差数列求和公式展开，得 这是一边的长度递增的对角线上的方案数，两边的要乘以二，因为有两个方向，所以最后还要乘以二。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXT = 5000; const int MAXN = 1000000; inline long long f(long long a, long long b) { return a * (b - 1) * b; } inline long long g(long long n, long long m) { // m &gt;= n if (m &lt; n) std::swap(m, n); unsigned long long x = ((n - 1) * n * (n - 2)) / 3; return f(m - n + 1, n) + x * 2; } int main() { int n, m; while (~scanf("%d %d", &amp;n, &amp;m), !(n == 0 &amp;&amp; m == 0)) { printf("%llu\n", f(n, m) + f(m, n) + g(n, m) * 2); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计数原理</tag>
        <tag>组合数学</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11806」Cheerleaders - 组合数 + 容斥原理]]></title>
    <url>%2Fuva-11806%2F</url>
    <content type="text"><![CDATA[在一个 的矩阵中摆放 只石子，要求第一行、第一列、第 行、第 列必须有石子，求方案总数。 链接 UVa 11806 题解 设 、 分别表示第一行、第 行没有摆放石子的方案集合； 设 、 分别表示第一列、第 列没有摆放石子的方案集合； 设 表示在 的矩阵中任意摆放 只石子的方案集合。 则问题转化为，求在集合 内但不在集合 、、、 内的元素总数。 由容斥原理得，答案 各个集合的元素数量可用组合数计算，组合数需要预处理。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; const int MAXT = 50; const int MAXN = 20; const int MAXK = 500; const int p = 1000007; int combo[MAXK + 1][MAXK + 1]; inline void makeComboTable() { for (int i = 0; i &lt;= MAXK; i++) { combo[i][0] = combo[i][i] = 1; for (int j = 1; j &lt; i; j++) { combo[i][j] = (combo[i - 1][j] + combo[i - 1][j - 1]) % p; } } } inline long long C(int a, int b) { return (long long)combo[a][b]; } inline int solve(int m, int n, int k) { long long ans = C(m * n, k); // |A| = |C| = C(m(n - 1), k) // |B| = |D| = C((m - 1)n, k) ans -= C(m * (n - 1), k), ans += p, ans %= p; ans -= C(m * (n - 1), k), ans += p, ans %= p; ans -= C((m - 1) * n, k), ans += p, ans %= p; ans -= C((m - 1) * n, k), ans += p, ans %= p; // |AB| = |BC| = |CD| = |DA| = C((m - 1)(n - 1), k) // |AC| = C(m(n - 2), k) // |BD| = C((m - 2)n, k) ans += C((m - 1) * (n - 1), k), ans %= p; ans += C((m - 1) * (n - 1), k), ans %= p; ans += C((m - 1) * (n - 1), k), ans %= p; ans += C((m - 1) * (n - 1), k), ans %= p; ans += C(m * (n - 2), k), ans %= p; ans += C((m - 2) * n, k), ans %= p; // |ABC| = |ADC| = C((m - 1)(n - 2), k) // |ABD| = |CBD| = C((m - 2)(n - 1), k) ans -= C((m - 1) * (n - 2), k), ans += p, ans %= p; ans -= C((m - 1) * (n - 2), k), ans += p, ans %= p; ans -= C((m - 2) * (n - 1), k), ans += p, ans %= p; ans -= C((m - 2) * (n - 1), k), ans += p, ans %= p; // |ABCD| = C((m - 2)(n - 2), k); ans += C((m - 2) * (n - 2), k), ans %= p; return ans; } int main() { makeComboTable(); int t; scanf("%d", &amp;t); for (int i = 1; i &lt;= t; i++) { int n, m, k; scanf("%d %d %d", &amp;m, &amp;n, &amp;k); printf("Case %d: %d\n", i, solve(m, n, k)); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 2728」Desert King - 01 分数规划]]></title>
    <url>%2Fpoj-2728%2F</url>
    <content type="text"><![CDATA[一个王国有 个城市，每个城市有坐标 和海拔 ，在 个城市之间修水渠，要保证每个城市有水，水渠是水平的，每个城市的海拔不同，现在要求修单位长度的水渠的海拔高度差最小。 链接 POJ 2728 题解 最优比率生成树，01 分数规划，搞的不是很明白 …… Orz PS：果然我的代码自带大常数，搞了一早上不是 WA 就是 TLE，最后把编译器从 G++ 改为 VC++ 就 AC 了 …… 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; const int MAXN = 1000; const int CACHE_FIX = 3; const float EPS = 1e-4; struct Node; struct UndirectedEdge; struct Node { int id; int x, y, z; bool inTree; UndirectedEdge *e; } nodes[MAXN]; struct UndirectedEdge { float benifit, cost; float w; UndirectedEdge(float benifit, float cost) : benifit(benifit), cost(cost) {} UndirectedEdge() {} } edges[MAXN + CACHE_FIX][MAXN]; int n; inline float prim() { nodes[0].inTree = true; for (int i = 1; i &lt; n; i++) nodes[i].e = &amp;edges[0][i], nodes[i].inTree = false; float ans = 0; for (int i = 0; i &lt; n - 1; i++) { Node *v = NULL; for (int i = 0; i &lt; n; i++) if (!nodes[i].inTree &amp;&amp; (v == NULL || nodes[i].e-&gt;w &lt; v-&gt;e-&gt;w)) v = &amp;nodes[i]; ans += v-&gt;e-&gt;w; v-&gt;e = NULL; v-&gt;inTree = true; for (int i = 0; i &lt; n; i++) if (!nodes[i].inTree &amp;&amp; nodes[i].e-&gt;w &gt; edges[i][v-&gt;id].w) nodes[i].e = &amp;edges[i][v-&gt;id]; } return ans; } inline float test(float p) { for (register int i = 0; i &lt; n; i++) { for (register int j = i + 1; j &lt; n; j++) { edges[j][i].w = edges[i][j].w = edges[i][j].cost - edges[i][j].benifit * p; } } float result = prim(); //printf("test(%lf) = %lf\n", p, result); return result; } inline float solve(float sum) { register float l = 0, r = sum; //while (r - l &gt; EPS) { for (int i = 0; i &lt; 22; i++) { float mid = l + (r - l) / 2; if (test(mid) &gt; 0) l = mid; else r = mid; } return l + (r - l) / 2; } inline float sqr(float x) { return x * x; } inline float distance(float x1, float x2, float y1, float y2) { return sqrt(sqr(x1 - x2) + sqr(y1 - y2)); } int main() { while (scanf("%d", &amp;n) != EOF &amp;&amp; n != 0) { for (int i = 0; i &lt; n; i++) nodes[i].id = i; for (int i = 0; i &lt; n; i++) scanf("%d %d %d", &amp;nodes[i].x, &amp;nodes[i].y, &amp;nodes[i].z); float sum = 0; for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { edges[j][i] = edges[i][j] = UndirectedEdge(distance(nodes[i].x, nodes[j].x, nodes[i].y, nodes[j].y), abs(nodes[i].z - nodes[j].z)); sum += edges[i][j].benifit; } } float ans = solve(100); printf("%.3f\n", ans); } return 0; } 数据生成器 #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; const int MAXN = 1000; inline int luckyRand(int l, int r) { const int MAGIC_NUMBER = 20000528; const int x = rand(); srand(x ^ ((time(NULL) &lt;&lt; 16) | (clock() &lt;&lt; 16 &gt;&gt; 16)) ^ MAGIC_NUMBER); return (rand() ^ x ^ MAGIC_NUMBER) % (r - l + 1) + l; } int main() { const int t = 3; const int n = MAXN; for (int i = 0; i &lt; t; i++) { printf("%d\n", n); for (int i = 0; i &lt; n; i++) { int x = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), y = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), z = luckyRand(luckyRand(0, 10000), luckyRand(90000, 100000)); printf("%d %d %d\n", x, y, z); } } puts("0"); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>POJ</tag>
        <tag>Prim</tag>
        <tag>分数规划</tag>
        <tag>实数二分</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「APIO2009」抢掠计划 - 强连通分量]]></title>
    <url>%2Fapio2009-atm%2F</url>
    <content type="text"><![CDATA[城中的道路都是单向的。不同的道路由路口连接。在每个路口都设立了一个 ATM 取款机。酒吧也都设在路口，虽然并不是每个路口都设有酒吧。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆祝他的胜利。 他获知了每个 ATM 机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机里面就不会再有钱了。 链接 CodeVS 1611 BZOJ 1179 题解 Tarjan 求强连通分量，一个强连通分量中的点肯定可以同时被抢走。缩点后图转化为 DAG，求出 DAG 上的最长路即为答案。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; #include &lt;queue&gt; const int MAXN = 500000; const int MAXM = 500000; struct Node; struct Edge; struct SCC; struct Node { Edge *firstEdge, *inEdge, *currentEdge; int dfn, low, w, dist; bool inStack, pushed, visited, isBar, inQueue; SCC *scc; } nodes[MAXN]; struct Edge { Node *from, *to; Edge *next; Edge(Node *from, Node *to) : from(from), to(to), next(from-&gt;firstEdge) {} }; struct SCC { Node v; int size; } sccs[MAXN]; inline void addEdge(int from, int to) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to]); } int n; inline int tarjan() { int timeStamp = 0, count = 0; for (int i = 0; i &lt; n; i++) { if (nodes[i].visited) continue; std::stack&lt;Node *&gt; s, t; s.push(&amp;nodes[i]); nodes[i].pushed = true; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; v-&gt;dfn = v-&gt;low = timeStamp++; v-&gt;currentEdge = v-&gt;firstEdge; v-&gt;inStack = true; t.push(v); } if (v-&gt;currentEdge) { Edge *&amp;e = v-&gt;currentEdge; if (e-&gt;to-&gt;inStack) v-&gt;low = std::min(v-&gt;low, e-&gt;to-&gt;dfn); else if (!e-&gt;to-&gt;pushed) s.push(e-&gt;to), e-&gt;to-&gt;pushed = true, e-&gt;to-&gt;inEdge = e; e = e-&gt;next; } else { s.pop(); if (v-&gt;dfn == v-&gt;low) { Node *u; v-&gt;scc = &amp;sccs[count++]; do { u = t.top(); t.pop(); u-&gt;inStack = false; u-&gt;scc = v-&gt;scc; u-&gt;scc-&gt;size++; u-&gt;scc-&gt;v.w += u-&gt;w; u-&gt;scc-&gt;v.isBar |= u-&gt;isBar; } while (u != v); } if (v-&gt;inEdge) v-&gt;inEdge-&gt;from-&gt;low = std::min(v-&gt;inEdge-&gt;from-&gt;low, v-&gt;low); } } } return count; } inline void contract() { for (int i = 0; i &lt; n; i++) { for (Edge *e = nodes[i].firstEdge; e; e = e-&gt;next) { if (e-&gt;from-&gt;scc != e-&gt;to-&gt;scc) { Node *from = &amp;e-&gt;from-&gt;scc-&gt;v, *to = &amp;e-&gt;to-&gt;scc-&gt;v; from-&gt;firstEdge = new Edge(from, to); } } } } inline void bellmanford(int start) { std::queue&lt;Node *&gt; q; q.push(&amp;nodes[start].scc-&gt;v); nodes[start].scc-&gt;v.dist = nodes[start].scc-&gt;v.w; while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;inQueue = false; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;to-&gt;dist &lt; v-&gt;dist + e-&gt;to-&gt;w) { e-&gt;to-&gt;dist = v-&gt;dist + e-&gt;to-&gt;w; if (!e-&gt;to-&gt;inQueue) { e-&gt;to-&gt;inQueue = true; q.push(e-&gt;to); } } } } } int main() { int m; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) { int from, to; scanf("%d %d", &amp;from, &amp;to), from--, to--; addEdge(from, to); } for (int i = 0; i &lt; n; i++) { scanf("%d", &amp;nodes[i].w); } int s, p; scanf("%d %d", &amp;s, &amp;p), s--; for (int i = 0; i &lt; p; i++) { int x; scanf("%d", &amp;x), x--; nodes[x].isBar = true; } int count = tarjan(); contract(); bellmanford(s); int ans = 0; for (int i = 0; i &lt; count; i++) { if (sccs[i].v.isBar) ans = std::max(ans, sccs[i].v.dist); } printf("%d\n", ans); return 0; } 吐槽 一开始想到最长路，然后写了个 Dijkstra …… 写了个 Dijkstra …… (╯‵□′)╯︵┻━┻ 为什么我要写 Dijkstra！ ┬—┬ノ('-'ノ) 改成 Bellman-Ford 之后 WA 的更离谱了 …… 最后发现是读进来的起点下标忘了减一 …… 以后不能再出这种沙茶错误了啊啊啊啊啊啊 OvO …… 还是吐槽 从测试点命名中我们可以看出出题人的恶意 →_→ 测试点 结果 内存使用量 时间使用量 large-dag-0.in AC 42504kB 423ms large-dag-1.in 51052kB 476ms large-path-0.in 55288kB 491ms large-path-1.in 53096kB 494ms large-tree-0.in 49512kB 430ms large-tree-1.in 49772kB 406ms medium-dag-0.in 364kB 2ms medium-dag-1.in 492kB medium-path-0.in 488kB medium-path-1.in 492kB medium-tree-0.in 360kB medium-tree-1.in 492kB 1ms small-dag-0.in 128kB small-path-0.in small-tree-0.in 256kB]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>APIO</tag>
        <tag>Bellman-Ford</tag>
        <tag>DAG</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>最长路</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2006」最大获利 - 最大权闭合图]]></title>
    <url>%2Fnoi2006-profit%2F</url>
    <content type="text"><![CDATA[在前期市场调查和站址勘测之后，公司得到了一共 个可以作为通讯信号中转站的地址，建立第 个通讯中转站需要的成本为 （）。另外公司调查得出了所有期望中的用户群，一共 个。关于第 个用户群的信息概括为 , 和 ：这些用户会使用中转站 和中转站 进行通讯，公司可以获益 。（，，）公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益（获益之和）。那么如何选择最终建立的中转站才能让公司的净获利最大呢？ 链接 CodeVS 1789 BZOJ 1497 题解 裸的最大权闭合图，用最小割。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 5000; const int MAXM = 50000; struct Node; struct Edge; struct Node { Edge *firstEdge, *currentEdge; int level, id; } nodes[MAXN + MAXM + 2]; struct Edge { Node *from, *to; int capacity, flow; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from-&gt;firstEdge) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, int n) { for (int i = 0; i &lt; n; i++) nodes[i].level = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;to-&gt;level == 0 &amp;&amp; e-&gt;flow &lt; e-&gt;capacity) { e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; else q.push(e-&gt;to); } } } return false; } int findPath(Node *s, Node *t, int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;currentEdge; e; e = e-&gt;next) { if (e-&gt;to-&gt;level == s-&gt;level + 1 &amp;&amp; e-&gt;flow &lt; e-&gt;capacity) { int flow = findPath(e-&gt;to, t, std::min(limit, e-&gt;capacity - e-&gt;flow)); if (flow &gt; 0) { e-&gt;flow += flow; e-&gt;reversedEdge-&gt;flow -= flow; return flow; } } } return 0; } int operator()(int s, int t, int n) { int ans = 0; while (makeLevelGraph(&amp;nodes[s], &amp;nodes[t], n)) { for (int i = 0; i &lt; n; i++) nodes[i].currentEdge = nodes[i].firstEdge; int flow; while ((flow = findPath(&amp;nodes[s], &amp;nodes[t])) &gt; 0) ans += flow; } return ans; } } dinic; inline void addEdge(int from, int to, int capacity) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } int n, m, a[MAXN]; int main() { scanf("%d %d", &amp;n, &amp;m); const int s = 0, t = n + m + 1; for (int i = 1; i &lt;= n; i++) { int x; scanf("%d", &amp;x); addEdge(i, t, x); } int sum = 0; for (int i = n + 1; i &lt;= n + m; i++) { int a, b, c; scanf("%d %d %d", &amp;a, &amp;b, &amp;c); sum += c; addEdge(s, i, c); addEdge(i, a, INT_MAX); addEdge(i, b, INT_MAX); } int maxFlow = dinic(s, t, n + m + 2); printf("%d\n", sum - maxFlow); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>最大权闭合图</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>最小割</tag>
        <tag>CodeVS</tag>
        <tag>图论</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2007」修车 - 费用流]]></title>
    <url>%2Fscoi2007-repair%2F</url>
    <content type="text"><![CDATA[同一时刻有 位车主带着他们的爱车来到了汽车维修中心。维修中心共有 位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这 位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。 顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。 链接 BZOJ 1070 CodeVS 2436 题解 为每辆车建立点，为每个技术人员的每一次修车建立点。 设第 个技术人员修第 辆车所用时间为 ，第 辆车的点为 ，第 个技术人员倒数第 次修车（此时有 个人在等待）的点为 （）。 从源点向每辆车连边，容量为 1，费用为 0；从每个 向每个 连边，容量为 1，费用为 ；从每个 向汇点连边，容量为 1，费用为 0。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 60; const int MAXM = 9; const int MAXT = 1000; struct Node; struct Edge; struct Node { Edge *firstEdge, *inEdge; int flow, dist; bool inQueue; } nodes[MAXN + MAXM * MAXN + 2]; struct Edge { Node *from, *to; int flow, capacity, cost; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), flow(0), capacity(capacity), cost(cost), next(from-&gt;firstEdge) {} }; struct Dinic { bool bellmanford(Node *s, Node *t, int n, int &amp;flow, int &amp;cost) { for (int i = 0; i &lt; n; i++) { nodes[i].inEdge = NULL; nodes[i].flow = 0; nodes[i].dist = INT_MAX; nodes[i].inQueue = false; } std::queue&lt;Node *&gt; q; q.push(s); s-&gt;flow = INT_MAX; s-&gt;dist = 0; while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;inQueue = false; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;dist &gt; v-&gt;dist + e-&gt;cost) { e-&gt;to-&gt;dist = v-&gt;dist + e-&gt;cost; e-&gt;to-&gt;inEdge = e; e-&gt;to-&gt;flow = std::min(v-&gt;flow, e-&gt;capacity - e-&gt;flow); if (!e-&gt;to-&gt;inQueue) { e-&gt;to-&gt;inQueue = true; q.push(e-&gt;to); } } } } if (t-&gt;dist == INT_MAX) return false; for (Edge *e = t-&gt;inEdge; e; e = e-&gt;from-&gt;inEdge) { e-&gt;flow += t-&gt;flow; e-&gt;reversedEdge-&gt;flow -= t-&gt;flow; } flow += t-&gt;flow; cost += t-&gt;flow * t-&gt;dist; return true; } void operator()(int s, int t, int n, int &amp;flow, int &amp;cost) { flow = cost = 0; while (bellmanford(&amp;nodes[s], &amp;nodes[t], n, flow, cost)); } } edmondskarp; inline void addEdge(int from, int to, int capacity, int cost) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity, cost); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0, -cost); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } int n, m, time[MAXM][MAXN]; inline int hash(int j, int k) { return n + (j - 1) * n + k; } int main() { scanf("%d %d", &amp;m, &amp;n); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { scanf("%d", &amp;time[j][i]); } } const int s = 0, t = n + n * m + 1; //printf("s = %d, t = %d\n", s, t); for (int i = 1; i &lt;= n; i++) { addEdge(s, i, 1, 0); } for (int j = 1; j &lt;= m; j++) { for (int k = 1; k &lt;= n; k++) { addEdge(hash(j, k), t, 1, 0); for (int i = 1; i &lt;= n; i++) { //printf("%d -&gt; %d\n", i, hash(j, k)); addEdge(i, hash(j, k), 1, time[j - 1][i - 1] * k); } } } int flow, cost; edmondskarp(s, t, n + n * m + 2, flow, cost); printf("%.2lf\n", (double)cost / (double)n); return 0; } 吐槽 又一次把 、 读入倒了 …… 又一次敲错 EK 模板 …… hehe]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>Edmonds-Karp</tag>
        <tag>费用流</tag>
        <tag>CodeVS</tag>
        <tag>图论</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2008」紧急集合 - 最近公共祖先]]></title>
    <url>%2Fahoi2008-meet%2F</url>
    <content type="text"><![CDATA[在树上寻找一个点，使其到给定三点的距离之和最小。 链接 BZOJ 1787 题解 从样例中找出规律，三个点两两之间的 LCA 必有一对相等，写了个数据生成器用大数据验证了一下，确实是成立的。 进一步得到规律，要找的点就是除了相等的一对 LCA 以外的另一个 LCA …… 别问我怎么证明，我不会 qwq 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;cassert&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 500000; const int MAXLOGN = 19; // log(500000, 2) = 18.931568569324174 const int MAXM = 500000; struct Node; struct Edge; struct Node { Edge *firstEdge; int id, depth; struct SparseTable { int dist; Node *v; } st[MAXLOGN + 1]; } nodes[MAXN]; struct Edge { Node *from, *to; Edge *next; Edge(Node *from, Node *to) : from(from), to(to), next(from-&gt;firstEdge) {} }; int n, m; inline void addEdge(int u, int v) { nodes[u].firstEdge = new Edge(&amp;nodes[u], &amp;nodes[v]); nodes[v].firstEdge = new Edge(&amp;nodes[v], &amp;nodes[u]); } inline void makeSparseTable() { std::queue&lt;Node *&gt; q; q.push(&amp;nodes[0]); nodes[0].depth = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;to-&gt;depth == 0) { e-&gt;to-&gt;depth = v-&gt;depth + 1; e-&gt;to-&gt;st[0].v = v; e-&gt;to-&gt;st[0].dist = 1; q.push(e-&gt;to); } } } nodes[0].st[0].v = &amp;nodes[0]; nodes[0].st[0].dist = 0; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) { for (int i = 0; i &lt; n; i++) { nodes[i].st[j].v = nodes[i].st[j - 1].v-&gt;st[j - 1].v; nodes[i].st[j].dist = nodes[i].st[j - 1].dist + nodes[i].st[j - 1].v-&gt;st[j - 1].dist; } } } inline int query(const int a, const int b, Node **lca = NULL) { Node *u = &amp;nodes[a], *v = &amp;nodes[b]; int dist = 0; if (u-&gt;depth &lt; v-&gt;depth) { std::swap(u, v); } if (u-&gt;depth != v-&gt;depth) { for (int i = MAXLOGN; i &gt;= 0; i--) { if (u-&gt;st[i].v != NULL &amp;&amp; u-&gt;st[i].v-&gt;depth &gt;= v-&gt;depth) { dist += u-&gt;st[i].dist; u = u-&gt;st[i].v; } } } if (u != v) { for (int i = MAXLOGN; i &gt;= 0; i--) { if (u-&gt;st[i].v != v-&gt;st[i].v) { dist += u-&gt;st[i].dist + v-&gt;st[i].dist; u = u-&gt;st[i].v; v = v-&gt;st[i].v; } } dist += u-&gt;st[0].dist + v-&gt;st[0].dist; if (lca) *lca = u-&gt;st[0].v; return dist; } if (lca) *lca = u; return dist; } inline int solve(int a, int b, int c) { Node *ab, *bc, *ca; int distAB, distBC, distCA; query(a, b, &amp;ab); query(b, c, &amp;bc); query(c, a, &amp;ca); // printf("%d, %d, %d\n", ab-&gt;id, bc-&gt;id, ca-&gt;id); Node *v; if (ab == bc) { v = ca; } else if (bc == ca) { v = ab; } else if (ca == ab) { v = bc; } assert(v != NULL); return v-&gt;id; } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) nodes[i].id = i + 1; for (int i = 0; i &lt; n - 1; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v), u--, v--; addEdge(u, v); } makeSparseTable(); for (int i = 0; i &lt; m; i++) { int a, b, c; scanf("%d %d %d", &amp;a, &amp;b, &amp;c), a--, b--, c--; int id = solve(a, b, c); int dist = query(a, id - 1) + query(b, id - 1) + query(c, id - 1); printf("%d %d\n", id, dist); } return 0; } 数据生成器 #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;algorithm&gt; const int MAXN = 500000; const int MAXM = 500000; struct UnionFindSet { int a[MAXN]; void init(int n) { for (int i = 0; i &lt; n; i++) a[i] = i; } int find(int x) { return a[x] == x ? x : a[x] = find(a[x]); } void merge(int x, int y) { a[find(x)] = find(y); } }; inline int rand(int l, int r) { const int MAGIC_NUMBER = 20000528; int x = rand(); srand((time(NULL) &lt;&lt; 16) | ((clock() &lt;&lt; 16) &gt;&gt; 16) ^ x ^ MAGIC_NUMBER); return (rand() ^ x) % (r - l + 1) + l; } int main() { int n = MAXN, m = MAXM; static UnionFindSet ufs; ufs.init(n); printf("%d %d\n", n, m); for (int i = 0; i &lt; n - 1; ) { int u, v; u = rand(1, n), v = rand(1, n); if (ufs.find(u - 1) != ufs.find(v - 1)) { ufs.merge(u - 1, v - 1); printf("%d %d\n", u, v); i++; } } for (int i = 0; i &lt; m; i++) { int a, b, c; a = rand(1, n), b = rand(1, n), c = rand(1, n); printf("%d %d %d\n", a, b, c); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>AHOI</tag>
        <tag>BZOJ</tag>
        <tag>乱搞</tag>
        <tag>倍增</tag>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2010」游戏 - 二分图匹配]]></title>
    <url>%2Fscoi2010-game%2F</url>
    <content type="text"><![CDATA[在游戏里，他拥有很多的装备，每种装备都有两个属性，这些属性的值用 之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。终极 BOSS 很奇怪，攻击他的装备所使用的属性值必须从 开始连续递增地攻击，才能对 BOSS 产生伤害。也就是说一开始的时候，只能使用某个属性值为 的装备攻击 BOSS，然后只能使用某个属性值为 的装备攻击 BOSS，然后只能使用某个属性值为 的装备攻击 BOSS …… 以此类推。他最多能连续攻击 BOSS 多少次？ 链接 BZOJ 1854 题解 看一下数据范围 ，如果枚举每件武器，肯定要 的算法才能过，但又想不出 的算法来 …… 我们换一种思路，从属性值小到大，之间如果有一个数不能没有可用的武器，则不可能继续打出比这个数更大的属性值了。也就是说答案具有单调性，可以采用枚举答案并检验的方法。 题目中并没有要求某个属性值要由特定的武器打出，所以说可以任意选择某个可用的武器来打出指定的属性值。 从 开始，任选一个可打出 的武器并标记为使用过，枚举时如果发现能打出 的武器全部被用过了，就尝试将某一件属性值为 武器标记为 ，并寻找 的替代（），这样递归下去，直到某个属性值使用了一件没有被使用武器，则成功，否则失败。 算法思想与『二分图匹配』中的匈牙利算法比较相似。 代码 #include &lt;cstdio&gt; #include &lt;vector&gt; const int MAXN = 1000000; const int MAXX = 10000; struct Gun { int x[2]; int selected; Gun() : selected(-1) {} void select(int x) { if (this-&gt;x[0] == x) selected = 0; else selected = 1; } } guns[MAXN]; int n; std::vector&lt;int&gt; gunID[MAXX]; inline bool check(int x, int ignore = -1) { for (std::vector&lt;int&gt;::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) { Gun &amp;g = guns[*p]; if (g.selected == -1) { g.select(x); return true; } } for (std::vector&lt;int&gt;::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) { if (*p == ignore) continue; Gun &amp;g = guns[*p]; if (check(g.x[g.selected ^ 1], *p)) { g.select(x); return true; } } return false; } int main() { scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) { Gun &amp;g = guns[i]; scanf("%d %d", &amp;g.x[0], &amp;g.x[1]), g.x[0]--, g.x[1]--; gunID[g.x[0]].push_back(i); gunID[g.x[1]].push_back(i); } int i; for (i = 0; i &lt; MAXX; i++) { if (!check(i)) break; } printf("%d\n", i); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>二分图匹配</tag>
        <tag>枚举答案</tag>
        <tag>SCOI</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS X 与虚拟机中 Linux 无缝整合]]></title>
    <url>%2Fvirtualbox-archlinux%2F</url>
    <content type="text"><![CDATA[OS X 中有很多与 GNU/Linux 相似的地方，但也有很大的差异，很多时候 GNU/Linux 系统比 OS X 好用一些，而 OS X 的图形界面比 GNU/Linux 不知要高到哪里去了 …… 二者兼得的方法，就是使用虚拟机。 下面以最好用的虚拟机软件 VirtualBox 为例，演示配置 Archlinux 虚拟机与 OS X 主机无缝整合的步骤。 安装 OpenSSH 首先，在虚拟机中安装好 Arch Linux 系统，并安装好增强工具。 安装 OpenSSH： sudo pacman -S openssh sudo systemctl enable sshd sudo systemctl start sshd 配置端口转发 打开「设置」→「网络」，选择「网络地址转换「NAT」连接方式。 点击「端口转发」。 子系统端口填写 22，主机端口填一个大于 1000 的值，因为在 OS X 下，非 root 用户的进程是无法绑定 1000 以下的端口的。 确定后，在主机的 Terminal 中尝试连接。 ssh -p5280 127.0.0.1 共享文件夹 在 Virtualbox 的「设置」→「共享文件夹」中设置共享根目录。 为了解决权限问题，不要选择「自动挂载」，而是手动配置自动挂载。 rc.local 服务 Archlinux 的 systemd 原生不支持开机自动执行 rc.local 文件，所以我们需要先添加一个服务。 sudo nano /usr/lib/systemd/system/rc-local.service 输入以下内容： [Unit] Description="/etc/rc.local Compatibility" After=vboxadd.service vboxadd-service.service [Service] Type=forking ExecStart=/etc/rc.local start TimeoutSec=0 StandardInput=tty RemainAfterExit=yes SysVStartPriority=999 [Install] WantedBy=multi-user.target 保存后启用服务，并创建 rc.local 文件： sudo systemctl enable rc-local 自动挂载脚本 sudo touch /etc/rc.local sudo chmod +x /etc/rc.local sudo nano /etc/rc.local #!/bin/bash /usr/bin/mount -t vboxsf Host /media/Host -o uid=1000,gid=1000 /usr/bin/mount --bind /media/Host/Users/Menci /home/Menci exit 0 重启后，虚拟机中的主目录就和主机上的主目录共享啦。 SSH 免密码登录 进行完以上步骤后，已经可以在主机通过 SSH 连接到虚拟机了，但需要输入密码。我们可以使用私钥认证的方式免去输入密码。 ssh-keygen -b 1024 -t rsa 一路回车后，会在 ~/.ssh 目录下生成私钥和公钥。 cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 因为主机和虚拟机的主目录是共享的，所以在主机里设置后，虚拟机里也会生效。 现在试试 SSH 连接到虚拟机，应该不需要密码了。 配置 Terminal 快捷键 众所周知，Terminal 中以默认设置打开新窗口的快捷键是 Command + N。我们也可以设置打开新窗口并 SSH 连接到虚拟机的快捷键。 添加描述文件 在 Terminal 的偏好设置中，选择「描述文件」，把「Basic」配置复制一份，命名为「Basic Linux」，并在 Shell 一栏中填写「运行命令」为 SSH，不勾选下方的「在 Shell 中运行」。 这样就已经可以在菜单中打开连接虚拟机的新窗口了。 添加快捷键 在系统偏好设置中添加快捷键： 「系统偏好设置」→「键盘」→「快捷键」→「应用程序快捷键」→「添加」 点击「添加」后，就可以使用快捷键啦！ 成果 在 Terminal 中，按下 Command + B： 为了比较好的效果，可以改一下 screenfetch。]]></content>
      <categories>
        <category>Geek</category>
      </categories>
      <tags>
        <tag>Archlinux</tag>
        <tag>Linux</tag>
        <tag>OS X</tag>
        <tag>SSH</tag>
        <tag>VirtualBox</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2003」文本编辑器 - Splay]]></title>
    <url>%2Fnoi2003-editor%2F</url>
    <content type="text"><![CDATA[操作名称 输入文件中的格式 功能 Move k 将光标移动到第 个字符之后，如果 ，将光标移到文本第一个字符之前 Insert n S 在光标后插入长度为 的字符串 ，光标位置不变， Delete n 删除光标后的 个字符，光标位置不变， Get n 输出光标后的 个字符，光标位置不变， Prev 光标前移一个字符 Next 光标后移一个字符 链接 BZOJ 1507 题解 块状链表太鬼畜辣！还是 Splay 比较好写好调w 一点小技巧，插入的时候可以照着选择区间的方法选出一段空白区间，然后 build 出一棵子树给接上去，可以少一个 。 代码 #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; const int MAXM = 50000 + 4000 + 200000; template &lt;typename T&gt; struct Splay { enum Relation { L = 0, R = 1 }; struct Node { Node *child[2], *parent, **root; T value; int size; bool bound; Node(Node *parent, const T &amp;value, Node **root, bool bound = false) : parent(parent), value(value), root(root), size(1), bound(bound) { child[L] = child[R] = NULL; } ~Node() { if (child[L]) delete child[L]; if (child[R]) delete child[R]; } Relation relation() { return this == parent-&gt;child[L] ? L : R; } void maintain() { //if (child[L]) child[L]-&gt;maintain(); //if (child[R]) child[R]-&gt;maintain(); size = (child[L] ? child[L]-&gt;size : 0) + (child[R] ? child[R]-&gt;size : 0) + 1; } void rotate() { Relation x = relation(); Node *oldParent = parent; if (oldParent-&gt;parent) oldParent-&gt;parent-&gt;child[oldParent-&gt;relation()] = this; parent = oldParent-&gt;parent; oldParent-&gt;child[x] = child[x ^ 1]; if (child[x ^ 1]) child[x ^ 1]-&gt;parent = oldParent; child[x ^ 1] = oldParent; oldParent-&gt;parent = this; oldParent-&gt;maintain(), maintain(); if (!parent) *root = this; } void splay(Node *targetParent = NULL) { while (parent != targetParent){ if (parent-&gt;parent == targetParent) rotate(); else if (parent-&gt;relation() == relation()) parent-&gt;rotate(), rotate(); else rotate(), rotate(); } } Node *pred() { splay(); Node *v = child[L]; while (v-&gt;child[R]) v = v-&gt;child[R]; return v; } Node *succ() { splay(); Node *v = child[R]; while (v-&gt;child[L]) v = v-&gt;child[L]; return v; } int rank() { return child[L] ? child[L]-&gt;size : 0; } } *root; Splay() : root(NULL) { buildBound(L), buildBound(R); } ~Splay() { if (root) delete root; } void buildBound(Relation x) { Node **v = &amp;root, *parent = NULL; while (*v) { parent = *v; parent-&gt;size++; v = &amp;parent-&gt;child[x]; } *v = new Node(parent, 0, &amp;root, true); } Node *build(const T *a, int l, int r, Node *parent = NULL) { if (l &gt; r) return NULL; int mid = l + ((r - l) &gt;&gt; 1); Node *v = new Node(parent, a[mid - 1], &amp;root); v-&gt;child[L] = build(a, l, mid - 1, v); v-&gt;child[R] = build(a, mid + 1, r, v); v-&gt;maintain(); return v; } Node *select(int k) { k++; //printf("select(%d) in size = %d\n", k, root-&gt;size); Node *v = root; while (v-&gt;maintain(), k != v-&gt;rank() + 1) { if (k &lt; v-&gt;rank() + 1) v = v-&gt;child[L]; else k -= v-&gt;rank() + 1, v = v-&gt;child[R]; } return v; } Node *&amp;select(int l, int r) { Node *lbound = select(l - 1); Node *rbound = select(r + 1); lbound-&gt;splay(); rbound-&gt;splay(lbound); return rbound-&gt;child[L]; } void insert(const T *a, int n, int pos) { Node *&amp;v = select(pos + 1, pos); v = build(a, 1, n, root-&gt;child[R]); root-&gt;child[R]-&gt;maintain(), root-&gt;maintain(); } void erase(int l, int r) { Node *&amp;v = select(l, r); delete v; v = NULL; root-&gt;child[R]-&gt;maintain(), root-&gt;maintain(); } void fetch(T *a, int l, int r) { int i = 0; dfs(select(l, r), a, i); } void dfs(Node *v, T *a, int &amp;i) { if (!v) return; dfs(v-&gt;child[L], a, i); a[i++] = v-&gt;value; dfs(v-&gt;child[R], a, i); } }; int t, pos; Splay&lt;char&gt; splay; inline bool isValid(char ch) { return ch &gt;= 32 &amp;&amp; ch &lt;= 126; } int main() { scanf("%d", &amp;t); static std::vector&lt;char&gt; buffers; for (int i = 0; i &lt; t; i++) { char command[sizeof("Insert")]; scanf("%s", command); if (command[0] == 'M') { scanf("%d", &amp;pos); } else if (command[0] == 'I') { int n; scanf("%d", &amp;n); buffers.clear(); buffers.reserve(n); char ch; for (int i = 0; i &lt; n; ) { if (isValid(ch = getchar())) { buffers.push_back(ch); i++; } } splay.insert(buffers.data(), n, pos); } else if (command[0] == 'D') { int n; scanf("%d", &amp;n); splay.erase(pos + 1, pos + n); } else if (command[0] == 'G') { int n; scanf("%d", &amp;n); buffers.clear(); buffers.resize(n + 1); splay.fetch(const_cast&lt;char *&gt;(buffers.data()), pos + 1, pos + n); buffers[n] = '\0'; printf("%s\n", buffers.data()); } else if (command[0] == 'P') pos--; else if (command[0] == 'N') pos++; } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>高级数据结构</tag>
        <tag>BZOJ</tag>
        <tag>Splay</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2011」糖果 - 强连通分量 + 拓扑排序]]></title>
    <url>%2Fscoi2011-candy%2F</url>
    <content type="text"><![CDATA[幼儿园里有 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。在分配糖果的时候，需要满足小朋友们的 个要求。幼儿园的糖果总是有限的，想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。 链接 BZOJ 2330 题解 在满足题目的要求下，最优解一定是：最少的一个，比别人多也只多一个。很容易想到用查分约束系统来做。 然而刚学了 Tarjan 就想乱搞搞，做法是，把所有关系转化为小于等于和小于两种，先把小于等于的边全部加进去，跑一遍 Tarjan，然后缩点，此时一个强连通分量上的小朋友糖果数是相同的。 把小于的边再加上，进行拓扑排序，如果有环说明无解。把小于等于的边权值置为 0，小于的边权值置为 1，入度为零的点距离置为 1。求出所有最长路，每个点距离乘以该点小朋友的数量的和即为答案。 注意开 long long。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; #include &lt;queue&gt; const int MAXN = 100000; const int MAXK = 100000; struct Node; struct Edge; struct Connected; struct Node { Edge *firstEdge, *currentEdge, *inEdge; int dfn, low, inDegree, dist; bool visited, pushed, inStack; Connected *scc; } nodes[MAXN]; struct Edge { Node *from, *to; Edge *next; int w; Edge(Node *from, Node *to, int w) : from(from), to(to), next(from-&gt;firstEdge), w(w) {} }; struct Connected { int size; Node v; } sccs[MAXN]; struct Condition { int x, u, v; } conditions[MAXK]; int n, k; inline int tarjan() { int timeStamp = 0, count = 0; for (int i = 0; i &lt; n; i++) { if (nodes[i].visited) continue; std::stack&lt;Node *&gt; s, t; s.push(&amp;nodes[i]); nodes[i].pushed = true; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; v-&gt;currentEdge = v-&gt;firstEdge; v-&gt;dfn = v-&gt;low = timeStamp++; v-&gt;inStack = true; t.push(v); } if (v-&gt;currentEdge) { Edge *&amp;e = v-&gt;currentEdge; if (!e-&gt;to-&gt;pushed) s.push(e-&gt;to), e-&gt;to-&gt;pushed = true, e-&gt;to-&gt;inEdge = e; else if (e-&gt;to-&gt;inStack) v-&gt;low = std::min(v-&gt;low, e-&gt;to-&gt;dfn); e = e-&gt;next; } else { s.pop(); if (v-&gt;dfn == v-&gt;low) { v-&gt;scc = &amp;sccs[count++]; Node *u; do { u = t.top(); t.pop(); u-&gt;inStack = false; u-&gt;scc = v-&gt;scc; u-&gt;scc-&gt;size++; } while (u != v); } if (v-&gt;inEdge) v-&gt;inEdge-&gt;from-&gt;low = std::min(v-&gt;inEdge-&gt;from-&gt;low, v-&gt;low); } } } return count; } inline void contract() { for (int i = 0; i &lt; n; i++) { for (Edge *e = nodes[i].firstEdge; e; e = e-&gt;next) { if (e-&gt;from-&gt;scc != e-&gt;to-&gt;scc) { e-&gt;from-&gt;scc-&gt;v.firstEdge = new Edge(&amp;e-&gt;from-&gt;scc-&gt;v, &amp;e-&gt;to-&gt;scc-&gt;v, e-&gt;w); e-&gt;to-&gt;scc-&gt;v.inDegree++; } } } } inline long long topoSort(int count) { std::queue&lt;Node *&gt; q; for (int i = 0; i &lt; count; i++) { if (sccs[i].v.inDegree == 0) { sccs[i].v.dist = 1; q.push(&amp;sccs[i].v); } } int x = count; while (!q.empty()) { Node *v = q.front(); q.pop(); x--; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;to-&gt;dist == 0 || e-&gt;to-&gt;dist &lt; v-&gt;dist + e-&gt;w) e-&gt;to-&gt;dist = v-&gt;dist + e-&gt;w; if (--e-&gt;to-&gt;inDegree == 0) { q.push(e-&gt;to); } } } if (x &gt; 0) return -1; else { long long ans = 0; for (int i = 0; i &lt; count; i++) { ans += (long long)sccs[i].size * (long long)sccs[i].v.dist; } return ans; } } inline void addEdge(int from, int to, int w) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], w); } int main() { scanf("%d %d", &amp;n, &amp;k); for (int i = 0; i &lt; k; i++) { scanf("%d %d %d", &amp;conditions[i].x, &amp;conditions[i].u, &amp;conditions[i].v); conditions[i].u--, conditions[i].v--; if (conditions[i].x == 4) { std::swap(conditions[i].u, conditions[i].v); conditions[i].x = 2; } else if (conditions[i].x == 3) { std::swap(conditions[i].u, conditions[i].v); conditions[i].x = 5; } } for (int i = 0; i &lt; k; i++) { if (conditions[i].x == 1) { addEdge(conditions[i].u, conditions[i].v, 0); addEdge(conditions[i].v, conditions[i].u, 0); } else if (conditions[i].x == 5) { addEdge(conditions[i].u, conditions[i].v, 0); } } int count = tarjan(); contract(); for (int i = 0; i &lt; k; i++) { if (conditions[i].x == 2) { Node *u = &amp;nodes[conditions[i].u].scc-&gt;v, *v = &amp;nodes[conditions[i].v].scc-&gt;v; u-&gt;firstEdge = new Edge(u, v, 1); v-&gt;inDegree++; } } printf("%lld\n", topoSort(count)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>缩点</tag>
        <tag>拓扑排序</tag>
        <tag>SCOI</tag>
        <tag>差分约束系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2006」受欢迎的牛 - 强连通分量]]></title>
    <url>%2Fhaoi2006-cow%2F</url>
    <content type="text"><![CDATA[每一头牛的愿望就是变成一头最受欢迎的牛。现在有 头牛，给你 对整数 ，表示牛 认为牛 受欢迎。这种关系是具有传递性的，如果 认为 受欢迎， 认为 受欢迎，那么牛 也认为牛 受欢迎。你的任务是求出有多少头牛被所有的牛认为是受欢迎的。 链接 BZOJ 1051 题解 求出强连通分量，缩点，然后判断是不是只有一个出度为零的点，如果是输出它的大小。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; const int MAXN = 10000; struct Node; struct Edge; struct Connected; struct Node { Edge *firstEdge, *currentEdge, *inEdge; int dfn, low, outDegree; bool visited, pushed, inStack; Connected *connected; } nodes[MAXN]; struct Edge { Node *from, *to; Edge *next; Edge(Node *from, Node *to) : from(from), to(to), next(from-&gt;firstEdge) {} }; struct Connected { int size; Node v; } connecteds[MAXN]; int n, m; inline int tarjan() { int timeStamp = 0, count = 0; for (int i = 0; i &lt; n; i++) { if (nodes[i].visited) continue; std::stack&lt;Node *&gt; s, t; s.push(&amp;nodes[i]); nodes[i].pushed = true; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; v-&gt;currentEdge = v-&gt;firstEdge; v-&gt;dfn = v-&gt;low = timeStamp++; v-&gt;inStack = true; t.push(v); } if (v-&gt;currentEdge) { Edge *&amp;e = v-&gt;currentEdge; if (!e-&gt;to-&gt;pushed) { s.push(e-&gt;to); e-&gt;to-&gt;pushed = true; e-&gt;to-&gt;inEdge = e; } else if (e-&gt;to-&gt;inStack) v-&gt;low = std::min(v-&gt;low, e-&gt;to-&gt;dfn); e = e-&gt;next; } else { s.pop(); if (v-&gt;dfn == v-&gt;low) { v-&gt;connected = &amp;connecteds[count++]; Node *u; do { u = t.top(); t.pop(); u-&gt;inStack = false; u-&gt;connected = v-&gt;connected; u-&gt;connected-&gt;size++; } while (u != v); } if (v-&gt;inEdge) v-&gt;inEdge-&gt;from-&gt;low = std::min(v-&gt;inEdge-&gt;from-&gt;low, v-&gt;low); } } } return count; } inline Connected *contract(int count) { int zeroCount = count; for (int i = 0; i &lt; n; i++) { for (Edge *e = nodes[i].firstEdge; e; e = e-&gt;next) { if (e-&gt;from-&gt;connected != e-&gt;to-&gt;connected) { e-&gt;from-&gt;connected-&gt;v.firstEdge = new Edge(&amp;e-&gt;from-&gt;connected-&gt;v, &amp;e-&gt;to-&gt;connected-&gt;v); if (e-&gt;from-&gt;connected-&gt;v.outDegree++ == 0) zeroCount--; } } } if (zeroCount != 1) return NULL; for (int i = 0; i &lt; count; i++) { if (connecteds[i].v.outDegree == 0) return &amp;connecteds[i]; } return NULL; } inline void addEdge(int from, int to) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to]); } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) { int from, to; scanf("%d %d", &amp;from, &amp;to), from--, to--; addEdge(from, to); } int count = tarjan(); Connected *popular = contract(count); if (!popular) puts("-1"); else printf("%d\n", popular-&gt;size); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>缩点</tag>
        <tag>HAOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeVS 2822」爱在心中 - 强连通分量]]></title>
    <url>%2Fcodevs-2822%2F</url>
    <content type="text"><![CDATA[在爱的国度里有 N 个人，在他们的心中都有着一个爱的名单，上面记载着他所爱的人（不会出现自爱的情况）。爱是具有传递性的，即如果 A 爱 B，B 爱 C，则 A 也爱 C。 如果有这样一部分人，他们彼此都相爱，则他们就超越了一切的限制，用集体的爱化身成为一个爱心天使。现在，我们想知道在这个爱的国度里会出现多少爱心天使。而且，如果某个爱心天使被其他所有人或爱心天使所爱则请输出这个爱心天使是由哪些人构成的，否则输出 -1。 链接 CodeVS 2822 题解 第一问很明显的，求出图中有多少不是单点的强连通分量就是答案。 第二问，把每个强连通分量缩成一个点，重新构图，如果新图中有出度为零的点，则该点对应的原图中的点集即为第二问答案。注意排除一个点情况。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; #include &lt;vector&gt; const int MAXN = 1000; const int MAXM = 1000; struct Node; struct Edge; struct Connected; struct Node { Edge *firstEdge, *currentEdge, *inEdge; int id, dfn, low, outDegree; bool visited, pushed, inStack; Connected *connected; } nodes[MAXN]; struct Edge { Node *from, *to; Edge *next; Edge(Node *from, Node *to) : from(from), to(to), next(from-&gt;firstEdge) {} }; struct Connected { int size; std::vector&lt;int&gt; vec; Node v; } connecteds[MAXN]; int n, m; inline int tarjan() { int timeStamp = 0, count = 0; for (int i = 0; i &lt; n; i++) { if (nodes[i].visited) continue; std::stack&lt;Node *&gt; s, t; s.push(&amp;nodes[i]); nodes[i].pushed = true; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; v-&gt;currentEdge = v-&gt;firstEdge; v-&gt;dfn = v-&gt;low = timeStamp++; v-&gt;inStack = true; t.push(v); } if (v-&gt;currentEdge) { Edge *&amp;e = v-&gt;currentEdge; if (!e-&gt;to-&gt;pushed) s.push(e-&gt;to), e-&gt;to-&gt;pushed = true, e-&gt;to-&gt;inEdge = e; else if (e-&gt;to-&gt;inStack) v-&gt;low = std::min(v-&gt;low, e-&gt;to-&gt;dfn); e = e-&gt;next; } else { if (v-&gt;dfn == v-&gt;low) { v-&gt;connected = &amp;connecteds[count++]; Node *u; do { u = t.top(); t.pop(); u-&gt;inStack = false; u-&gt;connected = v-&gt;connected; u-&gt;connected-&gt;size++; u-&gt;connected-&gt;vec.push_back(u-&gt;id); } while (u != v); } if (v-&gt;inEdge) v-&gt;inEdge-&gt;from-&gt;low = std::min(v-&gt;inEdge-&gt;from-&gt;low, v-&gt;low); s.pop(); } } } return count; } inline Connected *contract(int count) { int zeroCount = count; for (int i = 0; i &lt; n; i++) { for (Edge *e = nodes[i].firstEdge; e; e = e-&gt;next) { if (e-&gt;from-&gt;connected != e-&gt;to-&gt;connected) { e-&gt;from-&gt;connected-&gt;v.firstEdge = new Edge(&amp;e-&gt;from-&gt;connected-&gt;v, &amp;e-&gt;to-&gt;connected-&gt;v); if (e-&gt;from-&gt;connected-&gt;v.outDegree++ == 0) zeroCount--; } } } if (zeroCount != 1) return NULL; for (int i = 0; i &lt; count; i++) { if (connecteds[i].size &gt; 1 &amp;&amp; connecteds[i].v.outDegree == 0) return &amp;connecteds[i]; } return NULL; } inline void addEdge(int from, int to) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to]); } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) nodes[i].id = i + 1; for (int i = 0; i &lt; m; i++) { int from, to; scanf("%d %d", &amp;from, &amp;to), from--, to--; addEdge(from, to); } int count = tarjan(); int ans = 0; for (int i = 0; i &lt; count; i++) { if (connecteds[i].size &gt; 1) { ans++; } } printf("%d\n", ans); Connected *loved = contract(count); if (!loved) { puts("-1"); } else { std::sort(loved-&gt;vec.begin(), loved-&gt;vec.end()); for (std::vector&lt;int&gt;::const_iterator p = loved-&gt;vec.begin(); p != loved-&gt;vec.end(); p++) { printf("%d ", *p); } putchar('\n'); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>缩点</tag>
        <tag>CodeVS</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tarjan 强连通分量学习笔记]]></title>
    <url>%2Ftarjan-scc-notes%2F</url>
    <content type="text"><![CDATA[在一个有向图中，如果某两点间都有互相到达的路径，那么称中两个点强连通，如果任意两点都强连通，那么称这个图为强连通图；一个有向图的极大强连通子图称为强连通分量。 Tarjan 算法可以在 的时间内求出一个图的所有强连通分量。 定义 Tarjan 算法的核心过程是一次 DFS，它基于的事实是，一个强连通分量中的点一定处于搜索树中同一棵子树中。 栈，搜索树中同一棵子树中的点在栈中是相邻的。 表示进入节点 时的时间。 表示由节点 开始搜索所能到达的点中，在搜索树上是 的祖先且 最小的节点的 。 算法描述 从起点开始 DFS； 进入一个节点时，初始化它的 和 均为当前时间戳，并进栈； 枚举当前点 的所有邻接点； 如果某个邻接点 已在栈中，则更新 ； 如果某个邻接点 未被访问过，则对 进行 DFS，并在回溯后更新 ； 所有邻接点回溯完成后，如果当前点仍满足 ，则将栈中从 到栈顶的所有元素出栈，并标记为一个强连通分量。 解释 枚举 的邻接点时，如果某个邻接点 已在栈中，则更新 因为栈中的所有点均为搜索树上点 的祖先，从搜索树上一个点搜到它的祖先，说明找到了一个环。此时用 去更新 的最远祖先。 如果某个邻接点 未被访问过，则对 进行 DFS，并在回溯后更新 点 出发能到达的点，点 必定也能到达。尽管 可能不是 的祖先（可能是 或 本身），但这并不影响。 所有邻接点回溯完成后，如果当前点仍满足 说明从当前点出发不可能回到任意一个搜索树上的祖先，即当前节点是某个强连通分量所在子树的根节点，而这些节点都在当前节点之后被压在了栈中。 注意，同一个强连通分量的点一定有相同的 值， 值相同的两个点也一定在同一个强连通分量中。 模板 实际代码中要用到两个栈，一个用于控制 DFS（代码中的 s），另一个用于 Tarjan 算法（代码中的 t）。 因为图不一定是弱连通图，所以要以每个点为起点进行一次上述算法。 struct Node { Edge *firstEdge, *currentEdge, *inEdge; Connected *connected; int dfn, low; bool inStack, visited, pushed; } nodes[MAXN]; struct Edge { Node *from, *to; Edge *next; Edge(Node *from, Node *to) : from(from), to(to), next(from-&gt;firstEdge) {} }; struct Connected { int size; } connecteds[MAXN]; int n; inline int tarjan() { int timeStamp = 0, count = 0; for (int i = 0; i &lt; n; i++) { if (nodes[i].visited) continue; std::stack&lt;Node *&gt; s, t; s.push(&amp;nodes[i]); nodes[i].pushed = true; while (!s.empty()) { Node *v = s.top(); if (!v-&gt;visited) { v-&gt;visited = true; v-&gt;currentEdge = v-&gt;firstEdge; v-&gt;dfn = v-&gt;low = timeStamp++; v-&gt;inStack = true; t.push(v); } if (v-&gt;currentEdge) { Edge *&amp;e = v-&gt;currentEdge; if (!e-&gt;to-&gt;pushed) s.push(e-&gt;to), e-&gt;to-&gt;pushed = true, e-&gt;to-&gt;inEdge = e; else if (e-&gt;to-&gt;inStack) v-&gt;low = std::min(v-&gt;low, e-&gt;to-&gt;dfn); e = e-&gt;next; } else { if (v-&gt;dfn == v-&gt;low) { v-&gt;connected = &amp;connecteds[count++]; Node *u; do { u = t.top(); t.pop(); u-&gt;inStack = false; u-&gt;connected = v-&gt;connected; u-&gt;connected-&gt;size++; } while (u != v); } if (v-&gt;inEdge) v-&gt;inEdge-&gt;from-&gt;low = std::min(v-&gt;inEdge-&gt;from-&gt;low, v-&gt;low); s.pop(); } } } return count; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2010」星际竞速 - 费用流]]></title>
    <url>%2Fsdoi2010-starrace%2F</url>
    <content type="text"><![CDATA[大赛要求车手们从一颗与这 颗行星之间没有任何航路的天体出发，访问这 颗行星每颗恰好一次。超能电驴有两种移动模式：高速航行模式和能力爆发模式。在高速航行模式下，超能电驴会沿星际航路高速航行。在能力爆发模式下，经过一段时间的定位之后，它能瞬间移动到任意一个行星。在使用高速航行模式的时候，只能由每个星球飞往引力比它大的星球，否则赛车就会发生爆炸。求完成比赛的最少时间。 链接 BZOJ 1927 CodeVS 2313 题解 求完成比赛的最少时间，很容易想到最短路，然而不确定起点终点而且恰好访问一次都不太适合最短路 …… 考虑网络流建模吧。 刚开始想到的一个错误的解法： 把每个点拆成两个点，一个表示入另一个表示出，之间连一条容量为 1，费用为零的边； 从源点到每个入点连一条容量为 1 费用为零的边； 从每个出点到汇点连一条容量为 1 费用为零的边； 对于每个点，从它的出点到所有他所能到达的点的入点连一条容量为 1 费用为航行时间的边； 建立『中转站』，从每个点到中转站连一条容量为 1 费用为 0 的边；从中转站到每个点连一条容量为 1 费用为定位时间的边。 求出最小费用最大流 …… 呃，答案就是零 …… 很容易想出上面的模型是错的，因为它不能保证每个点都被访问过 —— 虽然它比较直观。 再来分析一下题意，每个点都经过一次，有点类似路径覆盖，而路径覆盖中是没有边权的，考虑把边权加在费用上。 一种类似于路径覆盖的建模方式： 把每个点拆成两个点，一个表示入另一个表示出； 从源点向每个入点连一条容量为 1 费用为零的边； 从每个出点向汇点连一条容量为 1 费用为零的边； 对于每个点，从它的出点到所有他所能到达的点的入点连一条容量为 1 费用为航行时间的边； 从源点向每个出点连一条容量为 1 费用为定位时间的边。 这种建模思想抓住了题目中『每个点经过一次』的条件，避开了路径上的问题 —— 整个网络保证了到汇点边全部满流，也就对应了每个点被经过一次。 处理『瞬间移动』的思路是，不考虑是从哪个星球移动过来，向哪里走 —— 因为从每个点向哪里走是由选择的边决定的（甚至可能瞬移到的点就是终点），只需要考虑，瞬移经过的点不需要再在其他路径上被经过，所以直接从源点连到某个点的出点就好啦。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 800; const int MAXM = 15000; struct Node; struct Edge; struct Node { Edge *firstEdge, *inEdge; int flow, dist; bool inQueue; } nodes[MAXN * 2 + 2]; struct Edge { Node *from, *to; int capacity, flow, cost; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from-&gt;firstEdge) {} }; struct EdmondsKarp { bool bellmanford(Node *s, Node *t, int n, int &amp;flow, int &amp;cost) { for (int i = 0; i &lt; n; i++) { nodes[i].inEdge = NULL; nodes[i].flow = 0; nodes[i].dist = INT_MAX; nodes[i].inQueue = false; } std::queue&lt;Node *&gt; q; q.push(s); s-&gt;flow = INT_MAX; s-&gt;dist = 0; while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;inQueue = false; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;dist &gt; v-&gt;dist + e-&gt;cost) { e-&gt;to-&gt;dist = v-&gt;dist + e-&gt;cost; e-&gt;to-&gt;inEdge = e; e-&gt;to-&gt;flow = std::min(v-&gt;flow, e-&gt;capacity - e-&gt;flow); if (!e-&gt;to-&gt;inQueue) { q.push(e-&gt;to); e-&gt;to-&gt;inQueue = true; } } } } if (t-&gt;dist == INT_MAX) return false; for (Edge *e = t-&gt;inEdge; e; e = e-&gt;from-&gt;inEdge) { e-&gt;flow += t-&gt;flow; e-&gt;reversedEdge-&gt;flow -= t-&gt;flow; } flow += t-&gt;flow; cost += t-&gt;flow * t-&gt;dist; return true; } void operator()(int s, int t, int n, int &amp;flow, int &amp;cost) { flow = cost = 0; while (bellmanford(&amp;nodes[s], &amp;nodes[t], n, flow, cost)); } } edmondskarp; inline void addEdge(int from, int to, int capacity, int cost) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity, cost); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0, -cost); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } int n, m; int main() { scanf("%d %d", &amp;n, &amp;m); const int s = 0, t = n * 2 + 1; for (int i = 1; i &lt;= n; i++) { int x; scanf("%d", &amp;x); addEdge(s, i + n, 1, x); addEdge(s, i, 1, 0); addEdge(i + n, t, 1, 0); } for (int i = 0; i &lt; m; i++) { int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); if (u &gt; v) std::swap(u, v); addEdge(u, v + n, 1, w); } int flow, cost; edmondskarp(s, t, n * 2 + 2, flow, cost); printf("%d\n", cost); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>Edmonds-Karp</tag>
        <tag>费用流</tag>
        <tag>图论</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2015」星际战争 - 网络流]]></title>
    <url>%2Fsdoi2015-war%2F</url>
    <content type="text"><![CDATA[Y 军团一共派遣了 个巨型机器人进攻 X 军团的阵地，其中第 个巨型机器人的装甲值为 。当一个巨型机器人的装甲值减少到 0 或者以下时，这个巨型机器人就被摧毁了。X 军团有 个激光武器，其中第 个激光武器每秒可以削减一个巨型机器人 的装甲值。激光武器的攻击是连续的。这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y 军团需要知道 X 军团最少需要用多长时间才能将 Y 军团的所有巨型机器人摧毁。 链接 BZOJ 3993 题解 先二分一个时间，然后用网络流判定是否能在这段时间内打完。 从源点到每一个武器连一条边，容量为武器的威力 × 时间； 从每一个机器人向汇点连一条边，容量为该机器人的装甲值； 从每个武器向所有从该武器能攻击的机器人连一条边，容量为正无穷。 嗯，说起来很容易对吧w …… 然而答案是实数，实数二分倒没什么问题，要注意的是 Dinic 模板也要改成实数的。 二分的范围不太好确定，既然题目明确有解，那就定上界为用一个威力最小的武器打所有机器人所用时间，反正不会错。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;cmath&gt; #include &lt;cfloat&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 50; const int MAXM = 50; const double EPS = 1e-4; struct Node; struct Edge; struct Node { Edge *firstEdge, *currentEdge; int level; } nodes[MAXN + MAXM + 2]; struct Edge { Node *from, *to; double capacity, flow; Edge *next, *reversedEdge; Edge(Node *from, Node *to, double capacity) : from(from), to(to), capacity(capacity), flow(0), next(from-&gt;firstEdge) {} }; int n, m, robot[MAXN], sumRobot, gun[MAXM], minGun = INT_MAX, attack[MAXM][MAXN]; inline bool equal(double a, double b) { return fabs(a - b) &lt; EPS; } struct Dinic { bool makeLevelGraph(Node *s, Node *t, int n) { for (int i = 0; i &lt; n; i++) nodes[i].level = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (!equal(e-&gt;capacity - e-&gt;flow, 0) &amp;&amp; e-&gt;to-&gt;level == 0) { e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; else q.push(e-&gt;to); } } } return false; } double findPath(Node *s, Node *t, double limit = DBL_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;currentEdge; e; e = e-&gt;next) { if (e-&gt;to-&gt;level == s-&gt;level + 1 &amp;&amp; !equal(e-&gt;capacity - e-&gt;flow, 0)) { double flow = findPath(e-&gt;to, t, std::min(limit, e-&gt;capacity - e-&gt;flow)); if (flow &gt; 0) { e-&gt;flow += flow; e-&gt;reversedEdge-&gt;flow -= flow; return flow; } } } return 0; } double operator()(int s, int t, int n) { double ans = 0; while (makeLevelGraph(&amp;nodes[s], &amp;nodes[t], n)) { for (int i = 0; i &lt; n; i++) nodes[i].currentEdge = nodes[i].firstEdge; double flow; while ((flow = findPath(&amp;nodes[s], &amp;nodes[t])) &gt; 0) ans += flow; } return ans; } } dinic; inline void addEdge(int from, int to, double capacity) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } inline void cleanUp(int n) { for (int i = 0; i &lt; n; i++) { Edge *next; for (Edge *&amp;e = nodes[i].firstEdge; e; next = e-&gt;next, delete e, e = next); } } inline bool check(double time) { const int s = 0, t = n + m + 1; for (int i = 1; i &lt;= m; i++) addEdge(s, i, gun[i - 1] * time); for (int i = 1; i &lt;= n; i++) addEdge(i + m, t, robot[i - 1]); for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= n; j++) { if (attack[i - 1][j - 1] == 1) { addEdge(i, j + m, DBL_MAX); } } } double flow = dinic(s, t, n + m + 2); cleanUp(n + m + 2); //printf("%.3lf %d\n", flow, sumRobot); return equal(flow, sumRobot); } inline double dichotomy() { double l = 0, r = ((double)sumRobot) / ((double)minGun); while (r - l &gt; EPS) { double mid = l + (r - l) / 2; //printf("mid = %.6lf\n", mid); if (check(mid)) r = mid; else l = mid; } return l + (r - l) / 2; } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;robot[i]), sumRobot += robot[i]; for (int i = 0; i &lt; m; i++) scanf("%d", &amp;gun[i]), minGun = std::min(minGun, gun[i]); for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { scanf("%d", &amp;attack[i][j]); } } printf("%.6lf\n", dichotomy()); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>二分答案</tag>
        <tag>实数二分</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「COGS 741」负载平衡 - 费用流]]></title>
    <url>%2Fcogs-741%2F</url>
    <content type="text"><![CDATA[G 公司有 n 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 n 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。 链接 COGS 741 题解 这道题猛地看上去有点像之前写过的一道贪心 —— 均分纸牌，那道题只要把每一个数减去平均数，然后从左到右累加，特判一下零就好。但这题难点在于是环形的。 首先，还是要将每个仓库中的库存数量减去平均数，目标便转化为把正数全部加到负数中。『只能在相邻的仓库之间搬运』这一条件，让人很容易想到在相邻仓库之间连边，但稍微思考一下就会发现这样是不行的，因为有时候需要将货物重复移动多次才能到达目的仓库。 不妨只考虑最终的结果 —— 正数最后都要被移动到负数里面。在相邻的仓库之间转移，单位代价是 1，则隔着多个位置的仓库之间转移的代价就是两间仓库的最短距离，环中两点的最短路只有两种情况，顺时针走或者逆时针走，预处理出来就好。 从源点向每个库存量为正数的点连一条边，容量为库存量，费用为 0；从每个库存量为负数的点向汇点连一条边，容量为库存量的相反数，费用为 0；从每个库存量为正数的点向每个库存量为负数的点连一条边，容量为正无穷，费用为两间仓库的最短距离，求出最小费用最大流，则费用即为答案。 代码 #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 100; struct Node; struct Edge; struct Node { Edge *firstEdge, *inEdge; int flow, dist; bool inQueue; } nodes[MAXN + 2]; struct Edge { Node *from, *to; int flow, capacity, cost; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from-&gt;firstEdge) {} }; int n, a[MAXN], dist[MAXN][MAXN]; struct EdmondsKarp { bool bellmanford(Node *s, Node *t, int n, int &amp;flow, int &amp;cost) { for (int i = 0; i &lt; n; i++) { nodes[i].inEdge = NULL; nodes[i].flow = 0; nodes[i].dist = INT_MAX; nodes[i].inQueue = false; } std::queue&lt;Node *&gt; q; q.push(s); s-&gt;flow = INT_MAX; s-&gt;dist = 0; while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;inQueue = false; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;dist &gt; v-&gt;dist + e-&gt;cost) { e-&gt;to-&gt;dist = v-&gt;dist + e-&gt;cost; e-&gt;to-&gt;inEdge = e; e-&gt;to-&gt;flow = std::min(v-&gt;flow, e-&gt;capacity - e-&gt;flow); if (!e-&gt;to-&gt;inQueue) { q.push(e-&gt;to); e-&gt;to-&gt;inQueue = true; } } } } if (t-&gt;dist == INT_MAX) return false; for (Edge *e = t-&gt;inEdge; e; e = e-&gt;from-&gt;inEdge) { e-&gt;flow += t-&gt;flow; e-&gt;reversedEdge-&gt;flow -= t-&gt;flow; } flow += t-&gt;flow; cost += t-&gt;flow * t-&gt;dist; return true; } void operator()(int s, int t, int n, int &amp;flow, int &amp;cost) { flow = cost = 0; while (bellmanford(&amp;nodes[s], &amp;nodes[t], n, flow, cost)); } } edmondskarp; inline void addEdge(int from, int to, int capacity, int cost) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity, cost); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0, -cost); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } inline void getDistances() { for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { dist[i][j] = dist[j][i] = std::min(std::abs(j - i), (n - j) + i); } } } int main() { freopen("overload.in", "r", stdin); freopen("overload.out", "w", stdout); scanf("%d", &amp;n); int sum = 0; for (int i = 0; i &lt; n; i++) { scanf("%d", &amp;a[i]); sum += a[i]; } int average = sum / n; for (int i = 0; i &lt; n; i++) a[i] -= average; getDistances(); const int s = 0, t = n + 1; for (int i = 1; i &lt;= n; i++) { if (a[i - 1] &gt; 0) addEdge(s, i, a[i - 1], 0); else if (a[i - 1] &lt; 0) addEdge(i, t, -a[i - 1], 0); } for (int i = 1; i &lt;= n; i++) { if (a[i - 1] &gt; 0) { for (int j = 1; j &lt;= n; j++) { if (a[j - 1] &lt; 0) addEdge(i, j, INT_MAX, dist[i - 1][j - 1]); } } } int flow, cost; edmondskarp(s, t, n + 2, flow, cost); printf("%d\n", cost); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>Edmonds-Karp</tag>
        <tag>费用流</tag>
        <tag>COGS</tag>
        <tag>图论</tag>
        <tag>网络流 24 题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「COGS 740」分配问题 - 二分图最大权匹配]]></title>
    <url>%2Fcogs-740%2F</url>
    <content type="text"><![CDATA[有 n 件工作要分配给 n 个人做。第 i 个人做第 j 件工作产生的效益为 c[i][j]。试设计一个将 n 件工作分配给 n 个人做的分配方案，使产生的总效益最大。 链接 COGS 740 题解 把工作和人放在网络流模型中，可以发现这是一张二分图，问题转化为从图中选取一些边，使这些边没有交点（没有人做重复的工作，没有工作被重复做），并且边权总和最大。即二分图最大权匹配。 建立源点与汇点，从源点向每个人连一条边，容量为 1（每个人只能匹配一次），费用为 0；从每个工作到汇点连一条边，容量为 1（每个工作只能匹配一次），费用为 0；从每个人向每个工作连一条边，容量为 0，费用为效益的相反数。求出网络的最小费用最大流，所得费用的相反数即为最大权匹配。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 100; struct Node; struct Edge; struct Node { Edge *firstEdge, *inEdge; int dist, flow; bool inQueue; } nodes[MAXN + MAXN + 2]; struct Edge { Node *from, *to; int capacity, flow, cost; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), next(from-&gt;firstEdge), capacity(capacity), flow(0), cost(cost) {} }; int n, a[MAXN][MAXN]; struct EdmondsKarp { bool bellmanford(Node *s, Node *t, int n, int &amp;flow, int &amp;cost) { for (int i = 0; i &lt; n; i++) { nodes[i].dist = INT_MAX; nodes[i].inEdge = NULL; nodes[i].flow = 0; nodes[i].inQueue = false; } std::queue&lt;Node *&gt; q; q.push(s); s-&gt;dist = 0; s-&gt;flow = INT_MAX; while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;inQueue = false; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;dist &gt; v-&gt;dist + e-&gt;cost) { e-&gt;to-&gt;dist = v-&gt;dist + e-&gt;cost; e-&gt;to-&gt;inEdge = e; e-&gt;to-&gt;flow = std::min(v-&gt;flow, e-&gt;capacity - e-&gt;flow); if (!e-&gt;to-&gt;inQueue) { e-&gt;to-&gt;inQueue = true; q.push(e-&gt;to); } } } } if (t-&gt;dist == INT_MAX) return false; for (Edge *e = t-&gt;inEdge; e; e = e-&gt;from-&gt;inEdge) { e-&gt;flow += t-&gt;flow; e-&gt;reversedEdge-&gt;flow -= t-&gt;flow; } flow += t-&gt;flow; cost += t-&gt;dist * t-&gt;flow; return true; } void operator()(int s, int t, int n, int &amp;flow, int &amp;cost) { flow = cost = 0; while (bellmanford(&amp;nodes[s], &amp;nodes[t], n, flow, cost)); } } edmondskarp; inline void addEdge(int from, int to, int capacity, int cost) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity, cost); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0, -cost); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } inline int solve(int d) { for (int i = 0; i &lt; n + n + 2; i++) { Edge *next; for (Edge *&amp;e = nodes[i].firstEdge; e; next = e-&gt;next, delete e, e = next); } const int s = 0, t = n + n + 1; for (int i = 1; i &lt;= n; i++) { addEdge(s, i, 1, 0); addEdge(n + i, t, 1, 0); } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { addEdge(i, n + j, 1, a[i - 1][j - 1] * d); } } int flow, cost; edmondskarp(s, t, n + n + 2, flow, cost); return cost * d; } int main() { freopen("job.in", "r", stdin); freopen("job.out", "w", stdout); scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { scanf("%d", &amp;a[i][j]); } } printf("%d\n", solve(1)); printf("%d\n", solve(-1)); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>Edmonds-Karp</tag>
        <tag>费用流</tag>
        <tag>COGS</tag>
        <tag>图论</tag>
        <tag>二分图匹配</tag>
        <tag>网络流 24 题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CTSC1999」星际转移 - 网络流]]></title>
    <url>%2Fctsc1999-home%2F</url>
    <content type="text"><![CDATA[现有 n 个太空站位于地球与月球之间，且有 m 艘太空船在其间来回穿梭。每个太空站可容纳无限多的人，第 i 个太空船只可容纳 H[i] 个人。每艘太空船将周期性地停靠一系列的太空站。每一艘太空船从一个太空站驶往任一太空站耗时均为 1。人们只能在太空船停靠太空站（或月球、地球）时上、下船。初始时所有人全在地球上，太空船全在初始站。求让所有人尽快地全部转移到月球上的最短时间。 链接 COGS 736 题解 话说这题真是难调 …… qwq 考虑到『一个太空站和一个时间点』确定了一个状态，枚举答案 t，将每个太空站拆成 t + 1 个点（因为初始状态是在 0 时刻）。对于每一个时刻，从上一时刻每个太空船的停留站到这一时刻每个太空船的停留站连一条边，容量为该太空船载客量；对于任何一个太空站，从上一时刻到这一时刻连一条边，容量为正无穷（表示人停留在太空站）；对于任意时刻的地球，从源点向其连一条边，容量为正无穷；对于任意时刻的月球，从其向汇点连一条边，容量为正无穷。 从小到大枚举答案，答案每增大 1，在原图中加入新边。直到汇点的流量大于等于总人数，则答案合法。 也可以二分答案 …… 不过那样要拆掉图重建，总感觉数据小的情况下比枚举还要慢。qwq 数据范围有坑！数据范围有坑！数据范围有坑！n 和 m 的最大值颠倒了！ 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;vector&gt; const int MAXN = 13; const int MAXM = 20; const int MAXK = 50; struct Node; struct Edge; struct Node { Edge *firstEdge, *currentEdge; int level; //char info[256]; } nodes[MAXN * (MAXN + 2) * (MAXM + 1) * MAXK * 2 + 2]; struct Edge { Node *from, *to; int capacity, flow; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from-&gt;firstEdge) {} }; int n, m, k, a[MAXM]; std::vector&lt;int&gt; v[MAXM]; std::vector&lt;int&gt;::const_iterator currentStation[MAXM]; inline void print(Node *v) { //printf("%s", v-&gt;info); return; //int x = (int)(v - nodes); //if (x == 0) putchar('s'); //else if (x == n * (n + 2) * (m + 1) * k * 2 + 1) putchar('t'); //else { // printf("{ day: %d, station: %d }", x / (n + 2), x % (n + 2) - 2); //} } struct Dinic { bool makeLevelGraph(Node *s, Node *t, int n) { for (int i = 0; i &lt; n; i++) nodes[i].level = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == 0) { //print(e-&gt;from); //printf(" -&gt; "); //print(e-&gt;to); //putchar('\n'); e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; else q.push(e-&gt;to); } } } return false; } int findPath(Node *s, Node *t, int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;currentEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == s-&gt;level + 1) { int flow = findPath(e-&gt;to, t, std::min(e-&gt;capacity - e-&gt;flow, limit)); if (flow &gt; 0) { //printf("(%d)\n", (int)(s - nodes)); e-&gt;flow += flow; e-&gt;reversedEdge-&gt;flow -= flow; return flow; } } } return 0; } int operator()(int s, int t, int n) { for (int i = 0; i &lt; n; i++) { for (Edge *e = nodes[i].firstEdge; e; e = e-&gt;next) { e-&gt;flow = 0; } } int ans = 0; while (makeLevelGraph(&amp;nodes[s], &amp;nodes[t], n)) { for (int i = 0; i &lt; n; i++) nodes[i].currentEdge = nodes[i].firstEdge; int flow; while ((flow = findPath(&amp;nodes[s], &amp;nodes[t])) &gt; 0) ans += flow; } return ans; } } dinic; inline void addEdge(int from, int to, int capacity) { //printf("\t\t%d\n", capacity); nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } inline int stationID(int station, int day) { //sprintf(nodes[day * (n + 2) + station].info, "{ day: %d, station: %d }", day, station - 2); return day * (n + 2) + station; } inline int solve() { const int s = 0, t = n * (n + 2) * (m + 1) * k * 2 + 1; //nodes[s].info[0] = 's'; //nodes[t].info[0] = 't'; //puts("s --&gt; { day: 0, station: 0 }"); addEdge(s, stationID(2, 0), INT_MAX); //puts("s --&gt; { day: 0, station: -1 }"); addEdge(stationID(1, 0), t, INT_MAX); for (int i = 1; i &lt;= (n + 2) * (m + 1) * k * 2; i++) { for (int j = 1; j &lt;= m; j++) { int oldStation = *currentStation[j - 1]; currentStation[j - 1]++; if (currentStation[j - 1] == v[j - 1].end()) currentStation[j - 1] = v[j - 1].begin(); int newStation = *currentStation[j - 1]; //printf("{ day: %d, station: %d } --&gt; { day: %d, station: %d }\n", i - 1, oldStation - 2, i, newStation - 2); addEdge(stationID(oldStation, i - 1), stationID(newStation, i), a[j - 1]); } //printf("s --&gt; { day: %d, station: 0 }\n", i); //printf("{ day: %d, station: -1 } --&gt; t\n", i); addEdge(stationID(1, i), t, INT_MAX); addEdge(s, stationID(2, i), INT_MAX); for (int j = 3; j &lt;= n + 2; j++) { //printf("{ day: %d, station: %d } --&gt; { day: %d, station: %d }\n", i - 1, j - 2, i, j - 2); addEdge(stationID(j, i - 1), stationID(j, i), INT_MAX); } int flow = dinic(s, t, n * (n + 2) * (m + 1) * k * 2 + 2); //printf("%d\n", flow); if (flow &gt;= k) return i; } return 0; } int main() { //printf("%d\n", sizeof(nodes)); freopen("home.in", "r", stdin); freopen("home.out", "w", stdout); scanf("%d %d %d", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; m; i++) { scanf("%d", &amp;a[i]); int t; scanf("%d", &amp;t); for (int j = 0; j &lt; t; j++) { int x; scanf("%d", &amp;x); v[i].push_back(x + 2); } currentStation[i] = v[i].begin(); } printf("%d\n", solve()); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>COGS</tag>
        <tag>图论</tag>
        <tag>网络流 24 题</tag>
        <tag>CTSC</tag>
        <tag>枚举答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「COGS 742」深海机器人 - 费用流]]></title>
    <url>%2Fcogs-742%2F</url>
    <content type="text"><![CDATA[有多个深海机器人到达深海海底后离开潜艇向预定目标移动。深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。 链接 COGS 742 题解 最大费用最大流建模，从源点向每个起点连一条边，流量为出发的机器人数量，费用为零；从每个终点向汇点连一条边，流量为到达的机器人数量，费用为零；把每个格点看做点，从每个格点向其东边、北边各连两条边，第一条容量为 1，费用为生物标本价值的相反数（保证第一个通过的机器人取走标本），另一条容量为正无穷，费用为 0（保证多个机器人可占据同一位置，并且路径可重叠）。 计算坐标是个大坑。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;cassert&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXP = 15; const int MAXQ = 15; const int MAXA = 10; const int MAXB = 10; struct Node; struct Edge; struct Node { Edge *firstEdge, *inEdge; int flow, dist; bool inQueue; } nodes[(MAXP + 1) * (MAXQ + 1) + 2]; struct Edge { Node *from, *to; int capacity, flow, cost; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from-&gt;firstEdge) {} }; int a, b, p, q; struct EdmondsKarp { bool bellmanford(Node *s, Node *t, int n, int &amp;flow, int &amp;cost) { for (int i = 0; i &lt; n; i++) { nodes[i].dist = INT_MAX; nodes[i].inQueue = false; nodes[i].flow = 0; nodes[i].inEdge = NULL; } std::queue&lt;Node *&gt; q; q.push(s); s-&gt;flow = INT_MAX; s-&gt;dist = 0; while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;inQueue = false; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;dist &gt; v-&gt;dist + e-&gt;cost) { e-&gt;to-&gt;dist = v-&gt;dist + e-&gt;cost; e-&gt;to-&gt;inEdge = e; e-&gt;to-&gt;flow = std::min(v-&gt;flow, e-&gt;capacity - e-&gt;flow); if (!e-&gt;to-&gt;inQueue) { q.push(e-&gt;to); e-&gt;to-&gt;inQueue = true; } } } } if (t-&gt;dist == INT_MAX) return false; for (Edge *e = t-&gt;inEdge; e; e = e-&gt;from-&gt;inEdge) { //printf("%d -&gt; %d = %d\n", (int)(e-&gt;from - nodes), (int)(e-&gt;to - nodes), t-&gt;flow); e-&gt;flow += t-&gt;flow; e-&gt;reversedEdge-&gt;flow -= t-&gt;flow; } flow += t-&gt;flow; cost += t-&gt;dist * t-&gt;flow; //printf("flow += %d, cost += %d\n", t-&gt;flow, t-&gt;dist * t-&gt;flow); return true; } void operator()(int s, int t, int n, int &amp;flow, int &amp;cost) { flow = cost = 0; while (bellmanford(&amp;nodes[s], &amp;nodes[t], n, flow, cost)); } } edmondskarp; inline void addEdge(int from, int to, int capacity, int cost) { assert(from &lt; (p + 1) * (q + 1) + 2); assert(to &lt; (p + 1) * (q + 1) + 2); nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity, cost); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0, -cost); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } inline int getNodeID(int x, int y) { return x * (q + 1) + y + 1; } int main() { freopen("shinkai.in", "r", stdin); freopen("shinkai.out", "w", stdout); scanf("%d %d\n%d %d", &amp;a, &amp;b, &amp;p, &amp;q); const int s = 0, t = (p + 1) * (q + 1) + 1; for (int i = 0; i &lt; p + 1; i++) { for (int j = 0; j &lt; q; j++) { int x; scanf("%d", &amp;x); //printf("(%d, %d) -&gt; (%d, %d) = %d\n", i, j, i, j + 1, x); addEdge(getNodeID(i, j), getNodeID(i, j + 1), 1, -x); addEdge(getNodeID(i, j), getNodeID(i, j + 1), INT_MAX, 0); } } for (int j = 0; j &lt; q + 1; j++) { for (int i = 0; i &lt; p; i++) { int x; scanf("%d", &amp;x); //printf("(%d, %d) -&gt; (%d, %d) = %d\n", i, j, i + 1, j, x); addEdge(getNodeID(i, j), getNodeID(i + 1, j), 1, -x); addEdge(getNodeID(i, j), getNodeID(i + 1, j), INT_MAX, 0); } } for (int i = 0; i &lt; a; i++) { int k, x, y; scanf("%d %d %d", &amp;k, &amp;x, &amp;y); addEdge(s, getNodeID(x, y), k, 0); } for (int i = 0; i &lt; b; i++) { int k, x, y; scanf("%d %d %d", &amp;k, &amp;x, &amp;y); addEdge(getNodeID(x, y), t, k, 0); } int flow, cost; edmondskarp(s, t, (p + 1) * (q + 1) + 2, flow, cost); printf("%d\n", -cost); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>Edmonds-Karp</tag>
        <tag>费用流</tag>
        <tag>COGS</tag>
        <tag>图论</tag>
        <tag>网络流 24 题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「COGS 739」运输问题 - 费用流]]></title>
    <url>%2Fcogs-739%2F</url>
    <content type="text"><![CDATA[W 公司有 m 个仓库和 n 个零售商店。第 i 个仓库有 个货物，第 j 个商店需要 个货物，从第 i 个仓库运输到第 j 个零售商店的费用为 ，要将所有货物运到商店，最小费用是多少？ 链接 COGS 739 题解 裸费用流。 从源点向每个仓库连接一条边，容量为仓库的货物数量；从每个商店向汇点连一条边，容量为商店需要的货物数量；在每一对仓库和商店之间连接一条边，容量为无穷大，费用为运输费用。分别求出最大、最小费用最大流就是答案。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 100; const int MAXM = 100; struct Node; struct Edge; struct Node { Edge *firstEdge, *inEdge; int dist, flow; bool inQueue; } nodes[MAXM + MAXN + 2]; struct Edge { Node *from, *to; int capacity, flow, cost; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from-&gt;firstEdge) {} }; int n, m, a[MAXM], b[MAXN], cost[MAXM][MAXN]; struct EdmondsKarp { bool bellmanford(Node *s, Node *t, int n, int &amp;flow, int &amp;cost) { for (int i = 0; i &lt; n; i++) { nodes[i].flow = 0; nodes[i].inEdge = NULL; nodes[i].dist = INT_MAX; nodes[i].inQueue = false; } std::queue&lt;Node *&gt; q; q.push(s); s-&gt;dist = 0; s-&gt;flow = INT_MAX; while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;inQueue = false; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;dist &gt; v-&gt;dist + e-&gt;cost) { e-&gt;to-&gt;dist = v-&gt;dist + e-&gt;cost; e-&gt;to-&gt;inEdge = e; e-&gt;to-&gt;flow = std::min(v-&gt;flow, e-&gt;capacity - e-&gt;flow); if (!e-&gt;to-&gt;inQueue) { e-&gt;to-&gt;inQueue = true; q.push(e-&gt;to); } } } } if (t-&gt;dist == INT_MAX) return false; for (Edge *e = t-&gt;inEdge; e; e = e-&gt;from-&gt;inEdge) { e-&gt;flow += t-&gt;flow; e-&gt;reversedEdge-&gt;flow -= t-&gt;flow; } flow += t-&gt;flow; cost += t-&gt;dist * t-&gt;flow; return true; } void operator()(int s, int t, int n, int &amp;flow, int &amp;cost) { flow = cost = 0; while (bellmanford(&amp;nodes[s], &amp;nodes[t], n, flow, cost)); } } edmondskarp; inline void addEdge(int from, int to, int capacity, int cost) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity, cost); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0, -cost); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } inline int solve(int d) { for (int i = 0; i &lt; m + n + 2; i++) { Edge *next; for (Edge *&amp;e = nodes[i].firstEdge; e; next = e-&gt;next, delete e, e = next); } const int s = 0, t = m + n + 1; for (int i = 1; i &lt;= m; i++) addEdge(s, i, a[i - 1], 0); for (int j = 1; j &lt;= n; j++) addEdge(m + j, t, b[j - 1], 0); for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= n; j++) { addEdge(i, m + j, INT_MAX, cost[i - 1][j - 1] * d); } } int flow, cost; edmondskarp(s, t, m + n + 2, flow, cost); return cost * d; } int main() { freopen("tran.in", "r", stdin); freopen("tran.out", "w", stdout); scanf("%d %d", &amp;m, &amp;n); for (int i = 0; i &lt; m; i++) scanf("%d", &amp;a[i]); for (int j = 0; j &lt; n; j++) scanf("%d", &amp;b[j]); for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { scanf("%d", &amp;cost[i][j]); } } printf("%d\n", solve(1)); printf("%d\n", solve(-1)); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>Edmonds-Karp</tag>
        <tag>费用流</tag>
        <tag>COGS</tag>
        <tag>图论</tag>
        <tag>网络流 24 题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2008」最大数 - Splay]]></title>
    <url>%2Fjsoi2008-maxnumber%2F</url>
    <content type="text"><![CDATA[现在请求你维护一个数列，要求提供以下两种操作： 查询操作。 语法：Q L 功能：查询当前数列中末尾 L 个数中的最大的数，并输出这个数的值。 限制：L 不超过当前数列的长度。 插入操作。语法：A n 功能：将 n 加上 t，其中 t 是最近一次查询操作的答案（如果还未执行过查询操作，则 t = 0)，并将所得结果对一个固定的常数 D 取模，将所得答案插入到数列的末尾。 限制：n 是非负整数并且在长整范围内。 注意：初始时数列是空的，没有一个数。 链接 BZOJ 1012 题解 Splay 裸题不用说了吧 …… 话说开一棵大线段树也资磁吧？ 敲个 Splay 练练代码能力，结果折腾了俩小时，这段时间代码能力急剧下降啊！qwq 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXM = 200000; template &lt;typename T&gt; struct Splay { enum Relation { L = 0, R = 1 }; struct Node { Node *parent, *child[2], **root; int value, max; int size; bool bound; Node(Node *parent, const T &amp;value, Node **root, bool bound = false) : parent(parent), value(value), root(root), bound(bound), size(1) {} void maintain() { size = (child[L] ? child[L]-&gt;size : 0) + (child[R] ? child[R]-&gt;size : 0) + 1; max = value; if (child[L] &amp;&amp; !child[L]-&gt;bound) max = std::max(max, child[L]-&gt;max); if (child[R] &amp;&amp; !child[R]-&gt;bound) max = std::max(max, child[R]-&gt;max); } Relation relation() { return this == parent-&gt;child[L] ? L : R; } void rotate() { Relation r = relation(); Node *oldParent = parent; if (oldParent-&gt;parent) oldParent-&gt;parent-&gt;child[oldParent-&gt;relation()] = this; parent = oldParent-&gt;parent; oldParent-&gt;child[r] = child[r ^ 1]; if (child[r ^ 1]) child[r ^ 1]-&gt;parent = oldParent; child[r ^ 1] = oldParent; oldParent-&gt;parent = this; oldParent-&gt;maintain(), maintain(); if (!parent) *root = this; } void splay(Node *targetParent = NULL) { while (parent != targetParent) { if (parent-&gt;parent == targetParent) rotate(); else if (relation() == parent-&gt;relation()) parent-&gt;rotate(), rotate(); else rotate(), rotate(); } } int rank() { return child[L] ? child[L]-&gt;size : 0; } Node *pred() { splay(); Node *v = this-&gt;child[L]; while (v-&gt;child[R]) v = v-&gt;child[R]; return v; } Node *succ() { splay(); Node *v = this-&gt;child[R]; while (v-&gt;child[L]) v = v-&gt;child[L]; return v; } void print(int depth = 0) { if (child[L]) child[L]-&gt;print(depth + 1); for (int i = 0; i &lt; depth; i++) putchar(' '); //printf("%d\n", value); if (child[R]) child[R]-&gt;print(depth + 1); } } *root; Splay() { buildBound(L), buildBound(R); } void print() { root-&gt;print(); puts("---------------------------"); } void buildBound(Relation r) { Node **v = &amp;root, *parent = NULL; while (*v) { parent = *v; parent-&gt;size++; v = &amp;parent-&gt;child[r]; } *v = new Node(parent, r == L ? -1 : 1, &amp;root, true); } void append(const T &amp;value) { Node **v = &amp;root, *parent = NULL; while (*v) { parent = *v; parent-&gt;size++; if (parent-&gt;bound &amp;&amp; parent-&gt;value == 1) v = &amp;parent-&gt;child[L]; else v = &amp;parent-&gt;child[R]; } *v = new Node(parent, value, &amp;root); //print(); (*v)-&gt;splay(); } Node *select(int k) { k++; Node *v = root; while (k != v-&gt;rank() + 1) { //printf("select(k = %d) in [%d] - { size = %d, rank = %d }\n", k, v-&gt;value, v-&gt;size, v-&gt;rank()); if (k &lt; v-&gt;rank() + 1) v = v-&gt;child[L]; else k -= v-&gt;rank() + 1, v = v-&gt;child[R]; } return v; } Node *select(int l, int r) { Node *pred = select(l)-&gt;pred(); Node *succ = select(r)-&gt;succ(); pred-&gt;splay(); succ-&gt;splay(root); return succ-&gt;child[L]; } const T &amp;queryMax(int l, int r) { return select(l, r)-&gt;max; } int size() { return root-&gt;size - 2; } }; int m, p, lastAns; Splay&lt;int&gt; splay; inline char isVaild(char ch) { return ch == 'A' || ch == 'Q'; } int main() { scanf("%d %d", &amp;m, &amp;p); for (int i = 0; i &lt; m; i++) { char cmd; while (!isVaild(cmd = getchar())); //printf("cmd('%c')\n", cmd); if (cmd == 'A') { int n; scanf("%d", &amp;n); splay.append((n + lastAns) % p); } else { int l; scanf("%d", &amp;l); printf("%d\n", lastAns = splay.queryMax(splay.size() - l + 1, splay.size())); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>高级数据结构</tag>
        <tag>BZOJ</tag>
        <tag>Splay</tag>
        <tag>JSOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Edmonds-Karp 费用流学习笔记]]></title>
    <url>%2Fedmonds-karp-notes%2F</url>
    <content type="text"><![CDATA[有一类网络流问题，最大流并不唯一，而每一条边都有一个单位流量的费用，最优解的目标是保证流量最大的前提下使总费用最小。单纯的最大流可以使用 Edmonds-Karp 算法求解，但这个算法不够优，最常用的是 Dinic 算法。但 Edmonds-Karp 确是最小费用流问题最常用的算法。 定义 费用（）：单位流量流过一条边需要支付的费用，算法的目标是使总流量最大的前提下总费用最小。 其他的定义和 Dinic 中基本相同，但 Edmonds-Karp 中没有「层次」和「层次图」的概念。 Edmonds-Karp 的反向边的费用是原边的费用相反数。 算法 在残量网络中以「费用」为距离，沿着未满流边找出一条从源点到汇点的最短路，并进行增广。 增广时将总费用加上汇点的距离 增广流量。 无法找到增广路时算法结束，此时已找出网络的最小费用最大流。 找最短路时，一般使用 Bellman-Ford 算法，因为网络中一般都会存在负权边，而不可能有负环 —— 当有负环时，最小费用最大流不存在。 Edmonds-Karp 基于一个事实：如果当前费用是在当前流量下的最小费用，那么以最小费用增广之后的费用也为增广后的流量下的最小费用。不断增广找到的就是最小费用最大流。 代码实现 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 400; struct Node { struct Edge *firstEdge, *inEdge; int flow, dist; bool inQueue; } N[MAXN + 1]; struct Edge { Node *from, *to; int capacity, flow, cost; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from-&gt;firstEdge) {} }; inline void addEdge(int from, int to, int capacity, int cost) { N[from].firstEdge = new Edge(&amp;N[from], &amp;N[to], capacity, cost); N[to].firstEdge = new Edge(&amp;N[to], &amp;N[from], 0, -cost); N[from].firstEdge-&gt;reversedEdge = N[to].firstEdge; N[to].firstEdge-&gt;reversedEdge = N[from].firstEdge; } inline void edmondskarp(int s, int t, int n, int &amp;flow, int &amp;cost) { flow = cost = 0; while (1) { for (int i = 1; i &lt;= n; i++) { N[i].inEdge = NULL; N[i].flow = 0; N[i].dist = INT_MAX; N[i].inQueue = false; } std::queue&lt;Node *&gt; q; q.push(&amp;N[s]); N[s].flow = INT_MAX; N[s].dist = 0; while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;inQueue = false; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;dist &gt; v-&gt;dist + e-&gt;cost) { e-&gt;to-&gt;dist = v-&gt;dist + e-&gt;cost; e-&gt;to-&gt;inEdge = e; e-&gt;to-&gt;flow = std::min(v-&gt;flow, e-&gt;capacity - e-&gt;flow); if (!e-&gt;to-&gt;inQueue) { q.push(e-&gt;to); e-&gt;to-&gt;inQueue = true; } } } } if (N[t].dist == INT_MAX) break; for (Edge *e = N[t].inEdge; e; e = e-&gt;from-&gt;inEdge) { e-&gt;flow += N[t].flow; e-&gt;reversedEdge-&gt;flow -= N[t].flow; } flow += N[t].flow; cost += N[t].dist * N[t].flow; } } int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); while (m--) { int u, v, cap, cost; scanf("%d %d %d %d", &amp;u, &amp;v, &amp;cap, &amp;cost); addEdge(u, v, cap, cost); } int flow, cost; edmondskarp(1, n, n, flow, cost); printf("%d %d\n", flow, cost); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>Edmonds-Karp</tag>
        <tag>费用流</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2010」关押罪犯 - 二分图染色]]></title>
    <url>%2Fnoip2010-prison%2F</url>
    <content type="text"><![CDATA[S 城现有两座监狱，一共关押着 N 名罪犯，编号分别为 1 ~ N，我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。每年每一对有仇恨的罪犯会发生一次冲突。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力。那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小，求这个最小值是多少？ 链接 CodeVS 1069 Tyvj 1043 洛谷 1525 题解 因为要求最小值，所以考虑二分答案。当我们二分一个答案 x 后，只需要考虑怒气值大于 x 的成对罪犯了，这时候对整张图进行二分图染色，如果能被染色成为二分图，则这个答案合法。 二分图染色：把每个未标记的节点标记为任意一种颜色，对其进行一次 BFS，每一次扩展把未被染色的节点标记为与自身相反的颜色，如果发现扩展出去的节点的颜色与自身相同，则染色失败。 时间复杂度为 ，理论上来说可以过 100% 的数据，然而 Tyvj 的评测机太烂竟然 TLE 了一个点。 有神犇说可以用并查集，然而我太弱不会 …… qwq 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 20000; const int MAXM = 100000; enum Color { None = 0, Red = 2000, Blue = 5280 }; struct Node; struct Edge; struct Node { Edge *firstEdge; Color color; } nodes[MAXN]; struct Edge { Node *from, *to; int w; Edge *next; Edge(Node *from, Node *to, int w) : from(from), to(to), next(from-&gt;firstEdge), w(w) {} }; int n, m, max; inline void addEdge(int u, int v, int w) { nodes[u].firstEdge = new Edge(&amp;nodes[u], &amp;nodes[v], w); nodes[v].firstEdge = new Edge(&amp;nodes[v], &amp;nodes[u], w); } inline Color getReveseColor(Color c) { return c == Red ? Blue : Red; } inline bool bfs(Node *start, int limit) { return true; } inline bool check(int limit) { for (int i = 0; i &lt; n; i++) nodes[i].color = None; for (int i = 0; i &lt; n; i++) { if (nodes[i].color == None) { nodes[i].color = Red; std::queue&lt;Node *&gt; q; q.push(&amp;nodes[i]); while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;w &lt; limit) continue; if (e-&gt;to-&gt;color == None) { e-&gt;to-&gt;color = getReveseColor(v-&gt;color); q.push(e-&gt;to); } else if (e-&gt;to-&gt;color == v-&gt;color) return false; } } } } return true; } inline int solve() { int l = 1, r = max; while (l &lt; r) { int mid = (l &amp; r) + ((l ^ r) &gt;&gt; 1); //printf("[%d, %d] with `mid` = %d\n", l, r, mid); if (check(mid)) r = mid; else l = mid + 1; } return l - 1; } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) { int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w), u--, v--; addEdge(u, v, w); max = std::max(max, w); } printf("%d\n", solve()); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeVS</tag>
        <tag>图论</tag>
        <tag>二分图染色</tag>
        <tag>二分答案</tag>
        <tag>NOIP</tag>
        <tag>洛谷</tag>
        <tag>Vijos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「COGS 746」骑士共存 - 二分图最大独立集]]></title>
    <url>%2Fcogs-746%2F</url>
    <content type="text"><![CDATA[在一个 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。问最多可以在棋盘上放多少个其实。 链接 COGS 746 题解 在题图中可以发现，每个马可以攻击的格子都在与自身颜色不同的格子上，即整个棋盘可以建立为二分图，并使能互相攻击到的格子位于不同的两列。 根据定理，二分图最大独立集即为最小点覆盖集的补集，而最小点覆盖集可以用最小割模型来求解。 建立源点 S 和汇点 T，对于二分图中每个 X 点集中的点，从 S 向其连一条边，容量为点权；对于每个 Y 点集中的点，从该点向汇点连一条边，容量为点权；对于原图中的每条边，转化为从 X 点集的点连接到 Y 点集中的点的边，容量为无穷大。求出最小割，则该最小割为简单割，即任意一条割边不可能是中间那条无穷大的边，而这些割边恰好不重复的覆盖了整个二分图中的所有点，并且权值和最小。 ——摘自《「COGS 734」方格取数 - 二分图最大独立集》 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 200; const int MAXM = MAXN * MAXN; struct Point { int x, y; Point(int x, int y) : x(x), y(y) {} Point operator+(const Point &amp;pt) const { return Point(x + pt.x, y + pt.y); } }; const Point turns[8] = { Point(1, 2), Point(2, 1), Point(-1, -2), Point(-2, -1), Point(1, -2), Point(-2, 1), Point(-1, 2), Point(2, -1) }; struct Node; struct Edge; struct Node { Edge *firstEdge, *currentEdge; int level; } nodes[MAXN * MAXN + 2]; struct Edge { Node *from, *to; int capacity, flow; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from-&gt;firstEdge) {} }; int n, m; bool blocked[MAXN][MAXN]; struct Dinic { bool makeLevelGraph(Node *s, Node *t, int n) { for (int i = 0; i &lt; n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == 0) { e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; else q.push(e-&gt;to); } } } return false; } int findPath(Node *s, Node *t, int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;currentEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == s-&gt;level + 1) { int flow = findPath(e-&gt;to, t, std::min(limit, e-&gt;capacity - e-&gt;flow)); if (flow &gt; 0) { e-&gt;flow += flow; e-&gt;reversedEdge-&gt;flow -= flow; return flow; } } } return 0; } int operator()(int s, int t, int n) { int ans = 0; while (makeLevelGraph(&amp;nodes[s], &amp;nodes[t], n)) { int flow; while ((flow = findPath(&amp;nodes[s], &amp;nodes[t])) &gt; 0) ans += flow; } return ans; } } dinic; inline void addEdge(int from, int to, int capacity) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } inline int getNodeID(int x, int y) { return y * n + x + 1; } int main() { freopen("knight.in", "r", stdin); freopen("knight.out", "w", stdout); scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) { int x, y; scanf("%d %d", &amp;x, &amp;y), x--, y--; blocked[x][y] = true; } const int s = 0, t = n * n + 1; int sum = 0; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (blocked[i][j]) continue; sum++; int id = getNodeID(i, j); if ((i + j) % 2 == 0) { //printf("S =&gt; (%d, %d)\n", i + 1, j + 1); addEdge(s, id, 1); for (int k = 0; k &lt; 8; k++) { Point pt = Point(i, j) + turns[k]; if (pt.x &lt; 0 || pt.x &gt; n - 1 || pt.y &lt; 0 || pt.y &gt; n - 1 || blocked[pt.x][pt.y]) continue; //printf("(%d, %d) =&gt; (%d, %d)\n", i + 1, j + 1, pt.x + 1, pt.y + 1); addEdge(id, getNodeID(pt.x, pt.y), INT_MAX); } } else addEdge(id, t, 1);//, printf("(%d, %d) =&gt; T\n", i + 1, j + 1); } } int maxFlow = dinic(s, t, n * n + 2); printf("%d\n", sum - maxFlow); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>COGS</tag>
        <tag>图论</tag>
        <tag>网络流 24 题</tag>
        <tag>最大独立集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「COGS 738」数字梯形 - 费用流]]></title>
    <url>%2Fcogs-738%2F</url>
    <content type="text"><![CDATA[一个数字梯形，共有 n 行，第一行有 m 个数字，每一行都比上一行多一个数字。从第一行的每一个数字开始，每一次向左下方或左上方走，直到最后一行，有以下三种规则： 任意两条路径没有公共部分； 任意两条路径只能在点（数字）上有公共部分，不能在边（数字与数字之间）上有公共部分； 任意两条路径可以在点上或边上有公共部分。 求分别在这三种规则下的路径所经过数字总和的最大值。 链接 COGS 738 题解 因为是从第一行走到最后一行，对于路径有限制，并且最大化总和，所以考虑费用流建模。 将每个数字拆成两个点，中间一条边容量为 1，费用为该数字的相反数；从源点到第一行每个数字的入点连一条边，容量为 1，费用为 0；从最后一行每个数字的出点向汇点连一条边，容量为 1，费用为 1；对于除最后一行外的每个数字，从其出点向其下方两个数字的入点分别连一条边，容量为 1，费用为 0。求出网络的最小费用最大流，则结果费用的相反数即为第一问答案。 有了第一问的基础，后面两问就比较容易了，第二问因为可以在数字上重复，就把每个数字的入点和出点之间的边容量改为正无穷，把指向汇点的边容量也改为正无穷；第三问因为可以在边上重复，就在第二问的基础上把每个数字的出点向下方连接的两条边容量改为正无穷。 一定要注意，计算网络流节点编号要用梯形面积公式，设源点 s 的编号为 0，则对数字进行拆点后所得的点数量为 ，即汇点的编号为 。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;cassert&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXM = 20; const int MAXN = 20; const int L = 0, R = 1, IN = 0, OUT = 1; struct Point { int x, y; Point() {} Point(int x, int y) : x(x), y(y) {} }; struct Node; struct Edge; struct Node { Edge *firstEdge, *inEdge; int flow, dist; bool inQueue; } nodes[((MAXM + (MAXM + MAXN - 1)) * MAXN / 2) * 2 + 2]; struct Edge { Node *from, *to; int capacity, flow, cost; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from-&gt;firstEdge) {} }; int n, m, a[MAXN][MAXM + MAXN - 1], s, t; int mapNode[MAXN][MAXM + MAXN - 1][2], mapEdge[MAXN][MAXM + MAXN - 1][2]; struct EdmondsKarp { bool bellmanford(Node *s, Node *t, int n, int &amp;flow, int &amp;cost) { for (int i = 0; i &lt; n; i++) { nodes[i].dist = INT_MAX; nodes[i].inEdge = NULL; nodes[i].flow = 0; nodes[i].inQueue = false; } s-&gt;flow = INT_MAX; s-&gt;dist = 0; std::queue&lt;Node *&gt; q; q.push(s); while (!q.empty()) { Node *v = q.front(); q.pop(); v-&gt;inQueue = false; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;dist &gt; v-&gt;dist + e-&gt;cost) { e-&gt;to-&gt;dist = v-&gt;dist + e-&gt;cost; //printf("dist((%d, %d), (%d, %d)) = %d\n", e-&gt;to-&gt;pt1.x, e-&gt;to-&gt;pt1.y, e-&gt;to-&gt;pt2.x, e-&gt;to-&gt;pt2.y, e-&gt;to-&gt;dist); e-&gt;to-&gt;inEdge = e; e-&gt;to-&gt;flow = std::min(v-&gt;flow, e-&gt;capacity - e-&gt;flow); if (!e-&gt;to-&gt;inQueue) { q.push(e-&gt;to); e-&gt;to-&gt;inQueue = true; } } } } if (t-&gt;dist == INT_MAX) return false; for (Node *v = t; v != s; v = v-&gt;inEdge-&gt;from) { v-&gt;inEdge-&gt;flow += t-&gt;flow; v-&gt;inEdge-&gt;reversedEdge-&gt;flow -= t-&gt;flow; } cost += t-&gt;dist * t-&gt;flow; flow += t-&gt;flow; //printf("flow += %d\n", t-&gt;flow); return true; } void operator()(int s, int t, int n, int &amp;flow, int &amp;cost) { flow = cost = 0; while (bellmanford(&amp;nodes[s], &amp;nodes[t], n, flow, cost)); } } edmondskarp; inline void addEdge(int from, int to, int capacity, int cost) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity, cost); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0, -cost); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } inline void releaseMemory() { for (int i = 0; i &lt; ((m + (m + n - 1)) * n / 2) * 2 + 2; i++) { Edge *next; for (Edge *e = nodes[i].firstEdge; e; next = e-&gt;next, delete e, e = next); nodes[i].firstEdge = NULL; } } inline void buildNetwork(int limitPerNode, int limitPerEdge) { releaseMemory(); for (int i = 0; i &lt; m; i++) addEdge(s, mapNode[0][i][IN], 1, 0); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m + i; j++) { //printf("i(%d) -&gt; %d, j(%d) -&gt; %d\n", i + 1, n, j + 1, m + i); int (&amp;v)[2] = mapNode[i][j]; int (&amp;e)[2] = mapEdge[i][j]; //printf("a[i][j] = %d\n", a[i][j]); addEdge(v[IN], v[OUT], limitPerNode, -a[i][j]); if (i == n - 1) { //printf("OUT(%d, %d) = %d to t\n", i + 1, j + 1, a[i][j]); addEdge(v[OUT], t, limitPerNode, 0); } else { //printf("OUT(%d, %d) = %d to IN(%d, %d) = %d\n", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1, a[i + 1][j]); addEdge(v[OUT], e[L], limitPerEdge, 0); //printf("OUT(%d, %d) = %d to IN(%d, %d) = %d\n", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1 + 1, a[i + 1][j + 1]); addEdge(v[OUT], e[R], limitPerEdge, 0); } } } } inline int solve() { int flow, cost; edmondskarp(s, t, ((m + (m + n - 1)) * n / 2) * 2 + 2, flow, cost); return -cost; } inline int task1() { buildNetwork(1, 1); return solve(); } inline int task2() { buildNetwork(INT_MAX, 1); return solve(); } inline int task3() { buildNetwork(INT_MAX, INT_MAX); return solve(); } int main() { freopen("digit.in", "r", stdin); freopen("digit.out", "w", stdout); scanf("%d %d", &amp;m, &amp;n); s = 0, t = ((m + (m + n - 1)) * n / 2) * 2 + 1; //printf("t = %d\n", t); int k = 1; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m + i; j++) { scanf("%d", &amp;a[i][j]); mapNode[i][j][IN] = k++; mapNode[i][j][OUT] = k++; assert(k - 1 &lt; ((m + (m + n - 1)) * n / 2) * 2 + 1); } } for (int i = 0; i &lt; n - 1; i++) { for (int j = 0; j &lt; m + i; j++) { mapEdge[i][j][L] = mapNode[i + 1][j][IN]; mapEdge[i][j][R] = mapNode[i + 1][j + 1][IN]; } } printf("%d\n", task1()); printf("%d\n", task2()); printf("%d\n", task3()); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>Edmonds-Karp</tag>
        <tag>费用流</tag>
        <tag>COGS</tag>
        <tag>图论</tag>
        <tag>网络流 24 题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「COGS 734」方格取数 - 二分图最大独立集]]></title>
    <url>%2Fcogs-734%2F</url>
    <content type="text"><![CDATA[在一个有 个方格的棋盘中，每个方格中有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大。 链接 COGS 734 题解 任意两个数所在的方格没有公共边，考虑把所有的格子建成图，不能同时选择的点之间两两连边，求出一个点权和最大的子图（最大独立集），其和即为答案。 进一步分析，发现这个图是一个二分图 —— 因为每个点只会和棋盘中与其相邻的点连边。 根据定理，二分图最大独立集即为最小点覆盖集的补集，而最小点覆盖集可以用最小割模型来求解。 建立源点 S 和汇点 T，对于二分图中每个 X 点集中的点，从 S 向其连一条边，容量为点权；对于每个 Y 点集中的点，从该点向汇点连一条边，容量为点权；对于原图中的每条边，转化为从 X 点集的点连接到 Y 点集中的点的边，容量为无穷大。求出最小割，则该最小割为简单割，即任意一条割边不可能是中间那条无穷大的边，而这些割边恰好不重复的覆盖了整个二分图中的所有点，并且权值和最小。 建立二分图模型的时候注意细节。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 30; const int MAXM = 30; struct Node; struct Edge; struct Node { Edge *firstEdge; int level; } nodes[MAXN * MAXM + 2]; struct Edge { Node *from, *to; int capacity, flow; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity) : from(from), to(to), next(from-&gt;firstEdge), capacity(capacity), flow(0) {} }; int n, m; struct Dinic { bool makeLevelGraph(Node *s, Node *t, int n) { for (int i = 0; i &lt; n; i++) nodes[i].level = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == 0) { e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; else q.push(e-&gt;to); } } } return false; } int findPath(Node *s, Node *t, int limit = INT_MAX) { if (s == t) return limit; for (Edge *e = s-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == s-&gt;level + 1) { int flow = findPath(e-&gt;to, t, std::min(limit, e-&gt;capacity - e-&gt;flow)); if (flow &gt; 0) { e-&gt;flow += flow; e-&gt;reversedEdge-&gt;flow -= flow; return flow; } } } return 0; } int operator()(int s, int t, int n) { int ans = 0; while (makeLevelGraph(&amp;nodes[s], &amp;nodes[t], n)) { int flow; while ((flow = findPath(&amp;nodes[s], &amp;nodes[t])) &gt; 0) ans += flow; } return ans; } } dinic; inline void addEdge(int from, int to, int capacity) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } inline int getNodeID(int x, int y) { return x * n + y + 1; } int main() { freopen("grid.in", "r", stdin); freopen("grid.out", "w", stdout); scanf("%d %d", &amp;m, &amp;n); const int s = 0, t = n * m + 1; int sum = 0; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { int num; scanf("%d", &amp;num); sum += num; int id = getNodeID(i, j); bool flag = (i + j) % 2 == 0; if (flag) addEdge(s, id, num); else addEdge(id, t, num); if (flag) { if (i &gt; 0) addEdge(id, getNodeID(i - 1, j), INT_MAX); if (i &lt; m - 1) addEdge(id, getNodeID(i + 1, j), INT_MAX); if (j &gt; 0) addEdge(id, getNodeID(i, j - 1), INT_MAX); if (j &lt; n - 1) addEdge(id, getNodeID(i, j + 1), INT_MAX); } } } int maxFlow = dinic(s, t, n * m + 2); printf("%d\n", sum - maxFlow); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>COGS</tag>
        <tag>图论</tag>
        <tag>网络流 24 题</tag>
        <tag>最大独立集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「COGS 439」软件补丁 - 记忆化搜索 + 位运算]]></title>
    <url>%2Fcogs-439%2F</url>
    <content type="text"><![CDATA[现在有一个软件，共有 n 个 BUG，开发人员开发了 m 个补丁，每个补丁有一个应用条件，要求某些 BUG 比如存在，某些 BUG 可以不存在，某些 BUG 存在或不存在都可以；每个补丁有一个影响，会使某些 BUG 消失，会使某些 BUG 产生；每个 BUG 有一个应用时间。问修复所有 BUG 需要的最短时间为多少。 链接 COGS 439 题解 记录状态：用一个 unsigned int 类型的数记录状态，从右边数第 i 个二进制位表示第 i 个 BUG 是否存在。用 std::tr1::unordered_map（哈希表）存储状态到所有时间的映射，即 map[status] 表示从初始状态到状态 status 所用的最短时间。 状态转移：每个补丁存储两个值 effectAddition、effectSubtract，前者表示应用该补丁后新增加的 BUG，后者表示减少的 BUG，则状态转移为： newStatus = ~(~(status | effectAddition) | effectSubtract) 一个难点在于怎样判断补丁的应用条件，「某些 BUG 存在或不存在都可以」是难以用位运算来体现的（或者说我不会），所以我们可以把这种情况转化为「某些 BUG 必须存在」，然后在判断条件时先将当前状态加上那些「可有可无」的 BUG，然后继续判断。 ((status | conditionAny) &amp; conditionTrue) == (conditionTrue | conditionAny) &amp;&amp; (~status &amp; conditionFalse) == conditionFalse 话说其实这道题暴力表示状态，一位一位地判断、转移也可以过的，而且照样是 COGS 上提交记录第一 …… 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;tr1/unordered_map&gt; #include &lt;queue&gt; const int MAXN = 20; const int MAXM = 100; struct Patch { unsigned int conditionTrue, conditionFalse, conditionAny; unsigned int effectAddition, effectSubtract; int time; } patches[MAXM]; int n, m; std::tr1::unordered_map&lt;unsigned int, int&gt; map; inline void setBit(unsigned int &amp;status, int i, bool flag) { if (flag) status |= (1 &lt;&lt; i); else status &amp;= ~(1 &lt;&lt; i); } inline bool getBit(unsigned int &amp;status, int i) { return ((status &gt;&gt; i) &amp; 1) == 1; } inline void printStatus(unsigned int status, bool newLine = true) { for (int i = 0; i &lt; n; i++) { if (getBit(status, i) == true) putchar('1'); else putchar('0'); } if (newLine) putchar('\n'); } inline void bfs(unsigned int start) { std::queue&lt;unsigned int&gt; q; q.push(start); map[start] = 0; while (!q.empty()) { unsigned int status = q.front(); //printStatus(status); q.pop(); for (Patch *p = patches; p != patches + m; p++) { if (!( ((status | p-&gt;conditionAny) &amp; p-&gt;conditionTrue) == (p-&gt;conditionTrue | p-&gt;conditionAny) &amp;&amp; (~status &amp; p-&gt;conditionFalse) == p-&gt;conditionFalse )) continue; unsigned int newStatus = ~(~(status | p-&gt;effectAddition) | p-&gt;effectSubtract); int step = map[status]; if (map.count(newStatus) != 0 &amp;&amp; map[newStatus] &lt;= step + p-&gt;time) continue; //printf("from `"), printStatus(status, false), printf("` useing `%d(%s, %s)` to `", (int)(p - patches + 1), p-&gt;condition, p-&gt;effect), printStatus(newStatus, false), printf("`\n"); map[newStatus] = step + p-&gt;time; q.push(newStatus); } } } int main() { freopen("bugs.in", "r", stdin); freopen("bugs.out", "w", stdout); scanf("%d %d", &amp;n, &amp;m); for (Patch *p = patches; p != patches + m; p++) { char condition[MAXN + 1], effect[MAXN + 1]; scanf("%d %s %s", &amp;p-&gt;time, condition, effect); for (int i = 0; i &lt; n; i++) { if (condition[i] == '0') setBit(p-&gt;conditionAny, i, true), setBit(p-&gt;conditionTrue, i, true); else if (condition[i] == '+') setBit(p-&gt;conditionTrue, i, true); else if (condition[i] == '-') setBit(p-&gt;conditionFalse, i, true); if (effect[i] == '+') setBit(p-&gt;effectAddition, i, true); else if (effect[i] == '-') setBit(p-&gt;effectSubtract, i, true); } } unsigned int status = 0; for (int i = 0; i &lt; n; i++) setBit(status, i, true); bfs(status); if (map.count(0) == 0) puts("-1"); else printf("%d\n", map[0]); fclose(stdin); fclose(stdout); return 0; } 吐槽 又是一道不是网络流但被放进「网络流 24 题」里的~水~题。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>COGS</tag>
        <tag>网络流 24 题</tag>
        <tag>map</tag>
        <tag>位运算</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「COGS 727」太空飞行计划 - 最大权闭合图]]></title>
    <url>%2Fcogs-727%2F</url>
    <content type="text"><![CDATA[W 教授正在为国家航天中心计划一系列的太空飞行。可供选择的实验集合为 ，这些实验需要使用的全部仪器的集合为 。实验 需要用到的仪器是 。仪器 的费用为 。实验 的赞助商为该实验结果支付 。设计方案使收益最大。 链接 COGS 727 题解 首先，这个问题抽象出来是一个『最大权闭合图』问题 —— 把每个实验作为点，权值为获利；把每个仪器作为点，权值为费用的相反数，求出一个点权和最大的子图，使这个子图中的每个点的所有出边指向的点都在这个子图中。特殊的，这个子图可以为空。 根据胡伯涛的论文，最大权闭合图可以用最小割模型来求解：添加源点和汇点，对于原图中的每个正权点，连接一条从源点流向该点的边，容量为权值；对于原图中的每个负权点，连接一条从该点流向汇点的边，容量为权值的绝对值；对于原图中的每一条有向边，对应在网络中连接一条容量为正无穷的边。求出该网络的最小割，割边中所有边一定是从源点连接到一个正权点或从一个负权点连到汇点，这些与割边相连的正权点是不选择的点，与割边相连的负权点是选择的负权点。 重点来说下怎么求最小割，用 Dinic 求出最大流之后，在包含反向边的残量网络中沿着不满流的边进行 BFS，将遍历到的点做上标记。BFS 结束后，所有有标记的点组成 S 集合，无标记的点组成 T 集合。枚举每条边，所有跨越了 S 和 T 集合的边组成了最小割。 得到不选择的正权点之后，用 std::set_difference 求出与所有正权点的差集就是选择的正权点。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;sstream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;list&gt; #include &lt;utility&gt; #include &lt;vector&gt; #include &lt;set&gt; #include &lt;iterator&gt; const int MAXN = 100; const int MAXM = 100; struct Node; struct Edge; struct Node { Edge *firstEdge; int level, id; bool flag; } nodes[MAXM + MAXN + 2]; struct Edge { Node *from, *to; int capacity, flow; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity) : from(from), to(to), next(from-&gt;firstEdge), capacity(capacity), flow(0) {} }; int n, m; std::list&lt;std::pair&lt;Node *, Node *&gt; &gt; edgeList; struct Dinic { bool makeLevelGraph(Node *s, Node *t, int n) { for (int i = 0; i &lt; n; i++) nodes[i].level = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == 0) { e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; else q.push(e-&gt;to); } } } return false; } int findPath(Node *s, Node *t, int limit) { if (s == t) return limit; for (Edge *e = s-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == s-&gt;level + 1) { int flow = findPath(e-&gt;to, t, std::min(limit, e-&gt;capacity - e-&gt;flow)); if (flow &gt; 0) { e-&gt;flow += flow; e-&gt;reversedEdge-&gt;flow -= flow; return flow; } } } return 0; } int operator()(int s, int t, int n) { int ans = 0; while (makeLevelGraph(&amp;nodes[s], &amp;nodes[t], n)) { int flow; while ((flow = findPath(&amp;nodes[s], &amp;nodes[t], INT_MAX)) &gt; 0) ans += flow; } return ans; } } dinic; inline void addEdge(int from, int to, int capacity) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; edgeList.push_back(std::make_pair(&amp;nodes[from], &amp;nodes[to])); } inline void minCut(int s) { std::queue&lt;Node *&gt; q;; q.push(&amp;nodes[s]); nodes[s].flag = true; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; !e-&gt;to-&gt;flag) { e-&gt;to-&gt;flag = true; q.push(e-&gt;to); } } } std::list&lt;std::pair&lt;Node *, Node *&gt; &gt;::iterator p = edgeList.begin(); while (p != edgeList.end()) { if (p-&gt;first-&gt;flag &amp;&amp; !p-&gt;second-&gt;flag) p++; else p = edgeList.erase(p); } } int main() { freopen("shuttle.in", "r", stdin); freopen("shuttle.out", "w", stdout); scanf("%d %d\n", &amp;m, &amp;n); for (int i = 0; i &lt; n + m + 1; i++) nodes[i].id = i; const int s = 0, t = n + m + 1; int sum = 0; for (int i = 1; i &lt;= m; i++) { std::string str; std::getline(std::cin, str); std::stringstream ss; ss &lt;&lt; str; int x; ss &gt;&gt; x; sum += x; addEdge(s, n + i, x); while (!ss.eof()) { ss &gt;&gt; x; addEdge(n + i, x, INT_MAX); } } for (int i = 1; i &lt;= n; i++) { int x; scanf("%d", &amp;x); addEdge(i, t, x); } int maxFlow = dinic(s, t, n + m + 2); minCut(s); std::vector&lt;int&gt; v; std::set&lt;int&gt; set, setAll; for (std::list&lt;std::pair&lt;Node *, Node *&gt; &gt;::const_iterator p = edgeList.begin(); p != edgeList.end(); p++) { if (p-&gt;first-&gt;id == s) set.insert(p-&gt;second-&gt;id - n); else v.push_back(p-&gt;first-&gt;id); } for (int i = 1; i &lt;= m; i++) setAll.insert(i); std::set&lt;int&gt; setDifference; std::set_difference(setAll.begin(), setAll.end(), set.begin(), set.end(), std::inserter(setDifference, setDifference.begin())); std::copy(setDifference.begin(), setDifference.end(), std::ostream_iterator&lt;int&gt;(std::cout, " ")); std::cout &lt;&lt; std::endl; std::sort(v.begin(), v.end()); std::copy(v.begin(), v.end(), std::ostream_iterator&lt;int&gt;(std::cout, " ")); std::cout &lt;&lt; std::endl; printf("%d\n", sum - maxFlow); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>最大权闭合图</tag>
        <tag>网络流</tag>
        <tag>COGS</tag>
        <tag>图论</tag>
        <tag>网络流 24 题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「COGS 731」最长递增子序列 - 线性 DP + 网络流]]></title>
    <url>%2Fcogs-731%2F</url>
    <content type="text"><![CDATA[给定正整数序列 X1 ~ Xn。 计算其最长递增子序列的长度 s。 计算从给定的序列中最多可取出多少个长度为 s 的递增子序列。 如果允许在取出的序列中多次使用 X1 和 Xn，则从给定序列中最多可取出多少个长度为 s 的递增子序列。 链接 COGS 731 题解 首先，重要的事情说三遍：非严格递增！非严格递增！非严格递增！ 设以 结尾的最长递增子序列长度为 ，用动态规划求出每个 ，最大的一个就是第一问答案，设它为 。 第二问采用网络流建模： 对于每个满足 的点，从该点向汇点连一条边，容量为 1； 对于每个满足 的点，从源点向该点连一条边，容量为 1； 对于第一问中每一次所有的有效状态转移（即满足 且的点对 i、j）从 j 向 i 连一条边，容量为 1。 求出最大流即为答案。 但是这样做有个问题，某一个点可能被使用所次，不符合题目要求。解决方法是把每一个点 i 拆成两个点 i 和 i'，所有进入该点的边连接 i，所有出该点边从 i' 连出，并从 i 到 i' 连接一条容量为 1 的边，保证了流过每个点的流量最多为 1。 第三问只需要在第二问的基础上做出一些修改，把所有与 1、n 两个点相关的边容量改为无穷大，就可以使这两个数“可多次使用”。 注意特判，如果输入进来的是一个严格递降序列，答案就是 1、N、N。从这里我们可以看出细节的重要性以及出题人的恶意。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;vector&gt; const int MAXN = 500; struct Node; struct Edge; struct Node { Edge *firstEdge; int level, id; } nodes[MAXN * 2 + 2]; struct Edge { Node *from, *to; int capacity, flow; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from-&gt;firstEdge) {} }; int n, a[MAXN], f[MAXN], k; struct Dinic { bool makeLevelGraph(Node *s, Node *t, int n) { for (int i = 0; i &lt; n; i++) nodes[i].level = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == 0) { e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; else q.push(e-&gt;to); } } } return false; } int findPath(Node *s, Node *t, int limit) { if (s == t) return limit; for (Edge *e = s-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == s-&gt;level + 1) { int flow = findPath(e-&gt;to, t, std::min(e-&gt;capacity - e-&gt;flow, limit)); if (flow &gt; 0) { e-&gt;flow += flow; e-&gt;reversedEdge-&gt;flow -= flow; return flow; } } } return 0; } int operator()(int s, int t, int n) { int ans = 0; while (makeLevelGraph(&amp;nodes[s], &amp;nodes[t], n)) { int flow; while ((flow = findPath(&amp;nodes[s], &amp;nodes[t], INT_MAX)) &gt; 0) ans += flow; } return ans; } } dinic; inline void addEdge(int from, int to, int capacity) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } inline int dp() { int ans = 0; for (int i = 0; i &lt; n; i++) { int last = 0; for (int j = 0; j &lt; i; j++) { if (a[j] &lt;= a[i] &amp;&amp; f[j] &gt; last) last = f[j]; } f[i] = last + 1; ans = std::max(ans, f[i]); } return ans; } inline int solve2() { memset(nodes, 0, sizeof(Node) * (n * 2 + 2)); const int s = 0, t = n * 2 + 1; for (int i = 1; i &lt;= n; i++) { addEdge(i, i + n, 1); if (f[i - 1] == 1) addEdge(s, i, 1); else if (f[i - 1] == k) addEdge(i + n, t, 1); for (int j = 1; j &lt; i; j++) { if (f[j - 1] == f[i - 1] - 1) addEdge(j + n, i, 1); } } return dinic(s, t, n * 2 + 2); } inline int solve3() { memset(nodes, 0, sizeof(Node) * (n * 2 + 2)); const int s = 0, t = n * 2 + 1; for (int i = 1; i &lt;= n; i++) { int capacity = 1; if (i == 1 || i == n) capacity = INT_MAX; addEdge(i, i + n, capacity) ; if (f[i - 1] == 1) addEdge(s, i, capacity); else if (f[i - 1] == k) addEdge(i + n, t, capacity); for (int j = 1; j &lt; i; j++) { if (f[j - 1] == f[i - 1] - 1 &amp;&amp; a[j - 1] &lt;= a[i - 1]) addEdge(j + n, i, 1); } } return dinic(s, t, n * 2 + 2); } int main() { freopen("alis.in", "r", stdin); freopen("alis.out", "w", stdout); scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) { scanf("%d", &amp;a[i]); } k = dp(); printf("%d\n", k); if (k == 1) printf("%d\n%d\n", n, n); else { printf("%d\n", solve2()); printf("%d\n", solve3()); } fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>COGS</tag>
        <tag>图论</tag>
        <tag>网络流 24 题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「COGS 729」圆桌聚餐 - 网络流]]></title>
    <url>%2Fcogs-729%2F</url>
    <content type="text"><![CDATA[假设有来自 m 个不同单位的代表参加一次国际会议。每个单位的代表数分别为 ri。会议餐厅共有 n 张餐桌，每张餐桌可容纳 ci 个代表就餐。 为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。试设计一个算法，给出满足要求的代表就餐方案。 链接 COGS 729 题解 问题的关键就是： 每个单位最多有一个人做到一张单独的餐桌上！ 进行网络流建模，建立源点 S，由 S 向每个代表单位的点连一条边，容量为单位人数；建立汇点 T，由每个代表餐桌的点向 T 连一条边，容量为餐桌容纳人数；分别从每个单位向所有餐桌连一条边，容量为 1。 然后求出最大流，如果最大流小于所有单位人数总和，那么问题无解，否则有解，即所有由单位指向餐桌的边构成了一组解。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;vector&gt; const int MAXN = 270; const int MAXM = 150; struct Node; struct Edge; struct Node { Edge *firstEdge; int level, id; } nodes[MAXN + MAXM + 2]; struct Edge { Node *from, *to; int capacity, flow; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from-&gt;firstEdge) {} }; int m, n; struct Dinic { bool makeLevelGraph(Node *s, Node *t, int n) { for (int i = 0; i &lt; n; i++) nodes[i].level = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == 0) { e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; else q.push(e-&gt;to); } } } return false; } int findPath(Node *s, Node *t, int limit) { if (s == t) return limit; for (Edge *e = s-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == s-&gt;level + 1) { int flow = findPath(e-&gt;to, t, std::min(e-&gt;capacity - e-&gt;flow, limit)); if (flow &gt; 0) { e-&gt;flow += flow; e-&gt;reversedEdge-&gt;flow -= flow; return flow; } } } return 0; } int operator()(int s, int t, int n) { int ans = 0; while (makeLevelGraph(&amp;nodes[s], &amp;nodes[t], n)) { int flow; while ((flow = findPath(&amp;nodes[s], &amp;nodes[t], INT_MAX)) &gt; 0) ans += flow; } return ans; } } dinic; inline void addEdge(int from, int to, int capacity) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } int main() { freopen("roundtable.in", "r", stdin); freopen("roundtable.out", "w", stdout); scanf("%d %d", &amp;m, &amp;n); for (int i = 0; i &lt; m + n + 2; i++) nodes[i].id = i; const int s = 0, t = m + n + 1; int sum = 0; for (int i = 1; i &lt;= m; i++) { int x; scanf("%d", &amp;x); sum += x; addEdge(s, i, x); for (int j = m + 1; j &lt;= m + n; j++) addEdge(i, j, 1); } for (int i = m + 1; i &lt;= m + n; i++) { int x; scanf("%d", &amp;x); addEdge(i, t, x); } int maxFlow = dinic(s, t, m + n + 2); if (maxFlow == sum) { puts("1"); for (int i = 1; i &lt;= m; i++) { std::vector&lt;int&gt; v; for (Edge *e = nodes[i].firstEdge; e; e = e-&gt;next) { if (e-&gt;to-&gt;id &gt; m &amp;&amp; e-&gt;to-&gt;id &lt;= m + n &amp;&amp; e-&gt;flow == e-&gt;capacity) { v.push_back(e-&gt;to-&gt;id - m); } } std::sort(v.begin(), v.end()); for (std::vector&lt;int&gt;::const_iterator p = v.begin(); p != v.end(); p++) { printf("%d ", *p); } putchar('\n'); } } else puts("0"); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>COGS</tag>
        <tag>图论</tag>
        <tag>网络流 24 题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「COGS 396」魔术球问题 - 贪心]]></title>
    <url>%2Fcogs-396%2F</url>
    <content type="text"><![CDATA[假设有 n 根柱子，现要按下述规则在这n根柱子中依次放入编号为 1，2，3，4 ...... 的球。 每次只能在某根柱子的最上面放球； 在同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。 试设计一个算法，计算出在 n 根柱子上最多能放多少个球。 链接 COGS 396 题解 放球的两个条件很显然，在上面放再多的球是不影响下面的。并且，某个球放在哪一根柱子上，只会影响其之上的球的编号，而不会影响全局的球总数。 所以可以使用贪心解决：策略是，先从一个柱子开始，每次枚举所有柱子，只要某个柱子能放就放上去，然后继续放下一个；直到所有的柱子不能放当前的球，则添加一个柱子；最后不能在添加时，就是最优解。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;vector&gt; const int MAXN = 60; int n; std::vector&lt;int&gt; v[MAXN]; inline bool isSquareNumber(int x) { int root = floor(sqrt(x)); return root * root == x; } int main() { freopen("balla.in", "r", stdin); freopen("balla.out", "w", stdout); scanf("%d", &amp;n); int x = 1; for (int k = 1; k &lt;= n; k++) { while (20000528) { bool flag = false; for (int i = 0; i &lt; k; i++) { if (v[i].empty() || isSquareNumber(v[i].back() + x)) { v[i].push_back(x++); flag = true; break; } } if (!flag) break; } } printf("%d\n", x - 1); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>COGS</tag>
        <tag>网络流 24 题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「COGS 728」最小路径覆盖问题 - 二分图匹配]]></title>
    <url>%2Fcogs-728%2F</url>
    <content type="text"><![CDATA[给定有向图 。设 P 是 G 的一个简单路（顶点不相交）的集合。如果 V 中每个顶点恰好在 P 的一条路上，则称 P 是 G 的一个路径覆盖。P 中路径可以从 V 的任何一个顶点开始，长度也是任意的，特别地，可以为 0。G 的最小路径覆盖是 G 的所含路径条数最少的路径覆盖。 设计一个有效算法求一个有向无环图 G 的最小路径覆盖。 链接 COGS 728 题解 用最少的路径覆盖所有的点。先从最简单的图开始，如果图中没有边，那么每个点都是一条独立的路径；如果添加一条边进去，那么需要的路径数量就减小 1；如果再添加一条边进去，并且这条边与上一条边有相同起点或终点的话，那么这条边对答案是没有贡献的，如果这条边与上一条边首尾相接或者不相交的话，那么需要的路径数量减小 1。 综上所述，问题转化为，从一个有向无环图中选出尽量多的边，使任意两条边没有相同起点或终点。 进一步将问题转化为二分图匹配，将每个点拆成左右两个，对于原图中任意一条有向边 (u, v)，在新图中将左边的 u 和右边的 v 连接，然后求出最大匹配，用总点数减去最大匹配就是答案。 输出方案嘛，只要枚举起点然后沿着匹配边向下搜就好咯 …… 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 150; struct Node; struct Edge; struct Node { Edge *firstEdge; int id, level; bool visited; } nodes[MAXN * 2 + 2]; struct Edge { Node *from, *to; int capacity, flow; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from-&gt;firstEdge) {} }; int n, m; inline void addEdge(int from, int to, int capacity) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } struct Dinic { bool makeLevelGraph(Node *s, Node *t, int n) { for (int i = 0; i &lt; n; i++) nodes[i].level = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == 0) { e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; else q.push(e-&gt;to); } } } return false; } int findPath(Node *s, Node *t, int limit = INT_MAX) { if (s == t) return limit; for (Edge *e = s-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;to-&gt;level == s-&gt;level + 1 &amp;&amp; e-&gt;capacity &gt; e-&gt;flow) { int flow = findPath(e-&gt;to, t, std::min(limit, e-&gt;capacity - e-&gt;flow)); if (flow &gt; 0) { e-&gt;flow += flow; e-&gt;reversedEdge-&gt;flow -= flow; return flow; } } } return 0; } int operator()(int s, int t, int n) { int ans = 0; while (makeLevelGraph(&amp;nodes[s], &amp;nodes[t], n)) { int flow; while ((flow = findPath(&amp;nodes[s], &amp;nodes[t])) &gt; 0) ans += flow; } return ans; } } dinic; inline void printPath(Node *v) { printf("%d ", v-&gt;id); v-&gt;visited = true; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow == e-&gt;capacity &amp;&amp; e-&gt;to-&gt;id != 0 &amp;&amp; !nodes[e-&gt;to-&gt;id].visited) { printPath(&amp;nodes[e-&gt;to-&gt;id]); break; } } } int main() { freopen("path3.in", "r", stdin); freopen("path3.out", "w", stdout); scanf("%d %d", &amp;n, &amp;m); const int s = 0, t = n * 2 + 1; for (int i = 1; i &lt;= n; i++) addEdge(s, i, 1), addEdge(i + n, t, 1), nodes[i].id = nodes[i + n].id = i; for (int i = 0; i &lt; m; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v); addEdge(u, v + n, 1); } int maxMatch = dinic(s, t, n * 2 + 2); for (int i = 1; i &lt;= n; i++) { if (!nodes[i].visited) { printPath(&amp;nodes[i]); putchar('\n'); } } printf("%d\n", n - maxMatch); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>COGS</tag>
        <tag>图论</tag>
        <tag>二分图匹配</tag>
        <tag>网络流 24 题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「COGS 14」搭配飞行员 - 二分图匹配]]></title>
    <url>%2Fcogs-14%2F</url>
    <content type="text"><![CDATA[从一个二分图中选出尽量多的边，使得任意两条边没有公共点。 链接 COGS 14 题解 二分图匹配，可以用匈牙利~也可以用带花树~，然而我不会写。 所以要把二分图最大匹配转化成最大流 …… 设二分图左右两列分别为 X 和 Y，建立超级源点 S，从 S 向 X 中的每个点连一条边，容量为 1，建立超级汇点 T，从 Y 中的每个点向 T 连一条边，容量为 1。最后对于原图的每一条边 (u, v)（假设 u 在左侧 v 在右侧），连接一条由 u 指向 v 的有向边，容量为 1。然后跑一遍最大流就是最大匹配啦！ 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 100; struct Node; struct Edge; struct Node { Edge *firstEdge; int level; } nodes[MAXN + 2]; struct Edge { Node *from, *to; int capacity, flow; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from-&gt;firstEdge) {} }; int n, n1; inline void addEdge(int from, int to, int capacity) { nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } struct Dinic { bool makeLevelGraph(Node *s, Node *t) { for (int i = 0; i &lt; n + 1; i++) nodes[i].level = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == 0) { e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; else q.push(e-&gt;to); } } } return false; } int findPath(Node *s, Node *t, int limit = INT_MAX) { if (s == t) return limit; for (Edge *e = s-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;to-&gt;level == s-&gt;level + 1 &amp;&amp; e-&gt;capacity &gt; e-&gt;flow) { int flow = findPath(e-&gt;to, t, std::min(limit, e-&gt;capacity - e-&gt;flow)); if (flow &gt; 0) { e-&gt;flow += flow; e-&gt;reversedEdge-&gt;flow -= flow; return flow; } } } return 0; } int operator()(int s, int t) { int ans = 0; while (makeLevelGraph(&amp;nodes[s], &amp;nodes[t])) { int flow; while ((flow = findPath(&amp;nodes[s], &amp;nodes[t])) &gt; 0) ans += flow; } return ans; } } dinic; int main() { freopen("flyer.in", "r", stdin); freopen("flyer.out", "w", stdout); scanf("%d %d", &amp;n, &amp;n1); const int s = 0, t = n + 1; for (int i = 1; i &lt;= n1; i++) addEdge(s, i, 1); for (int i = n1 + 1; i &lt;= n; i++) addEdge(i, t, 1); while (!feof(stdin)) { int u, v; scanf("%d %d", &amp;u, &amp;v); if (u &gt; v) std::swap(u, v); addEdge(u, v, 1); } printf("%d\n", dinic(s, t)); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>COGS</tag>
        <tag>图论</tag>
        <tag>二分图匹配</tag>
        <tag>网络流 24 题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2683」简单题 - CDQ]]></title>
    <url>%2Fbzoj-2683%2F</url>
    <content type="text"><![CDATA[有一个的棋盘，每个格子内有一个整数，初始时的时候全部为 0，现在需要维护两种操作： 将格子里的数字加上； 输出这个矩形内的数字和。 链接 BZOJ 2683 题解 题解见 BZOJ 1176。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; const int MAXN = 500000; const int MAXM = 200000 * 4; enum OperateType { Update = 1, Query = 2 }; struct Operate { OperateType type; int id, x, y, *ans, num; Operate(OperateType type, int id, int x, int y, int num, int *ans = NULL) : type(type), id(id), x(x), y(y), ans(ans), num(num) {} Operate() {} bool operator&lt;(const Operate &amp;other) const { if (x &lt; other.x) return true; else if (x == other.x &amp;&amp; y &lt; other.y) return true; else if (x == other.x &amp;&amp; y == other.y &amp;&amp; id &lt; other.id) return true; return false; } }; std::vector&lt;Operate&gt; v; int n, ans[MAXM]; struct BinaryIndexedTree { int a[MAXN]; static int lowbit(int x) { return x &amp; (-x); } void update(int pos, int x) { for (int i = pos; i &lt;= n; i += lowbit(i)) { a[i - 1] += x; } } int query(int pos) { int ans = 0; for (int i = pos; i &gt; 0; i -= lowbit(i)) { ans += a[i - 1]; } return ans; } } bit; void cdq(int l, int r) { if (l &gt;= r) return; int mid = l + ((r - l) &gt;&gt; 1); for (int i = l; i &lt;= r; i++) { const Operate &amp;o = v[i - 1]; if (o.id &lt;= mid &amp;&amp; o.type == Update) bit.update(o.y, o.num); else if (o.id &gt; mid &amp;&amp; o.type == Query) *o.ans += bit.query(o.y) * o.num; } for (int i = l; i &lt;= r; i++) { const Operate &amp;o = v[i - 1]; if (o.id &lt;= mid &amp;&amp; o.type == Update) bit.update(o.y, -o.num); } static Operate a[MAXM]; int L = l, R = mid + 1; for (int i = l; i &lt;= r; i++) { if (v[i - 1].id &lt;= mid) a[L++ - 1] = v[i - 1]; else a[R++ - 1] = v[i - 1]; } memcpy(&amp;v[l - 1], &amp;a[l - 1], sizeof(Operate) * (r - l + 1)); cdq(l, mid), cdq(mid + 1, r); } int main() { scanf("%d", &amp;n); int m = 0, queryCount = 0; while (20000528) { int type; scanf("%d", &amp;type); if (type == 1) { int x, y, num; scanf("%d %d %d", &amp;x, &amp;y, &amp;num); v.push_back(Operate(Update, ++m, x, y, num)); } else if (type == 2) { int x1, y1, x2, y2; scanf("%d %d %d %d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); v.push_back(Operate(Query, ++m, x1 - 1, y1 - 1, 1, &amp;ans[queryCount])); v.push_back(Operate(Query, ++m, x1 - 1, y2, -1, &amp;ans[queryCount])); v.push_back(Operate(Query, ++m, x2, y1 - 1, -1, &amp;ans[queryCount])); v.push_back(Operate(Query, ++m, x2, y2, 1, &amp;ans[queryCount])); queryCount++; } else break; } std::sort(v.begin(), v.end()); cdq(1, m); for (int i = 0; i &lt; queryCount; i++) printf("%d\n", ans[i]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>BZOJ</tag>
        <tag>CDQ</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeVS 1563」奶牛的交通 - 网络流]]></title>
    <url>%2Fcodevs-1563%2F</url>
    <content type="text"><![CDATA[给出一个无向图，问最少割掉多少个点使 s 点与 t 点不连通。 链接 CodeVS 1563 洛谷 1345 题解 首先，这题一看就是最小割，由最小割最大流定理得，求出最大流就是最小割。 怎么流？ 一般的网络流，流量都在边上，求出的割也是割的边 …… 而我们这次需要割点，那就拆点呀！ 把每个点拆成 i 和 i' 两个点，i 表示进入这个点，i' 表示离开这个点。由 i 向 i' 连接一条有向边，容量为 1。对于原图中任意一条有向边 (i, j)，连接 (i', j)，容量为正无穷。 于是就完成了喜闻乐见的建模，求出 s' 到 t（想一想为什么不是 s 到 t'？）的最大流就是答案啦！ ###代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 100; const int MAXM = 600; struct Node; struct Edge; struct Node { Edge *firstEdge; int level; } nodes[MAXN + MAXN]; struct Edge { Node *from, *to; int capacity, flow; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from-&gt;firstEdge) {} }; int n, m, s, t; inline void addEdge(int from, int to, int capacity) { //printf("addEdge(%d, %d, %d)\n", from + 1, to + 1, capacity); nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge; } inline void link(int u, int v) { addEdge(u + n, v, INT_MAX); addEdge(v + n, u, INT_MAX); } struct Dinic { bool makeLevelGraph(Node *s, Node *t) { for (int i = 0; i &lt; n + n; i++) nodes[i].level = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;to-&gt;level == 0 &amp;&amp; e-&gt;capacity != e-&gt;flow) { e-&gt;to-&gt;level = v-&gt;level + 1; q.push(e-&gt;to); } } } return t-&gt;level != 0; } int findPath(Node *s, Node *t, int limit = INT_MAX) { if (s == t) return limit; for (Edge *e = s-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;to-&gt;level == s-&gt;level + 1) { int flow = findPath(e-&gt;to, t, std::min(limit, e-&gt;capacity - e-&gt;flow)); if (flow &gt; 0) { e-&gt;flow += flow; e-&gt;reversedEdge-&gt;flow -= flow; return flow; } } } return 0; } int operator()(int s, int t){ int ans = 0; while (makeLevelGraph(&amp;nodes[s], &amp;nodes[t])) { int flow; while ((flow = findPath(&amp;nodes[s], &amp;nodes[t])) &gt; 0) ans += flow; } return ans; } } dinic; int main() { scanf("%d %d %d %d", &amp;n, &amp;m, &amp;s, &amp;t), s--, t--; for (int i = 0; i &lt; n; i++) addEdge(i, i + n, 1); for (int i = 0; i &lt; m; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v), u--, v--; link(u, v); } printf("%d\n", dinic(s + n, t)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>CodeVS</tag>
        <tag>USACO</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDB 入门教程]]></title>
    <url>%2Fgnu-debugger%2F</url>
    <content type="text"><![CDATA[GDB（GNU Debugger）是 GNU 计划中的标准调试器，可以在 UNIX、Linux 和 Windows 下运行，支持多种语言（如 C、C++、Pascal 等）程序的调试。 安装 Linux 在 Ubuntu 及其衍生版本下，使用 apt 安装 GDB。 sudo apt-get install gdb 另外，NOI Linux 也中有预装的 GDB。 在 RHEL/Fedora/Archlinux 下，使用其各自的包管理器来安装 GDB。 sudo yum install gdb # RHEL sudo dnf install gdb # Fedora sudo pacman -S gdb # Archlinux Windows 在 Windows 下，可选择 Cygwin/MSYS2 环境，也需使用其各自的包管理器来安装 GDB，但通常使用更加轻量的 MinGW 工具集。 一般地，Dev-C++ 安装时会配带 MinGW，我们可以在其 bin 目录下找到 gdb.exe，为了方便，我们通常将 bin 目录的路径添加进 PATH 环境变量中，这样我们就可以直接在 cmd 中执行 gdb 命令。 启动 在控制台中输入 gdb 命令（Windows 系统有时需要手动配置环境变量），启动 GDB： gdb 在 GDB 中，用 file 命令指定需要被调试的程序： (gdb) file test 或者，也可以直接在启动 GDB 的时候指定需要被调试的程序： gdb test 其中 test 为被调试的程序的可执行文件名。 需要注意的是，被 GDB 调试的程序，在编译时需要加上 -g 选项，表示在生成的可执行文件中包含调试信息。 g++ test.cpp -o test -g fpc test.cpp -g GDB 启动时的提示大概是酱紫的： Menci@Menci-Laptop:~$ gdb GNU gdb (Ubuntu 7.10-1ubuntu2) 7.10 Copyright (C) 2015 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type "show copying" and "show warranty" for details. This GDB was configured as "x86_64-linux-gnu". Type "show configuration" for configuration details. For bug reporting instructions, please see: &lt;http://www.gnu.org/software/gdb/bugs/&gt;. Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/&gt;. For help, type "help". Type "apropos word" to search for commands related to "word". (gdb) 运行 使用 run（简写为 r）命令运行被调试的程序。 (gdb) run 之后可以像直接运行程序一样输入数据并获得输出，程序正常退出时，会得到类似于以下的提示： [Inferior 1 (process 52800) exited with code 1] 如果程序出现运行时错误（Runtime Error，RE），则会有一下提示，此时程序中断（以访问无效内存为例）： Program received signal SIGSEGV, Segmentation fault. 0x0000000000400598 in main () at test.cpp:6 6 aby[8999999999990] = 1; 其中 SIGSEGV 表示程序中断的信号，后面跟着解释文本“Segmentation fault”，即“段错误”。中间一行是程序中断所在函数及其调用参数，下面一行是程序中断所在行的代码，开头 6 为行号。 出现这种情况时，我们可以使用各种调试命令对其进行调♂试。 退出 使用 quit（简写为 q）命令退出。 如果程序正常运行结束，则 q 命令会成功退出 GDB，否则我们将会收到类似如下的提示： (gdb) q A debugging session is active. Inferior 1 [process 52800] will be killed. Quit anyway? (y or n) 这时候输入 y 后回车，可以强制杀死被调试的进行并退出 GDB。 断点 使用 break（简写为 b）命令设置断点，后跟一个行号或者函数名，之后程序会在执行到该行时中断。 (gdb) b 9 Breakpoint 1 at 0x4004fa: file test.cpp, line 9. (gdb) b main Breakpoint 1 at 0x4004fa: file test.cpp, line 9. break 命令也可以在断点位置后跟一个条件，仅当该条件为真时程序中断。 #include &lt;cstdio&gt; int main() { int a; scanf("%d", &amp;a); printf("%dn", a); return 0; } (gdb) b 6 if a == 528 使用 r 运行程序，当你输入 528 时，程序中断，否则程序继续运行。 Pascal 在设置条件断点时会有所不同，如这里的 == 需要改为 =。 控制 使用 continue（简写为 c）命令使中断的程序继续运行。 注意，这里“中断的程序”指的是通过断点中断的程序，而不是运行时错误而中断的，如果我们强制让一个运行时错误的程序继续运行 …… 你猜它会怎样 …… 使用 step（简写为 s）命令使中断的程序执行一行，如果该行有函数调用，程序将跟踪进入函数，在函数体的第一行中断。 int foo() { return 2333; } int main() { foo(); return 0; } (gdb) b 6 Breakpoint 1 at 0x40058f: file test.cpp, line 6. (gdb) r Starting program: /home/Menci/test Breakpoint 1, main () at test.cpp:6 6 foo(); (gdb) s foo () at test.cpp:2 2 return 2333; 或者，你想让我用 Pascal 来演示一下的话，是酱紫的： Program Test; Function Foo(): Longint; Begin Exit(2333); End; Begin Foo(); End. (gdb) b 7 Breakpoint 1 at 0x4001c1: file test.pas, line 7. (gdb) r Starting program: /home/Menci/test Breakpoint 1, main () at test.pas:7 7 Foo(); (gdb) s FOO () at test.pas:4 4 Exit(2333); 使用 next（简写为 n）命令使中断的程序执行一行，如果该行有函数调用，程序将不跟踪进入函数，直接在下一行中断。 源程序不变，执行效果如下： (gdb) b 6 Breakpoint 1 at 0x40058f: file test.cpp, line 6. (gdb) r Starting program: /home/Menci/test Breakpoint 1, main () at test.cpp:6 6 foo(); (gdb) n 7 return 0; (gdb) b 7 Breakpoint 1 at 0x4001c1: file test.pas, line 7. (gdb) r Starting program: /home/Menci/test Breakpoint 1, main () at test.pas:7 7 Foo(); (gdb) n 8 End. 监视 在 GDB 中，可以对表达式的值进行监视。 使用 print（简写为 p）命令输出一个表达式的值，这里的表达式可以只是一个变量，也可以是包含了多个函数调用的复杂表达式。 来看这个经典的 A + B 问题： #include &lt;cstdio&gt; int main() { int a, b; scanf("%d %d", &amp;a, &amp;b); printf("%dn", a + b); return 0; } (gdb) b 6 Breakpoint 1 at 0x400642: file test.cpp, line 6. (gdb) r Starting program: /home/Menci/test 233 2333 Breakpoint 1, main () at test.cpp:6 6 printf("%dn", a + b); (gdb) p a $1 = 233 (gdb) p b $2 = 2333 使用 display（简写为 disp）命令持续监视某个表达式的值。 #include &lt;cstdio&gt; int doSomething(int x) { return x * 10; } int main() { int n = 10; for (int i = 0; i &lt; n; i++) { printf("i = %dn", i); } return 0; } (gdb) b 10 Breakpoint 1 at 0x400603: file test.cpp, line 10. (gdb) r Starting program: /home/Menci/test Breakpoint 1, main () at test.cpp:10 10 printf("i = %dn", i); (gdb) disp doSomething(i) 1: doSomething(i) = 0 (gdb) n i = 0 9 for (int i = 0; i &lt; n; i++) { 1: doSomething(i) = 0 (gdb) n Breakpoint 1, main () at test.cpp:10 10 printf("i = %dn", i); 1: doSomething(i) = 10 (gdb) n i = 1 9 for (int i = 0; i &lt; n; i++) { 1: doSomething(i) = 10 (gdb) n Breakpoint 1, main () at test.cpp:10 10 printf("i = %dn", i); 1: doSomething(i) = 20 (gdb) n i = 2 在 GDB 7.0 之后的版本，可以直接使用 p 命令输出 STL 容器的内容。 栈 在函数调用时，系统栈会储存函数的调用信息，使用 backtrace（简写为 bt）命令查看调用栈。 为了方便演示，我们写一个使系统栈溢出的函数来演示。 int fac(int x) { if (x == 0) return 1; else return x * fac(x - 1); } int main() { int x = fac(1000000000); return 0; } (gdb) r Starting program: /home/Menci/test Program received signal SIGSEGV, Segmentation fault. 0x00000000004005a5 in fac (x=999737953) at test.cpp:3 3 else return x * fac(x - 1); (gdb) bt #0 0x00000000004005a5 in fac (x=999737953) at test.cpp:3 #1 0x00000000004005aa in fac (x=999737954) at test.cpp:3 #2 0x00000000004005aa in fac (x=999737955) at test.cpp:3 #3 0x00000000004005aa in fac (x=999737956) at test.cpp:3 #4 0x00000000004005aa in fac (x=999737957) at test.cpp:3 #5 0x00000000004005aa in fac (x=999737958) at test.cpp:3 （以上省略 272043 行） bt 命令可以看到函数的调用信息，同时调用参数、调用位置（行号）也会被显示。 使用 frame 命令切换正在调试的函数上下文。 int a(int x) { return x - 4; } int b(int x) { return a(x * 3); } int c(int x) { return b(x + 10); } int d(int x) { return c(x / 2); } int main() { int x = d(4); return 0; } (gdb) b 2 Breakpoint 1 at 0x400577: file test.cpp, line 2. (gdb) r Starting program: /home/Menci/test Breakpoint 1, a (x=36) at test.cpp:2 2 return x - 4; (gdb) bt #0 a (x=36) at test.cpp:2 #1 0x00000000004005a7 in b (x=12) at test.cpp:6 #2 0x00000000004005c9 in c (x=2) at test.cpp:10 #3 0x00000000004005f5 in d (x=4) at test.cpp:14 #4 0x0000000000400619 in main () at test.cpp:18 (gdb) frame 3 #3 0x00000000004005f5 in d (x=4) at test.cpp:14 14 return c(x / 2); (gdb) p x $1 = 4 从例子中我们看到，frame 3 命令使当前上下文切换到了 d(x) 函数中，此时 p x 输出的值为 4，与我们调用时所传递的值相同。 frame 命令在调试在 STL 中崩溃的程序时有很大作用，我们需要切换到自己的函数的上下文中，而不是对 STL 进行调试。 查看代码 使用 list（简写为 l）命令查看部分代码，后跟一个行号，表示查看从该行开始若干行的代码。 (gdb) l 1 1 int a(int x) { 2 return x - 4; 3 } 4 5 int b(int x) { 6 return a(x * 3); 7 } 8 9 int c(int x) { 10 return b(x + 10);]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>GDB</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dinic 学习笔记]]></title>
    <url>%2Fdinic-notes%2F</url>
    <content type="text"><![CDATA[Dinic 算法是一种对于网络流问题的增广路算法，它通过对残量网络进行分层，并在层次图上寻找增广路的方式，实现了在 的时间内求出网络的最大流。 定义 容量： 表示一条有向边 的最大允许的流量。 流量： 表示一条有向边 总容量中已被占用的流量。 剩余容量：即 ，表示当前时刻某条有向边 总流量中未被占用的部分。 反向边：原图中每一条有向边在残量网络中都有对应的反向边，反向边的容量为 ，容量的变化与原边相反；『反向边』的概念是相对的，即一条边的反向边的反向边是它本身。 残量网络：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改。 增广路（augmenting path）：残量网络中从源点到汇点的一条路径，增广路上所有边中最小的剩余容量为增广流量。 增广（augmenting）：在残量网络中寻找一条增广路，并将增广路上所有边的流量加上增广流量的过程。 层次： 表示节点 在层次图中与源点的距离。 层次图：在原残量网络中按照每个节点的层次来分层，只保留相邻两层的节点的图，满载（即流量等于容量）的边不存在于层次图中。 算法 遍历残量网络，建立层次图； 在层次图上寻找任意一条增广路，进行增广，并将答案加上增广流量； 重复第 2 步，直至层次图中不存在增广路，回到第 1 步重新建立层次图； 直到层次图无法建立，则当前流量即为最大流量。 每次建立层次图后都可以进行多次增广，无法增广时重新建立层次图，此时的层次图不再包含之前进行增广后满载的边。无法建立层次图时，说明源点到汇点的任意一条简单路径中，都至少有一条边满载，这也在直观上验证了最小割最大流定理。 优化 Dinic 有一个常见的优化——当前弧优化。 该优化基于一个显而易见的事实，每次建立层次图后，如果在某一次增广前，某个点有一条边增广过了，则这条边在当前的层次图中不会再用到了，即下一次 DFS 这个点的时候直接可以从这条边的下一条边开始。 代码实现 struct Node { struct Edge *firstEdge, *currentEdge; int level; } N[MAXN]; struct Edge { Node *from, *to; int capacity, flow; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), next(from-&gt;firstEdge), flow(0) {} }; struct Dinic { bool makeLevelGraph(Node *s, Node *t, int n) { for (int i = 0; i &lt; n; i++) { N[i].level = 0; N[i].currentEdge = N[i].firstEdge; } std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) { Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == 0) { e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; else q.push(e-&gt;to); } } } return false; } int findPath(Node *s, Node *t, int limit = INT_MAX) { if (s == t) return limit; for (Edge *&amp;e = s-&gt;currentEdge; e; e = e-&gt;next) { if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == s-&gt;level + 1) { int flow = findPath(e-&gt;to, t, std::min(limit, e-&gt;capacity - e-&gt;flow)); if (flow &gt; 0) { e-&gt;flow += flow; e-&gt;reversedEdge-&gt;flow -= flow; return flow; } } } return 0; } int operator()(int s, int t, int n) { int ans = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) { int flow; while ((flow = findPath(&amp;N[s], &amp;N[t])) &gt; 0) ans += flow; } return ans; } } dinic; inline void addEdge(int from, int to, int capacity) { N[from].firstEdge = new Edge(&amp;N[from], &amp;N[to], capacity); N[to].firstEdge = new Edge(&amp;N[to], &amp;N[from], 0); N[from].firstEdge-&gt;reversedEdge = N[to].firstEdge, N[to].firstEdge-&gt;reversedEdge = N[from].firstEdge; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>网络流</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1756」小白逛公园 - 线段树]]></title>
    <url>%2Fbzoj-1756%2F</url>
    <content type="text"><![CDATA[路的一边从南到北依次排着 n 个公园，一开始，小白就根据公园的风景给每个公园打了分。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第 a 个和第 b 个公园之间（包括 a、b 两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。那么，就请你来帮小白选择公园吧。 链接 BZOJ 1756 题解 区间内最大连续和，还带修改，当然是线段树咯！ 每个节点维护以下几项信息： 区间总和； 区间最大连续和； 强制包含左端点的最大连续和； 强制包含右端点的最大连续和。 然后使用动态规划的方式求出每个节点的四个值即可。 查询麻烦一点，如果跨左右子树查询的话，需要维护要查询的区间的以上四项值，然后用相似的方式向上传递。 合并两个区间时，需要注意细节。 还有就是读入 a、b 时，有可能 a 比 b 大！ 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 500000; const int MAXM = 100000; struct SegmentTree { struct Node { Node *lchild, *rchild; int l, r; int value, sum, lsum, rsum, maxSum; Node(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {} void maintain() { sum = value; if (lchild) sum += lchild-&gt;sum; if (rchild) sum += rchild-&gt;sum; lsum = rsum = sum; if (lchild) { lsum = std::max(lsum, lchild-&gt;lsum); if (rchild) lsum = std::max(lsum, lchild-&gt;sum + rchild-&gt;lsum); } if (rchild) { rsum = std::max(rsum, rchild-&gt;rsum); if (lchild) rsum = std::max(rsum, rchild-&gt;sum + lchild-&gt;rsum); } maxSum = sum; maxSum = std::max(maxSum, lsum); maxSum = std::max(maxSum, rsum); if (lchild) maxSum = std::max(maxSum, lchild-&gt;maxSum); if (rchild) maxSum = std::max(maxSum, rchild-&gt;maxSum); if (lchild &amp;&amp; rchild) maxSum = std::max(maxSum, lchild-&gt;rsum + rchild-&gt;lsum); } void query(int l, int r, int &amp;sum, int &amp;lsum, int &amp;rsum, int &amp;maxSum) { if (this-&gt;l &gt; r || this-&gt;r &lt; l) throw; else if (this-&gt;l &gt;= l &amp;&amp; this-&gt;r &lt;= r) { sum = this-&gt;sum; lsum = this-&gt;lsum; rsum = this-&gt;rsum; maxSum = this-&gt;maxSum; } else { int mid = this-&gt;l + ((this-&gt;r - this-&gt;l) &gt;&gt; 1); if (r &lt;= mid) return lchild-&gt;query(l, r, sum, lsum, rsum, maxSum); if (l &gt;= mid + 1) return rchild-&gt;query(l, r, sum, lsum, rsum, maxSum); else { int suml, lsuml, rsuml, maxSuml; int sumr, lsumr, rsumr, maxSumr; lchild-&gt;query(l, r, suml, lsuml, rsuml, maxSuml); rchild-&gt;query(l, r, sumr, lsumr, rsumr, maxSumr); maxSum = sum = suml + sumr; lsum = std::max(lsuml, suml + lsumr); rsum = std::max(rsumr, sumr + rsuml); maxSum = std::max(maxSum, maxSuml); maxSum = std::max(maxSum, maxSumr); maxSum = std::max(maxSum, lsumr + rsuml); } } } void update(int pos, int value) { if (this-&gt;l &gt; pos || this-&gt;r &lt; pos) return; else if (this-&gt;l == pos &amp;&amp; this-&gt;r == pos) this-&gt;value = value, maintain(); else { if (lchild) lchild-&gt;update(pos, value); if (rchild) rchild-&gt;update(pos, value); maintain(); } } } *root; SegmentTree(int l, int r) { root = build(l, r); } Node *build(int l, int r) { if (l &gt; r) return NULL; else if (l == r) return new Node(l, r, NULL, NULL); else return new Node(l, r, build(l, l + ((r - l) &gt;&gt; 1)), build(l + ((r - l) &gt;&gt; 1) + 1, r)); } void update(int pos, int value) { root-&gt;update(pos, value); } int query(int l, int r) { int sum, lsum, rsum, maxSum; root-&gt;query(l, r, sum, lsum, rsum, maxSum); return maxSum; } }; int main() { int n, m; scanf("%d %d", &amp;n, &amp;m); SegmentTree *segment = new SegmentTree(1, n); for (int i = 1; i &lt;= n; i++) { int x; scanf("%d", &amp;x); segment-&gt;update(i, x); } for (int i = 0; i &lt; m; i++) { int k; scanf("%d", &amp;k); if (k == 1) { int l, r; scanf("%d %d", &amp;l, &amp;r); printf("%d\n", segment-&gt;query(std::min(l, r), std::max(l, r))); } else { int p, s; scanf("%d %d", &amp;p, &amp;s); segment-&gt;update(p, s); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>高级数据结构</tag>
        <tag>DP</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2004」郁闷的出纳员 - Splay]]></title>
    <url>%2Fnoi2004-cashier%2F</url>
    <content type="text"><![CDATA[工资的频繁调整很让员工反感，尤其是集体扣除工资的时候，一旦某位员工发现自己的工资已经低于了合同规定的工资下界，他就会立刻气愤地离开公司，并且再也不会回来了。每位员工的工资下界都是统一规定的。每当一个人离开公司，我就要从电脑中把他的工资档案删去，同样，每当公司招聘了一位新员工，我就得为他新建一个工资档案。老板经常到我这边来询问工资情况，现在工资第 k 多的员工拿多少工资。 链接 BZOJ 1503 CodeVS 1286 题解 这是道 Splay 入门题，多思考思考还是挺容易的。 唯一的难点貌似在同时修改工资，这时候只要像维护数列那样弄一个标记，然后向下传就好咯。扣工资时直接删掉 范围内的节点就好。 还有统计离开公司人数，一开始还在想删除时用了辅助节点，不知道该怎么算，一想才知道，直接看整棵树的大小变了多少嘛！ 第四次敲 Splay，在从临沂经西安到成都的飞机上用了一个小时。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; const int MAXN = 200100; template &lt;typename T, T INF&gt; struct Splay { enum Relation { L = 0, R = 1 }; struct Node { Node *child[2], *parent, **root; T value, lazy; int size, count; Node(Node *parent, Node **root, const T &amp;value) : parent(parent), root(root), value(value), size(1), count(1), lazy(0) { child[L] = child[R] = NULL; } ~Node() { if (child[L]) delete child[L]; if (child[R]) delete child[R]; } void pushDown() { if (lazy) { if (child[L]) child[L]-&gt;update(lazy); if (child[R]) child[R]-&gt;update(lazy); lazy = 0; } } void maintain() { pushDown(); size = count; if (child[L]) size += child[L]-&gt;size; if (child[R]) size += child[R]-&gt;size; } void update(const T &amp;value) { if (this-&gt;value != INF &amp;&amp; this-&gt;value != -INF) this-&gt;value += value; this-&gt;lazy += value; } Relation relation() { return this == parent-&gt;child[L] ? L : R; } void rotate() { pushDown(); Relation x = relation(); Node *oldParent = parent; if (oldParent-&gt;parent) oldParent-&gt;parent-&gt;child[oldParent-&gt;relation()] = this; parent = oldParent-&gt;parent; oldParent-&gt;child[x] = child[x ^ 1]; if (child[x ^ 1]) child[x ^ 1]-&gt;parent = oldParent; child[x ^ 1] = oldParent; oldParent-&gt;parent = this; oldParent-&gt;maintain(), maintain(); if (!parent) *root = this; } void splay(Node *targetParent = NULL) { while (parent != targetParent) { parent-&gt;pushDown(), pushDown(); if (parent-&gt;parent == targetParent) rotate(); else { parent-&gt;parent-&gt;pushDown(); if (relation() == parent-&gt;relation()) parent-&gt;rotate(), rotate(); else rotate(), rotate(); } } } Node *pred() { splay(); Node *v = child[L]; while (v-&gt;child[R]) v = v-&gt;child[R]; return v; } Node *succ() { splay(); Node *v = child[R]; while (v-&gt;child[L]) v = v-&gt;child[L]; return v; } int rank() { return child[L] ? child[L]-&gt;size : 0; } } *root; Splay() : root(NULL) { insert(INF), insert(-INF); } ~Splay() { delete root; } Node *find(const T &amp;value) { Node *v = root; while (v &amp;&amp; value != v-&gt;value) { v-&gt;pushDown(); if (value &lt; v-&gt;value) v = v-&gt;child[L]; else v = v-&gt;child[R]; } if (v) v-&gt;splay(); return v; } Node *insert(const T &amp;value) { Node *v = find(value); if (v) { v-&gt;count++, v-&gt;size++; return v; } Node **target = &amp;root, *parent = NULL; while (*target) { parent = *target; parent-&gt;pushDown(); parent-&gt;size++; if (value &lt; parent-&gt;value) target = &amp;parent-&gt;child[L]; else target = &amp;parent-&gt;child[R]; } *target = new Node(parent, &amp;root, value); (*target)-&gt;splay(); return root; } const T &amp;select(int k) { k++; Node *v = root; while (v-&gt;pushDown(), !(v-&gt;rank() + 1 &lt;= k &amp;&amp; v-&gt;rank() + v-&gt;count &gt;= k)) { if (k &lt; v-&gt;rank() + 1) v = v-&gt;child[L]; else k -= v-&gt;rank() + v-&gt;count, v = v-&gt;child[R]; } v-&gt;splay(); return v-&gt;value; } void erase(Node *v) { if (v-&gt;count &gt; 1) v-&gt;count--; else erase(v, v); } void erase(Node *l, Node *r) { Node *pred = l-&gt;pred(); Node *succ = r-&gt;succ(); pred-&gt;splay(); succ-&gt;splay(pred); delete succ-&gt;child[L]; succ-&gt;child[L] = NULL; succ-&gt;maintain(), pred-&gt;maintain(); } void erase(const T &amp;l, const T &amp;r) { Node *vl = find(l), *vr = find(r); if (!vl) vl = insert(l); if (!vr) vr = insert(r); erase(vl, vr); } void update(const T &amp;value) { root-&gt;update(value); } int rank(const T &amp;value) { Node *v = find(value); if (v) return v-&gt;rank(); else { v = insert(value); int result = v-&gt;rank(); erase(v); return result; } } int size() { return root-&gt;size - 2; } }; int n, min, deletedCount; Splay&lt;int, INT_MAX&gt; splay; void dfs(Splay&lt;int, INT_MAX&gt;::Node *v, int depth = 0) { if (!v) return; v-&gt;pushDown(); dfs(v-&gt;child[Splay&lt;int, INT_MAX&gt;::L], depth + 1); for (int i = 0; i &lt; depth; i++) putchar(' '); printf("%d\n", v-&gt;value); dfs(v-&gt;child[Splay&lt;int, INT_MAX&gt;::R], depth + 1); } inline void print() { dfs(splay.root); puts("----------------------"); } inline bool isValid(char c) { return c == 'I' || c == 'A' || c == 'S' || c == 'F'; } int main() { scanf("%d %d", &amp;n, &amp;min); for (int i = 0; i &lt; n; i++) { char c; int k; while (!isValid(c = getchar())); scanf("%d", &amp;k); //printf("{ command: '%c', k: '%d' }\n", c, k); if (c == 'I') { if (k &gt;= min) splay.insert(k); } else if (c == 'A') { splay.update(k); } else if (c == 'S') { splay.update(-k); int oldSize = splay.size(); splay.erase(-INT_MAX + 1, min - 1); deletedCount += oldSize - Splay.size(); } else if (c == 'F') { if (k &lt; 1 || k &gt; splay.size()) puts("-1"); else printf("%d\n", splay.select(splay.size() - k + 1)); } //print(); } printf("%d\n", deletedCount); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>高级数据结构</tag>
        <tag>BZOJ</tag>
        <tag>CodeVS</tag>
        <tag>Splay</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1477」青蛙的约会 - 扩展欧几里得]]></title>
    <url>%2Fbzoj-1477%2F</url>
    <content type="text"><![CDATA[我们把这两只青蛙分别叫做青蛙 A 和青蛙 B，并且规定纬度线上东经 0 度处为原点，由东往西为正方向，单位长度 1 米，这样我们就得到了一条首尾相接的数轴。设青蛙 A 的出发点坐标是 x，青蛙 B 的出发点坐标是 y。青蛙 A 一次能跳 m 米，青蛙 B 一次能跳 n 米，两只青蛙跳一次所花费的时间相同。纬度线总长 L 米。现在要你求出它们跳了几次以后才会碰面。 链接 BZOJ 1477 Tyvj 2366 题解 设两只青蛙跳了 次后碰面，则有： 令 ，得 移项，得 题目转化为求一个二元一次不定方程的最小正整数解。 扩展欧几里得直接上即可，注意细节，注意细节，注意细节！ 代码 #include &lt;cstdio&gt; const long long MAXX = 2000000000; const long long MAXY = 2000000000; const long long MAXN = 2000000000; const long long MAXM = 2000000000; const long long MAXL = 2100000000; void exgcd(long long a, long long b, long long &amp;g, long long &amp;x, long long &amp;y) { if (b == 0) { g = a; x = 1, y = 0; } else { exgcd(b, a % b, g, y, x); y -= x * (a / b); } } inline bool solve(long long a, long long b, long long c, long long &amp;x, long long &amp;y) { if (b &lt; 0) a = -a, b = -b, c = -c; long long g; exgcd(a, b, g, x, y); if (c % g != 0) return false; x = x * c / g; y = y * c / g; long long newx = ((x % b) + b) % b; y = y - ((newx - x) / (b / g)) * (a / g); x = newx; return true; } int main() { long long x, y, m, n, l; scanf("%lld %lld %lld %lld %lld", &amp;x, &amp;y, &amp;m, &amp;n, &amp;l); long long t, k; if (!solve(m - n, -l, y - x, t, k)) puts("Impossible"); else printf("%lld\n", t); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论</tag>
        <tag>EXGCD</tag>
        <tag>Tyvj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2015」软件包管理器 - 树链剖分]]></title>
    <url>%2Fnoi2015-manager%2F</url>
    <content type="text"><![CDATA[你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 A 依赖软件包 B，那么安装软件包 A 以前，必须先安装软件包 B。同时，如果想要卸载软件包 B，则必须卸载软件包A。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 0 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 0 号软件包不依赖任何一个软件包。依赖关系不存在环，当然也不会有一个软件包依赖自己。用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态。 链接 CodeVS 4621 BZOJ 4196 题解 首先，两种操作抽象为树上询问与修改： 询问某节点到根的一条链上有多少个节点打了标记； 将某节点到根的一条链上所有节点打上标记； 询问某节点的整棵子树上有多少个节点打了标记； 将某节点的整棵子树上所有节点打上标记。 对于前两种，普通的树链剖分就可以了，但是对于后两种，我们还需要维护一个 DFS 序。DFS 序和轻重路径划分的维护看起来是有冲突的，实际上只要按照 DFS 的方式连接路径，并且在 DFS 时先遍历重链连接的子树，同时记录 DFS 序，这样得到的 DFS 序中，同一条路径是连续的，同一棵子树也是连续的。 代码 #include &lt;cstdio&gt; #include &lt;stack&gt; #include &lt;queue&gt; const int MAXN = 100000; struct Tree; struct SegmentTree; struct Path; struct SegmentTree { enum LazyTag { Cover = 1, Null = 0, Uncover = -1 }; struct Node { Node *lchild, *rchild; int l, r; LazyTag lazy; bool covered; int count; void pushDown() { if (lazy != Null) { if (lazy == Cover) { if (lchild) lchild-&gt;cover(true); if (rchild) rchild-&gt;cover(true); } else { if (lchild) lchild-&gt;cover(false); if (rchild) rchild-&gt;cover(false); } lazy = Null; } } void cover(bool flag) { if (flag) count = r - l + 1, covered = true, lazy = Cover; else count = 0, covered = false, lazy = Uncover; } void cover(int l, int r, bool flag) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) cover(flag); else { pushDown(); count = 0; if (lchild) lchild-&gt;cover(l, r, flag), count += lchild-&gt;count; if (rchild) rchild-&gt;cover(l, r, flag), count += rchild-&gt;count; } } int query(int l, int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return count; else { pushDown(); return (lchild ? lchild-&gt;query(l, r) : 0) + (rchild ? rchild-&gt;query(l, r) : 0); } } Node(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), covered(false), count(0), lazy(Null) {} } *root; static Node *build(int l, int r) { if (l &gt; r) return NULL; else if (l == r) return new Node(l, r, NULL, NULL); else return new Node(l, r, build(l, l + ((r - l) &gt;&gt; 1)), build(l + ((r - l) &gt;&gt; 1) + 1, r)); } SegmentTree(int l, int r) { root = build(l, r); } int query(int l, int r) { return root-&gt;query(l, r); } void cover(int l, int r, bool flag) { root-&gt;cover(l, r, flag); } }; struct Path { Tree *top; Path(Tree *top) : top(top) {} }; struct Tree { Path *path; Tree *parent, *children, *next; Tree *maxSizeChild; int size, pos, posEnd; bool visited; Tree() : children(NULL) {} Tree(Tree *parent) : parent(parent), next(parent-&gt;children), path(NULL), maxSizeChild(NULL), size(1) {} } trees[MAXN + 1]; int n, q; Tree *dfsOrder[MAXN + 1]; SegmentTree *segment; inline void addEdge(int parent, int child) { trees[parent].children = new (&amp;trees[child]) Tree(&amp;trees[parent]); } inline void cutTree(Tree *root) { std::stack&lt;Tree *&gt; s; s.push(root); while (!s.empty()) { Tree *t = s.top(); if (!t-&gt;visited) { for (Tree *c = t-&gt;children; c; c = c-&gt;next) { s.push(c); } t-&gt;visited = true; } else { for (Tree *c = t-&gt;children; c; c = c-&gt;next) { t-&gt;size += c-&gt;size; if (t-&gt;maxSizeChild == NULL || t-&gt;maxSizeChild-&gt;size &lt; c-&gt;size) { t-&gt;maxSizeChild = c; } } s.pop(); } } for (int i = 0; i &lt; n; i++) trees[i].visited = false; int i = 0; s.push(root); while (!s.empty()) { Tree *t = s.top(); if (!t-&gt;visited) { dfsOrder[t-&gt;pos = i++] = t; for (Tree *c = t-&gt;children; c; c = c-&gt;next) { if (c != t-&gt;maxSizeChild) s.push(c); } if (t-&gt;maxSizeChild) s.push(t-&gt;maxSizeChild); if (t == root || t != t-&gt;parent-&gt;maxSizeChild) { t-&gt;path = new Path(t); } else { t-&gt;path = t-&gt;parent-&gt;path; } t-&gt;visited = true; } else { t-&gt;posEnd = i - 1; s.pop(); } } segment = new SegmentTree(0, n - 1); } int install(Tree *t) { int ans = 0; while (t) { ans += (t-&gt;pos - t-&gt;path-&gt;top-&gt;pos + 1) - segment-&gt;query(t-&gt;path-&gt;top-&gt;pos, t-&gt;pos); segment-&gt;cover(t-&gt;path-&gt;top-&gt;pos, t-&gt;pos, true); t = t-&gt;path-&gt;top-&gt;parent; } return ans; } int uninstall(Tree *t) { int ans = segment-&gt;query(t-&gt;pos, t-&gt;posEnd); segment-&gt;cover(t-&gt;pos, t-&gt;posEnd, false); return ans; } int main() { scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) { int p; scanf("%d", &amp;p); addEdge(p, i); } cutTree(&amp;trees[0]); scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++) { char command[9 + 1]; int u; scanf("%s %d", command, &amp;u); if (command[0] == 'i') { printf("%d\n", install(&amp;trees[u])); } else { printf("%d\n", uninstall(&amp;trees[u])); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
        <tag>高级数据结构</tag>
        <tag>BZOJ</tag>
        <tag>CodeVS</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2015」程序自动分析 - 离散化 + 并查集]]></title>
    <url>%2Fnoi2015-prog%2F</url>
    <content type="text"><![CDATA[给定 n 个形如或 的变量相等 / 不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。 链接 CodeVS 4600 BZOJ 4195 题解 首先，x 的值很大，我们要把它离散化掉。 然后用一个并查集，要离线做，先把相等的都并掉，然后枚举所有不相等的，如果某一对被并了说明不成立。 代码 手写哈希表 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;new&gt; const int HASH_SIZE = 10000007; const int MAXN = 1000000; template &lt;typename T, size_t SIZE&gt; struct MemoryPool { char preAlloc[SIZE * sizeof(T)]; T *curr; T *recycle[SIZE]; int i; void init() { curr = (T *)preAlloc; i = -1; } T *alloc() { if (curr != (T *)preAlloc + SIZE) return curr++; else return recycle[i++]; } void free(T *p) { recycle[++i] = p; } }; template &lt;typename T, T DEFAULT, size_t SIZE&gt; struct HashMap { struct Node { int key; T value; Node *next; Node(int key, const T &amp;value, Node *next) : key(key), value(value), next(next) {} } *list[HASH_SIZE]; MemoryPool&lt;Node, SIZE&gt; pool; void init() { pool.init(); memset(list, 0, sizeof(list)); } int hash(int x) { return (unsigned int)((x &lt;&lt; 16) | (x &gt;&gt; 16)) % HASH_SIZE; } T &amp;operator[](int key) { int i = hash(key); for (Node *v = list[i]; v; v = v-&gt;next) { if (v-&gt;key == key) return v-&gt;value; } list[i] = new(pool.alloc()) Node(key, DEFAULT, list[i]); return list[i]-&gt;value; } }; template &lt;size_t SIZE&gt; struct UnionFindSet { int p[SIZE]; void init(int n) { for (int i = 0; i &lt; n; i++) p[i] = i; } int find(int x) { return p[x] == x ? x : p[x] = find(p[x]); } void merge(int x, int y) { p[find(y)] = find(x); } }; struct Query { int x, y, e, fx, fy; } queries[MAXN]; HashMap&lt;int, -1, MAXN * 2&gt; map; UnionFindSet&lt;MAXN * 2&gt; ufs; int main() { int t; scanf("%d", &amp;t); for (int i = 0; i &lt; t; i++) { int n; scanf("%d", &amp;n); map.init(); ufs.init(n * 2); int k = 0; for (int i = 0; i &lt; n; i++) { scanf("%d %d %d", &amp;queries[i].x, &amp;queries[i].y, &amp;queries[i].e); int &amp;fx = map[queries[i].x], &amp;fy = map[queries[i].y]; if (fx == -1) fx = k++; if (fy == -1) fy = k++; queries[i].fx = fx, queries[i].fy = fy; } for (int i = 0; i &lt; n; i++) { if (queries[i].e == 1) { if (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy); } } bool flag = true; for (int i = 0; i &lt; n; i++) { if (queries[i].e == 0) { if (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) { flag = false; break; } } } if (flag) puts("YES"); else puts("NO"); } return 0; } STL #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;tr1/unordered_map&gt; const int HASH_SIZE = 10000007; const int MAXN = 1000000; template &lt;typename T, T DEFAULT, size_t SIZE&gt; struct HashMap { std::tr1::unordered_map&lt;int, T&gt; map; void init() { map.clear(); } T &amp;operator[](int key) { if (map.count(key) == 0) map[key] = -1; return map[key]; } }; template &lt;size_t SIZE&gt; struct UnionFindSet { int p[SIZE]; void init(int n) { for (int i = 0; i &lt; n; i++) p[i] = i; } int find(int x) { return p[x] == x ? x : p[x] = find(p[x]); } void merge(int x, int y) { p[find(y)] = find(x); } }; struct Query { int x, y, e, fx, fy; } queries[MAXN]; HashMap&lt;int, -1, MAXN * 2&gt; map; UnionFindSet&lt;MAXN * 2&gt; ufs; int main() { int t; scanf("%d", &amp;t); for (int i = 0; i &lt; t; i++) { int n; scanf("%d", &amp;n); map.init(); ufs.init(n * 2); int k = 0; for (int i = 0; i &lt; n; i++) { scanf("%d %d %d", &amp;queries[i].x, &amp;queries[i].y, &amp;queries[i].e); int &amp;fx = map[queries[i].x], &amp;fy = map[queries[i].y]; if (fx == -1) fx = k++; if (fy == -1) fy = k++; queries[i].fx = fx, queries[i].fy = fy; } for (int i = 0; i &lt; n; i++) { if (queries[i].e == 1) { if (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy); } } bool flag = true; for (int i = 0; i &lt; n; i++) { if (queries[i].e == 0) { if (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) { flag = false; break; } } } if (flag) puts("YES"); else puts("NO"); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>离散化</tag>
        <tag>BZOJ</tag>
        <tag>CodeVS</tag>
        <tag>并查集</tag>
        <tag>map</tag>
        <tag>NOI</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论学习笔记（一）]]></title>
    <url>%2Fnumber-theory-notes-1%2F</url>
    <content type="text"><![CDATA[数论是 OI 中很重要的一部分，然而我基本上都不会，所以从现在开始我要学数论！ 欧几里得 算是 OI 中数论最基本的了吧，求两个数的最大公约数。 int gcd(int a, int b) { return !b ? a : gcd(b, a % b); } 顺便求两个数的最小公倍数。 写程序时先除后乘防炸。 int lcm(int a, int b) { return a / gcd(a, b) * b; } 扩展欧几里得 扩展欧几里得 exgcd 可以在求出 的同时求出二元一次不定方程 的一组整数解。 举个栗子，求 时，得到以下式子。 把余数移到左边 从 开始，将四个式子依次带入，得 解得 。 由上述式子可观察到，每次辗转交换了 x 和 y，并将 y 减去了原 x 与辗转相除所得商的乘积。 void exgcd(int a, int b, int g, int &amp;x, int &amp;y) { if (b == 0) { x = 1, y = 0; g = a; } else { exgcd(b, a % b, g, y, x); y -= x * (a / b); } } Eratosthenes 筛法 在筛选之前，先认为每个数都是素数。枚举所有数，如果这个数是素数，那么筛掉这个数的所有倍数，标记它们为“不是素数”。 bool isNotPrime[MAXN + 1]; std::vector&lt;int&gt; primes; inline void getPrimes(int n) { for (int i = 2; i &lt;= n; i++) { if (isNotPrime[i]) continue; for (int j = i * 2; j &lt;= n; j += i) isNotPrime[j] = true; } primes.reserve(n); for (int i = 2; i &lt;= n; i++) if (!isNotPrime[i]) primes.push_back(i); } 两个优化： 第二层循环可以从 开始，因为对于每个小于 的数 ， 都已经在第 次循环筛掉了。 枚举 的素数即可，因为对于每个合数 ，则必有素数 满足 且 ，所以 会在第 次循环被筛掉。 bool isNotPrime[MAXN + 1]; std::vector&lt;int&gt; primes; inline void getPrimes(int n) { int m = floor(sqrt(n + 0.5)); for (int i = 2; i &lt;= m; i++) { if (isNotPrime[i]) continue; for (int j = i * i; j &lt;= n; j += i) isNotPrime[j] = true; } primes.reserve(n); for (int i = 2; i &lt;= n; i++) if (!isNotPrime[i]) primes.push_back(i); } 欧拉函数 根据唯一分解定理，任何一个正整数 都可以写成 个素数的幂的积的形式，其中第 个素数的指数为 。即： 根据容斥原理，从总数 中先减去每个 的倍数，再把多减的补回来，再把多补的减回来 …… 最终得到公式 把求和和容斥原理的应用全部展开之后就是 程序实现就是先令结果为 ，每次把结果除掉一个 再乘上 。嗯，不是很好理解 …… 对于给定的 ，用类似筛法的思想枚举素数，每次找到一个素数后把它的倍数全部筛掉。 int phi() { int m = floor(sqrt(n + 0.5)), ans = n; for (int i = 2; i &lt;= m; i++) { if (n % i == 0) { ans = ans / i * (i - 1); while (n % i == 0) n /= i; } } if (n != 1) ans = ans / n * (n - 1); // 前面没筛干净的 return ans; } 未完待续 ……]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2012」同余方程 - 扩展欧几里得]]></title>
    <url>%2Fnoip2012-mod%2F</url>
    <content type="text"><![CDATA[求关于 x 同余方程 的最小正整数解。 链接 CodeVS 1200 Tyvj 2074 题解 扩展欧几里得裸题，注意求最小正整数解，求出来 x 要模一次 b，然后加上 b 再模一次。 代码 #include &lt;cstdio&gt; void exgcd(int a, int b, int g, int &amp;x, int &amp;y) { if (b == 0) { x = 1, y = 0; g = a; } else { exgcd(b, a % b, g, y, x); y -= x * (a / b); } } int main() { int a, b, g, x, y; scanf("%d %d", &amp;a, &amp;b); exgcd(a, b, g, x, y); x = ((x % b) + b) % b; printf("%d\n", x); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>CodeVS</tag>
        <tag>EXGCD</tag>
        <tag>Tyvj</tag>
        <tag>乘法逆元</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Link-Cut Tree 学习笔记]]></title>
    <url>%2Flink-cut-tree-notes%2F</url>
    <content type="text"><![CDATA[Link-Cut Tree 是一种用来维护动态森林连通性的数据结构，适用于动态树问题。它采用类似树链剖分的轻重边路径剖分，把树边分为实边和虚边，并用 Splay 来维护每一条实路径。Link-Cut Tree 的基本操作复杂度为均摊 ，但常数因子较大，一般效率会低于树链剖分。 定义 一棵 Link-Cut Tree 上的边分为两种：实边和虚边。每一种边都是有向的，由子节点指向父节点。首尾相连的实边组成的不可延伸的链叫做路径。路径中深度最大的节点称为路径头部，深度最小的节点称为路径尾部。 将每一条路径上的节点按照深度排序，得到一个序列，用 Splay 来维护这个序列。 每一条链对应着一棵 Splay，每棵 Splay 的根节点有一个成员 Path Parent，表示该 Splay 维护的路径的尾部的节点的父节点，整棵树的根节点所对应的 Splay 节点的 Path Parent 为空；其他节点（不是其所在 Splay 的根节点的节点）的 Path Parent 也为空。 value 用于维护点权，sum 和 max 是根据题目要求维护的链上的区间信息。reversed 表示以该节点为根的 Splay 有没有被翻转。 struct Node { Node *child[2], *parent, *pathParent; T value, sum, max; bool reversed; } 操作 Link-Cut Tree 支持以下几种基本操作： Access(u)，“访问”某个节点 u，被“访问”过的节点会与根节点之间以路径相连，并且该节点为路径头部（最下端）； Evert(u)，将某个节点 u 置为其所在树的根节点，该操作等价于把该节点到根节点所经过的所有边方向取反； Link(u, v)，将某两个节点 u 和 v 连接，执行操作后 u 成为 v 的父节点； Cut(u, v)，将某两个节点 u 和 v 分离，执行操作后 v 及其子节点组成单独的一棵树； FindRoot(u)，查找某个节点 u 所在树的根节点； MakeTree()，向森林中种植一棵新的树。 Access 操作 Expose 操作 在实现 Access 操作前，我们先来实现 Expose 操作，它的作用是将当前节点置为其所在路径的头部节点，即切断自该节点向下的部分路径。 将该节点 Splay 到其所在 Splay 的根节点； 如果该节点有右孩子，那么断开其与其右孩子的连接。 不要忘了各种标记的下放和值的维护。 void expose() { splay(); pushDown(); if (child[R]) { child[R]-&gt;parent = NULL; child[R]-&gt;pathParent = this; child[R] = NULL; maintain(); } } Splice 操作 接下来，我们来实现 Splice 操作，它的作用是将当前节点所在的路径与其尾部节点的父节点所在的路径合并，即实现了路径的向上延长。 将该节点 Splay 到其所在 Splay 的根节点； 如果该节点没有 Path Parent，那么说明该节点所在路径中包含根节点，即 Splice 操作失败。 对该节点的 Path Parent 执行 Expose 操作，将其原有的路径断开； 将该节点连接到其 Path Parent 的右孩子上，并将 Path Parent 置为空。 bool splice() { splay(); if (!pathParent) return false; pathParent-&gt;expose(); pathParent-&gt;child[R] = this; parent = pathParent; pathParent = NULL; parent-&gt;maintain(); return true; } Access 操作 有了 Expose 和 Splice，Access 就简单多了，Expose 后执行 Splice 直到失败即可。 void access() { expose(); while (splice()); } Evert 操作 首先执行 Access，将该节点与根节点之间用一条完整的路径连接，然后翻转这条路径即可。 void evert() { access(); splay(); reversed ^= 1; } Link 操作 将节点 v 置为其所在树的根，然后将其 Path Parent 置为节点 u 即可。 void link(int u, int v) { nodes[v - 1]-&gt;evert(); nodes[v - 1]-&gt;pathParent = nodes[u - 1]; } Cut 操作 Cut 操作稍微复杂一点： 将节点 u 置为其所在树的根节点，以保证 v 是 u 的子节点； 对 v 执行 Access 操作，将 v 与 u 之间用一条完整的路径连接； 对 v 执行 Splay 操作，将 v 置于其所在 Splay 的根节点； 将 v 与其左子树分离，即将路径断开。 void cut(int u, int v) { nodes[u - 1]-&gt;evert(); nodes[v - 1]-&gt;access(); nodes[v - 1]-&gt;splay(); nodes[v - 1]-&gt;pushDown(); nodes[v - 1]-&gt;child[L]-&gt;parent = NULL; nodes[v - 1]-&gt;child[L] = NULL; nodes[v - 1]-&gt;maintain(); } Query 和 Update 操作 以 QueryMax(u, v) 查询两个点之间的点权最大值为例。首先在 Node 结构体中存储 max 成员，并在 Maintain() 中维护它。 首先，如果需要查询某个点到根节点之间的点权最大值，只需先访问这个节点，即 Access(u)，然后对该节点执行 Splay 操作，将其置为其所在 Splay 的根节点，此时 u 的 max 存储的值即为 u 到其所在树的根节点的路径上的点权最大值。 如果要查询任意两点间的点权最大值，只需要先对其中一个节点执行 Evert 操作，将其置为树根，就可以转化为上述情况进行处理。 const T &amp;Node::queryMax() { access(); splay(); return max; } const T &amp;queryMax(int u, int v) { nodes[u - 1]-&gt;evert(); return nodes[v - 1]-&gt;queryMax(); } 要修改某个点的点权值，只需要对该节点执行 Splay 操作，将其置为其所在 Splay 的根节点，然后直接修改即可，这样可以避免修改时标记的向上传递。 void update(int u, const T &amp;value) { nodes[u - 1]-&gt;splay(); nodes[u - 1]-&gt;value = value; nodes[u - 1]-&gt;maintain(); } MakeTree 操作 直接新建节点就可以。 void makeTree(int u, const T &amp;value) { nodes[u - 1] = new Node(value); } 其他操作 &amp; 注意事项 进行 Splay 和 Rotate 时，要注意标记的传递； Rotate 时，需要将自己的 Path Parent 与父节点的 Path Parent 互换，以保证 Path Parent 成员的有效值总在一棵 Splay 的根节点上。 void pushDown() { if (reversed) { std::swap(child[L], child[R]); if (child[L]) child[L]-&gt;reversed ^= 1; if (child[R]) child[R]-&gt;reversed ^= 1; reversed = false; } } void maintain() { sum = value; if (child[L]) sum += child[L]-&gt;sum; if (child[R]) sum += child[R]-&gt;sum; max = value; if (child[L]) max = std::max(max, child[L]-&gt;max); if (child[R]) max = std::max(max, child[R]-&gt;max); } void rotate() { if (parent-&gt;parent) parent-&gt;parent-&gt;pushDown(); parent-&gt;pushDown(), pushDown(); std::swap(pathParent, parent-&gt;pathParent); Relation x = relation(); Node *oldParent = parent; if (oldParent-&gt;parent) oldParent-&gt;parent-&gt;child[oldParent-&gt;relation()] = this; parent = oldParent-&gt;parent; oldParent-&gt;child[x] = child[x ^ 1]; if (child[x ^ 1]) child[x ^ 1]-&gt;parent = oldParent; child[x ^ 1] = oldParent; oldParent-&gt;parent = this; oldParent-&gt;maintain(), maintain(); } void splay() { while (parent) { if (!parent-&gt;parent) rotate(); else { parent-&gt;parent-&gt;pushDown(), parent-&gt;pushDown(); if (relation() == parent-&gt;relation()) parent-&gt;rotate(), rotate(); else rotate(), rotate(); } } } 完整代码（树的统计） #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 30000; void print(void *p); template &lt;typename T&gt; struct LinkCutTree { enum Relation { L = 0, R = 1 }; struct Node { Node *child[2], *parent, *pathParent; T value, sum, max; bool reversed; Node(const T &amp;value) : reversed(false), value(value), sum(value), max(value), parent(NULL), pathParent(NULL) { child[L] = child[R] = NULL; } Relation relation() { return this == parent-&gt;child[L] ? L : R; } void pushDown() { if (reversed) { std::swap(child[L], child[R]); if (child[L]) child[L]-&gt;reversed ^= 1; if (child[R]) child[R]-&gt;reversed ^= 1; reversed = false; } } void maintain() { sum = value; if (child[L]) sum += child[L]-&gt;sum; if (child[R]) sum += child[R]-&gt;sum; max = value; if (child[L]) max = std::max(max, child[L]-&gt;max); if (child[R]) max = std::max(max, child[R]-&gt;max); } void rotate() { if (parent-&gt;parent) parent-&gt;parent-&gt;pushDown(); parent-&gt;pushDown(), pushDown(); std::swap(pathParent, parent-&gt;pathParent); Relation x = relation(); Node *oldParent = parent; if (oldParent-&gt;parent) oldParent-&gt;parent-&gt;child[oldParent-&gt;relation()] = this; parent = oldParent-&gt;parent; oldParent-&gt;child[x] = child[x ^ 1]; if (child[x ^ 1]) child[x ^ 1]-&gt;parent = oldParent; child[x ^ 1] = oldParent; oldParent-&gt;parent = this; oldParent-&gt;maintain(), maintain(); } void splay() { while (parent) { if (!parent-&gt;parent) rotate(); else { parent-&gt;parent-&gt;pushDown(), parent-&gt;pushDown(); if (relation() == parent-&gt;relation()) parent-&gt;rotate(), rotate(); else rotate(), rotate(); } } } void evert() { access(); splay(); reversed ^= 1; } void expose() { splay(); pushDown(); if (child[R]) { child[R]-&gt;parent = NULL; child[R]-&gt;pathParent = this; child[R] = NULL; maintain(); } } bool splice() { splay(); if (!pathParent) return false; pathParent-&gt;expose(); pathParent-&gt;child[R] = this; parent = pathParent; pathParent = NULL; parent-&gt;maintain(); return true; } void access() { expose(); while (splice()); } const T &amp;querySum() { access(); splay(); return sum; } const T &amp;queryMax() { access(); splay(); return max; } }; Node *nodes[MAXN]; void makeTree(int u, const T &amp;value) { nodes[u - 1] = new Node(value); } void link(int u, int v) { nodes[v - 1]-&gt;evert(); nodes[v - 1]-&gt;pathParent = nodes[u - 1]; } void cut(int u, int v) { nodes[u - 1]-&gt;evert(); nodes[v - 1]-&gt;access(); nodes[v - 1]-&gt;splay(); nodes[v - 1]-&gt;pushDown(); nodes[v - 1]-&gt;child[L]-&gt;parent = NULL; nodes[v - 1]-&gt;child[L] = NULL; nodes[v - 1]-&gt;maintain(); } const T &amp;querySum(int u, int v) { nodes[u - 1]-&gt;evert(); return nodes[v - 1]-&gt;querySum(); } const T &amp;queryMax(int u, int v) { nodes[u - 1]-&gt;evert(); return nodes[v - 1]-&gt;queryMax(); } void update(int u, const T &amp;value) { nodes[u - 1]-&gt;splay(); nodes[u - 1]-&gt;value = value; nodes[u - 1]-&gt;maintain(); } }; struct UndirectedEdge { int u, v; UndirectedEdge() {} UndirectedEdge(int u, int v) : u(u), v(v) {} } edges[MAXN - 1]; int n, q; LinkCutTree&lt;int&gt; lct; void dfs(LinkCutTree&lt;int&gt;::Node *v, int depth) { if (!v) return; dfs(v-&gt;child[LinkCutTree&lt;int&gt;::L], depth + 1); for (int i = 0; i &lt; depth; i++) putchar(' '); printf("%d, max = %d, sum = %d\n", v-&gt;value, v-&gt;max, v-&gt;sum); dfs(v-&gt;child[LinkCutTree&lt;int&gt;::R], depth + 1); } void print(void *p) { dfs((LinkCutTree&lt;int&gt;::Node *)p, 0); } int main() { scanf("%d", &amp;n); for (int i = 0; i &lt; n - 1; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v); edges[i] = UndirectedEdge(u, v); } for (int i = 1; i &lt;= n; i++) { int value; scanf("%d", &amp;value); lct.makeTree(i, value); } for (int i = 0; i &lt; n - 1; i++) { lct.link(edges[i].u, edges[i].v); } scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++) { char str[6 + 1]; scanf("%s", str); if (str[1] == 'H') { int u, t; scanf("%d %d", &amp;u, &amp;t); lct.update(u, t); } else if (str[1] == 'M') { int u, v; scanf("%d %d", &amp;u, &amp;v); printf("%d\n", lct.queryMax(u, v)); } else if (str[1] == 'S') { int u, v; scanf("%d %d", &amp;u, &amp;v); printf("%d\n", lct.querySum(u, v)); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>高级数据结构</tag>
        <tag>算法模板</tag>
        <tag>Splay</tag>
        <tag>Link-Cut Tree</tag>
        <tag>动态树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splay 学习笔记（三）]]></title>
    <url>%2Fsplay-notes-3%2F</url>
    <content type="text"><![CDATA[在《Splay 学习笔记（一）》中，我们学会了利用 Splay 来维护二叉排序树，现在让我们来把我们的 Splay 变得更加优美。 模板请见《Splay 模板 + 详细注释》。 结构体定义 两个孩子用一个数组来存，0 表示左孩子，1 表示右孩子，不需要再编写函数来获得某个孩子的引用了。 引入 count 成员，表示这个值共出现了几次，不再重复插入相同的值，效率可以得到提高，特别是求前趋后继，实现起来也会变得更加简单。 enum Relation { L = 0, R = 1 }; struct Node { Node *child[2], *parent, **root; T value; int size, count; } Splay 操作 把之前的“旋转到某位置”改为“旋转直到某节点成为自己的父节点”，不需要二级指针了，也不需要判断如果参数为 NULL 那么转到根了。 void splay(Node *targetParent = NULL) { while (parent != targetParent) { if (parent-&gt;parent == targetParent) rotate(); else if (parent-&gt;relation() == relation()) parent-&gt;rotate(), rotate(); else rotate(), rotate(); } } 节点的前趋 / 后继 直接 Splay 后求即可，不需要多次迭代了。 Node *pred() { splay(); Node *v = child[L]; while (v-&gt;child[R]) v = v-&gt;child[R]; return v; } Node *succ() { splay(); Node *v = child[R]; while (v-&gt;child[L]) v = v-&gt;child[L]; return v; } 选择 选择第 k 小的元素时，需要把循环的条件改为**k 是否在 [rank + 1, rank + count]**的范围内，迭代到右子树时也要做相应的改动。 Node *select(int k) { k++; Node *v = root; while (!(v-&gt;rank() + 1 &lt;= k &amp;&amp; v-&gt;rank() + v-&gt;count &gt;= k)) { if (k &lt; v-&gt;rank() + 1) { v = v-&gt;child[L]; } else { k -= v-&gt;rank() + v-&gt;count; v = v-&gt;child[R]; } } v-&gt;splay(); return v; } 完整代码（普通平衡树） #include &lt;cstdio&gt; #include &lt;climits&gt; const int MAXN = 100000; template &lt;typename T, T INF&gt; struct Splay { enum Relation { L = 0, R = 1 }; struct Node { Node *child[2], *parent, **root; T value; int size, count; Node(Node *parent, const T &amp;value, Node **root) : parent(parent), value(value), root(root), count(1) { child[L] = child[R] = NULL; } ~Node() { if (child[L]) delete child[L]; if (child[R]) delete child[R]; } Relation relation() { return this == parent-&gt;child[L] ? L : R; } void maintain() { size = (child[L] ? child[L]-&gt;size : 0) + (child[R] ? child[R]-&gt;size : 0) + count; } void rotate() { Relation x = relation(); Node *oldParent = parent; if (oldParent-&gt;parent) oldParent-&gt;parent-&gt;child[oldParent-&gt;relation()] = this; parent = oldParent-&gt;parent; oldParent-&gt;child[x] = child[x ^ 1]; if (child[x ^ 1]) child[x ^ 1]-&gt;parent = oldParent; child[x ^ 1] = oldParent; oldParent-&gt;parent = this; oldParent-&gt;maintain(), maintain(); if (!parent) *root = this; } void splay(Node *targetParent = NULL) { while (parent != targetParent) { if (parent-&gt;parent == targetParent) rotate(); else if (parent-&gt;relation() == relation()) parent-&gt;rotate(), rotate(); else rotate(), rotate(); } } Node *pred() { splay(); Node *v = child[L]; while (v-&gt;child[R]) v = v-&gt;child[R]; return v; } Node *succ() { splay(); Node *v = child[R]; while (v-&gt;child[L]) v = v-&gt;child[L]; return v; } int rank() { return !child[L] ? 0 : child[L]-&gt;size; } } *root; Splay() : root(NULL) { insert(INF), insert(-INF); } ~Splay() { delete root; } Node *find(const T &amp;value) { Node *v = root; while (v &amp;&amp; value != v-&gt;value) { if (value &lt; v-&gt;value) { v = v-&gt;child[L]; } else { v = v-&gt;child[R]; } } if (!v) return NULL; v-&gt;splay(); return v; } Node *insert(const T &amp;value) { Node *v = find(value); if (v) { v-&gt;count++, v-&gt;maintain(); return v; } Node **target = &amp;root, *parent = NULL; while (*target) { parent = *target; parent-&gt;size++; if (value &lt; parent-&gt;value) { target = &amp;parent-&gt;child[L]; } else { target = &amp;parent-&gt;child[R]; } } *target = new Node(parent, value, &amp;root); (*target)-&gt;splay(); return root; } void erase(const T &amp;value) { erase(find(value)); } void erase(Node *v) { if (v-&gt;count != 1) { v-&gt;splay(); v-&gt;count--; v-&gt;maintain(); return; } Node *pred = v-&gt;pred(); Node *succ = v-&gt;succ(); pred-&gt;splay(); succ-&gt;splay(pred); delete succ-&gt;child[L]; succ-&gt;child[L] = NULL; succ-&gt;maintain(), pred-&gt;maintain(); } int rank(const T &amp;value) { Node *v = find(value); if (v) return v-&gt;rank(); else { v = insert(value); int ans = v-&gt;rank(); erase(v); return ans; } } Node *select(int k) { k++; Node *v = root; while (!(v-&gt;rank() + 1 &lt;= k &amp;&amp; v-&gt;rank() + v-&gt;count &gt;= k)) { if (k &lt; v-&gt;rank() + 1) { v = v-&gt;child[L]; } else { k -= v-&gt;rank() + v-&gt;count; v = v-&gt;child[R]; } } v-&gt;splay(); return v; } const T &amp;pred(const T &amp;value) { Node *v = find(value); if (v) return v-&gt;pred()-&gt;value; else { v = insert(value); const T &amp;ans = v-&gt;pred()-&gt;value; erase(v); return ans; } } const T &amp;succ(const T &amp;value) { Node *v = find(value); if (v) return v-&gt;succ()-&gt;value; else { v = insert(value); const T &amp;ans = v-&gt;succ()-&gt;value; erase(v); return ans; } } }; int n; Splay&lt;int, INT_MAX&gt; splay; void dfs(Splay&lt;int, INT_MAX&gt;::Node *v, int depth) { if (v-&gt;child[Splay&lt;int, INT_MAX&gt;::L]) dfs(v-&gt;child[Splay&lt;int, INT_MAX&gt;::L], depth + 1); for (int i = 0; i &lt; depth; i++) { putchar(' '); } printf("%d\n", v-&gt;value); if (v-&gt;child[Splay&lt;int, INT_MAX&gt;::R]) dfs(v-&gt;child[Splay&lt;int, INT_MAX&gt;::R], depth + 1); } void print() { dfs(splay.root, 0); puts("--------------------------------------------------"); } int main() { scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) { int command, x; scanf("%d %d", &amp;command, &amp;x); if (command == 1) { splay.insert(x); } else if (command == 2) { splay.erase(x); } else if (command == 3) { printf("%d\n", splay.rank(x)); } else if (command == 4) { printf("%d\n", splay.select(x)-&gt;value); } else if (command == 5) { printf("%d\n", splay.pred(x)); } else if (command == 6) { printf("%d\n", splay.succ(x)); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>高级数据结构</tag>
        <tag>学习笔记</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1251」序列终结者 - Splay]]></title>
    <url>%2Fbzoj-1251%2F</url>
    <content type="text"><![CDATA[给定一个长度为 N 的序列，每个序列的元素是一个整数。要支持以下三种操作： 将 [L,R] 这个区间内的所有数加上 V。 将 [L,R] 这个区间翻转，比如 1 2 3 4 变成 4 3 2 1。 求 [L,R] 这个区间中的最大值。最开始所有元素都是 0。 链接 BZOJ 1251 CodeVS 4655 题解 Splay 裸题，比文艺平衡树强一点，那个没有区间修改和查询。 区间修改：和翻转一样，维护一个 lazy-tag，然后 pushDown() 的时候下放即可。 区间查询：维护一个子树值的和，查询的时候直接选择区间然后返回这个和。需要在 maintain() 中维护。 细节需要注意，各种下放 …… 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 50000; const int MAXM = 100000; void print(); template &lt;typename T&gt; struct Splay { enum Relation { L = 0, R = 1 }; struct Node { Node *child[2], *parent, **root; T value, max, lazy; int size; bool reversed, bound; Node(Node *parent, const T &amp;value, Node **root, bool bound = false) : parent(parent), value(value), lazy(0), max(value), reversed(false), root(root), bound(bound), size(1) { child[L] = child[R] = NULL; } ~Node() { if (child[L]) delete child[L]; if (child[R]) delete child[R]; } Relation relation() { return this == parent-&gt;child[L] ? L : R; } void maintain() { pushDown(); size = 1; if (child[L]) size += child[L]-&gt;size; if (child[R]) size += child[R]-&gt;size; max = value; if (child[L]) max = std::max(max, child[L]-&gt;max); if (child[R]) max = std::max(max, child[R]-&gt;max); } void pushDown() { if (reversed) { if (child[L]) child[L]-&gt;reversed ^= 1; if (child[R]) child[R]-&gt;reversed ^= 1; std::swap(child[L], child[R]); reversed = false; } if (lazy) { if (child[L]) child[L]-&gt;lazy += lazy, child[L]-&gt;value += lazy, child[L]-&gt;max += lazy; if (child[R]) child[R]-&gt;lazy += lazy, child[R]-&gt;value += lazy, child[R]-&gt;max += lazy; lazy = 0; } } void rotate() { if (parent-&gt;parent) parent-&gt;parent-&gt;pushDown(); parent-&gt;pushDown(), pushDown(); Relation x = relation(); Node *oldParent = parent; if (oldParent-&gt;parent) oldParent-&gt;parent-&gt;child[oldParent-&gt;relation()] = this; parent = oldParent-&gt;parent; oldParent-&gt;child[x] = child[x ^ 1]; if (child[x ^ 1]) child[x ^ 1]-&gt;parent = oldParent; child[x ^ 1] = oldParent; oldParent-&gt;parent = this; oldParent-&gt;maintain(), maintain(); if (!parent) *root = this; } void splay(Node *targetParent = NULL) { while (parent != targetParent) { if (parent-&gt;parent == targetParent) rotate(); else { parent-&gt;parent-&gt;pushDown(), parent-&gt;pushDown(); if (parent-&gt;relation() == relation()) parent-&gt;rotate(), rotate(); else rotate(), rotate(); } } } int rank() { return !child[L] ? 0 : child[L]-&gt;size; } } *root; Splay() : root(NULL) {} ~Splay() { if (root) delete root; } void build(const T *a, int n) { root = buildRange(a, 1, n, NULL); buildBound(L), buildBound(R); } Node *buildRange(const T *a, int l, int r, Node *parent) { if (l &gt; r) return NULL; int mid = l + ((r - l) &gt;&gt; 1); Node *v = new Node(parent, a[mid - 1], &amp;root); if (l != r) { v-&gt;child[L] = buildRange(a, l, mid - 1, v); v-&gt;child[R] = buildRange(a, mid + 1, r, v); } v-&gt;maintain(); return v; } void buildBound(Relation x) { Node **v = &amp;root, *parent = NULL; while (*v) { parent = *v; parent-&gt;size++; v = &amp;parent-&gt;child[x]; } *v = new Node(parent, 0, &amp;root, true); (*v)-&gt;maintain(); } Node *select(int k) { k++; Node *v = root; //v-&gt;pushDown(); while (v-&gt;pushDown(), k != v-&gt;rank() + 1) { if (k &lt; v-&gt;rank() + 1) { v = v-&gt;child[L]; } else { k -= v-&gt;rank() + 1; v = v-&gt;child[R]; } //printf("select(k = %d)\n", k); //print(); //v-&gt;pushDown(); } v-&gt;splay(); return v; } Node *select(int l, int r) { Node *lbound = select(l - 1); Node *rbound = select(r + 1); lbound-&gt;splay(); rbound-&gt;splay(lbound); return rbound-&gt;child[L]; } void update(int l, int r, const T &amp;addition) { Node *range = select(l, r); range-&gt;value += addition, range-&gt;lazy += addition, range-&gt;max += addition; } const T &amp;queryMax(int l, int r) { Node *range = select(l, r); return range-&gt;max; } void reverse(int l, int r) { Node *range = select(l, r); range-&gt;reversed ^= 1; } void fetch(T *a) { dfsFetch(a, root); } void dfsFetch(T *&amp;a, Node *v) { if (!v) return; v-&gt;pushDown(), v-&gt;maintain(); dfsFetch(a, v-&gt;child[L]); if (!v-&gt;bound) *a++ = v-&gt;value; dfsFetch(a, v-&gt;child[R]); } }; int n, m, a[MAXN]; Splay&lt;int&gt; splay; void dfs(Splay&lt;int&gt;::Node *v, int depth) { if (!v) return; dfs(v-&gt;child[Splay&lt;int&gt;::L], depth + 1); v-&gt;pushDown(), v-&gt;maintain(); for (int i = 0; i &lt; depth; i++) { putchar(' '); } printf("%d : %d\n", v-&gt;value, v-&gt;size); dfs(v-&gt;child[Splay&lt;int&gt;::R], depth + 1); } void print() { dfs(splay.root, 0); puts("--------------------------------------------------"); } int main() { scanf("%d %d", &amp;n, &amp;m); memset(a, 0, sizeof(int) * n); splay.build(a, n); for (int i = 0; i &lt; m; i++) { int command; scanf("%d", &amp;command); if (command == 1) { int l, r, addition; scanf("%d %d %d", &amp;l, &amp;r, &amp;addition); splay.update(l, r, addition); } else if (command == 2) { int l, r; scanf("%d %d", &amp;l, &amp;r); splay.reverse(l, r); } else if (command == 3) { int l, r; scanf("%d %d", &amp;l, &amp;r); printf("%d\n", splay.queryMax(l, r)); } else throw; } //print(); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>高级数据结构</tag>
        <tag>BZOJ</tag>
        <tag>CodeVS</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2006」金明的预算方案 - 背包 DP + 树形 DP]]></title>
    <url>%2Fnoip2006-budget%2F</url>
    <content type="text"><![CDATA[金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的。 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 链接 CodeVS 1155 Tyvj 1057 洛谷 1064 Vijos 1313 题解 其实题挺水的，直接枚举选哪个附件就好，但学了树形 DP 就要写一写嘛。 首先，我们有一个 01 背包的方程： 对某个节点求解时，先对每一个子物品递归求解，然后进行一次 01 背包，得到一个由该物品及其附属物品组成的泛化物品组，然后一级一级地传到最顶层。 设置一个价值与费用均为 0 的虚拟节点并将其作为所有无依赖的物品的父节点，求解 0 即为最终结果。 更具体的讲解详见《背包九讲》。~我太弱了讲不明白呢。~ PS：有个“坑”就是题目中的背包容量太大太大了，是妥妥的要 TLE 的（只能过前五个），但是因为背包容量和每件物品的体积都是 10 的倍数，所以读入数据后直接除以 10 就好。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; const int MAXN = 60; const int MAXV = 3200; int n, V; struct Tree { Tree *children, *next; int c, w; int f[MAXV + 1]; Tree() {} Tree(Tree *parent, int c, int w) : next(parent-&gt;children), c(c), w(w) { memset(f, 0, sizeof(f)); } void solve() { for (int v = V; v &gt;= c; v--) f[v] = w; for (Tree *t = children; t; t = t-&gt;next) { t-&gt;solve(); for (int v = V - c; v &gt;= t-&gt;c; v--) { for (int i = t-&gt;c; i &lt;= std::min(V - c, v + c); i++) { f[v + c] = std::max(f[v + c], f[v + c - i] + t-&gt;f[i]); } } } } } trees[MAXN + 1]; inline void addTree(int id, int parent, int c, int w) { trees[parent].children = new (&amp;trees[id]) Tree(&amp;trees[parent], c, w); } int main() { scanf("%d %d", &amp;V, &amp;n); V /= 10; for (int i = 0; i &lt; n; i++) { int c, p, q; scanf("%d %d %d", &amp;c, &amp;p, &amp;q); addTree(i + 1, q, c / 10, c * p); } trees[0].solve(); printf("%d\n", trees[0].f[V]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形 DP</tag>
        <tag>CodeVS</tag>
        <tag>背包 DP</tag>
        <tag>Tyvj</tag>
        <tag>洛谷</tag>
        <tag>Vijos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2442」修剪草坪 - 线性 DP + 单调队列]]></title>
    <url>%2Fbzoj-2442%2F</url>
    <content type="text"><![CDATA[FJ 有 N（）只排成一排的奶牛，编号为 1 到 N。每只奶牛的效率是不同的，奶牛 i 的效率为（）。 靠近的奶牛们很熟悉，因此，如果 FJ 安排超过 K 只连续的奶牛，那么，这些奶牛就会罢工去开派对。因此，现在 FJ 需要你的帮助，计算 FJ 可以得到的最大效率，并且该方案中没有连续的超过 K 只奶牛。 链接 CodeVS 4654 BZOJ 2442 题解 一个 的解法是采用线性 DP，用 表示第 i 头奶牛的效率， 表示选择前 i 只奶牛中部分或全部可获得的最大效率，对于每次状态转移，枚举 j（），计算不选择第 j 头奶牛时的最大效率。 边界条件为： 用前缀和数组来维护效率和，每次转移要耗费 的时间。 实现代码：（注意边界判断和数组访问的 -1） f[0] = a[0]; for (int i = 2; i &lt;= n; i++) { for (int j = std::max(i - k, 0); j &lt; i; j++) { if (j == 0) f[i - 1] = std::max(f[i - 1], prefixSum[i - 1] - 0); else f[i - 1] = std::max(f[i - 1], (j == 1 ? 0 : f[j - 1 - 1]) + prefixSum[i - 1] - prefixSum[j + 1 - 1 - 1]); f[i - 1] = std::max(f[i - 1], f[i - 1 - 1]); } } 现在让我们来尝试优化这个 DP，首先，设 忽略 ，把转移方程中的前缀和项展开 令 则转移方程的前半部分化为 用一个长度为 k + 1 的单调队列来维护 ，然后就可以优化到 的计算出每个状态。 最终，新的转移方程为 两个坑： 加起来妥妥的爆 int，快上 long long 保平安； 边界条件！边界条件！边界条件！ ~（才不是坑呢是我太弱了啦）~ 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;deque&gt; const int MAXN = 100000; template &lt;typename T&gt; struct MonotoneQueue { std::deque&lt;T&gt; q, m; void push(const T &amp;x) { q.push_back(x); while (!m.empty() &amp;&amp; m.back() &lt; x) m.pop_back(); m.push_back(x); } void pop() { T x = q.front(); q.pop_front(); if (x == m.front()) m.pop_front(); } size_t size() { return q.size(); } T top() { return m.front(); } }; int n, k, a[MAXN]; long long prefixSum[MAXN], f[MAXN + 1]; inline void makePrefixSum() { prefixSum[0] = a[0]; for (int i = 0; i &lt; n; i++) { prefixSum[i] = prefixSum[i - 1] + a[i]; } } inline long long sum(int i, int j) { if (i &gt; j) return 0; return i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1]; } int main() { scanf("%d %d", &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) { scanf("%d", &amp;a[i]); } makePrefixSum(); MonotoneQueue&lt;long long&gt; q; q.push(0); for (int i = 1; i &lt;= n; i++) { if (q.size() == k + 1) q.pop(); q.push((i == 1 ? 0 : f[i - 1 - 1]) - prefixSum[i + 1 - 1 - 1]); f[i - 1] = q.top() + prefixSum[i - 1]; if (i != 1) f[i - 1] = std::max(f[i - 1], f[i - 1 - 1]); } printf("%lld\n", f[n - 1]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BZOJ</tag>
        <tag>单调队列</tag>
        <tag>CodeVS</tag>
        <tag>USACO</tag>
        <tag>线性 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeVS 3269」混合背包 - 背包 DP + 单调队列]]></title>
    <url>%2Fcodevs-3269-monotone-queue%2F</url>
    <content type="text"><![CDATA[背包体积为 V（&lt;= 200,000），给出 N（&lt;= 200）个物品，每个物品占用体积为 Vi，价值为 Wi，每个物品要么至多取 1 件，要么至多取 Mi（&gt; 1）件，要么数量无限，求装入背包内物品总价值的最大值。 链接 CodeVS 3269 题解 01 和完全这两种之前写过，这里就重点说说怎么用单调队列来解多重。 首先，对于多重背包的每件物品，n 表示这件物品的数量，w 表示这件物品的体积，c 表示这件物品的价值。 朴素的多重背包状态转移方程为： 设 ，。 m 的意义为，如果当前状态的背包容量全部用来放当前物品，能放多少件。 r 的意义为，如果当前状态的背包容量全部用来放当前物品，则剩下的容量是多少。 到此，我们可以修改一下方程，使原来的枚举 i 变为先枚举 r，然后在 上枚举 d，以 代替原来的 i。 令 代入上式得 进一步化为 令 代入上式得 由此得到一个可以用单调队列优化的方程，结合方程我们知道，是由之前的 n + 1 项的最大值推出的，于是用一个长度为 n + 1 的单调队列维护 ，就可以 地求出每个状态。 需要注意的是，在使用单调队列实现这个算法时，方程中的 m 应该被替换为当前状态对应的 k，因为枚举的 k 总是当前状态的背包容量全部用来放当前物品的最大件数。 代码 #include &lt;cstdio&gt; #include &lt;deque&gt; #include &lt;algorithm&gt; const int MAXN = 200; const int MAXV = 200000; template &lt;typename T&gt; struct MonotoneQueue { std::deque&lt;T&gt; q, m; void push(const T &amp;x) { q.push_back(x); while (!m.empty() &amp;&amp; m.back() &lt; x) m.pop_back(); m.push_back(x); } void pop() { T x = q.front(); q.pop_front(); if (x == m.front()) m.pop_front(); } size_t size() { return q.size(); } T top() { return m.front(); } }; int n, V; int f[MAXV + 1]; inline void pack(int c, int w, int n) { if (n == 1) { for (int v = V; v &gt;= c; v--) { f[v] = std::max(f[v], f[v - c] + w); } } else if (n == -1) { for (int v = c; v &lt;= V; v++) { f[v] = std::max(f[v], f[v - c] + w); } } else { n = std::min(n, V / c); for (int r = 0; r &lt; c; r++) { MonotoneQueue&lt;int&gt; q; int m = (V - r) / c; for (int k = 0; k &lt;= m; k++) { if (q.size() == n + 1) q.pop(); q.push(f[k * c + r] - k * w); f[k * c + r] = q.top() + k * w; } } } } int main() { scanf("%d %d", &amp;n, &amp;V); for (int i = 0; i &lt; n; i++) { int c, w, n; scanf("%d %d %d", &amp;c, &amp;w, &amp;n); pack(c, w, n); } printf("%d\n", f[V]); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>单调队列</tag>
        <tag>CodeVS</tag>
        <tag>背包 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调队列学习笔记]]></title>
    <url>%2Fmonotone-queue-notes%2F</url>
    <content type="text"><![CDATA[单调队列，就是单调的队列，通常用来解决滑动窗口的最值问题，可以应用到 DP 的优化上。一个单调队列中的元素总是单调递增（或递减）的。 滑动窗口 例：有一个队列，每次从队尾加入一个元素，或从队首删除一个元素，并在任何时刻求整个队列的最大值。 一个很直接的想法是使用优先队列 priority_queue 即堆，堆可以在 的时间内求出最大值，但每次加入或删除时需要 的时间完成堆的调整，但是用了堆后就不能按照进队的顺序出队了！这时候你可以大胆地写一个平衡树或者 set——如果你不怕多出来的 和平衡树常数带来的 TLE 的话。 单调队列就是解决这类问题的数据结构，我们用一个辅助队列，使该队列的首元素总是原队列的最大值，这样就可以 地求出队列的最大值了。 维护单调队列 现有需要维护最大值的队列 Q，和辅助队列 M，设计算法使任何时刻时 M 队首元素都是当前 Q 的最大值。 每次在 Q 的队尾加入元素 x 时，也将其加入到 M 中，从 M 的队尾向前遍历，将遍历到的所有 小于等 x 的元素全部删除，因为它们在 x 之前被加入到队列中，在 x 出队前它们就已经都出队了，即在 x 出队前这些元素不可能成为队列中的最大值。 每次在 Q 的队首删除元素时，将要删除的元素与 M 的队首元素比较，如果该元素与 M 队首元素相等，即该元素为执行删除操作前队列的最大值，则同时也要将 M 的队首元素删除，使原 Q 的次小值成为 M 的队首元素，保证 M 的队首元素是删除操作后 Q 中最大的元素。 应用 状态转移方程形如 的动态规划可以使用单调队列来优化。 实现 因为同时要从队列的两端添加、删除，所以要使用 deque 实现，而不是 queue。 template &lt;typename T&gt; struct MonotoneQueue { std::deque&lt;T&gt; q, m; void push(const T &amp;x) { q.push_back(x); while (!m.empty() &amp;&amp; m.back() &lt; x) m.pop_back(); m.push_back(x); } void pop() { T x = q.front(); q.pop_front(); if (x == m.front()) m.pop_front(); } size_t size() { return q.size(); } T top() { return m.front(); } };]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>高级数据结构</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeVS 1345」饥饿的奶牛 - 线性 DP]]></title>
    <url>%2Fcodevs-1345%2F</url>
    <content type="text"><![CDATA[在 n（≤ 1000）条线段中选出若干条，保证任意两条线段没有公共点（端点也不能重合），使总长度最大。 链接 CodeVS 1345 题解 刚开始确实晕了，又是想线段树又是想背包 …… 保证线段不重合是个难点 …… 解决方法以线段的右端点排序，去除后效性。 以 表示前 i 条线段中选出若干条（必选第 i 条）的最大总长度，则转移方程为： 简单地说，就是只要保证最后一条线段不与当前线段重合，就可以添加当前线段。 注意最终答案是 ，而不一定是 ，因为不选最后一条线段可能比选最后一条线段更优。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 1000; struct Range { int l, r; int length() { return r - l + 1; } bool operator&lt;(const Range &amp;other) const { if (r == other.r) return l &lt; other.l; else return r &lt; other.r; } } a[MAXN]; int n, f[MAXN]; int main() { scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) { scanf("%d %d", &amp;a[i].l, &amp;a[i].r); } std::sort(a, a + n); int ans = 0; for (int i = 0; i &lt; n; i++) { int max = 0; for (int j = 0; j &lt; i; j++) { if (a[j].r &lt; a[i].l) max = std::max(max, f[j]); } f[i] = a[i].length() + max; ans = std::max(ans, f[i]); } printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>CodeVS</tag>
        <tag>USACO</tag>
        <tag>线性 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2003」数字游戏 - 划分 DP]]></title>
    <url>%2Fnoip2003-game%2F</url>
    <content type="text"><![CDATA[在你面前有一圈整数（一共 n（≤ 50）个），你要按顺序将其分为 m（≤ 9）个部分，各部分内的数字相加，相加所得的 m 个结果对 10 取模后再相乘，最终得到一个数 k。游戏的要求是使你所得的 k 最大或者最小。 链接 CodeVS 1085 Tyvj 1901 洛谷 1043 题解 又是一道划分 DP，不过坑挺多的 …… 一是枚举断点，二是注意负数对 10 取模后的结果是正数。 以最大值为例，以“分的部分”的数量划分阶段，用 表示前 i 个数划分为 j 个部分所得的最大值，状态转移方程为： 边界条件为： 求和可以用前缀和来维护，但是注意枚举每个断点都必须重新初始化前缀和。 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;cstring&gt; #include &lt;typeinfo&gt; #include &lt;algorithm&gt; typedef const int &amp;(*Extreme)(const int &amp;, const int &amp;); const int MAXN = 50; const int MAXM = 9; int n, m, a[MAXN], prefixSum[MAXN]; int ans[MAXN][MAXM]; bool calced[MAXN][MAXM]; inline int mod10(int x) { return ((x % 10) + 10) % 10; } inline void initPrefixSum() { prefixSum[0] = a[0]; for (int i = 1; i &lt; n; i++) { prefixSum[i] = prefixSum[i - 1] + a[i]; } } inline int sum(int i, int j) { return mod10(i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1]); } int search(int i, int j, Extreme extreme) { if (!calced[i - 1][j - 1]) { if (j == 1) ans[i - 1][j - 1] = sum(1, i); else { for (int k = j - 1; k &lt;= i - 1; k++) { ans[i - 1][j - 1] = extreme(ans[i - 1][j - 1], search(k, j - 1, extreme) * sum(k + 1, i)); } } //printf("f[%d][%d] = %d\n", i, j, ans[i - 1][j - 1]); calced[i - 1][j - 1] = true; } return ans[i - 1][j - 1]; } inline void work(int &amp;ansMin, int &amp;ansMax) { /*for (int i = 0; i &lt; n; i++) { printf("%d ", a[i]); } putchar('\n');*/ initPrefixSum(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { ans[i][j] = INT_MIN, calced[i][j] = false; } } ansMax = std::max(ansMax, search(n, m, std::max)); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { ans[i][j] = INT_MAX, calced[i][j] = false; } } ansMin = std::min(ansMin, search(n, m, std::min)); } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) { scanf("%d", &amp;a[i]); } int ansMin = INT_MAX, ansMax = INT_MIN; for (int i = 0; i &lt; n; i++) { int first = a[0]; for (int i = 0; i &lt; n - 1; i++) { a[i] = a[i + 1]; } a[n - 1] = first; work(ansMin, ansMax); } printf("%d\n%d\n", ansMin, ansMax); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>CodeVS</tag>
        <tag>Tyvj</tag>
        <tag>划分 DP</tag>
        <tag>NOIP</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2006」能量项链 - 区间 DP]]></title>
    <url>%2Fnoip2006-energy%2F</url>
    <content type="text"><![CDATA[在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为（Mars单位），新产生的珠子的头标记为m，尾标记为n。需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。 链接 CodeVS 1154 Tyvj 1056 题解 首先，项链是一个环，枚举断点给它拆开。 区间DP，用 表示第 i 颗珠子的头标记（即第 i + 1 颗珠子的尾标记），用 表示第 i 到第 j 颗珠子聚合成一颗后释放能量的最大值，枚举 k，自 k 处断开后，无论左右两段如何聚合，两段分别聚合成的两个珠子的标记值是不变的，即状态转移方程为： 边界条件为： 注意代码编写时，访问最后一颗珠子的尾标记时，会越界，可以通过将下标对珠子总数取模的方法解决，因为最后一颗珠子的尾标记等于第一颗珠子的头标记。 总时间复杂度为 ，刚好解决 的最大测试点 TvT。 调试可费了大功夫，详见注释掉的代码。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;cassert&gt; const int MAXN = 100; int n, a[MAXN]; int ans[MAXN][MAXN]; bool calced[MAXN][MAXN]; int search(int i, int j) { if (i == j) return 0; if (!calced[i - 1][j - 1]) { if (j - i == 1) ans[i - 1][j - 1] = a[i - 1] * a[j - 1] * a[(j + 1 - 1) % (n)]; else { ans[i - 1][j - 1] = 0; int p = a[i - 1] * a[(j + 1 - 1) % (n)]; int m = -1; for (int k = i; k &lt;= j - 1; k++) { ans[i - 1][j - 1] = std::max(ans[i - 1][j - 1], search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)]); /*if (search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)] &gt; ans[i - 1][j - 1]) { ans[i - 1][j - 1] = search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)]; m = k; }*/ } //printf("%d %d %d\n", i, (m + 1), (j + 1)); //printf("from k = %d, %d * %d * %d, ", m, a[i - 1], a[(m + 1 - 1) % (n - 1)], a[(j + 1 - 1) % (n - 1)]); } calced[i - 1][j - 1] = true; //printf("f[%d][%d] = %d\n", i, j, ans[i - 1][j - 1]); } return ans[i - 1][j - 1]; } int main() { scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) { scanf("%d", &amp;a[i]); } int ans = 0; for (int i = 0; i &lt; n; i++) { int first = a[0]; for (int i = 0; i &lt; n - 1; i++) { a[i] = a[i + 1]; } a[n - 1] = first; memset(calced, 0, sizeof(calced)); /*for (int i = 0; i &lt; n; i++) { printf("%d ", a[i]); } putchar('\n');*/ ans = std::max(ans, search(1, n)); } printf("%d\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>CodeVS</tag>
        <tag>Tyvj</tag>
        <tag>区间 DP</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Tyvj 3317」火车票 - 划分 DP]]></title>
    <url>%2Ftyvj-3317%2F</url>
    <content type="text"><![CDATA[铁路线上有n（2 ≤ n ≤ 10000）个火车站，每个火车站到该线路的首发火车站距离都是已知的。任意两站之间的票价如下表所示： 其中L1，L2，L3，C1，C2，C3都是已知的正整数，且( , )。显然若两站之间的距离大于 L3，那么从一站到另一站至少要买两张票。 注意：每一张票在使用时只能从一站开始到另一站结束。 对于给出的起点和终点，求出最省钱的方案。 链接 Tyvj 3317 CodeVS 1349 题解 以经过火车站站点的数量划分阶段，用 表示从站点 0 到站点 i 的距离，用 表示从起点 s 到站点 i 所需要的最少花费，则转移方程为： 边界条件为 代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 10000; int n, a[MAXN], s, t; int L1, L2, L3, C1, C2, C3; int ans[MAXN]; bool calced[MAXN]; inline int cost(int s, int t) { int L = a[t - 1] - a[s - 1]; if (L &gt; L3) return INT_MAX; else if (L &gt; L2) return C3; else if (L &gt; L1) return C2; else return C1; } int search(int i) { if (i == s) return 0; if (!calced[i - 1]) { ans[i - 1] = INT_MAX; for (int k = s; k &lt; i; k++) { if (cost(k, i) == INT_MAX) continue; ans[i - 1] = std::min(ans[i - 1], search(k) + cost(k, i)); } calced[i - 1] = true; } return ans[i - 1]; } int main() { scanf("%d %d %d %d %d %d", &amp;L1, &amp;L2, &amp;L3, &amp;C1, &amp;C2, &amp;C3); scanf("%d\n%d %d", &amp;n, &amp;s, &amp;t); for (int i = 1; i &lt; n; i++) { scanf("%d", &amp;a[i]); } if (s &gt; t) std::swap(s, t); printf("%d\n", search(t)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>CodeVS</tag>
        <tag>Tyvj</tag>
        <tag>划分 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splay 模板 + 详细注释]]></title>
    <url>%2Fsplay-template%2F</url>
    <content type="text"><![CDATA[普通平衡树的模板。 插入、查询、删除、前趋、后继、排名、选择。 更新于 2016 年 1 月 11 日：insert 有锅，根节点处重复插入时没有使 size 增加。 #include &lt;cstdio&gt; #include &lt;climits&gt; struct Splay { struct Node { // root 可能会被修改，使用指向指针的指针 Node *fa, *ch[2], **root; // x 表示这个节点上的数 // size 表示整棵树（左右子树和自身）的大小 // cnt 表示这个数 x 有多少个 int x, size, cnt; Node(Node **root, Node *fa, int x) : root(root), fa(fa), x(x), cnt(1), size(1) { ch[0] = ch[1] = NULL; // 不要忘记初始化 } // 如果当前节点是其父节点的左儿子，返回 0 否则返回 1 int relation() { return this == fa-&gt;ch[0] ? 0 : 1; } void maintain() { size = cnt; if (ch[0]) size += ch[0]-&gt;size; if (ch[1]) size += ch[1]-&gt;size; } void rotate() { // 旧的父节点 Node *old = fa; // 旋转前当前节点与父节点的关系 int r = relation(); // 自身 &lt;--&gt; 父节点的父节点 fa = old-&gt;fa; if (old-&gt;fa) { // 如果父节点有父节点（不是根），那么用当前节点替换父节点的父节点中父节点的位置的指向 old-&gt;fa-&gt;ch[old-&gt;relation()] = this; } // 原有的另一个子节点 &lt;--&gt; 原有的父节点 if (ch[r ^ 1]) { ch[r ^ 1]-&gt;fa = old; } old-&gt;ch[r] = ch[r ^ 1]; // 右边的 ch[r ^ 1] 相当于 this-&gt;ch[r ^ 1] // 原有的父节点 作为自身的子节点 old-&gt;fa = this; ch[r ^ 1] = old; // 更新维护信息 old-&gt;maintain(); maintain(); // 如果转到了根，更新储存的指向根节点的指针 if (fa == NULL) { *root = this; } } // 旋转到某一特定位置，如在删除时将后继节点旋转为根的右儿子 // target 为目标父节点，缺省参数为 NULL，即旋转直到成为根（没有父节点） void splay(Node *target = NULL) { while (fa != target) // while (父节点不是目标父节点) { if (fa-&gt;fa == target) // 父节点的父节点是目标父节点，直接转一次 { rotate(); } else if (fa-&gt;relation() == relation()) // 关系相同，先转父节点，再转自身 { fa-&gt;rotate(); rotate(); } else { rotate(); rotate(); } } } // 前趋，全称 precursor 或 predecessor Node *pred() { // 左子树的最右点 Node *v = ch[0]; while (v-&gt;ch[1]) v = v-&gt;ch[1]; return v; } // 后继，全称 successor Node *succ() { // 右子树的最左点 Node *v = ch[1]; while (v-&gt;ch[0]) v = v-&gt;ch[0]; return v; } // 求一个节点的排名，即左子树大小 int rank() { return ch[0] ? ch[0]-&gt;size : 0; } } *root; Splay() : root(NULL) { insert(INT_MAX); insert(INT_MIN); } Node *insert(int x) { // v 是一个指向指针的指针 // 表示要插入到的位置 // 如果 v 指向一个空指针 // 那么就可以插入到这里 // // fa 是新节点的父节点 Node **v = &amp;root, *fa = NULL; while (*v != NULL &amp;&amp; (*v)-&gt;x != x) // 直到找到一个空位置，或者找到原有的值为 x 的节点 { fa = *v; // 以上一次找到的不空的 v 作为父节点 fa-&gt;size++; // 因为要在这棵子树下插入一个新的节点 // 根据大小向左右子树迭代 if (x &lt; fa-&gt;x) { v = &amp;fa-&gt;ch[0]; } else { v = &amp;fa-&gt;ch[1]; } } if (*v != NULL) { (*v)-&gt;cnt++; (*v)-&gt;size++; // 锅 } else { (*v) = new Node(&amp;root, fa, x); } (*v)-&gt;splay(); // 伸展之后，*v 这个位置存的可能不再是新节点（因为父子关系改变了，而 v 一般指向一个节点的某个子节点的位置） // 直接返回根 return root; } Node *find(int x) { // 从根节点开始找 Node *v = root; while (v != NULL &amp;&amp; v-&gt;x != x) { if (x &lt; v-&gt;x) { v = v-&gt;ch[0]; } else { v = v-&gt;ch[1]; } } if (v) v-&gt;splay(); return v; } // 删除一个节点 void erase(Node *v) { Node *pred = v-&gt;pred(), *succ = v-&gt;succ(); pred-&gt;splay(); succ-&gt;splay(pred); // 使后继成为前趋（根）的右儿子 // 此时后继的左儿子即为要删除的节点 v，且 v 此时为叶子节点 if (v-&gt;size &gt; 1) { // 如果存在不止一个 x，只需将计数减一 v-&gt;size--; v-&gt;cnt--; } else { delete succ-&gt;ch[0]; // 使用 delete 关键字（严格地说，new 和 delete 是运算符）释放 new 分配的内存 succ-&gt;ch[0] = NULL; // 不要忘记置空 } // 删了节点，需要将大小减小 succ-&gt;size--; pred-&gt;size--; } // 删除一个数 void erase(int x) { Node *v = find(x); if (!v) return; // 没有找到要删的节点，直接返回（一般题目中不会出现这种情况） erase(v); } // 求一个数的前趋 int pred(int x) { Node *v = find(x); if (v == NULL) { v = insert(x); int res = v-&gt;pred()-&gt;x; erase(v); return res; } else { return v-&gt;pred()-&gt;x; } } // 求一个数的后继 int succ(int x) { Node *v = find(x); if (v == NULL) { v = insert(x); int res = v-&gt;succ()-&gt;x; erase(v); return res; } else { return v-&gt;succ()-&gt;x; } } // 求一个数的排名 int rank(int x) { Node *v = find(x); if (v == NULL) { v = insert(x); // 此时 v 已经是根节点了，因为新插入插入节点会被伸展 int res = v-&gt;rank(); // 因为有一个无穷小，所以不需要 +1 erase(v); return res; } else { // 此时 v 已经是根节点了，因为查找到的节点会被伸展 return v-&gt;rank(); } } // 求第 k 小的数 int select(int k) { Node *v = root; while (!(k &gt;= v-&gt;rank() &amp;&amp; k &lt; v-&gt;rank() + v-&gt;cnt)) { if (k &lt; v-&gt;rank()) { // 要查的第 k 比当前节点的排名小，需要继续在左子树中查询 v = v-&gt;ch[0]; } else { k -= v-&gt;rank() + v-&gt;cnt; v = v-&gt;ch[1]; } } v-&gt;splay(); return v-&gt;x; } } splay; int main() { int n; scanf("%d", &amp;n); while (n--) { int opt, x; scanf("%d %d", &amp;opt, &amp;x); if (opt == 1) { splay.insert(x); } else if (opt == 2) { splay.erase(x); } else if (opt == 3) { printf("%d\n", splay.rank(x)); } else if (opt == 4) { printf("%d\n", splay.select(x)); } else if (opt == 5) { printf("%d\n", splay.pred(x)); } else if (opt == 6) { printf("%d\n", splay.succ(x)); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>高级数据结构</tag>
        <tag>算法模板</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeVS 2598」编辑距离问题 - 线性 DP]]></title>
    <url>%2Fcodevs-2598%2F</url>
    <content type="text"><![CDATA[设 A 和 B 是 2 个字符串。要用最少的字符操作将字符串 A 转换为字符串 B。这里所说的字符操作包括： 删除一个字符； 插入一个字符； 将一个字符改为另一个字符。 求将字符串 A 变换为字符串 B 所用的最少字符操作数，即 A 到 B 的编辑距离。 字符串 A、B 的长度均不超过4000。 链接 CodeVS 2598 题解 字符串的题乍一看都很恶心，但这道题仔细想想还是很简单的。用 f[i][j] 表示字符串 A 的前 i 个字符到字符串 B 的前 j 个字符的编辑距离，则转移方程为： 当 时，当前位置无需编辑，直接等于上一位的编辑距离。 当 时，有三种情况： 字符串 B 的前 j 位可由 编辑到 后插入 B 的第 j 个字符得到。 字符串 B 的前 j 位可由 编辑到 后删除 A 的第 i 个字符得到。 字符串 B 的前 j 位可由 编辑到 后修改 A 的第 i 个字符为 B 的第 j 个字符得到。 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 4000; char s1[MAXN + 1], s2[MAXN + 1]; int n1, n2, ans[MAXN][MAXN]; bool calced[MAXN][MAXN]; int search(int i, int j) { if (i == 0) return j; if (j == 0) return i; if (!calced[i - 1][j - 1]) { if (s1[i - 1] == s2[j - 1]) { ans[i - 1][j - 1] = search(i - 1, j - 1); } else { ans[i - 1][j - 1] = INT_MAX; ans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j - 1) + 1); ans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j) + 1); ans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i, j - 1) + 1); } calced[i - 1][j - 1] = true; } return ans[i - 1][j - 1]; } int main() { scanf("%s %s", s1, s2); n1 = strlen(s1), n2 = strlen(s2); printf("%d\n", search(n1, n2)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>字符串</tag>
        <tag>CodeVS</tag>
        <tag>线性 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2000」乘积最大 - 划分 DP]]></title>
    <url>%2Fnoip2000-cheng-ji-zui-da%2F</url>
    <content type="text"><![CDATA[在一个长度为 N（&lt;= 40）的数字字符串中加上 K（&lt;= 6）个乘号，使所得表达式值最大。 链接 CodeVS 1017 题解 考虑划分 DP，以加入的乘号数量作为划分阶段，用 f[n][k] 表示原数字前 n 位中加入 k 个乘号所得表达式的最大值，预处理出 a[i][j] 表示原数字第 i 位到第 j 位组成的数字，则转移方程为： 因为数据较水，所以使用 long long 即可，无需高精。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 40; const int MAXK = 6; int n, k; char num[MAXN + 1]; long long a[MAXN][MAXN], ans[MAXN][MAXK]; bool calced[MAXN][MAXK]; inline void preProcess() { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (i &lt;= j) { for (int k = i; k &lt;= j; k++) { a[i][j] *= 10; a[i][j] += (num[k] - '0'); } } } } } long long search(int n, int k) { if (k == 0) return a[0][n - 1]; if (!calced[n - 1][k - 1]) { for (int i = k; i &lt; n; i++) { ans[n - 1][k - 1] = std::max(ans[n - 1][k - 1], search(i, k - 1) * a[i + 1 - 1][n - 1]); } calced[n - 1][k - 1] = true; } return ans[n - 1][k - 1]; } int main() { scanf("%d %d\n%s", &amp;n, &amp;k, num); preProcess(); printf("%lld\n", search(n, k)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>CodeVS</tag>
        <tag>划分 DP</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CTSC1997」选课 - 树形 DP]]></title>
    <url>%2Fctsc1997-course%2F</url>
    <content type="text"><![CDATA[学校开设了 N（&lt;= 300）门课程，每门课程有不同的学分，每个学生最多可以选择 M 门课程，有些课程有“先修课”，即这门课必须在先修课选定之后再选，每门课程的先修课最多有一门。求获得学分最多的选课方案。 链接 CodeVS 1378 题解 很显然，这里的依赖关系是以森林的形式给出的，我们增加一个虚拟节点作为所有无先修课的课程的父节点，搜索这棵树，用 表示选择第 i 个节点及其之后节点（兄弟或孩子）中的 m 个节点所对应的课程所获得的最大学分，则有两个转移方向： 给第 i 个节点和它的一个或多个子节点分配一定的课程数量 k，剩余课程数量 m - k - 1 分给下一个兄弟节点。 不选择第 i 个节点，全部课程数量 m 分配给下一个兄弟节点。 树结构储存时使用类似邻接表的结构，储存当前节点的第一个孩子节点，和下一个兄弟节点。 struct Tree { Tree *children, *next; int w; struct Answer { bool solved; int value; inline Answer() : solved(false) {} } ans[MAXM + 1]; inline Tree() {} inline Tree(Tree *parent, int w) : w(w), next(parent-&gt;children) {} } trees[MAXN + 1]; 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 300; const int MAXM = 300; struct Tree { Tree *children, *next; int w; struct Answer { bool solved; int value; inline Answer() : solved(false) {} } ans[MAXM + 1]; inline Tree() {} inline Tree(Tree *parent, int w) : w(w), next(parent-&gt;children) {} } trees[MAXN + 1]; int n, m; inline void addTree(int parent, int child, int w) { trees[parent].children = new (&amp;trees[child]) Tree(&amp;trees[parent], w); } int solve(Tree *t, int m) { if (!t || m &lt; 0) return 0; if (!t-&gt;ans[m].solved) { t-&gt;ans[m].value = 0; for (int i = 0; i &lt; m; i++) { t-&gt;ans[m].value = std::max(t-&gt;ans[m].value, solve(t-&gt;children, i) + solve(t-&gt;next, m - i - 1) + t-&gt;w); } t-&gt;ans[m].value = std::max(t-&gt;ans[m].value, solve(t-&gt;next, m)); t-&gt;ans[m].solved = true; } return t-&gt;ans[m].value; } int main() { scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { int parent, w; scanf("%d %d", &amp;parent, &amp;w); addTree(parent, i, w); } printf("%d\n", solve(&amp;trees[0], m + 1)); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形 DP</tag>
        <tag>CodeVS</tag>
        <tag>CTSC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeVS 3168 / 3162」抄书问题 - 划分 DP / 二分答案]]></title>
    <url>%2Fcodevs-3168-3162%2F</url>
    <content type="text"><![CDATA[把 M 本有顺序的书分给 K 个人抄写，每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的（比如不能把第一、第三、第四本数给同一个人抄写）。现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。 链接 CodeVS 3162 - 抄书问题 CodeVS 3168 - 抄书问题 3 划分 DP 考虑用动态规划求出最短时间，以 表示第 m 本书的页数， 表示前 m 本书给前 k 个人抄需要的最短时间。 边界条件为： 转移方程为： 即，枚举第 k 个人抄的书数，从“前面 k - 1 个人每人只抄一本，剩下的全留给第 k 个人”到“前面 k - 1 个人一共抄 m - 1 本，给第 k 个人留一本”，并上第 k 个人抄的时间，取最小值。 求书本页数的区间和可以用一个前缀和数组来优化时间复杂度，故该算法时间复杂度为 。 int search(int m, int k) { if (f[m - 1][k - 1] == -1) { if (k == 1) { f[m - 1][k - 1] = sum(0, m - 1); } else { for (int i = k - 1; i &lt;= m - 1; i++) { int ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1)); if (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] &gt; ans) { f[m - 1][k - 1] = ans; } } } } return f[m - 1][k - 1]; } 二分答案 加大后的数据量已不能使用 DP 的方法，考虑对最短时间在最大页数到总页数之间进行二分，检验过程贪心枚举每一本书，从最后一个人开始，如果当前的人还能抄就给他抄，否则给前一个人抄，如果最后能抄完则可行。 时间复杂度为 。 inline bool check(int limit) { memset(pageCount, 0, sizeof(pageCount)); int j = k - 1, lastEnd = m - 1; for (int i = m - 1; i &gt;= 0; i--) { if (pageCount[j] + a[i] &lt;= limit) { pageCount[j] += a[i]; } else { if (j == 0) { return false; } lastEnd = i; pageCount[--j] += a[i]; } } return sum(0, lastEnd - 1) &lt;= limit; } inline int binaryDivide() { int l = max, r = sum(0, m - 1); while (l &lt; r) { int mid = l + ((r - l) &gt;&gt; 1); if (check(mid)) r = mid; else l = mid + 1; } return l; } 方案输出 输出方案算是这题最难的地方。~才不会告诉你们我 WA 了 8 次呢！~ 和二分答案求最短时间的思路相似，贪心枚举每本书，从最后一个人开始（注意题目要求前面的人少抄），如果当前人还能抄，就给他抄，否则给下一个人抄，如果剩余人的数量大于剩余书的数量，则无论如何都要给下一个人抄（后面的全给抄完了咱前面的吵啥啊）。 输出顺序可以用一个栈来调整。 inline void printPlan() { memset(pageCount, 0, sizeof(pageCount)); int j = k - 1, lastEnd = m - 1; stack&lt;pair&lt;int, int&gt; &gt; s; for (int i = m - 1; i &gt;= 0; i--) { if (j &gt; i || pageCount[j] + a[i] &gt; ans) { pageCount[--j] += a[i]; s.push(make_pair(i + 1 + 1, lastEnd + 1)); lastEnd = i; } else { pageCount[j] += a[i]; } } printf("%d %d\n", 1, lastEnd + 1); while (!s.empty()) { pair&lt;int, int&gt; range = s.top(); s.pop(); printf("%d %d\n", range.first, range.second); } } 代码（划分 DP，CodeVS 3162） #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; #include &lt;utility&gt; using std::stack; using std::pair; using std::make_pair; const int MAXM = 100; const int MAXK = 100; int m, k; int a[MAXM], prefix[MAXM], f[MAXM][MAXK], pageCount[MAXK]; int ans; inline void makePrefix() { prefix[0] = a[0]; for (int i = 1; i &lt; m; i++) { prefix[i] = prefix[i - 1] + a[i]; } } inline int sum(int i, int j) { return i == 0 ? prefix[j] : prefix[j] - prefix[i - 1]; } int search(int m, int k) { if (f[m - 1][k - 1] == -1) { if (k == 1) { f[m - 1][k - 1] = sum(0, m - 1); } else { for (int i = k - 1; i &lt;= m - 1; i++) { int ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1)); if (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] &gt; ans) { f[m - 1][k - 1] = ans; } } } } return f[m - 1][k - 1]; } inline void printPlan() { memset(pageCount, 0, sizeof(pageCount)); int j = k - 1, lastEnd = m - 1; stack&lt;pair&lt;int, int&gt; &gt; s; for (int i = m - 1; i &gt;= 0; i--) { if (j &gt; i || pageCount[j] + a[i] &gt; ans) { pageCount[--j] += a[i]; s.push(make_pair(i + 1 + 1, lastEnd + 1)); lastEnd = i; } else { pageCount[j] += a[i]; } } printf("%d %d\n", 1, lastEnd + 1); while (!s.empty()) { pair&lt;int, int&gt; range = s.top(); s.pop(); printf("%d %d\n", range.first, range.second); } } int main() { scanf("%d %d", &amp;m, &amp;k); if (!m) return 0; for (int i = 0; i &lt; m; i++){ scanf("%d", &amp;a[i]); } makePrefix(); memset(f, 0xff, sizeof(f)); ans = search(m, k); printPlan(); return 0; } 代码（二分答案，CodeVS 3162，CodeVS 3168） #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;stack&gt; #include &lt;utility&gt; using std::stack; using std::pair; using std::make_pair; const int MAXM = 1000000; const int MAXK = 10000; int m, k; int a[MAXM], prefix[MAXM], pageCount[MAXK], max; int ans; inline void makePrefix() { prefix[0] = a[0]; for (int i = 1; i &lt; m; i++) { prefix[i] = prefix[i - 1] + a[i]; } } inline int sum(int i, int j) { return i == 0 ? prefix[j] : prefix[j] - prefix[i - 1]; } inline bool check(int limit) { memset(pageCount, 0, sizeof(pageCount)); int j = k - 1, lastEnd = m - 1; for (int i = m - 1; i &gt;= 0; i--) { if (pageCount[j] + a[i] &lt;= limit) { pageCount[j] += a[i]; } else { if (j == 0) { return false; } lastEnd = i; pageCount[--j] += a[i]; } } return sum(0, lastEnd - 1) &lt;= limit; } inline int binaryDivide() { int l = max, r = sum(0, m - 1); while (l &lt; r) { int mid = l + ((r - l) &gt;&gt; 1); if (check(mid)) r = mid; else l = mid + 1; } return l; } inline void printPlan() { memset(pageCount, 0, sizeof(pageCount)); int j = k - 1, lastEnd = m - 1; stack&lt;pair&lt;int, int&gt; &gt; s; for (int i = m - 1; i &gt;= 0; i--) { if (j &gt; i || pageCount[j] + a[i] &gt; ans) { pageCount[--j] += a[i]; s.push(make_pair(i + 1 + 1, lastEnd + 1)); lastEnd = i; } else { pageCount[j] += a[i]; } } printf("%d %d\n", 1, lastEnd + 1); while (!s.empty()) { pair&lt;int, int&gt; range = s.top(); s.pop(); printf("%d %d\n", range.first, range.second); } } int main() { scanf("%d %d", &amp;m, &amp;k); if (!m) return 0; for (int i = 0; i &lt; m; i++){ scanf("%d", &amp;a[i]); max = std::max(max, a[i]); } makePrefix(); ans = binaryDivide(); printPlan(); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>CodeVS</tag>
        <tag>贪心</tag>
        <tag>二分答案</tag>
        <tag>划分 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树 && 次小生成树]]></title>
    <url>%2Fminimum-spanning-tree-notes%2F</url>
    <content type="text"><![CDATA[最近回顾了一下图论中的最小生成树算法，又学习了“次小生成树”的算法。 最小生成树 Kruskal 算法 对所有边进行排序，用并查集维护连通性，从小到大枚举边，判断当前边的起止点是否在同一连通块中，若不是，则加入这条边，否则放弃这条边。 图结构需要以边集数组储存。 时间复杂度为 （其中 m 为边数）。 据说适用于稀疏图。 struct UndirectedEdge { int u, v, w; UndirectedEdge() {} UndirectedEdge(int u, int v, int w) : u(u), v(v), w(w) {} bool operator&lt;(const UndirectedEdge &amp;other) const { return w &lt; other.w; } } edges[MAXM]; struct UnionFindSet { int f[MAXN]; UnionFindSet(int n) { for (int i = 0; i &lt; n; i++) { f[i] = i; } } int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); } void merge(int x, int y) { f[find(x)] = find(y); } }; inline int kruskal() { int sum = 0, count = 0; UnionFindSet ufs(n); std::sort(edges, edges + m); for (int i = 0; i &lt; m; i++) { if (ufs.find(edges[i].u) != ufs.find(edges[i].v)) { ufs.merge(edges[i].u, edges[i].v); sum += edges[i].w; count++; if (count == n - 1) { break; } } } return sum; } 次小生成树 一个图的次小生成树，是指异于该图的最小生成树的边权和最小的生成树。 注意，这里的次小生成树是非严格次小，即可能存在一个图，其最小生成树与次小生成树的边权和相等。 算法 不难得出，次小生成树可以由最小生成树更换一条边得到。 首先构造原图的最小生成树，然后枚举每一条不在最小生成树中的边 (u, v, w)，尝试将这条边加入生成树，因为直接加入边会产生环，所以我们需要在加边之前删去最小生成树上 u 到 v 的路径上权值最大的边。在枚举每一条边时我们都会得到一棵生成树，这些生成树中边权和最小的即为要求的次小生成树。 需要在构造最小生成树时将完整的树结构构造出来，并且使用树上倍增算法查询两点间边权值最大的值。 代码（POJ 1679） 链接：POJ 1679 题目要求判断最小生成树的唯一性。求出该图的非严格次小生成树，与最小生成树的权值和作比较即可。 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXT = 20; const int MAXN = 100; const int MAXM = MAXN * (MAXN - 1) / 2; const int MAXLOGN = 7; struct UndirectedEdge { int u, v, w; bool used; UndirectedEdge() {} UndirectedEdge(int u, int v, int w) : u(u), v(v), w(w), used(false) {} bool operator&lt;(const UndirectedEdge &amp;other) const { return w &lt; other.w; } } edges[MAXM]; struct UnionFindSet { int f[MAXN]; UnionFindSet(int n) { for (int i = 0; i &lt; n; i++) { f[i] = i; } } int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); } void merge(int x, int y) { f[find(x)] = find(y); } }; struct Edge; struct Node; struct Node { Edge *edges; int id; int depth; } nodes[MAXN]; struct Edge { Node *from, *to; Edge *next; int w; Edge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from-&gt;edges) {} }; struct SparseTable { Node *target; int max; } f[MAXN][MAXLOGN + 1]; int t, n, m, logn; inline void addEdge(int u, int v, int w) { nodes[u].edges = new Edge(&amp;nodes[u], &amp;nodes[v], w); nodes[v].edges = new Edge(&amp;nodes[v], &amp;nodes[u], w); } inline int kruskal() { int sum = 0, count = 0; UnionFindSet ufs(n); std::sort(edges, edges + m); for (int i = 0; i &lt; m; i++) { if (ufs.find(edges[i].u) != ufs.find(edges[i].v)) { ufs.merge(edges[i].u, edges[i].v); sum += edges[i].w; count++; edges[i].used = true; addEdge(edges[i].u, edges[i].v, edges[i].w); if (count == n - 1) { break; } } } return sum; } inline int log(int x) { int i = 0; while ((1 &lt;&lt; i) &lt;= x) { i++; } return i; } inline void makeST() { for (int i = 0; i &lt; n; i++) { nodes[i].id = i; } f[0][0].target = &amp;nodes[0]; f[0][0].max = 0; nodes[0].depth = 1; std::queue&lt;Node *&gt; q; q.push(&amp;nodes[0]); while (!q.empty()) { Node *node = q.front(); q.pop(); for (Edge *edge = node-&gt;edges; edge; edge = edge-&gt;next) { if (edge-&gt;to-&gt;depth == 0) { edge-&gt;to-&gt;depth = node-&gt;depth + 1; q.push(edge-&gt;to); f[edge-&gt;to-&gt;id][0].target = node; f[edge-&gt;to-&gt;id][0].max = edge-&gt;w; } } } for (int j = 1; j &lt;= logn; j++) { for (int i = 0; i &lt; n; i++) { f[i][j].target = f[f[i][j - 1].target-&gt;id][j - 1].target; f[i][j].max = std::max(f[i][j - 1].max, f[f[i][j - 1].target-&gt;id][j - 1].max); } } } inline int queryMax(int u, int v) { Node *a = &amp;nodes[u], *b = &amp;nodes[v]; if (a-&gt;depth &lt; b-&gt;depth) { std::swap(a, b); } int max = 0; if (a-&gt;depth != b-&gt;depth) { for (int i = logn; i &gt;= 0; i--) { if (f[a-&gt;id][i].target-&gt;depth &gt;= b-&gt;depth) { max = std::max(max, f[a-&gt;id][i].max); a = f[a-&gt;id][i].target; } } } if (a != b) { for (int i = logn; i &gt;= 0; i--) { if (f[a-&gt;id][i].target != f[b-&gt;id][i].target) { max = std::max(max, f[a-&gt;id][i].max); max = std::max(max, f[b-&gt;id][i].max); a = f[a-&gt;id][i].target; b = f[b-&gt;id][i].target; } } max = std::max(max, f[a-&gt;id][0].max); max = std::max(max, f[b-&gt;id][0].max); } return max; } int main() { scanf("%d", &amp;t); while (~scanf("%d %d", &amp;n, &amp;m)) { logn = log(n); memset(edges, 0, sizeof(edges)); memset(nodes, 0, sizeof(nodes)); memset(f, 0, sizeof(f)); for (int i = 0; i &lt; m; i++) { int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); u--, v--; edges[i] = UndirectedEdge(u, v, w); } int sum = kruskal(); makeST(); int ans = int_MAX; for (int i = 0; i &lt; m; i++) { if (!edges[i].used) { ans = std::min(ans, sum - queryMax(edges[i].u, edges[i].v) + edges[i].w); } } if (sum == ans) { puts("Not Unique!"); } else { printf("%d\n", sum); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>倍增</tag>
        <tag>最小生成树</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>Kruskal</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[差分约束系统学习笔记]]></title>
    <url>%2Fsystem-of-difference-constraints-notes%2F</url>
    <content type="text"><![CDATA[差分约束系统，就是给出一组形如 的不等式，求出这组不等式的一组解。这类问题通常转化为图论中的最短路来解。 原理 在图论中，求解单源最短路的算法在进行每一次每条边上的“松弛”操作时，都是根据以下条件： （其中 from、to 表示边的起点、终点，$ 表示某个点到源点的当前距离） if ($to &gt; $from + w) { $to = $from + w; } 也就是说，每一次松弛操作保证了： $to - $from &gt;= w 于是，我们可以把差分约束系统中的变量看做图中的点，把不等关系看做边，然后对整个图进行一次单源最短路算法，即可使所有不等式满足。 如果图中存在权值和为负的环，则说明不等式组无解。 实现 对于每一个不等式 ，从 j 向 i 连一条边，权值为 d。 如果不等号的方向相反，即 ，则应在不等式两边同时乘以 -1，变成 ，即从 i 到 j 连一条边，权值为 -d。 算法初始化时，将源点的 dist 置为 0，其他的点 dist 置为无穷大。若有解，则算法结束后每个点的 dist 值即为解。 如果图中有负边，则必须使用 Bellman-Ford 算法，如果 Bellman-Ford 算法在 n - 1 次松弛后还继续进行松弛，则说明图中有权值和为负的环，原不等式组无解。 如果使用带有队列优化的 Bellman-Ford 算法，则每个点入队次数超过 n 时说明图中有权值和为负的环，原不等式组无解。 例题 CodeVS 4416 - FFF 团卧底的后宫 给出 n 个形如 或 的不等式，求一组使 与 差最大的解，输出最大差值，若无解输出 -1，若 与 的差为无限大则输出 -2。 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; const int MAXN = 1000; const int MAXM = 10000; struct Edge; struct Node; struct Node { Edge *edges; bool inQueue; int dist; int count; } nodes[MAXN]; struct Edge { Node *from, *to; int w; Edge *next; Edge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from-&gt;edges) {} }; int n, m, k; inline void addEdge(int from, int to, int w) { nodes[from].edges = new Edge(&amp;nodes[from], &amp;nodes[to], w); } inline bool bellmanFord() { std::queue&lt;Node *&gt; q; q.push(&amp;nodes[0]); while (!q.empty()) { Node *node = q.front(); q.pop(); node-&gt;inQueue = false; for (Edge *edge = node-&gt;edges; edge; edge = edge-&gt;next) { if (edge-&gt;to-&gt;dist &gt; node-&gt;dist + edge-&gt;w) { edge-&gt;to-&gt;dist = node-&gt;dist + edge-&gt;w; if (!edge-&gt;to-&gt;inQueue) { edge-&gt;to-&gt;inQueue = true; edge-&gt;to-&gt;count++; q.push(edge-&gt;to); if (edge-&gt;to-&gt;count &gt; n) { return false; } } } } } return true; } int main() { scanf("%d %d %d", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; n; i++) { nodes[i].dist = INT_MAX; } nodes[0].dist = 0; for (int i = 0; i &lt; m; i++) { int a, b, d; scanf("%d %d %d", &amp;a, &amp;b, &amp;d); a--, b--; addEdge(a, b, d); // $b - $a &lt;= d // $a + d &gt;= $b } for (int i = 0; i &lt; k; i++) { int a, b, d; scanf("%d %d %d", &amp;a, &amp;b, &amp;d); a--, b--; addEdge(b, a, -d); // $b - $a &gt;= d // $a - $b &lt;= -d // $b + -d &gt;= $a } if (!bellmanFord()) { puts("-1"); } else { if (nodes[n - 1].dist == INT_MAX) { puts("-2"); } else { printf("%d\n", nodes[n - 1].dist); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>差分约束系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP 学习笔记]]></title>
    <url>%2Fkmp-notes%2F</url>
    <content type="text"><![CDATA[KMP（Knuth-Morris-Pratt）是算法竞赛中常用的字符串匹配算法之一，它可以有效地利用失配信息来使得匹配全过程中不回溯，从而在线性时间内完成匹配。 原理 设模式串 pattern 为 "utqqutnu"，目标串 target 为 "utqlwutqqutnu"，使用朴素算法进行匹配时（"-" 表示匹配成功，"|" 表示在此字符失配）： utqqutlwutqqutnu ------| utqqutnu 首先，将两串首部对齐，逐个字符匹配，可见在字符 'l' 处失配，按照朴素算法的思想，我们需要把模式串右移一个字符，然后再从模式串首部开始匹配，即： utqqutlwutqqutnu | utqqutnu 这时发现从第一个字符起就不匹配，还要继续右移 …… 但是，似乎有一种更好的策略：我们可以直接把模式串的开头对齐目标串的 "ut" 处，就可以一次跳过几个字符，并且模式串无需回溯： utqqutlwutqqutnu --| utqqutnu 而接下来这次失配后，本来需要将模式串与 't' 对齐，但事实上并不需要，将模式串直接与 'l' 对齐即可。 utqqutlwutqqutnu | utqqutnu KMP 算法就是利用了失配后的部分匹配信息来选择模式串的移动方式，尽可能地避免无用的匹配。 失配信息的利用 通过上述例子我们可以观察到，如果部分匹配的串有对称的前后缀，则我们可以直接将模式串中部分匹配串的前缀与目标串中部分匹配串的后缀对齐，如： utqqutlwutqqutnu ------| utqqutnu 例子中的部分匹配串为 "utqqut"，有对称的前后缀 "ut"，则可以直接将目标串的第二个 "ut" 与模式串的第一个 "ut" 对齐。 再来看这个例子，模式串为 "ttitty"，目标串为 "ttittitty" ttittittypoi -----| ttitty 此时的部分匹配串为 "ttitt"，它有两个对称的前后缀，分别是 "tt" 和 "t"，我们会想，以 "t" 对齐，可以移动更长的距离，事实上呢？ ttittittypoi -| ttitty 在模式串第二个 't' 处失配后，继续匹配，最终结果是匹配失败。 然而，如果我们以 "tt" 对齐，则有： ttittittypoi ------ ttitty 结果是匹配成功。 这个例子告诉我们，当部分匹配串有多个对称前后缀时，需要选择最长的，以保证匹配结果的正确。 失配信息的推导 事实上，KMP 算法利用的失配信息是与目标串无关的，它仅与模式串有关，我们可以用递推的方法在线性的时间内求出模式串的**每个可能的部分匹配串（即所有前缀）**前缀的失配信息。 我们定义 fail 数组是一个长度等于模式串长度的数组，它的第 i 个成员代表以模式串前 i 个字符作为部分匹配串时，部分匹配串的最长对称前后缀长度。 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 target| u | t | q | q | u | t | n | u fail | 0 | 0 | 0 | 0 | 1 | 2 | 0 | 1 推导 fail[i] 的方法如下： 如果 fail[i - 1] 不为 0，且第 i 个字符与第 fail[i - 1] + １ 个字符相同，则 fail[i] 即为 fail[i - 1] + 1； 如果 fail[i - 1] 为 0，且第 i 个字符与首个字符相同，则 fail[i] = 1，否则 fail[i] = 0； 难点：如果 fail[i - 1] 不为 0，且第 i 个字符与第 fail[i - 1] + １ 个字符不同，则继续对比第 i 个字符与 fail[fail[i - 1]] + 1 个字符，一直向前找直到匹配或者找到了 0。 如模式串：agctagcagctagct 加粗的 'a' 与最后一个 't' 不匹配，此时向前找找到 "agctagc" 的最后一个 'c' 的对称位置的后一个字符，发现是 't'，则找到前后的 "agct" 是一个对称的前后缀。 匹配 有了 fail 数组，匹配就简单多了，只要根据以下三种情况对应处理即可： 如果当前字符匹配，则继续匹配下一个字符； 如果当前在模式串的首字符处不匹配，则直接将模式串右移一个字符； 否则移动模式串，使模式串中部分匹配串的前缀与目标串中部分匹配串的后缀对齐。 完整代码（POJ 3461） 更新于 2016 年 12 月 26 日。 #include &lt;cstdio&gt; #include &lt;cstring&gt; const int MAXN = 1000000; inline int kmp(char *a, char *b) // 在 a 中寻找 b { // 求出字符串长度 int na = strlen(a + 1), nb = strlen(b + 1); static int fail[MAXN + 1]; fail[1] = 0; for (int i = 2; i &lt;= nb; i++) { // 取上一位置的 fail 位置之后的字符，判断是否和该位相同 int j = fail[i - 1]; // 不断地向前找 fail 位置，直到找到 0 位置或可以匹配当前字符 while (j != 0 &amp;&amp; b[j + 1] != b[i]) j = fail[j]; // 如果能匹配，设置当前位置的 fail 位置 if (b[j + 1] == b[i]) fail[i] = j + 1; else fail[i] = 0; // 找不到匹配位置 } int res = 0; // 匹配次数 for (int i = 1, j = 0; i &lt;= na; i++) { // 取上一位置的 fail 位置之后的字符，判断是否和要匹配的字符相同 while (j != 0 &amp;&amp; b[j + 1] != a[i]) j = fail[j]; // 这一位可以匹配上 if (b[j + 1] == a[i]) j++; // 匹配成功 if (j == nb) { res++; j = fail[j]; // 为了能匹配重叠串 // j = 0 // 如果不允许重叠匹配 } } return res; } int main() { int T; scanf("%d", &amp;T); while (T--) { static char a[MAXN + 2], b[MAXN + 2]; // 下标从 1 开始 scanf("%s %s", a + 1, b + 1); printf("%d\n", kmp(b, a)); } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>学习笔记</tag>
        <tag>算法模板</tag>
        <tag>CodeVS</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树链剖分学习笔记]]></title>
    <url>%2Ftree-chain-split-notes%2F</url>
    <content type="text"><![CDATA[更新于 2016 年 12 月 28 日。 树链剖分是一种维护树上路径信息的算法，它将一棵树剖分成一些不相交的链，保证每个点在且仅在一条链上。并通过线段树、树状数组等数据结构维护每一条链上的信息。 题目：树的统计 CodeVS 2460 BZOJ 1036 给出一棵树，每个点有一个可修改的点权，每次查询两点之间所有点的点权和或点权最大值。 基本思想 把整棵树划分成许多条链，使每个节点都在唯一的链上，对每一条链维护一棵线段树，把在树上的操作转移到线段树上。 树链剖分的策略是轻重边路径剖分，这种策略可以保证整棵树上的轻边和链的数量都不超过 。 定义 struct Node { struct Edge *firstEdge; struct Chain *chain; // 所在的链 // maxChild 最大的子树 Node *fa, *maxChild; // size 以当前节点为根的子树大小 // pos 当前节点在链上的编号 int size, dfn, pos, depth; bool vis; } N[MAXN + 1]; struct Edge { Node *from, *to; Edge *next; Edge(Node *from, Node *to) : from(from), to(to), next(from-&gt;firstEdge) {} }; struct Chain { Node *top; // 链的顶端 // 这里还可以维护更多的信息，比如链的长度 int len; Chain(Node *top) : top(top), len(0) {} }; 对于每个节点 ， 表示这个节点的深度（即到整棵树的根的距离）， 表示以这个节点为根的树的大小（即节点总数）， 表示该节点的最大子树。 每个节点都在一条链上，每条链 上深度最小的点称为链顶节点 。 表示当前节点 是链上的第几个点（链顶节点的 为 ，即 ）。 剖分 inline void split() { N[1].depth = 1; // 注意先赋值根的深度为 1 dfs1(&amp;N[1]); dfs2(&amp;N[1]); } 剖分的过程主要由两次 DFS 组成，第一遍 DFS 求出每个节点 的 和 。 inline void dfs1(Node *v) { v-&gt;vis = true; v-&gt;size = 1; // 统计子节点之前，整棵树的大小为 1 for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (!e-&gt;to-&gt;vis) { e-&gt;to-&gt;fa = v; e-&gt;to-&gt;depth = v-&gt;depth + 1; dfs1(e-&gt;to); // 递归回溯时统计子树大小 v-&gt;size += e-&gt;to-&gt;size; // 求最大子树，如果最大子树为空， // 或者当前子树比最大子树更大，则更新最大子树 if (!v-&gt;maxChild || v-&gt;maxChild-&gt;size &lt; e-&gt;to-&gt;size) v-&gt;maxChild = e-&gt;to; } } } 第二遍 DFS，求出每个点所在的链。 对于每个节点，如果它是根（没有父节点）或它不是父节点的「最大子树（）」，则创建一条以该节点为链顶节点的链，否则该节点与其父节点在同一条链上（实现了链的延伸）。 为了维护树上路径信息，我们记录每个点的 DFS 序 ，为了使同一条链上的点在 DFS 序中是相邻的，我们在 DFS 时优先递归处理最大子树 。 inline void dfs2(Node *v) { static int ts = 0; // 时间戳 v-&gt;dfn = ++ts; // 记录 DFS 序 // 创建一条新链 if (!v-&gt;fa || v != v-&gt;fa-&gt;maxChild) v-&gt;chain = new Chain(v); else v-&gt;chain = v-&gt;fa-&gt;chain; // 与父节点在同一条链上 // 优先递归处理最大子树， // 保证一条链在 DFS 序中是连续的 if (v-&gt;maxChild) dfs2(v-&gt;maxChild); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { // // 最大子树已经处理过，不要重复处理 if (e-&gt;to-&gt;fa == v &amp;&amp; e-&gt;to != v-&gt;maxChild) { dfs2(e-&gt;to); } } } 线段树 我们使用线段树维护每一条链的信息，以 DFS 序建树，保证每条链上的节点在线段树中是连续的。 segt = SegmentTree::build(1, n); 修改 修改某个点的权值，只需要在线段树上该点 DFS 序的位置上更新即可。 注意修改时一定要以 DFS 序作为修改位置。 inline void update(int u, int x) { segt-&gt;update(N[u].dfn, x); } 查询路径信息 查询两个点 与 之间的点权和（或点权极值）的方法： 如果 与 不在同一条链上，不妨设 所在链链顶节点深度较大，在线段树上查询 所在链链顶节点（）到 的路径，并将 跳到其所在链链顶节点； 如果 与 在同一条链上，则直接在线段树中查询。 注意查询时一定要以 DFS 序作为区间端点查询。 inline int querySum(int a, int b) { Node *u = &amp;N[a], *v = &amp;N[b]; int res = 0; while (u-&gt;chain != v-&gt;chain) { // 令 u 链顶节点的深度较大 if (u-&gt;chain-&gt;top-&gt;depth &lt; v-&gt;chain-&gt;top-&gt;depth) std::swap(u, v); res += segt-&gt;querySum(u-&gt;chain-&gt;top-&gt;dfn, u-&gt;dfn); u = u-&gt;chain-&gt;top-&gt;fa; } if (u-&gt;depth &gt; v-&gt;depth) std::swap(u, v); res += segt-&gt;querySum(u-&gt;dfn, v-&gt;dfn); return res; } inline int queryMax(int a, int b) { Node *u = &amp;N[a], *v = &amp;N[b]; int res = INT_MIN; // 答案初始化负无穷 while (u-&gt;chain != v-&gt;chain) { if (u-&gt;chain-&gt;top-&gt;depth &lt; v-&gt;chain-&gt;top-&gt;depth) std::swap(u, v); res = std::max(res, segt-&gt;queryMax(u-&gt;chain-&gt;top-&gt;dfn, u-&gt;dfn)); u = u-&gt;chain-&gt;top-&gt;fa; } if (u-&gt;depth &gt; v-&gt;depth) std::swap(u, v); res = std::max(res, segt-&gt;queryMax(u-&gt;dfn, v-&gt;dfn)); return res; } 最近公共祖先 用类似查询路径信息的方法，当两个点跳到同一条链上时，深度较小的即为原两点的 LCA。 inline Node *lca(Node *u, Node *v) { while (u-&gt;chain != v-&gt;chain) { if (u-&gt;chain-&gt;top-&gt;depth &lt; v-&gt;chain-&gt;top-&gt;depth) std::swap(u, v); u = u-&gt;chain-&gt;top-&gt;fa; } if (u-&gt;depth &gt; v-&gt;depth) std::swap(u, v); return u; } 完整代码 #include &lt;cstdio&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; const int MAXN = 30000; struct Node { struct Edge *firstEdge; struct Chain *chain; Node *fa, *maxChild; int size, dfn, depth; bool vis; } N[MAXN + 1]; struct Edge { Node *from, *to; Edge *next; Edge(Node *from, Node *to) : from(from), to(to), next(from-&gt;firstEdge) {} }; struct Chain { Node *top; Chain(Node *top) : top(top) {} }; inline void addEdge(int from, int to) { N[from].firstEdge = new Edge(&amp;N[from], &amp;N[to]); N[to].firstEdge = new Edge(&amp;N[to], &amp;N[from]); } inline void dfs1(Node *v) { v-&gt;vis = true; v-&gt;size = 1; for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (!e-&gt;to-&gt;vis) { e-&gt;to-&gt;fa = v; e-&gt;to-&gt;depth = v-&gt;depth + 1; dfs1(e-&gt;to); v-&gt;size += e-&gt;to-&gt;size; if (!v-&gt;maxChild || v-&gt;maxChild-&gt;size &lt; e-&gt;to-&gt;size) v-&gt;maxChild = e-&gt;to; } } } inline void dfs2(Node *v) { static int ts = 0; v-&gt;dfn = ++ts; if (!v-&gt;fa || v != v-&gt;fa-&gt;maxChild) v-&gt;chain = new Chain(v); else v-&gt;chain = v-&gt;fa-&gt;chain; if (v-&gt;maxChild) dfs2(v-&gt;maxChild); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) { if (e-&gt;to-&gt;fa == v &amp;&amp; e-&gt;to != v-&gt;maxChild) { dfs2(e-&gt;to); } } } inline void split() { N[1].depth = 1; dfs1(&amp;N[1]); dfs2(&amp;N[1]); } struct SegmentTree { int l, r, mid; SegmentTree *lc, *rc; int sum, max; SegmentTree(int l, int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), sum(0), max(INT_MIN) {} void maintain() { sum = lc-&gt;sum + rc-&gt;sum; max = std::max(lc-&gt;max, rc-&gt;max); } void update(int pos, int x) { if (l == r) sum = max = x; else { if (pos &lt;= mid) lc-&gt;update(pos, x); else rc-&gt;update(pos, x); maintain(); } } int querySum(int l, int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return sum; else return lc-&gt;querySum(l, r) + rc-&gt;querySum(l, r); } int queryMax(int l, int r) { if (l &gt; this-&gt;r || r &lt; this-&gt;l) return INT_MIN; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return max; else return std::max(lc-&gt;queryMax(l, r), rc-&gt;queryMax(l, r)); } static SegmentTree *build(int l, int r) { if (l == r) return new SegmentTree(l, r, NULL, NULL); else { int mid = l + (r - l) / 2; return new SegmentTree(l, r, build(l, mid), build(mid + 1, r)); } } } *segt; inline void update(int u, int x) { segt-&gt;update(N[u].dfn, x); } inline int querySum(int a, int b) { Node *u = &amp;N[a], *v = &amp;N[b]; int res = 0; while (u-&gt;chain != v-&gt;chain) { if (u-&gt;chain-&gt;top-&gt;depth &lt; v-&gt;chain-&gt;top-&gt;depth) std::swap(u, v); res += segt-&gt;querySum(u-&gt;chain-&gt;top-&gt;dfn, u-&gt;dfn); u = u-&gt;chain-&gt;top-&gt;fa; } if (u-&gt;depth &gt; v-&gt;depth) std::swap(u, v); res += segt-&gt;querySum(u-&gt;dfn, v-&gt;dfn); return res; } inline int queryMax(int a, int b) { Node *u = &amp;N[a], *v = &amp;N[b]; int res = INT_MIN; while (u-&gt;chain != v-&gt;chain) { if (u-&gt;chain-&gt;top-&gt;depth &lt; v-&gt;chain-&gt;top-&gt;depth) std::swap(u, v); res = std::max(res, segt-&gt;queryMax(u-&gt;chain-&gt;top-&gt;dfn, u-&gt;dfn)); u = u-&gt;chain-&gt;top-&gt;fa; } if (u-&gt;depth &gt; v-&gt;depth) std::swap(u, v); res = std::max(res, segt-&gt;queryMax(u-&gt;dfn, v-&gt;dfn)); return res; } int main() { int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n - 1; i++) { int u, v; scanf("%d %d", &amp;u, &amp;v); addEdge(u, v); } split(); segt = SegmentTree::build(1, n); for (int i = 1; i &lt;= n; i++) { int x; scanf("%d", &amp;x); update(i, x); } int q; scanf("%d", &amp;q); while (q--) { char cmd[sizeof("CHANGE")]; int a, b; scanf("%s %d %d", cmd, &amp;a, &amp;b); if (cmd[1] == 'H') { update(a, b); } else if (cmd[1] == 'S') { printf("%d\n", querySum(a, b)); } else if (cmd[1] == 'M') { printf("%d\n", queryMax(a, b)); } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
        <tag>高级数据结构</tag>
        <tag>算法模板</tag>
        <tag>BZOJ</tag>
        <tag>CodeVS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL 在 OI 中的应用]]></title>
    <url>%2Fstl-in-oi%2F</url>
    <content type="text"><![CDATA[在 OI 竞赛中，可以使用的语言有 C++、C、Pascal，其中 C++ 最大的优势是，它本身提供了一个模板库 —— Standard Template Library（标准模板库），简称 STL。STL 包含一系列算法和容器等，合理地使用 STL，可以在提高编写代码的效率。NOI 系列比赛自 2011 年起允许 C++ 选手使用 STL，所以我们应该利用好 STL，发挥 C++ 语言的优势。 分类 STL 可分为容器（containers）、迭代器（iterators）、空间配置器（allocator）、配接器（adapters）、算法（algorithms）、仿函数（functors）六个部分。 本文主要讲解容器、迭代器、算法，其他的几个部分在竞赛中很少使用到。 命名空间 命名空间（namespace）是 C++ 的一个特性，它被用于解决名称冲突，比如假设 Menci 和 Fuxey 都在自己的头文件里编写了一个 work() 函数，如果这两个函数我们都要用，则名称会产生冲突，但如果两人都将自己的函数写在单独的命名空间内，就成了 Menci::work() 和 Fuxey::work()，就不会冲突了。 STL 的所有内容都包含在 std 命名空间内。 如果我们要调用 STL 中的 sort 函数（下文会有提到），要这样写： std::sort(a, a + n); 我们也可以将 std::sort 这个函数“导入”到全局中，就可以直接 sort(a, a + n) 这样调用了。 使用 using 关键字来“导入”命名空间中的函数或类。 using std::sort; 也可以将整个命名空间导入全局，这样就可以直接访问命名空间中的所有内容，但更容易产生名称冲突（比如你可能会声明一个叫做 max 的变量，但它会覆盖 STL 中的 max 函数）。 使用 using namespace 来“导入”整个命名空间。 using namespace std; 算法 STL 中的算法主要包含在 &lt;algorithm&gt; 头文件中，这个文件名要记住，每天念一遍。 排序 STL 中提供一系列与排序有关的函数，其中最常用到的是 sort 和 stable_sort，sort 是不稳定的排序，它的期望时间复杂度为 ，stable_sort 是稳定的排序，它的时间复杂度为 。 sort 使用类似与快速排序的算法，在大多数情况下能获得最高的效率，stable_sort 使用多路归并排序算法，可以在稳定的前提下取得较高的效率。一般常用 sort。 用法（以 sort 为例，stable_sort 相同）： 对左闭右开区间 [l, r) 排序，使用 sort(l, r)。其中 l 和 r 是指向元素的迭代器，在了解迭代器之前，我们可以将其理解为指向元素的指针。 注意这里的区间表示是一个左闭右开区间，STL 中经常会出现这种区间，如果我们要对一个数组 a 的前 n 个元素进行排序，则对应区间为 [a, a + n)，因为 a 指向数组的第一个元素（下标为 0），a + n 指向数组的第 n 个元素之后。 sort 函数默认是升序排序，如果需要降序，可以通过自定义“比较函数”来实现。 bool compare(int a, int b) { return a &gt; b; } std::sort(a, a + n, &amp;compare); 下面的代码演示了读入 n（n &lt;= 100000）个数，并降序排序后输出。 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 100000; int n; int a[MAXN]; bool compare(int a, int b) { return a &gt; b; } int main() { scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) { scanf("%d", &amp;a[i]); } std::sort(a, a + n, &amp;compare); for (int i = 0; i &lt; n; i++) { printf("%d\n", a[i]); } return 0; } 降序排序是大于号，升序排序是小于号（注意不能加等号变成大于等于、小于等于），如果不指定比较函数，默认为升序。 也可以通过重载运算符或者定义比较函数的方法对结构体进行排序： struct student_t { unsigned int id; long double score; bool operator&lt;(const student_t &amp;other) const { return score &lt; other.score; } } students[MAXN]; bool compare(const student_t &amp;student1, const student_t &amp;student2) { return student1.score &lt; student2.score; } std::sort(students, students + n, &amp;compare); 写在结构体中的 operator&lt; 即为重载运算符，这让我们的结构体支持小于号的比较操作。 结构体下面的 compare 是比较函数，比较函数和重载运算符只需要写一个就够了。 注意两种写法中的 const 和 &amp; 都不能省略。 去重 使用 unique 函数来去除数组中的重复元素，其调用格式与 sort 类似，注意调用 unique 前必须保证数组是有序的（升序降序都可以）。 std::sort(a, a + n); std::unique(a, a + n); unique 函数返回去重后的数组的最后一个元素之后，一般通过用返回值减去首地址的方法获得不重复的元素数量： int count = std::unique(a, a + n) - a; 下面的代码演示了读入 n（n &lt;= 100000）个数，并升序排序并去重后输出。 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const int MAXN = 100000; int n; int a[MAXN]; int main() { scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) { scanf("%d", &amp;a[i]); } std::sort(a, a + n); int count = std::unique(a, a + n) - a; for (int i = 0; i &lt; count; i++) { printf("%d\n", a[i]); } return 0; } 较大、较小值 使用 max 和 min 来取得两个数中较大或较小的。 int a = -1, b = 890; x = std::max(a, b); // 结果为 890 y = std::min(a, b); // 结果为 -1 查找 STL 中常用的用于查找的函数有三个：lower_bound、upper_bound、binary_search，一般 lower_bound 最为常用。 lower_bound 用于在一个升序序列中查找某个元素，并返回第一个不小于该元素的元素的迭代器，如果找不到，则返回指向序列中最后一个元素之后的迭代器。 upper_bound 用于在一个升序序列中查找某个元素，并返回第一个大于该元素的元素的迭代器，如果找不到，则返回指向序列中最后一个元素之后的迭代器。 binary_search 用于确定某个元素有没有在一个升序序列中出现过，返回 true 或 false。 三个函数的时间复杂度均为。 int a[8] = { -9, 5, -1, 2, 7, 1, -2, 2 }, n = 8; std::sort(a, a + n); // a = { -9, -2, -1, 1, 2, 2, 5, 7 } int *p1 = std::lower_bound(a, a + n, 1); // p1 指向 a 中第 4 个元素 a[3] = 1 int *p2 = std::lower_bound(a, a + n, 2); // p2 指向 a 中第 5 个元素 a[4] = 2 int *p3 = std::upper_bound(a, a + n, 2); // p3 指向 a 中第 7 个元素 a[6] = 5 int *p4 = std::lower_bound(a, a + n, 8); // p4 = a + n，因为数组 a 中没有不小于 8 的元素，此时访问 *p4 会越界 bool flag = std::binary_search(a, a + n, 3); // flag = false 因为数组 a 中没有 3 交换 使用 swap 函数交换两个变量的值。 int a = -1, b = 1; std::swap(a, b); // a = 1, b = -1 迭代器 迭代器是用于访问 STL 容器中元素的一种数据类型，一般迭代器的声明如下： std::CONTAINER&lt;T&gt;::iterator p; 上述代码声明了一个迭代器 p，其中 CONTAINER 是容器类型，可以是 vector、set 等，T 是容器中元素的类型。 一般的，容器的 begin() 方法返回首个元素的迭代器，end() 方法返回最后一个元素之后的迭代器。这两个迭代器确定了一个包含容器内所有元素的左闭右开区间 [begin(), end())。对于任何指向有效元素的迭代器都有其不等于 end()，end() 并不指向任何一个元素，试图访问 end() 对应的元素是非法的。 在使用 STL 提供的算法时，可以用迭代器表示一个区间，如： std::sort(v.begin(), v.end()); 一些容器的迭代器可以支持随机访问，如指向 vector[i] 的迭代器为 vector.begin() + i，而另一些容器如 set 不支持这种用法。 所有的迭代器都支持使用 ++ 和 -- 运算符将迭代器加一或减一。 迭代器的用法类似于指向数组元素的指针，对于迭代器 p，用 *p 得到迭代器对应的元素；如果该迭代器所对应的元素类型为结构体，则可以直接使用 -&gt; 访问其对应结构体中的元素。 一般的，使用迭代器遍历容器类似于下述代码： for (std::CONTAINER&lt;T&gt;::iterator p = C.begin(); p != C.end(); p++) { std::cout &lt;&lt; *p &lt;&lt; std::endl; } 容器 数组 vector STL 在头文件 &lt;vector&gt; 提供了一个可变长的数组 vector，它支持动态的插入、删除操作。 以下代码声明了一个 vector，它的每个元素类型为 int，初始元素数量为 0。 std::vector&lt;int&gt; v; 以下代码声明了一个 vector，它的每个元素类型为 int，初始元素数量为 n。 std::vector&lt;int&gt; v(n); vector 提供 begin() 和 end()，分别获取指向第一个元素和最后一个元素之后的迭代器。 以下代码对 v 中的所有元素以升序排序： std::sort(v.begin(), v.end()); 使用 size() 得到 vector 的元素数量，使用 resize() 重新指定 vector 的元素数量。 分别使用 push_back() 和 pop_back() 在 vector 的尾部加入或删除元素，这两个过程的时间复杂度为。 使用 insert() 在某个特定的位置插入一个元素，时间复杂度为。 使用 erase() 删除某个位置的元素，时间复杂度为。 std::vector&lt;int&gt; v; // v.size() = 0 v.push_back(23333); // v.size() = 1, v = { 23333 } v.insert(v.begin() + 0, 890); // v.size() = 2, v = { 890, 23333 } v.insert(v.begin() + 1, 12345); // v.size() = 3, v = { 890, 12345, 23333 } v.erase(v.begin() + 0); // v.size() = 2, v = { 12345, 23333 } for (nt i = 0; i &lt; v.size(); i++) { printf("%d\n", v[i]); } // 依次输出 12345、23333 v.pop_back(); // v.size() = 1, v = { 12345 } 注意，在加入元素时，如果 vector 拥有的内存空间不足以存放欲加入的元素，则 vector 会申请一块新的内存，并将旧数据拷贝过去，这个过程通常花费 的时间。 集合 set STL 在头文件 &lt;set&gt; 中提供了一个有序集合 set，其中的元素全部是唯一的，并且插入进的元素自动按照升序排列，但 set 不支持通过下标定位某个元素，只能通过迭代器遍历。 以下代码声明了一个 int 类型的集合。 std::set&lt;int&gt; s; 使用 insert() 在集合中加入一个元素，其时间复杂度为。 使用 erase() 删除集合中某个元素或某个位置的元素，其时间复杂度均为。 set 自身提供 lower_bound() 用于定位元素，其作用与前文中的同名函数类似，也可以使用 find() 来精确查找元素。 遍历 set 只能使用迭代器。set 的迭代器为 set&lt;T&gt;::iterator，其中 T 为元素类型。 std::set&lt;int&gt; s; s.insert(23333); s.insert(23333); // 重复插入无效 s.insert(66666); s.insert(890); s.insert(-1); // s.size() = 4, s = { -1, 890, 23333, 66666 } s.erase(66666); // s.size() = 3, s = { -1, 890, 23333 } std::set&lt;int&gt;::iterator p1 = s.lower_bound(555); // *p1 = 890 std::set&lt;int&gt;::iterator p2 = s.find(555); // p2 = s.end()，因为未找到 555 s.erase(p1); // s.size() = 2, s = { -1, 23333 } for (std::set&lt;int&gt;::iterator p = s.begin(); p != s.end(); p++) { printf("%d\n", *p); } // 依次输出 -1、23333 上述代码中运用的迭代器的方法在 STL 容器中较为常见。 字符串 string STL 在头文件 &lt;string&gt; 中将一些与字符串有关的操作封装在了 string 内。 使用 cin 和 cout 来输入、输出字符串。 使用 find() 查找另一个字符串在该字符串中的出现位置，返回结果从 0 开始。 使用 c_str() 获得 string 对应的 const char * 类型数据，可用于向 C 库函数传递。 std::string s = "Menci"; int pos = s.find("23333"); // pos = string::npos，因为没有找到 23333 pos = s.find("ci"); // pos = 3，因为出现位置为第 4 个字符 char ch = s[0]; // ch = 'M' std::cout &lt;&lt; s &lt;&lt; std::endl; puts(s.c_str()); // 输出两次 Menci 队列 queue STL 在头文件 &lt;queue&gt; 中提供了先入先出（FIFO）队列 queue。 使用 push() 向队列中加入元素。 使用 front() 获取队首元素（并不删除）。 使用 pop() 删除队首元素。 使用 empty() 判断队列是否为空。 std::queue&lt;int&gt; q; bool flag = q.empty(); // flag = true，队列初始为空 q.push(23333); q.push(66666); while (!q.empty()) { printf("%d\n", q.front()); q.pop(); } // 依次输出 23333，66666 栈 stack STL 在头文件 &lt;stack&gt; 提供了后入先出（LIFO）栈 stack。 使用 push() 向栈中加入元素。 使用 top() 获取栈顶元素（并不删除）。 使用 pop() 删除栈顶元素。 使用 empty() 判断栈是否为空。 std::stack&lt;int&gt; s; bool flag = s.empty(); // flag = true，栈初始为空 s.push(23333); s.push(66666); while (!s.empty()) { printf("%d\n", s.top()); s.pop(); } // 依次输出 66666，23333 优先队列 priority_queue STL 在头文件 &lt;queue&gt; 中提供优先队列 priority_queue，在任意时间都能取出队列中的最大值。 使用 push() 向优先队列中加入元素，其时间复杂度为。 使用 top() 获取优先队列中最大的元素（并不删除），其时间复杂度为。 使用 pop() 删除优先队列中最大元素，其时间复杂度为。 使用 empty() 判断优先队列是否为空。 std::priority_queue&lt;int&gt; q; bool flag = q.empty(); // flag = true，优先队列初始为空 q.push(23333); q.push(-1); q.push(66666); while (!q.empty()) { printf("%d\n", q.top()); q.pop(); } // 依次输出 66666，23333，-1 priority_queue 默认提供队列中的最大值，也可以以以下声明方式让 priority_queue 提供最小值。 std::priority_queue&lt;T, std::vector&lt;T&gt;, std::greater&lt;T&gt; &gt; q; 注意把三个 T 换成优先队列中元素的类型（如 int）；std::greater&lt;T&gt; 的右边要加一个空格，否则会被编译器误认为是 &gt;&gt; 右移运算符。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splay 学习笔记（二）]]></title>
    <url>%2Fsplay-notes-2%2F</url>
    <content type="text"><![CDATA[在 Splay 学习笔记（一）中，我们学会了用 Splay 维护二叉排序树，来实现了有序集合的查询 / 修改操作，接下来，我们来研究 Splay 在维护数列中的用途。 基本原理 我们知道，Splay 可以在不改变二叉树的中序遍历的情况下对节点进行旋转，通常我们用 Splay 来维护二叉排序树，用 Splay 维护的二叉排序树支持区间删除操作，但我们也可以通过一个数列的中序遍历创建一棵 Splay，然后使用类似区间删除中选择区间的原理来处理区间问题。 这里，我们使用 Splay 实现数列的区间反转，反转一段区间，就对应了二叉树中的反转其中序遍历，我们可以使用递归交换左右子树的方法来实现，类比线段树的区间操作，在这里也可以应用线段树中的 lazy-tag 思想，给区间打标记。 struct node_t { node_t *lchild, *rchild, *parent, **root; T value; uint size; bool reversed; bool bound; } 其中 reversed 表示以该节点为根的 Splay（其中序序列）有没有被反转，bound 表示该节点是否为数列的边界（相当于原 Splay 二叉排序树中的 MIN 和 MAX 两个虚拟节点）。 数列de构建 我们通常使用一个数列（数组）来初始化 Splay，这里使用递归构造每个区间的方式实现。具体我们编写两个 build()，分别针对整棵树和一个区间。 void build(const T *a, uint n) { root = build(a, 1, n, NULL); node_t **lbound = &amp;root, *lbound_parent = NULL; while (*lbound) { lbound_parent = *lbound; lbound_parent-&gt;size++; lbound = &amp;(*lbound)-&gt;lchild; } *lbound = new node_t(lbound_parent, &amp;root, 0, true); node_t **rbound = &amp;root, *rbound_parent = NULL; while (*rbound) { rbound_parent = *rbound; rbound_parent-&gt;size++; rbound = &amp;(*rbound)-&gt;rchild; } *rbound = new node_t(rbound_parent, &amp;root, 0, true); } node_t *build(const T *a, uint l, uint r, node_t *parent) { if (l &gt; r) { return NULL; } uint mid = l + ((r - l) &gt;&gt; 1); node_t *node = new node_t(parent, &amp;root, a[mid - 1]); if (l != r) { node-&gt;lchild = build(a, l, mid - 1, node); node-&gt;rchild = build(a, mid + 1, r, node); node-&gt;maintain(); } return node; } 为了方便区间操作，我们在树的最左下端和最右下端分别创建一个虚拟节点，表示整棵树所表示的开区间的边界。 注意递归构建时的区间计算，与线段树的只有叶子节点表示单点，其它节点全部表示区间不同，Splay 的每个节点都既表示一个单点，又表示以该节点为根的 Splay 的所有节点构成的区间，每个节点所代表的区间都会根据树的形态变化而变化，正因为如此，我们才可以通过 Splay 实现灵活的区间操作。 标记de下放 我们对区间操作的维护采用了类似线段树中 lazy-tag 的思想。同样，在 Splay 中，我们也需要在必要时对标记进行下放。 node_t *pushdown() { if (reversed) { std::swap(lchild, rchild); if (lchild) { lchild-&gt;reversed ^= 1; } if (rchild) { rchild-&gt;reversed ^= 1; } reversed = false; } return this; } 反转标记的下放非常简单，交换左右子树，然后将标记打到子树上（^= 1 这里使用位运算异或来实现取反）。 单点de选择 当我们需要查询数列中某个点的信息时，我们需要对单点进行 select() 操作，这恰好对应了原 Splay 中选择第 k 大的操作。 node_t *select(uint k) { k++; node_t *node = root; while (k != node-&gt;pushdown()-&gt;lsize() + 1) { if (k &lt; node-&gt;lsize() + 1) { node = node-&gt;lchild; } else { k -= node-&gt;lsize() + 1; node = node-&gt;rchild; } } return node-&gt;splay(); } 注意：while 循环判断条件中，调用 node-&gt;lsize() 取得其左子树大小前，一定要先将 node 的标记下放。如果某个节点上的标记没有被下放，那么对其左、右孩子的访问都是非法的。 区间de选择 为了实现区间操作，我们需要选择某个区间。注意这里的 select() 操作得到区间是指代表该区间的节点。为了准确的选择区间，我们需要对树的形态做一些调整。 在 Splay 中选择一个开区间的步骤： 将区间的左端点 Splay 到根； 将区间的右端点 Splay 到根的右子树； 右端点的左子树即为要选择的区间。 代码实现要注意闭区间到开区间的转化，同时，这里也体现出了两个虚拟节点带来的便利。 node_t *select(uint l, uint r) { node_t *lbound = select(l - 1); node_t *rbound = select(r + 1); lbound-&gt;splay(); rbound-&gt;splay(&amp;lbound-&gt;rchild); return rbound-&gt;lchild; } 区间de操作 对区间进行操作时，我们只需要选择这段区间，并对所得的节点打上标记即可。 以区间反转为例： void reverse(uint l, uint r) { node_t *range = select(l, r); range-&gt;reversed ^= 1; } 结果de获取 为了在结束时获取操作结果并输出，我们编写 fetch() 方法，将整棵树的中序序列复制到一个数组中。 void fetch(T *a) { dfs(a, root); } void dfs(T *&amp;a, node_t *node) { if (node) { node-&gt;pushdown(); dfs(a, node-&gt;lchild); if (!node-&gt;bound) { *a++ = node-&gt;value; } dfs(a, node-&gt;rchild); } } 需要注意及时进行 pushdown() 操作和对边界的判断。 注意事项 需要注意的是，在访问每个节点之前，我们都需要保证树上没有针对该节点的标记（即从根节点到该节点的一整条链上没有标记），否则即为不可预料的非法访问。 旋转，操作前先对父节点和自身执行 pushdown()，然后再求 relation()。 void rotate() { parent-&gt;pushdown(); pushdown(); node_t *old = parent; uint x = relation(); if (grandparent()) { grandparent()-&gt;child(old-&gt;relation()) = this; } parent = grandparent(); old-&gt;child(x) = child(x ^ 1); if (child(x ^ 1)) { child(x ^ 1)-&gt;parent = old; } child(x ^ 1) = old; old-&gt;parent = this; old-&gt;maintain(); maintain(); if (!parent) { *root = this; } } Splay 操作，每次循环开始时需要对父节点进行一次 pushdown()，因为接下来就要调用 relation()。 node_t *splay(node_t **target = NULL) { if (!target) { target = root; } while (this != *target) { parent-&gt;pushdown(); if (parent == *target) { rotate(); } else if (relation() == parent-&gt;relation()) { parent-&gt;rotate(), rotate(); } else { rotate(), rotate(); } } return *target; } 还有上文提到过的单点选择 select() 和 dfs() 遍历，因为涉及到对子节点的访问，所以在访问前也需要 pushdown()。 完整代码（Tyvj / BZOJ 文艺平衡树） #include &lt;cstdio&gt; #include &lt;algorithm&gt; typedef unsigned int uint; const uint MAXN = 100000; const uint MAXM = 100000; void print(void *node); template &lt;typename T&gt; struct splay_t { struct node_t { node_t *lchild, *rchild, *parent, **root; T value; uint size; bool reversed; bool bound; node_t(node_t *parent, node_t **root, const T &amp;value, bool bound = false) : parent(parent), lchild(NULL), rchild(NULL), root(root), value(value), size(1), reversed(false), bound(bound) {} ~node_t() { if (lchild) { delete lchild; } if (rchild) { delete rchild; } } void maintain() { size = lsize() + rsize() + 1; } uint lsize() { return lchild ? lchild-&gt;size : 0; } uint rsize() { return rchild ? rchild-&gt;size : 0; } node_t *&amp;child(uint x) { return !x ? lchild : rchild; } node_t *grandparent() { return !parent ? NULL : parent-&gt;parent; } uint relation() { return this == parent-&gt;lchild ? 0 : 1; } node_t *pushdown() { if (reversed) { std::swap(lchild, rchild); if (lchild) { lchild-&gt;reversed ^= 1; } if (rchild) { rchild-&gt;reversed ^= 1; } reversed = false; } return this; } void rotate() { parent-&gt;pushdown(); pushdown(); node_t *old = parent; uint x = relation(); if (grandparent()) { grandparent()-&gt;child(old-&gt;relation()) = this; } parent = grandparent(); old-&gt;child(x) = child(x ^ 1); if (child(x ^ 1)) { child(x ^ 1)-&gt;parent = old; } child(x ^ 1) = old; old-&gt;parent = this; old-&gt;maintain(); maintain(); if (!parent) { *root = this; } } node_t *splay(node_t **target = NULL) { if (!target) { target = root; } while (this != *target) { parent-&gt;pushdown(); if (parent == *target) { rotate(); } else if (relation() == parent-&gt;relation()) { parent-&gt;rotate(), rotate(); } else { rotate(), rotate(); } } return *target; } } *root; ~splay_t() { delete root; } void build(const T *a, uint n) { root = build(a, 1, n, NULL); node_t **lbound = &amp;root, *lbound_parent = NULL; while (*lbound) { lbound_parent = *lbound; lbound_parent-&gt;size++; lbound = &amp;(*lbound)-&gt;lchild; } *lbound = new node_t(lbound_parent, &amp;root, 0, true); node_t **rbound = &amp;root, *rbound_parent = NULL; while (*rbound) { rbound_parent = *rbound; rbound_parent-&gt;size++; rbound = &amp;(*rbound)-&gt;rchild; } *rbound = new node_t(rbound_parent, &amp;root, 0, true); } node_t *build(const T *a, uint l, uint r, node_t *parent) { if (l &gt; r) { return NULL; } uint mid = l + ((r - l) &gt;&gt; 1); node_t *node = new node_t(parent, &amp;root, a[mid - 1]); if (l != r) { node-&gt;lchild = build(a, l, mid - 1, node); node-&gt;rchild = build(a, mid + 1, r, node); node-&gt;maintain(); } return node; } node_t *select(uint k) { k++; node_t *node = root; while (k != node-&gt;pushdown()-&gt;lsize() + 1) { if (k &lt; node-&gt;lsize() + 1) { node = node-&gt;lchild; } else { k -= node-&gt;lsize() + 1; node = node-&gt;rchild; } } return node-&gt;splay(); } node_t *select(uint l, uint r) { node_t *lbound = select(l - 1); node_t *rbound = select(r + 1); lbound-&gt;splay(); rbound-&gt;splay(&amp;lbound-&gt;rchild); return rbound-&gt;lchild; } void reverse(uint l, uint r) { node_t *range = select(l, r); range-&gt;reversed ^= 1; } void fetch(T *a) { dfs(a, root); } void dfs(T *&amp;a, node_t *node) { if (node) { node-&gt;pushdown(); dfs(a, node-&gt;lchild); if (!node-&gt;bound) { *a++ = node-&gt;value; } dfs(a, node-&gt;rchild); } } }; void dfs(splay_t&lt;uint&gt;::node_t *node, uint depth = 0) { if (node) { dfs(node-&gt;rchild, depth + 1); for (uint i = 0; i &lt; depth; i++) { putchar(' '); } printf("%d : %u\n", node-&gt;value, node-&gt;size); dfs(node-&gt;lchild, depth + 1); } } void print(void *node) { puts("------------------------------------------"); dfs((splay_t&lt;uint&gt;::node_t *)node); puts("------------------------------------------"); } uint n, m; splay_t&lt;uint&gt; splay; uint a[MAXN]; int main() { scanf("%u %u", &amp;n, &amp;m); for (uint i = 0; i &lt; n; i++) { a[i] = i + 1; } splay.build(a, n); for (uint i = 0; i &lt; m; i++) { uint l, r; scanf("%u %u", &amp;l, &amp;r); splay.reverse(l, r); } splay.fetch(a); for (uint i = 0; i &lt; n; i++) { printf("%u ", a[i]); } return 0; } 总结 学完了这些，对 Splay 维护数列的原理与实现也就基本了解了。其他的一些功能，比如区间最值，区间求和也都大同小异。有些区间操作使用线段树也可实现，但 Splay 的另一个优势在于，它可以动态地插入、删除节点，也就可以实现动态插入、删除区间，这是线段树所不具备的。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>高级数据结构</tag>
        <tag>学习笔记</tag>
        <tag>BZOJ</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splay 学习笔记（一）]]></title>
    <url>%2Fsplay-notes-1%2F</url>
    <content type="text"><![CDATA[上周周四开始学 Splay，一边看《高级数据结构》，一边看 FireStorm 的《Splay学习笔记》，现在终于弄明白最基础的一部分了。 模板请见《Splay 模板 + 详细注释》。 Splay 是什么? Splay Tree（伸展树）是一种自平衡二叉排序树，可以在均摊的时间内完成基于 Splay（伸展）操作的修改与查询。 基本结构 根据定义，Splay 是一棵二叉树，它的左子树和右子树分别是一棵 Splay，并且存储的值满足左子树 &lt; 根 &lt; 右子树，以下为每个 Splay 节点的定义。 struct node_t { T value; node_t *lchild, *rchild, *parent, **root; uint size; }; 其中 root 表示指向指向根节点的指针的指针，这样做可以方便从任意一个节点找到整棵 Splay 的根节点，并修改它。size 表示以当前节点为根的 Splay 共有多少个节点（包括自身），有了 size，就可以轻松地实现选择和排名操作。 准备 为了方便各种复杂的操作，我们先为节点类 node_t 编写几个短小的方法，代码如下： node_t(const T &amp;value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {} ~node_t() { if (lchild) { delete lchild; } if (rchild) { delete rchild; } } node_t *grandparent() { return !parent ? NULL : parent-&gt;parent; } node_t *&amp;child(uint x) { return !x ? lchild : rchild; } uint relation() { return this == parent-&gt;lchild ? 0 : 1; } uint maintain() { size = lsize() + rsize() + 1; } uint lsize() { return lchild ? lchild-&gt;size : 0; } uint rsize() { return rchild ? rchild-&gt;size : 0; } 这里在 node_t 的析构函数中递归释放所有内存，这在区间删除中可能耗时较长，如果内存不紧张，可以考虑不释放内存。 为了旋转操作的方便，我们给每个节点设置一个“关系”属性，表示该节点与其父节点的关系，若该节点为左孩子，则“关系”为 0，反之则为 1。relation() 方法用来计算这个“关系”，而 child() 方法返回与该节点“关系”为 x 的子节点的引用。 maintain() 方法则用来重新计算以该节点为根的 Splay 的大小，注意，为免去不必要的计算，假设两个子节点的大小是已经计算好的，不会再将其重新计算。 旋转 为了调换 Splay 中父节点与子节点的位置，我们实现 rotate() 方法，该方法在保证以下三点的情况下，将该节点向上移动一个位置： 整棵 Splay 的中序遍历不变； 受影响节点的 size 仍然有效； *root 总是指向整棵 Splay 的根。 以左旋（若当前节点为父节点的左孩子）为例，旋转分为四个步骤： 将祖父节点与自身连接； 将自己的右孩子接到自己的父节点的左孩子的位置（替代自己）； 将父节点接到自己的右孩子的位置； 检查如果此时自身节点为根，则更新 *root。 如图（图片来自 FireStorm 的《Splay学习笔记》）： 代码： void rotate() { node_t *old = parent; uint x = relation(); if (grandparent()) { grandparent()-&gt;child(old-&gt;relation()) = this; } parent = grandparent(); old-&gt;child(x) = child(x ^ 1); if (child(x ^ 1)) { child(x ^ 1)-&gt;parent = old; } child(x ^ 1) = old; old-&gt;parent = this; old-&gt;maintain(); maintain(); if (!parent) { *root = this; } } Splay 操作 Splay 规定，每访问一个节点后，都要强制将该节点旋转到根的位置，于是我们很容易想到使用一个循环，判断是否已经到达目标，若不是则旋转，但这种方法的出现的问题在于，一条单链在旋转后仍然是单链，而且每次操作的时间复杂度无法得到保证！ 所以我们需要 Splay 操作来进行更加“智能化”的旋转，Splay 操作的每一次循环分为三步： 如果父节点为目标位置，则向上旋转； 如果当前节点与父节点的“关系”和父节点与祖父节点的“关系”相同，则先旋转父节点，再旋转自身； 如果不满足以上条件，则将自身连续旋转两次。 代码（省略旋转目标的旋转到根）： node_t *splay(node_t **target = NULL) { if (!target) { target = root; } while (this != *target) { if (parent == *target) { rotate(); } else if (relation() == parent-&gt;relation()) { parent-&gt;rotate(), rotate(); } else { rotate(), rotate(); } } return *target; } 插入 一棵二叉排序树最基础的操作就是插入。 首先，设置一个变量 target，表示要插入到的位置，它被初始化为指向根节点，每次循环判断要插入的值大于或小于当前的 target 的值，并修改 target 为指向某个孩子，循环直到 target 指向一个 NULL，即可在此位置创建新节点。 插入完成后，需要将新节点 Splay 到根的位置。 代码： node_t *insert(const T &amp;value) { node_t **target = &amp;root, *parent = NULL; while (*target) { parent = *target; parent-&gt;size++; if (value &lt; (*target)-&gt;value) { target = &amp;(*target)-&gt;lchild; } else { target = &amp;(*target)-&gt;rchild; } } *target = new node_t(value, parent, &amp;root); return (*target)-&gt;splay(); } 为了下文删除操作的方便，我们在每棵 Splay 构造时为其插入两个节点，分别表示无穷大和无穷小，树中其他节点的值都应该在这两个节点的值构成的开区间内。 splay_t() : root(NULL) { insert(MIN); insert(MAX); } 查找 根据二叉排序树的有序性，我们可以很轻松的根据值查找到对应的节点，即从根开始查找，根据当前节点的值与要查找节点的值的大小关系，迭代到对应的子节点上，当当前节点的值等于要查找的值时即找到，若当前节点为 NULL，则说明查找失败。 注意，当有多个相同值时，查找过程应该返回相同值中排名最靠前的，在此我们使用求找到节点的前趋，然后求其后继的方法（前趋和后继的求法见下文）。 查找过程结束后，需要将找到的节点 Splay 到根。 代码： node_t *find(const T &amp;value) { node_t *node = root; while (node &amp;&amp; value != node-&gt;value) { if (value &lt; node-&gt;value) { node = node-&gt;lchild; } else { node = node-&gt;rchild; } } if (node) { return node-&gt;pred()-&gt;succ()-&gt;splay(); } else { return NULL; } } 排名 一个值在二叉排序树中的排名，即为该值在此二叉排序树的中序遍历中第一次出现的位置。 在 Splay 中求排名非常简单，只要找到对应的节点，将其 Splay 到根，此时其左子树的 size + 1 即为所求的排名，而因为我们在初始化时多插入了一个“无穷小”节点，所以还要将 1 减去。 一个有效数值的排名从 1 开始，因为表示“无穷小”的节点的排名为 0。 代码： uint rank(const T &amp;value) { return find(value)-&gt;lsize(); } 选择 对应“排名”操作，二叉排序树有“选择”操作——返回此二叉排序树的中序遍历中的第 k 个元素。 选择比排名要复杂一些，Splay 的选择过程和其他二叉排序树是相同的，我们通过以下几个步骤来实现： 初始化“当前节点”为根； 每次循环判断以当前节点为根的 Splay 中比该节点小的元素数量是否为 k - 1，如果是，则该节点即为要选择的节点； 如果 k 小于当前节点的排名，则迭代到左子树，否则，将 k 的值减小当前节点的排名后迭代到右子树（因为我们跳过的节点数等于当前节点排名）。 选择过程结束后，将得到的节点 Splay 到根。 代码： const T &amp;select(uint k) { k++; node_t *node = root; while (node-&gt;lsize() != k - 1) { if (k &lt; node-&gt;lsize() + 1) { node = node-&gt;lchild; } else { k -= node-&gt;lsize() + 1; node = node-&gt;rchild; } } return node-&gt;splay()-&gt;value; } 节点的前趋 / 后继 我们定义二叉排序树中一个节点的前趋为在此二叉排序树的中序遍历中最后一个数值小于该节点数值的节点，同理，一个节点的后继为在此二叉排序树的中序遍历中第一个数值大于该节点数值的节点。 以节点的前趋为例，其在 Splay 中的实现为： 将欲求其前趋的节点 Splay 到根； 找到根节点左子树的最右链的最下端（后继则相反），该节点即为此二叉排序树的中序遍历中最后一个数值小于等于根节点数值的节点； 如果该节点的数值与欲求其前趋的节点的数值相等，则转到步骤 1，否则该节点即为所求的前趋。 求出节点的前趋或后继后，将得到的节点 Splay 到根。 代码： node_t *pred() { node_t *pred = this; while (pred-&gt;value == this-&gt;value) { pred-&gt;splay(); pred = pred-&gt;lchild; while (pred-&gt;rchild) { pred = pred-&gt;rchild; } } return pred-&gt;splay(); } node_t *succ() { node_t *succ = this; while (succ-&gt;value == this-&gt;value) { succ-&gt;splay(); succ = succ-&gt;rchild; while (succ-&gt;lchild) { succ = succ-&gt;lchild; } } return succ-&gt;splay(); } 值的前趋 / 后继 我们定义一个数 x 在一棵二叉排序树中的前趋为此二叉排序树中小于 x 的数中最大的数，同理，一个数 x 在一棵二叉排序树中的后继为此二叉排序树中大于 x 的数中最小的数。 以值的前趋为例，其实现分为两种情况： 欲求前趋的值在此二叉排序树中，则找到该值对应的节点并求其前趋即可； 欲求前趋的值不在此二叉排序树中，我们将该值作为一个新节点插入此二叉排序树，用情况 1 的方法求得其前趋，然后将插入的节点删除即可（删除的方法见下文）。 代码： const T &amp;pred(const T &amp;value) { node_t *node = find(value); if (node) { return node-&gt;pred()-&gt;value; } else { node = insert(value); const T &amp;result = node-&gt;pred()-&gt;value; erase(node); return result; } } const T &amp;succ(const T &amp;value) { node_t *node = find(value); if (node) { return node-&gt;succ()-&gt;value; } else { node = insert(value); const T &amp;result = node-&gt;succ()-&gt;value; erase(node); return result; } } 删除（单点 / 区间） Splay 支持两种删除操作：单点删除和区间删除。因为单点删除即为左右端点相同的区间删除，所以我们在此主要讨论区间删除。 Splay 的区间删除实现并不难，但方法非常的巧妙（下文中提到的前趋、后继均为节点的前趋、后继）： 将左端点的前趋 Splay 到根； 将右端点的后继 Splay 到根的右子树； 删除右端点的后继的左子树； 分别重新计算右端点的后继、左端点的前趋的 size。 代码： void erase(const T &amp;value) { node_t *node = find(value); erase(node); } void erase(const T &amp;l, const T &amp;r) { erase(find(l), find(r)); } void erase(node_t *l, node_t *r = NULL) { if (!r) { r = l; } node_t *pred = l-&gt;pred(); node_t *succ = r-&gt;succ(); pred-&gt;splay(); succ-&gt;splay(&amp;pred-&gt;rchild); delete succ-&gt;lchild; succ-&gt;lchild = NULL; succ-&gt;maintain(); pred-&gt;maintain(); } 完整代码（Tyvj / BZOJ / CodeVS 普通平衡树） #include &lt;cstdio&gt; #include &lt;climits&gt; typedef unsigned int uint; const uint MAXN = 100000; void print(void *node); template &lt;typename T, T MIN, T MAX&gt; struct splay_t { struct node_t { T value; node_t *lchild, *rchild, *parent, **root; uint size; node_t(const T &amp;value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {} ~node_t() { if (lchild) { delete lchild; } if (rchild) { delete rchild; } } node_t *grandparent() { return !parent ? NULL : parent-&gt;parent; } node_t *&amp;child(uint x) { return !x ? lchild : rchild; } uint relation() { return this == parent-&gt;lchild ? 0 : 1; } void maintain() { size = lsize() + rsize() + 1; } uint lsize() { return lchild ? lchild-&gt;size : 0; } uint rsize() { return rchild ? rchild-&gt;size : 0; } void rotate() { node_t *old = parent; uint x = relation(); if (grandparent()) { grandparent()-&gt;child(old-&gt;relation()) = this; } parent = grandparent(); old-&gt;child(x) = child(x ^ 1); if (child(x ^ 1)) { child(x ^ 1)-&gt;parent = old; } child(x ^ 1) = old; old-&gt;parent = this; old-&gt;maintain(); maintain(); if (!parent) { *root = this; } } node_t *splay(node_t **target = NULL) { if (!target) { target = root; } while (this != *target) { if (parent == *target) { rotate(); } else if (relation() == parent-&gt;relation()) { parent-&gt;rotate(), rotate(); } else { rotate(), rotate(); } } return *target; } node_t *pred() { node_t *pred = this; while (pred-&gt;value == this-&gt;value) { pred-&gt;splay(); pred = pred-&gt;lchild; while (pred-&gt;rchild) { pred = pred-&gt;rchild; } } return pred-&gt;splay(); } node_t *succ() { node_t *succ = this; while (succ-&gt;value == this-&gt;value) { succ-&gt;splay(); succ = succ-&gt;rchild; while (succ-&gt;lchild) { succ = succ-&gt;lchild; } } return succ-&gt;splay(); } } *root; splay_t() : root(NULL) { insert(MIN); insert(MAX); } ~splay_t() { delete root; } node_t *insert(const T &amp;value) { node_t **target = &amp;root, *parent = NULL; while (*target) { parent = *target; parent-&gt;size++; if (value &lt; (*target)-&gt;value) { target = &amp;(*target)-&gt;lchild; } else { target = &amp;(*target)-&gt;rchild; } } *target = new node_t(value, parent, &amp;root); return (*target)-&gt;splay(); } node_t *find(const T &amp;value) { node_t *node = root; while (node &amp;&amp; value != node-&gt;value) { if (value &lt; node-&gt;value) { node = node-&gt;lchild; } else { node = node-&gt;rchild; } } if (node) { return node-&gt;pred()-&gt;succ()-&gt;splay(); } else { return NULL; } } uint rank(const T &amp;value) { return find(value)-&gt;lsize(); } const T &amp;select(uint k) { k++; node_t *node = root; while (node-&gt;lsize() != k - 1) { if (k &lt; node-&gt;lsize() + 1) { node = node-&gt;lchild; } else { k -= node-&gt;lsize() + 1; node = node-&gt;rchild; } } return node-&gt;splay()-&gt;value; } const T &amp;pred(const T &amp;value) { node_t *node = find(value); if (node) { return node-&gt;pred()-&gt;value; } else { node = insert(value); const T &amp;result = node-&gt;pred()-&gt;value; erase(node); return result; } } const T &amp;succ(const T &amp;value) { node_t *node = find(value); if (node) { return node-&gt;succ()-&gt;value; } else { node = insert(value); const T &amp;result = node-&gt;succ()-&gt;value; erase(node); return result; } } void erase(const T &amp;value) { node_t *node = find(value); erase(node); } void erase(const T &amp;l, const T &amp;r) { erase(find(l), find(r)); } void erase(node_t *l, node_t *r = NULL) { if (!r) { r = l; } node_t *pred = l-&gt;pred(); node_t *succ = r-&gt;succ(); pred-&gt;splay(); succ-&gt;splay(&amp;pred-&gt;rchild); delete succ-&gt;lchild; succ-&gt;lchild = NULL; succ-&gt;maintain(); pred-&gt;maintain(); } }; void dfs(splay_t&lt;int, INT_MIN, INT_MAX&gt;::node_t *node, uint depth = 0) { if (node) { dfs(node-&gt;rchild, depth + 1); for (uint i = 0; i &lt; depth; i++) { putchar(' '); } printf("%d : %u\n", node-&gt;value, node-&gt;size); dfs(node-&gt;lchild, depth + 1); } } void print(void *node) { puts("------------------------------------------"); dfs((splay_t&lt;int, INT_MIN, INT_MAX&gt;::node_t *)node); puts("------------------------------------------"); } uint n; splay_t&lt;int, INT_MIN, INT_MAX&gt; splay; int main() { scanf("%u", &amp;n); for (uint i = 0; i &lt; n; i++) { uint command; int x; scanf("%u %d", &amp;command, &amp;x); switch (command) { case 1: splay.insert(x); break; case 2: splay.erase(x); break; case 3: printf("%u\n", splay.rank(x)); break; case 4: printf("%d\n", splay.select(x)); break; case 5: printf("%d\n", splay.pred(x)); break; case 6: printf("%d\n", splay.succ(x)); break; default: break; } } return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>高级数据结构</tag>
        <tag>学习笔记</tag>
        <tag>BZOJ</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2004」宠物收养所 - set]]></title>
    <url>%2Fhnoi2004-pet%2F</url>
    <content type="text"><![CDATA[有 N（&lt;= 80000）个宠物或领养者，每个宠物或者领养者有一个特点值 a，每次当宠物或领养者到来时，从已有的当中匹配一个与其特点值相差最小（且特点值较小）的并删除，计算所有的领养特点值差的总和。 链接 CodeVS 1285 BZOJ 1208 Tyvj 1852 题解 匹配相差最小的元素，很容易联想到复杂度为的二分查找，但是题目要求动态插入删除，考虑使用 STL 中的 set。 为宠物和领养者各维护一个 set，每当有新的到来时，从另一个 set 中 lower_bound 找出第一个大于等于该特点值的元素，该元素的上一个即为第一个小于该特点值的元素，取二者与新加入的特点值相差较小的即可。 代码 #include &lt;cstdio&gt; #include &lt;set&gt; #include &lt;algorithm&gt; inline bool isempty(char ch) { return ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9'); } template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; while (isempty(ch = getchar())); register bool flag = false; if (ch == '-') { flag = true; ch = getchar(); } do { x = x * 10 + (ch - '0'); } while (!isempty(ch = getchar())); if (flag) { x = -x; } } const unsigned int MAXN = 80000; const unsigned int p = 1000000; std::set&lt;unsigned int&gt; pets, owners; unsigned int n, ans; inline unsigned int diff(unsigned int x, unsigned int y) { return std::max(x, y) - std::min(x, y); } inline void add(unsigned int x, unsigned int y) { ans = (ans + (diff(x, y) % p)) % p; } inline void solve(std::set&lt;unsigned int&gt; &amp;set, unsigned int x) { if (set.size() == 1) { add(x, *set.begin()); set.clear(); } else { std::set&lt;unsigned int&gt;::const_iterator r = set.lower_bound(x); if (r == set.begin()) { add(x, *r); set.erase(r); } else { std::set&lt;unsigned int&gt;::const_iterator l = --set.lower_bound(x); if (r == set.end() || diff(x, *l) &lt;= diff(x, *r)) { add(x, *l); set.erase(l); } else { add(x, *r); set.erase(r); } } } } int main() { read(n); for (unsigned int i = 0; i &lt; n; i++) { register unsigned int type, x; read(type), read(x); if (type == 0) { // pet if (owners.empty()) { pets.insert(x); } else { solve(owners, x); } } else { // owner if (pets.empty()) { owners.insert(x); } else { solve(pets, x); } } } printf("%u\n", ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>HNOI</tag>
        <tag>CodeVS</tag>
        <tag>STL</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeVS 3269」混合背包 - 背包 DP]]></title>
    <url>%2Fcodevs-3269%2F</url>
    <content type="text"><![CDATA[背包体积为 V（&lt;= 200,000），给出 N（&lt;= 200）个物品，每个物品占用体积为 Vi，价值为 Wi，每个物品要么至多取 1 件，要么至多取 Mi（&gt; 1）件，要么数量无限，求装入背包内物品总价值的最大值。 链接 CodeVS 3269 题解 混合三种背包问题，很经典的一个问题。 首先分开考虑这三种背包问题的解法。 使用动态规划，用 f[v] 表示把所有物品按要求装入一个体积为 v（v &lt;= V）的背包时，装入背包内物品总价值的最大值。 首先，对于 01 背包，显而易见其方程为： 实现代码（t[i].v 和 t[i].w 分别代表 Vi 和 Wi） for (unsigned int i = 0; i &lt; n; i++) { for (int v = V; v &gt;= 0; v--) { if (v &gt;= t[i].v) { f[v] = std::max(f[v], f[v - t[i].v] + t[i].w); } } } 特别注意第二层循环枚举 v 时的顺序，v 必须从 V 到 0 循环，因为当前 f[v] 要根据一个当 v 更小时的 f[v] 推出（为了腾出大小为 Vi 的空间防第 i 件物品），保证在计算 f[v] 时，f[v - Vi] 一定是没有尝试过放置第 i 件物品时的状态。 对于完全背包，我们可以将其每件拆分成 V / Vi 件 01 背包物品，对每件物品进行一次 01 背包处理。但显然这样做效率会很低。 考虑到完全背包与 01 背包的不同点，仅在于 01 背包每种物品只能放置一次，而完全背包可以放置任意次，将其体现在动态规划的状态转移上，即完全背包问题，需要保证在计算 f[v] 时，f[v - Vi] 一定是已经尝试过放置第 i 件物品时的状态。而只需将第二层循环 v 的遍历顺序改为从 0 到 V 即可。 实现代码为（t[i].v 和 t[i].w 分别代表 Vi 和 Wi）： for (unsigned int i = 0; i &lt; n; i++) { for (unsigned int v = 0; v &lt;= V; v++) { if (v &gt;= t[i].v) { f[v] = std::max(f[v], f[v - t[i].v] + t[i].w); } } } 这两段代码的差异比较难理解，这里举个例子：背包容量 V = 10，仅有一件物品体积 Vi = 3，价值 Wi = 5，现将这件物品尝试放入背包。 如果这件物品是 01 背包： 当 v = 10 时，f[v - Vi] = f[7] = 0，f[v] 被更新为 5。 当 v = 9 时，f[v - Vi] = f[6] = 0，f[v] 被更新为 5。 当 v = 8 时，f[v - Vi] = f[5] = 0，f[v] 被更新为 5。 当 v = 7 时，f[v - Vi] = f[4] = 0，f[v] 被更新为 5。 …… 当 v = 4 时，f[v - Vi] = f[1] = 0，f[v] 被更新为 5。 当 v = 3 时，f[v - Vi] = f[0] = 0，f[v] 被更新为 5。 如果这件物品是完全背包： 当 v = 3 时，f[v - Vi] = f[0] = 0，f[v] 被更新为 5。 当 v = 4 时，f[v - Vi] = f[1] = 0，f[v] 被更新为 5。 …… 当 v = 6 时，f[v - Vi] = f[3] = 5，f[v] 被更新为 10。 …… 当 v = 9 时，f[v - Vi] = f[6] = 10，f[v] 被更新为 15。 当 v = 10 时，f[v - Vi] = f[7] = 10，f[v] 被更新为 15。 以上例子可以体现出 01 背包与完全背包解法上的区别与问题实质的联系。 回到原来的话题上来，我们已经解决了前两类问题——01 背包和完全背包，现在来看多重背包。 还是考虑拆分，把一件可以装 Mi 次的多重背包物品拆分成 Mi 件 01 背包物品，分别对其进行 01 背包处理。这种方法很好理解，但时间复杂度达到了，考虑将其优化。 我们采用类似二进制的思想，将每个多重背包物品拆分为 t 个不同的 01 背包物品，每一个拆分后的物品都有一个系数 k，该物品的体积和价值分别等于原物品的体积和价值乘以这个系数，并且使所有拆分后的物品的系数之和，即原物品最多被放置的次数。并且要使每个系数 k 分别为 ,,,…,,。 举个例子，当 Mi = 17 时，将其拆成 5 件物品，系数 k 分别为 1,2,4,8,2。 使用二进制思想优化过的算法，复杂度降为了。 实现代码为（t[i].v 和 t[i].w 分别代表 Vi 和 Wi）： for (unsigned int i = 0; i &lt; n; i++) { unsigned int logx = log2(t[i].m), x = 0; for (unsigned int j = 0; j &lt;= logx; j++) { x += (1 &lt;&lt; j); // 1 &lt;&lt; j 将 1 按二进制位左移 j 位，快速计算 2 的 j 次方 for (int v = V; v &gt;= 0; v--) { // 01 背包 if (v &gt;= t[i].v * (1 &lt;&lt; j)) { f[v] = std::max(f[v], f[v - t[i].v * (1 &lt;&lt; j)] + t[i].w * (1 &lt;&lt; j)); } } } if (x &lt; t[i].m) { // 如果不能 2 的幂作为系数将原物品完全拆分，则多拆分出一件物品 k = Wi - 2 ^ (t - 1) for (int v = V; v &gt;= 0; v--) { // 01 背包 if (v &gt;= t[i].v * (t[i].m - x)) { f[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x)); } } } } 三种背包问题的思路明确后，就可以考虑混合背包问题了，具体实现方法是对于每一种物品，判断物品类型，分别进行处理。 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const unsigned int MAXN = 200; const unsigned int MAXV = 200000; unsigned int n, V; struct thing_t { unsigned int v, w; int m; } t[MAXN]; unsigned int f[MAXV + 1]; inline bool isempty(char ch) { return ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9'); } template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; while (isempty(ch = getchar())); register bool flag = false; if (ch == '-') { ch = getchar(); flag = true; } do { x = x * 10 + (ch - '0'); } while (!isempty(ch = getchar())); if (flag) { x = -x; } } unsigned int log2(unsigned int x) { unsigned int i = 0, y = 0; while ((y += (1 &lt;&lt; i)) &lt;= x) { i++; } return i - 1; } int main() { read(n), read(V); for (unsigned int i = 0; i &lt; n; i++) { read(t[i].v), read(t[i].w), read(t[i].m); } register unsigned int result = 0; for (unsigned int i = 0; i &lt; n; i++) { if (t[i].m == 1) { for (int v = V; v &gt;= 0; v--) { if (v &gt;= t[i].v) { f[v] = std::max(f[v], f[v - t[i].v] + t[i].w); result = std::max(result, f[v]); } } } else if (t[i].m == -1) { for (unsigned int v = 0; v &lt;= V; v++) { if (v &gt;= t[i].v) { f[v] = std::max(f[v], f[v - t[i].v] + t[i].w); result = std::max(result, f[v]); } } } else { unsigned int logx = log2(t[i].m), x = 0; for (unsigned int j = 0; j &lt;= logx; j++) { x += (1 &lt;&lt; j); for (int v = V; v &gt;= 0; v--) { if (v &gt;= t[i].v * (1 &lt;&lt; j)) { f[v] = std::max(f[v], f[v - t[i].v * (1 &lt;&lt; j)] + t[i].w * (1 &lt;&lt; j)); result = std::max(result, f[v]); } } } if (x &lt; t[i].m) { for (int v = V; v &gt;= 0; v--) { if (v &gt;= t[i].v * (t[i].m - x)) { f[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x)); result = std::max(result, f[v]); } } } } } printf("%u\n", result); return 0; } 吐槽 这段时间在学习 dp，听 liujz 学长讲完后自己抱着书啃了好久 …… 算是有些理解了吧 &gt;_&lt;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>CodeVS</tag>
        <tag>背包 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2002」银河英雄传说 - 并查集]]></title>
    <url>%2Fnoi2002-galaxy%2F</url>
    <content type="text"><![CDATA[有 30000 个元素，初始时每个元素以单独的队列形式存在，支持一下两种操作： 1.动态合并两条队列，将 x 元素所在队列首合并在 y 元素所在队列尾； 2.查询 x 与 y 是否在同一条队列中，若是，查询 x 与 y 间隔元素数量。 共 500,000 次操作。 链接 CodeVS 1540 题解 由「查询」操作，考虑到使用并查集。用并查集维护两个元素是否在同一队列中，可以对查询是否在同一队列中作出回答。 考虑将并查集扩展，维护每一个元素所在队列的队首和队尾。 unsigned int find_head(unsigned int x) { return head[x] == x ? x : find_head(head[x]); } unsigned int find_tail(unsigned int x) { return tail[x] == x ? x : find_tail(tail[x]); } void merge(unsigned int x, unsigned int y) { unsigned int head_x = find_head(x); unsigned int tail_y = find_tail(y); head[head_x] = tail_y; tail[tail_y] = head_x; } 然后就是查询间隔数量，这里采用前缀和的方式。 unsigned int sum(unsigned int x, unsigned int y) { return std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1; } pre(x) 的计算方法，根据合并时对 head 数组进行的修改，可得 find_head(x) 的迭代次数即为 x 到 x 所在队队首的元素数量。 unsigned int pre(unsigned int x) { register unsigned int result = 0; while (head[x] != x) { result++; x = head[x]; } return result; } 使用这种方式维护并查集，不能对并查集使用路径压缩的优化，故整个算法时间复杂度为 。 所以 …… Boom！ 解决方法：在进行路径压缩的同时，维护每一个 x 到 head[x] 的「距离」 prefix[x]。 在 find(x) 或者 pre(x) 每一次迭代时，进行路径压缩，并把 prefix[x] 加上 pre(head[x])，即队列中在 x 元素之前的元素的「前缀和」。 注意： 1.当迭代到根节点下时，不能对 prefix[x] 做修改。 2.队首元素，即满足 head[x] == x 的元素的前缀和应总是0。 unsigned int find_head(unsigned int x) { if (head[x] == x) { return x; } else { if (head[head[x]] != head[x]) { prefix[x] += pre(head[x]); // 处理 prefix[] 数组 } head[x] = find_head(head[x]); // 路径压缩 } return head[x]; } unsigned int pre(unsigned int x) { if (head[x] == x) { return prefix[x] = 0; } else { if (head[head[x]] != head[x]) { prefix[x] += pre(head[x]); // 处理 prefix[] 数组 } head[x] = find_head(head[x]); // 路径压缩 } return prefix[x]; } 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; const unsigned int MAXN = 30000; const unsigned int MAXM = 500000; unsigned int m; struct unionfind { unsigned int head[MAXN], tail[MAXN], prefix[MAXN]; void init(unsigned int n) { for (unsigned int i = 0; i &lt; n; i++) { head[i] = i; tail[i] = i; } } unsigned int find_head(unsigned int x) { if (head[x] == x) { return x; } else { if (head[head[x]] != head[x]) { prefix[x] += pre(head[x]); } head[x] = find_head(head[x]); } return head[x]; } unsigned int find_tail(unsigned int x) { return tail[x] == x ? x : tail[x] = find_tail(tail[x]); } unsigned int pre(unsigned int x) { if (head[x] == x) { return prefix[x] = 0; } else { if (head[head[x]] != head[x]) { prefix[x] += pre(head[x]); } head[x] = find_head(head[x]); } return prefix[x]; } unsigned int sum(unsigned int x, unsigned int y) { return std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1; } void merge(unsigned int x, unsigned int y) { unsigned int head_x = find_head(x); unsigned int tail_y = find_tail(y); head[head_x] = tail_y; tail[tail_y] = head_x; prefix[head_x] = 1; } } uf; inline bool isempty(char ch) { return ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9'); } template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; while (isempty(ch = getchar())); register bool flag = false; if (ch == '-') { flag = true; ch = getchar(); } do { x = x * 10 + (ch - '0'); } while (!isempty(ch = getchar())); if (flag) { x = -x; } } inline bool iscommand(char ch) { return ch == 'C' || ch == 'M'; } int main() { read(m); uf.init(MAXN); for (unsigned int i = 0; i &lt; m; i++) { register char command; register unsigned int x, y; while (!iscommand(command = getchar())); read(x), read(y); x--, y--; if (command == 'M') { uf.merge(x, y); } else { if (uf.find_head(x) == uf.find_head(y)) { printf("%u\n", uf.sum(x, y)); } else { puts("-1"); } } } return 0; } 吐槽 这是当年 NOI2002 的一道水（大雾）题。 刚开始学并查集的时候尝试做过这题，然后 …… 然后就没有然后了。 今天突然想起这题，就用了一个小时把它 A 掉了。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeVS</tag>
        <tag>并查集</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
</search>
